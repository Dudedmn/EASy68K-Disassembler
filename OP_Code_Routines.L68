000010B6 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/14/2019 3:53:02 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : OP Code routines for Disassembler
00000000                             3  * Written by : Daniel Yan
00000000                             4  * Date       : 2/28/2019, Updated 3/12/2019
00000000                             5  
00000000                             6  * Description: Disassembler routines to identify any valid
00000000                             7  * OP code dependent on current supported list.
00000000                             8  *------------------------------------------------------------
00004000                             9      ORG $4000
00004000                            10   
00004000                            11  CUR_OP_CODE     DS.W    1 * Used for Daniel's code
00004002  11F8 0012 4002            12     MOVE.B $12, $4002
00004008  11FC 0034 4004            13     MOVE.B #$34, $4004
0000400E  11FC 0012 4006            14     MOVE.B #$12, $4006
00004014  11FC 0034 4008            15     MOVE.B #$34, $4008
00004100                            16      ORG $4100
00004100                            17  G_BUFFER    DS.B 80 
00001000                            18      ORG $1000 ; Start at Address $1000
00001000                            19    
00001000                            20  
00001000                            21  
00001000                            22  MNEMONIC        DS.B    1 * First four BITS of any instruction
00001001                            23   
00001002                            24  TRAILING_SIZE   DS.W    1 * Size of any immediate or
00001004                            25                            * address values. Immediate or address
00001004                            26                            * value of a BYTE is still processed as
00001004                            27                            * WORD because the trailing bytes
00001004                            28                            * are represented as a word regardless.
00001004                            29                            * $1 = BYTE, $2 = WORD, $4 = LONG
00001004                            30  
00001004                            31  FIRST_3         DS.B    1 * First, second, third, and fourth bundles of three bits each
00001005                            32  SECOND_3        DS.B    1
00001006                            33  THIRD_3         DS.B    1
00001007                            34  FOURTH_3        DS.B    1
00001008                            35  
00001008                            36  EA_SIZE     DS.B 1
00001009                            37  
00001009                            38  B_BUFFER    DS.B 80
00001059                            39  
00001059                            40  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001059                            41  * MESSAGE VARIABLES ******************************
00001059                            42  
00001059                            43  * ASCII values for respective characters
00001059                            44  
00001059= 41                        45  ADDRESS         DC.B    $41
0000105A= 44                        46  DATA            DC.B    $44
0000105B                            47  
0000105B= 28                        48  PTHSIS_OPEN     DC.B    $28
0000105C= 29                        49  PTHSIS_CLSD     DC.B    $29
0000105D= 24                        50  HEX_SIGN        DC.B    $24
0000105E= 23                        51  IMMDTE_VALU     DC.B    $23
0000105F= 2B                        52  PLUS_SIGN       DC.B    $2B
00001060= 2D                        53  MINUS_SIGN      DC.B    $2D
00001061                            54  
00001061= 2C                        55  COMMA           DC.B    $2C
00001062= 20                        56  SPACE           DC.B    $20
00001063                            57  
00001063= 0D                        58  CR              DC.B    $D
00001064= 0A                        59  LF              DC.B    $A
00001065                            60  **************************************************
00001065                            61  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001065                            62  
00001065                            63  
00001065                            64  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001065                            65  * GLOBAL BUFFER **********************************
00001065                            66  
00001065                            67  
00001065  =00004000                 68  START_ADDRESS   EQU     $4000 * Used to parse through the entire instruction
00001065  =00005000                 69  END_ADDRESS     EQU     $5000
00001065                            70  
00001065                            71  EA_BUFFER       DS.B    80 * Used to load ASCII-converted EA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000010B5                            72  IS_VALID        DS.B    1 * EA-bit validity flag
000010B6                            73                            * $0 = invalid, $1 = valid
000010B6                            74  
000010B6                            75  START:
000010B6                            76      
000010B6  49F8 4100                 77      LEA G_BUFFER,A4         ;Load G_BUFFER into A4, put a pointer to it as A4
000010BA  18BC 0000                 78      MOVE.B #0, (A4)         ;Move 0 to indicate where to put the loaded buffer word
000010BE                            79  
000010BE                            80      ;MOVE.L (A5)+, D0
000010BE                            81  ************** BUFFER PRINTING/LOADING EXAMPLES *************************************
000010BE                            82      ; Load the message onto A4
000010BE                            83      ;MOVE.L #P_OP_MOVEA_L_T, Arg_AddStrToBuffer_String
000010BE                            84      ;MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer 
000010BE                            85      ;JSR AddStrToBuffer
000010BE                            86      ;LEA G_BUFFER, A4   ; Load the value of the message onto the G_BUFFER
000010BE                            87      ;MOVE.L P_OP_MOVEA_L_T,(A4)+
000010BE                            88      ;MOVE.L P_OP_MOVEA_L_A_L,(A4)+
000010BE                            89      
000010BE                            90  ***************************** Input Tests ********************************************
000010BE                            91      ; indicates a test has been finished
000010BE                            92      * indicates a test hasn't been finished
000010BE                            93      
000010BE                            94      ***GROUP 0 tests**** SUPPORTED: ORI, BCLR (static, dynamic), CMPI
000010BE                            95      ;MOVE.W #%0000000000111100,CUR_OP_CODE      ;ORI TO CCR              SHOULD FAIL
000010BE                            96      ;MOVE.W #%0000000001111100,CUR_OP_CODE      ;ORI TO SR               SHOULD FAIL
000010BE                            97      ;MOVE.W #%0000000010000101,CUR_OP_CODE      ;ORI.W D5                SHOULD PASS
000010BE                            98      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO CCR             SHOULD FAIL
000010BE                            99      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO SR              SHOULD FAIL
000010BE                           100      ;MOVE.W #%0000001010000101,CUR_OP_CODE      ;ANDI.W D5               SHOULD FAIL
000010BE                           101      ;MOVE.W #%0000010010000101,CUR_OP_CODE      ;SUBI.W D5               SHOULD FAIL
000010BE                           102      ;MOVE.W #%0000011010000101,CUR_OP_CODE      ;ADDI.W D5               SHOULD FAIL
000010BE                           103      ;MOVE.W #%0000101000111100,CUR_OP_CODE      ;EORI TO CCR             SHOULD FAIL
000010BE                           104      ;MOVE.W #%0000101001111100,CUR_OP_CODE      ;EORI TO SR              SHOULD FAIL
000010BE                           105      ;MOVE.W #%0000101010000101,CUR_OP_CODE      ;EORI.W D5               SHOULD FAIL
000010BE                           106      ;MOVE.W #%0000110010000101,CUR_OP_CODE      ;CMPI.L D5               SHOULD PASS
000010BE                           107      ;MOVE.W #%0000100000000101,CUR_OP_CODE      ;STATIC BTST. B D5       SHOULD FAIL
000010BE                           108      ;MOVE.W #%0000100001000101,CUR_OP_CODE      ;STATIC BCHG .B D5       SHOULD FAIL
000010BE                           109      ;MOVE.W #%0000100010000101,CUR_OP_CODE      ;STATIC BCL R D5         SHOULD PASS
000010BE                           110      ;MOVE.W #%0000100011000101,CUR_OP_CODE      ;STATIC BS ET.B D5       SHOULD FAIL
000010BE                           111      ;MOVE.W #%0000111100000101,CUR_OP_CODE      ;DYNAMIC BTST.B D7,D5    SHOULD FAIL
000010BE                           112      ;MOVE.W #%0000111101000101,CUR_OP_CODE      ;DYNAMIC BCHG.B,D7,D5    SHOULD FAIL
000010BE                           113      ;MOVE.W #%0000101110000111,CUR_OP_CODE      ;DYNAMIC BCLR.B D7,D5    SHOULD PASS
000010BE                           114      ;MOVE.W #%0000111111000101,CUR_OP_CODE      ;DYNAMIC BSET.B D7,D5    SHOULD FAIL
000010BE                           115      ;MOVE.W #%0000111111001101,CUR_OP_CODE      ;MOVEP.L MEM TO REG, A5  SHOULD FAIL, MADE A SPECIAL CASE FOR DYNAMIC BSET BIT SHIFTING
000010BE                           116          
000010BE                           117      ***GROUP 1 tests**** SUPPORTED: MOVE.B
000010BE                           118      ;MOVE.W #%0001101000000111,CUR_OP_CODE       ;MOVE.B D5,D7           SHOULD PASS
000010BE                           119      ***GROUP 2 tests**** SUPPORTED: MOVEA.L, MOVE.L
000010BE                           120      ;MOVE.W #%0010101000000111,CUR_OP_CODE       ;MOVE.L D5,D7           SHOULD PASS
000010BE                           121      ;MOVE.W #%0010101001000111,CUR_OP_CODE       ;MOVEA.L D5,D7          SHOULD PASS
000010BE                           122      ;MOVE.W #%0010 101 000 111 100, MOVE.L #imm,D5
000010BE  31FC 2A3C 4000           123        MOVE.W #%0010101000111100,CUR_OP_CODE       ;MOVE.L #immed,D5 
000010C4                           124         
000010C4                           125      ***GROUP 3 tests**** SUPPORTED: MOVEA.W, MOVE.W
000010C4                           126      ;MOVE.W #%0011101000000111,CUR_OP_CODE       ;MOVE.W D5,D7           SHOULD PASS
000010C4                           127      ;MOVE.W #%0011101001000111,CUR_OP_CODE       ;MOVEA.W D5,D7          SHOULD PASS
000010C4                           128      
000010C4                           129      ****GROUP 4 tests**** SUPPORTED: LEA, JSR, RTS, NEG, MOVEM  
000010C4                           130      ;MOVE.W #%0100000011000101,CUR_OP_CODE       ;MOVE_FROM_SR           SHOULD FAIL
000010C4                           131      ;MOVE.W #%0100010011000101,CUR_OP_CODE       ;MOVE_TO_CCR            SHOULD FAIL
000010C4                           132      ;MOVE.W #%0100011011000101,CUR_OP_CODE       ;MOVE_TO_SR             SHOULD FAIL
000010C4                           133      ;MOVE.W #%0100000010000101,CUR_OP_CODE       ;NEGX                   SHOULD FAIL
000010C4                           134      ;MOVE.W #%0100001010000101,CUR_OP_CODE       ;CLR                    SHOULD FAIL
000010C4                           135      ;MOVE.W #%0100010001000101,CUR_OP_CODE       ;NEG                    SHOULD PASS
000010C4                           136      ;MOVE.W #%0100011010000101,CUR_OP_CODE       ;NOT                    SHOULD FAIL
000010C4                           137      ;MOVE.W #%0100100011000101,CUR_OP_CODE       ;EXT                    SHOULD FAIL
000010C4                           138      ;MOVE.W #%0100100000000101,CUR_OP_CODE       ;NBCD                   SHOULD FAIL
000010C4                           139      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;SWAP                   SHOULD FAIL
000010C4                           140      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;PEA                    SHOULD FAIL
000010C4                           141      ;MOVE.W #%0100101011111100,CUR_OP_CODE       ;ILLEGAL                SHOULD FAIL
000010C4                           142      ;MOVE.W #%0100101011000101,CUR_OP_CODE       ;TAS                    SHOULD FAIL
000010C4                           143      ;MOVE.W #%0100101010000101,CUR_OP_CODE       ;TST                    SHOULD FAIL
000010C4                           144      ;MOVE.W #%0100111001000111,CUR_OP_CODE       ;TRAP                   SHOULD FAIL
000010C4                           145      ;MOVE.W #%0100111001010101,CUR_OP_CODE       ;LINK                   SHOULD FAIL
000010C4                           146      ;MOVE.W #%0100111001011101,CUR_OP_CODE       ;UNLK                   SHOULD FAIL
000010C4                           147      ;MOVE.W #%0100111001101101,CUR_OP_CODE       ;MOVE_USP               SHOULD FAIL
000010C4                           148      ;MOVE.W #%0100111001110000,CUR_OP_CODE       ;RESET                  SHOULD FAIL
000010C4                           149      ;MOVE.W #%0100111001110001,CUR_OP_CODE       ;NOP                    SHOULD FAIL
000010C4                           150      ;MOVE.W #%0100111001110010,CUR_OP_CODE       ;STOP                   SHOULD FAIL
000010C4                           151      ;MOVE.W #%0100111001110011,CUR_OP_CODE       ;RTE                    SHOULD FAIL
000010C4                           152      ;MOVE.W #%0100111001110101,CUR_OP_CODE       ;RTS                    SHOULD PASS
000010C4                           153      ;MOVE.W #%0100111001110110,CUR_OP_CODE       ;TRAPV                  SHOULD FAIL
000010C4                           154      ;MOVE.W #%0100111001110111,CUR_OP_CODE       ;RTR                    SHOULD FAIL
000010C4                           155      ;MOVE.W #%0100111010000101,CUR_OP_CODE       ;JSR                    SHOULD PASS
000010C4                           156      ;MOVE.W #%0100111011000101,CUR_OP_CODE       ;JMP                    SHOULD FAIL
000010C4                           157      ;MOVE.W #$488E,CUR_OP_CODE                   ;MOVEM.W Reg to Mem,A6  SHOULD PASS
000010C4                           158      ;MOVE.W #$4C8E,CUR_OP_CODE                   ;MOVEM.W Mem to Reg,A6  SHOULD PASS
000010C4                           159      ;MOVE.W #$43CC,CUR_OP_CODE                   ;LEA A1,A6              SHOULD PASS
000010C4                           160      ;MOVE.W #%0100000110000101,CUR_OP_CODE       ;CHK                    SHOULD FAIL
000010C4                           161      ;MOVE.W #$4E75,CUR_OP_CODE                   ;RTS                    SHOULD PASS
000010C4                           162      ;MOVE.W #$4E71,CUR_OP_CODE                   ;NOP                    SHOULD FAIL
000010C4                           163      ;MOVE.W #$4415,CUR_OP_CODE                   ;NEG.L D5               SHOULD PASS
000010C4                           164     
000010C4                           165      *****GROUP 5 TESTS**** SUPPORTED: SUBQ
000010C4                           166      ;MOVE.W #%0101110010000101,CUR_OP_CODE        ;ADDQ                  SHOULD FAIL
000010C4                           167      ;MOVE.W #%0101110110000101,CUR_OP_CODE        ;SUBQ                  SHOULD PASS
000010C4                           168      ;MOVE.W #%0101101011000101,CUR_OP_CODE        ;Scc (SPL)             SHOULD FAIL
000010C4                           169      ;MOVE.W #%0101101011001101,CUR_OP_CODE         ;DBcc (DCPL)          SHOULD FAIL
000010C4                           170         
000010C4                           171      *****GROUP 6 TESTS********* SUPPORTED: BCS,BGE,BLT,BVC
000010C4                           172      ; DISPLACEMENT, $00 is 16 bits, $FF is 32 bits
000010C4                           173      ; DISPLACEMENT = Last 8 bits
000010C4                           174      ;MOVE.W #%0110000001010101,CUR_OP_CODE   ;BRA                        SHOULD PASS
000010C4                           175      ;MOVE.W #%0110000110101010,CUR_OP_CODE   ;BSR                        SHOULD FAIL
000010C4                           176      ;MOVE.W #%0110010100000001,CUR_OP_CODE   ;BCS                        SHOULD PASS
000010C4                           177      ;MOVE.W #%0110110001010100,CUR_OP_CODE   ;BGE                        SHOULD PASS
000010C4                           178      ;MOVE.W #%0110110110101010,CUR_OP_CODE   ;BLT                        SHOULD PASS
000010C4                           179      ;MOVE.W #%0110100001010100,CUR_OP_CODE   ;BVC                        SHOULD PASS
000010C4                           180      
000010C4                           181      *****GROUP 7 TESTS********** NONE SUPPORTED
000010C4                           182      ;MOVE.W #%0111101011110000,CUR_OP_CODE   ;MOVEQ                      SHOULD FAIL
000010C4                           183      
000010C4                           184      *****GROUP 8 TESTS********** SUPPORTED: DIVS, OR
000010C4                           185      ;MOVE.W #%1000101011000101,CUR_OP_CODE    ;DIVU                      SHOULD FAIL
000010C4                           186      ;MOVE.W #%1000101111000110,CUR_OP_CODE    ;DIVS                      SHOULD PASS
000010C4                           187      ;MOVE.W #%1000101100001111,CUR_OP_CODE    ;SBCD                      SHOULD FAIL
000010C4                           188      ;MOVE.W #%1000110101000101,CUR_OP_CODE    ;OR                        SHOULD PASS
000010C4                           189              
000010C4                           190      *****GROUP 9 TESTS********** SUPPORTED: SUB
000010C4                           191      ;MOVE.W #%1001101100000101,CUR_OP_CODE    ;SUB                       SHOULD PASS
000010C4                           192      ;MOVE.W #%1001000110001101,CUR_OP_CODE    ;SUBX                      SHOULD FAIL
000010C4                           193      ;MOVE.W #%1001101011001101,CUR_OP_CODE    ;SUBA                      SHOULD FAIL
000010C4                           194      
000010C4                           195      *****GROUP A TESTS********** NONE SUPPORTED
000010C4                           196      ;MOVE.W #%1010110101010011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010C4                           197      
000010C4                           198      *****GROUP B TESTS********** SUPPORTED: EOR, CMP
000010C4                           199      *MOVE.W #%1011101101000110,CUR_OP_CODE    ;EOR                       SHOULD PASS
000010C4                           200      *MOVE.W #%1011110101001101,CUR_OP_CODE    ;CMPM                      SHOULD FAIL
000010C4                           201      *MOVE.W #%1011010001000101,CUR_OP_CODE    ;CMP                       SHOULD PASS
000010C4                           202      *MOVE.W #%1011110011000101,CUR_OP_CODE    ;CMPA                      SHOULD FAIL
000010C4                           203      
000010C4                           204      *****GROUP C TESTS********** SUPPORTED: MULS
000010C4                           205      ;MOVE.W #%1100101011000110,CUR_OP_CODE    ;MULU                      SHOULD FAIL
000010C4                           206      ;MOVE.W #%1100101111000101,CUR_OP_CODE    ;MULS                      SHOULD PASS
000010C4                           207      ;MOVE.W #%1100101100000101,CUR_OP_CODE    ;ABCD                      SHOULD FAIL
000010C4                           208      ;MOVE.W #%1100101110001110,CUR_OP_CODE    ;EXG                       SHOULD FAIL
000010C4                           209      ;MOVE.W #%1100101001000101,CUR_OP_CODE    ;AND                       SHOULD FAIL   
000010C4                           210       
000010C4                           211      *****GROUP D TESTS********** SUPPORTED: ADD, ADDA
000010C4                           212      ;MOVE.W #%1101101101000101,CUR_OP_CODE    ;ADDX                      SHOULD FAIL
000010C4                           213      ;MOVE.W #%1101101011001101,CUR_OP_CODE    ;ADDA                      SHOULD FAIL
000010C4                           214      ;MOVE.W #%1101101001001101,CUR_OP_CODE    ;ADD                       SHOULD PASS
000010C4                           215      
000010C4                           216      *****GROUP E TESTS********** SUPPORTED: LSX, ASX, ROX
000010C4                           217      ;MOVE.W #%1110000011000101,CUR_OP_CODE    ;ASR NO_ROT                SHOULD PASS
000010C4                           218      ;MOVE.W #%1110000111000101,CUR_OP_CODE    ;ASL NO_ROT                SHOULD PASS
000010C4                           219      ;MOVE.W #%1110001011000101,CUR_OP_CODE    ;LSR NO_ROT                SHOULD PASS
000010C4                           220      ;MOVE.W #%1110001111000101,CUR_OP_CODE    ;LSL NO_ROT                SHOULD PASS
000010C4                           221      ;MOVE.W #%1110010011000101,CUR_OP_CODE    ;ROXR NO_ROT               SHOULD FAIL
000010C4                           222      ;MOVE.W #%1110010111000101,CUR_OP_CODE    ;ROXL NO_ROT               SHOULD FAIL
000010C4                           223      ;MOVE.W #%1110011011000101,CUR_OP_CODE    ;ROR NO_ROT                SHOULD PASS
000010C4                           224      ;MOVE.W #%1110011111000101,CUR_OP_CODE    ;ROL NO_ROT                SHOULD PASS    
000010C4                           225      
000010C4                           226      ;MOVE.W #%1110000001000101,CUR_OP_CODE    ;ASR                       SHOULD PASS
000010C4                           227      ;MOVE.W #%1110000101000101,CUR_OP_CODE    ;ASL                       SHOULD PASS
000010C4                           228      ;MOVE.W #%1110001001001101,CUR_OP_CODE    ;LSR                       SHOULD PASS
000010C4                           229      ;MOVE.W #%1110001101001101,CUR_OP_CODE    ;LSL                       SHOULD PASS
000010C4                           230      ;MOVE.W #%1110010001010101,CUR_OP_CODE    ;ROXR                      SHOULD FAIL
000010C4                           231      ;MOVE.W #%1110010101010101,CUR_OP_CODE    ;ROXL                      SHOULD FAIL
000010C4                           232      ;MOVE.W #%1110011001011101,CUR_OP_CODE    ;ROR                       SHOULD PASS
000010C4                           233      ;MOVE.W #%1110011101011101,CUR_OP_CODE    ;ROL                       SHOULD PASS    
000010C4                           234          
000010C4                           235      *****GROUP F TESTS********** NONE SUPPORTED
000010C4                           236      ;MOVE.W #%1111010110101011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010C4                           237      
000010C4                           238      
000010C4                           239  ************************************************************************************
000010C4                           240  * PRINTING BUFFER FUNCTION HAS BEEN FINISHED
000010C4                           241  * STATUS: 
000010C4                           242  * IDENTIFICATION FOR ALL OP CODES:      DONE
000010C4                           243  * VALIDATION TESTING FOR ALL OP CODES:  DONE
000010C4                           244  * PRINTING ALL OP CODES TO BUFFER:      DONE
000010C4                           245  * PRINTING SIZE BITS OF ALL OP CODES:   NOT DONE
000010C4                           246  *-----------------------------------------------------------
000010C4                           247  *First Nibble Values (15-12)
000010C4                           248  *Value                  Operations
000010C4                           249  *$0                     GROUP_0: ORI,BCLR (static and dynamic),CMPI --- DONE
000010C4                           250  *$1                     GROUP_1: MOVE.B                             --- DONE
000010C4                           251  *$2                     GROUP_2: MOVE.L, MOVEA.L                    --- DONE
000010C4                           252  *$3                     GROUP_3: MOVE.W, MOVEA.W                    --- DONE
000010C4                           253  *$4                     GROUP_4: LEA,JSR,RTS,NEG,MOVEM              --- DONE
000010C4                           254  *$5                     GROUP_5: SUBQ                               --- DONE
000010C4                           255  *$6                     GROUP_6: Bcc(BCS,BGE,BLT,BVC), BRA          --- DONE
000010C4                           256  *$7                     GROUP_7: INVALID_OP                         --- DONE
000010C4                           257  *$8                     GROUP_8: DIVS, OR                           --- DONE
000010C4                           258  *$9                     GROUP_9: SUB                                --- DONE
000010C4                           259  *$A                     GROUP_A: INVALID_OP                         --- DONE
000010C4                           260  *$B                     GROUP_B: EOR, CMP                           --- DONE
000010C4                           261  *$C                     GROUP_C: MULS                               --- DONE
000010C4                           262  *$D                     GROUP_D: ADD, ADDA                          --- DONE
000010C4                           263  *$E                     GROUP_E: LSR, LSL, ASR, ASL, ROL, ROR       --- DONE
000010C4                           264  *$F                     GROUP_F: INVALID_OP                         --- DONE
000010C4                           265  
000010C4                           266  
000010C4                           267  * OP_JSR_Routine
000010C4                           268  **********************************************************************************
000010C4                           269  * Description: Catalog all supported OP codes into groupings based on their hex
000010C4                           270  * values. Sort the supported OP codes by looking at the first nibble for their
000010C4                           271  * grouping value. Call underlying subroutines for further identification of the
000010C4                           272  * op code.
000010C4                           273  *
000010C4                           274  * Registers used: A6,D0,D1 
000010C4                           275  *
000010C4                           276  * Precondition: Instruction set (size Word) has been loaded in the appropriate
000010C4                           277  * address to be parsed and read.
000010C4                           278  
000010C4                           279  * Postcondition: OP code has been identified as either valid or invalid. If it is
000010C4                           280  * valid, it is stored into A6 and EA parsing methods are called to pass needed
000010C4                           281  * information to EA. If invalid, DATA output will be utilized to indicate so.
000010C4                           282  **********************************************************************************
000010C4                           283  * These valid operand codes refer to the basic supported operand codes
000010C4                           284  * Groups refer to the first nibble value that is supported by the operand
000010C4                           285  LOAD_OP_CODE:
000010C4  3038 4000                286      MOVE.W CUR_OP_CODE,D0
000010C8  11FC 0001 10B5           287      MOVE.B #1,IS_VALID
000010CE  4EB9 000010D4            288      JSR OP_JSR_Routine             ;Use the JSR routine to identify the op code
000010D4                           289      
000010D4                           290  OP_JSR_Routine:
000010D4  48E7 C000                291      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
000010D8  720C                     292      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
000010DA  E2A8                     293      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
000010DC                           294  
000010DC                           295  GROUP_0:                ;$0| ORI, BCLR (static and dynamic), CMPI                  
000010DC  B03C 0000                296      CMP.B   #$0,D0                 ;Compare first nibble
000010E0  6600 000C                297      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
000010E4  4EB9 000012F8            298      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
000010EA  6000 010C                299      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000010EE                           300      
000010EE                           301  GROUP_1:                ;$1| MOVE.B
000010EE  B03C 0001                302      CMP.B   #$1,D0                 ;Compare first nibble
000010F2  6600 000C                303      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
000010F6  4EB9 000014C6            304      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
000010FC  6000 00FA                305      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001100                           306  
00001100                           307  GROUP_2:                ;$2| MOVE.L, MOVEA.L
00001100  B03C 0002                308      CMP.B   #$2,D0                 ;Compare first nibble
00001104  6600 000C                309      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
00001108  4EB9 000014F0            310      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
0000110E  6000 00E8                311      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001112                           312  
00001112                           313  GROUP_3:                ;$3| MOVE.W, MOVEA.W
00001112  B03C 0003                314      CMP.B   #$3,D0                 ;Compare first nibble
00001116  6600 000C                315      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
0000111A  4EB9 00001552            316      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
00001120  6000 00D6                317      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001124                           318  
00001124                           319  GROUP_4:                ;$4| LEA, JSR, RTS, NEG, MOVEM
00001124  B03C 0004                320      CMP.B   #$4,D0                 ;Compare first nibble
00001128  6600 000C                321      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
0000112C  4EB9 000015B4            322      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
00001132  6000 00C4                323      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001136                           324  
00001136                           325  
00001136                           326  GROUP_5:                ;$5| SUBQ
00001136  B03C 0005                327      CMP.B   #$5,D0                 ;Compare first nibble
0000113A  6600 000C                328      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
0000113E  4EB9 00001832            329      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
00001144  6000 00B2                330      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001148                           331  
00001148                           332  
00001148                           333  GROUP_6:                ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
00001148  B03C 0006                334      CMP.B   #$6,D0                 ;Compare first nibble
0000114C  6600 000C                335      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
00001150  4EB9 00001898            336      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
00001156  6000 00A0                337      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000115A                           338  
0000115A                           339  
0000115A                           340  GROUP_7:                ;$7| Display: DATA, $WXYZ (Unsupported)
0000115A  B03C 0007                341      CMP.B   #$7,D0                 ;Compare first nibble
0000115E  6600 000C                342      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
00001162  4EB9 0000193E            343      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
00001168  6000 008E                344      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000116C                           345  
0000116C                           346  
0000116C                           347  GROUP_8:                ;$8| DIVS, OR
0000116C  B03C 0008                348      CMP.B   #$8,D0                 ;Compare first nibble
00001170  6600 000C                349      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
00001174  4EB9 00001962            350      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
0000117A  6000 007C                351      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000117E                           352  
0000117E                           353  
0000117E                           354  GROUP_9:                ;$9| SUB
0000117E  B03C 0009                355      CMP.B   #$9,D0                 ;Compare first nibble
00001182  6600 000C                356      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
00001186  4EB9 000019B8            357      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
0000118C  6000 006A                358      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001190                           359  
00001190                           360  
00001190                           361  GROUP_A:                ;$A| Display: DATA, $WXYZ (Unsupported)
00001190  B03C 000A                362      CMP.B   #$A,D0                 ;Compare first nibble
00001194  6600 000C                363      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
00001198  4EB9 00001A12            364      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
0000119E  6000 0058                365      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011A2                           366  
000011A2                           367  
000011A2                           368  GROUP_B:                ;$B| EOR, CMP
000011A2  B03C 000B                369      CMP.B   #$B,D0                 ;Compare first nibble
000011A6  6600 000C                370      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
000011AA  4EB9 00001A1A            371      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
000011B0  6000 0046                372      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011B4                           373  
000011B4                           374  
000011B4                           375  GROUP_C:                ;$C| MULS
000011B4  B03C 000C                376      CMP.B   #$C,D0                 ;Compare first nibble
000011B8  6600 000C                377      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
000011BC  4EB9 00001A7A            378      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
000011C2  6000 0034                379      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011C6                           380  
000011C6                           381  
000011C6                           382  GROUP_D:                 ;$D| ADD, ADDA
000011C6  B03C 000D                383      CMP.B   #$D,D0                 ;Compare first nibble
000011CA  6600 000C                384      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
000011CE  4EB9 00001B10            385      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
000011D4  6000 0022                386      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011D8                           387  
000011D8                           388  
000011D8                           389  GROUP_E:                ;$E| LSR, LSL, ASR, ASL, ROL, ROR
000011D8  B03C 000E                390      CMP.B   #$E,D0                 ;Compare first nibble
000011DC  6600 000C                391      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
000011E0  4EB9 00001B52            392      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
000011E6  6000 0010                393      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011EA                           394  
000011EA                           395  
000011EA                           396  GROUP_F:                ;$F| Display: DATA, $WXYZ (Unsupported)
000011EA  B03C 000F                397      CMP.B   #$F,D0                 ;Compare first nibble
000011EE  4EB9 00001CEA            398      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
000011F4  6000 0002                399      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011F8                           400  
000011F8                           401  
000011F8                           402  OP_JSR_DONE:
000011F8  4CDF 0003                403           MOVEM.L (SP)+,D0-D1       ;Recover register D0
000011FC  FFFF FFFF                404           SIMHALT
00001200                           405           ;JMP EA_ROUTINE        ;This runs EA's routines after OP code portion is finished
00001200                           406  **********************************************************************************
00001200                           407  
00001200                           408  ********** EA Parsing ************************************************************
00001200                           409  
00001200                           410  * MOVE_LAST_6_BITS_TO_EA
00001200                           411  **********************************************************************************
00001200                           412  * Description: For OP codes with the last 6 bits specified as EA Mode and EA Reg,
00001200                           413  * the last 6 bits will be parsed and moved into the appropriate registers.
00001200                           414  *
00001200                           415  * Registers used: A6,D0,D1,D6,D7 
00001200                           416  
00001200                           417  * Precondition: OP code has been identified with only the last 6 bits for EA,
00001200                           418  * current instruction set is stored into A6.
00001200                           419  
00001200                           420  * Postcondition: Last 6 bits of instruction bit has been isolated and stored. Bits
00001200                           421  * for EA Mode have been stored in D7, Bits for EA Reg been stored in D6.
00001200                           422  **********************************************************************************
00001200                           423  MOVE_LAST_6_BITS_TO_EA:      ;Move last 6 bits from EA field to relevant registers
00001200                           424     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
00001200  3038 4000                425      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
00001204  323C 000A                426      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
00001208  E368                     427      LSL.W   D1,D0            ;Truncate to find the last 6 bits
0000120A  E268                     428      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
0000120C  3E00                     429      MOVE.W  D0,D7            ;Move last 6 bits into D7
0000120E  323C 0003                430      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001212  E26F                     431      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00001214  3C07                     432      MOVE.W  D7,D6            ;Move the 'upper' 3 bits into D6
00001216  323C 000D                433      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
0000121A  E368                     434      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
0000121C  E268                     435      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
0000121E  3E00                     436      MOVE.W  D0,D7            ;Move the 'lower' 3 bits into D7
00001220                           437     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
00001220  4E75                     438      RTS                      ;Return to stack
00001222                           439      
00001222                           440  * FIND_2_BIT_SIZE_TO_EA
00001222                           441  **********************************************************************************
00001222                           442  * Description: For OP codes with 2 bit size fields, the 2 relevant bits (7-6) will 
00001222                           443  * be parsed and moved to the appropriate registers.
00001222                           444  *
00001222                           445  * Registers used: A6,D0,D1,D5
00001222                           446  *
00001222                           447  * Precondition: OP code has been identified with 2 size bit field for EA, current
00001222                           448  * instruction set for OP code is stored in to A6.
00001222                           449  *
00001222                           450  * Postcondition: 2 bit size field has been isolated and stored into D5.
00001222                           451  **********************************************************************************
00001222                           452  FIND_2_BIT_SIZE_TO_EA:      ;Move the 2 bit size field relevant register
00001222                           453     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001222  3038 4000                454      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
00001226  323C 0008                455      MOVE.W   #8,D1          ;Prepare 8 bit shift to D1
0000122A  E368                     456      LSL.W    D1,D0          ;Truncate to find the 2 size bits
0000122C  E268                     457      LSR.W    D1,D0          ;Reposition the bits
0000122E  323C 0006                458      MOVE.W   #6,D1          ;Prepare 6 bit shift to D1
00001232  E268                     459      LSR.W    D1,D0          ;Truncate to shift 2 bits to a byte
00001234  3800                     460      MOVE.W   D0,D4          ;Move 2 size bits into D5
00001236                           461    ;  MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
00001236  4E75                     462      RTS                     ;Return to stack
00001238                           463  **********************************************************************************
00001238                           464  
00001238                           465  * FIND_3_BIT_REG_TO_EA
00001238                           466  **********************************************************************************
00001238                           467  * Description: OP codes with a dynamic 3 bit register in bits 11-9 will be parsed
00001238                           468  * and have those 3 bits isolated and moved to the appropriate registers.
00001238                           469  *
00001238                           470  * Registers used: A6,D0,D1,D5
00001238                           471  *
00001238                           472  * Precondition: OP code has been identified with a dynamic 3 bit register in bits
00001238                           473  * 11-9.
00001238                           474  *
00001238                           475  * Postcondition: 3 bit dynamic register has been isolated and stored into D4.
00001238                           476  **********************************************************************************
00001238                           477  FIND_3_BIT_REG_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
00001238                           478     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001238  3038 4000                479      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
0000123C  323C 0004                480      MOVE.W   #4,D1          ;Prepare 4 bit shift to D1
00001240  E368                     481      LSL.W    D1,D0          ;Truncate to find the 2 size bits
00001242  E268                     482      LSR.W    D1,D0          ;Reposition the bits
00001244  323C 0009                483      MOVE.W   #9,D1          ;Prepare 9 bit shift to D1
00001248  E268                     484      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
0000124A  3A00                     485      MOVE.W   D0,D5          ;Move 3 register bits into D4
0000124C                           486     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
0000124C  4E75                     487      RTS                     ;Return to stack
0000124E                           488  **********************************************************************************
0000124E                           489  
0000124E                           490  * MOVE_AND_MOVEA_PARSE_EA
0000124E                           491  **********************************************************************************
0000124E                           492  * Description: Special parsing for the SRC and DST Mode/Reg for MOVE/MOVE
0000124E                           493  *
0000124E                           494  * Registers used: A6,D0,D1,D7,D6,D5,D4
0000124E                           495  *
0000124E                           496  * Precondition: OP code has been identified with either MOVE or MOVEA
0000124E                           497  *
0000124E                           498  * Postcondition: Store all relevant EA bits into associated register.
0000124E                           499  **********************************************************************************
0000124E                           500  MOVE_AND_MOVEA_PARSE_EA:       ;Move the 3 bit dynamic register bits to proper register
0000124E                           501     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
0000124E  3038 4000                502      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
00001252  323C 000A                503      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
00001256  E368                     504      LSL.W   D1,D0            ;Truncate to find the last 6 bits
00001258  E268                     505      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
0000125A  3E00                     506      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
0000125C  323C 0003                507      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001260  E26F                     508      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00001262  3A07                     509      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
00001264  323C 000D                510      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
00001268  E368                     511      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
0000126A  E268                     512      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
0000126C  3800                     513      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
0000126E                           514      **************MOVING SOURCE*********** TO BE DONE LATER
0000126E                           515      ; MOVE.W #%0011 011 001 001 101,(A6)              ;MOVEA.W A5,A3
0000126E                           516      ; MOVE.W #%0010 011 001 001 101,D0                ;MOVEA.L A5,A3
0000126E                           517       ;Expected values:
0000126E                           518      ;D7, DST REG:   011
0000126E                           519      ;D6, DST MODE:  001
0000126E                           520      ;D5, SRC MODE:  001
0000126E                           521      ;D4, SRC REG:   101
0000126E                           522      ;00011001
0000126E  3038 4000                523      MOVE.W CUR_OP_CODE,D0     ;Move current OP code into D0     
00001272  323C 0004                524      MOVE.W  #4,D1             ;Prepare 4 bit shift to D1
00001276  E368                     525      LSL.W   D1,D0             ;Truncate to find bits 11-6
00001278  E268                     526      LSR.W   D1,D0             ;Reposition bits
0000127A  323C 0006                527      MOVE.W  #6,D1             ;Prepare 6 bit shift to D1
0000127E  E268                     528      LSR.W   D1,D0             ;Truncate the SRC Reg/Mode bits
00001280  323C 0003                529      MOVE.W  #3,D1             ;Prepare a 3 bit shift to D1 for DST Reg/Mode
00001284  3C00                     530      MOVE.W  D0,D6             ;Copy over the current 6 bits to D6
00001286  E268                     531      LSR.W   D1,D0             ;Truncate DST Mode  
00001288  3E00                     532      MOVE.W  D0,D7             ;Move DST Reg to D7
0000128A  323C 000D                533      MOVE.W  #13,D1             
0000128E  E36E                     534      LSL.W   D1,D6             ;Truncate 13 bits in D6
00001290  E26E                     535      LSR.W   D1,D6             ;Reposition D6
00001292                           536                                ;D6 now contains the DST Reg
00001292                           537     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
00001292  4E75                     538      RTS                     ;Return to stack
00001294                           539  **********************************************************************************
00001294                           540  
00001294                           541  *FIND_TRAILING_BITS_TO_EA
00001294                           542  **********************************************************************************
00001294                           543  FIND_TRAILING_BITS_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
00001294                           544     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001294  3038 4000                545      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
00001298  323C 0007                546      MOVE.W   #7,D1          ;Prepare 4 bit shift to D1
0000129C  E368                     547      LSL.W    D1,D0          ;Truncate to find the 2 size bits
0000129E  E268                     548      LSR.W    D1,D0          ;Reposition the bits
000012A0  323C 0006                549      MOVE.W   #6,D1          ;Prepare 9 bit shift to D1
000012A4  E268                     550      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
000012A6  3680                     551      MOVE.W   D0,(A3)          ;Move 3 register bits into D4
000012A8                           552     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
000012A8  4E75                     553      RTS                    ;Return to stack
000012AA                           554  **********************************************************************************
000012AA                           555  
000012AA                           556  *PARSE_EA_CONSTANT_BITS
000012AA                           557  **********************************************************************************
000012AA                           558  * Definition: Uses CUR_OP_CODE to shift the proper bits into the global constants
000012AA                           559  * used for EA (MNEMONIC,FIRST_3,SECOND_3,THIRD_3,FOURTH_3. Where MNEMONIC refers
000012AA                           560  * to the first 4 bits of CUR_OP_CODE (15-12), FIRST_3 refers to the first group
000012AA                           561  * of 3 bits (11-9), SECOND_3 refers to the second group of 3 bits (8-6), THIRD_3
000012AA                           562  * refers to the third group of 3 bits (5-3), and FOURTH_3 refers to the fourth
000012AA                           563  * group of 3 bits (2-0). Shifts CUR_OP_CODE bits to initialize constants.
000012AA                           564  *
000012AA                           565  * Registers used: D0,D1
000012AA                           566  *
000012AA                           567  * Precondition: CUR_OP_CODE has been set with an 4 hex instruction set
000012AA                           568  * 
000012AA                           569  * Postcondition: MNEMONIC, FIRST_3, SECOND_3, THIRD_3, FOURTH_3 have been set
000012AA                           570  * to the corresponding values.
000012AA                           571  **********************************************************************************
000012AA                           572  PARSE_EA_CONSTANT_BITS:
000012AA                           573      *MNEMONIC SHIFT
000012AA  3038 4000                574      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
000012AE  323C 000C                575      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
000012B2  E268                     576      LSR.W D1,D0                 ;Shift 12 bits from D0 right
000012B4  11C0 1000                577      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
000012B8                           578      *FIRST_3 SHIFT
000012B8  323C 0009                579      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
000012BC  3038 4000                580      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012C0  E948                     581      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
000012C2  E848                     582      LSR.W #4,D0                 ;Reposition D0
000012C4  E268                     583      LSR.W  D1,D0                ;Shift D0 9 bits right
000012C6  11C0 1004                584      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
000012CA                           585      *SECOND_3 SHIFT
000012CA  3038 4000                586      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012CE  EF48                     587      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
000012D0  EE48                     588      LSR.W #7,D0                 ;Reposition D0
000012D2  EC48                     589      LSR.W #6,D0                 ;Shift D0 6 bits right
000012D4  11C0 1005                590      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
000012D8                           591      *THIRD_3 SHIFT
000012D8  3038 4000                592      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012DC  E648                     593      LSR.W #3,D0                 ;Shift D0 3 bits right
000012DE  323C 000D                594      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
000012E2  E368                     595      LSL.W D1,D0                 ;Truncate first 13 bits of D0
000012E4  E268                     596      LSR.W D1,D0                 ;Reposition D0
000012E6  11C0 1006                597      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
000012EA                           598      *FOURTH_3 SHIFT
000012EA  3038 4000                599      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012EE  E368                     600      LSL.W D1,D0                 ;Grab the fourth 3-bit group
000012F0  E268                     601      LSR.W D1,D0                 ;Shift D0 back into position
000012F2  11C0 1007                602      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
000012F6  4E75                     603      RTS                         ;Return to stack
000012F8                           604  **********************************************************************************
000012F8                           605  ********** End of EA Parsing *****************************************************
000012F8                           606  
000012F8                           607  *******************JMP LABELS ****************************************************
000012F8                           608  * Labelling for group codes will be in the following format
000012F8                           609  
000012F8                           610  * <JMP Labelname>
000012F8                           611  ********************************************************************************
000012F8                           612  * Checking List Order (If more than one value)
000012F8                           613  * Operand1 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000012F8                           614  * Operand2 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000012F8                           615  
000012F8                           616  * Where a-b will refer to the bit corresponding bit value in the instruction
000012F8                           617  * format, and a specifier will be attached such as Size, EA Mode, SRC Reg, etc
000012F8                           618  * to clarify what a specific bit range means.
000012F8                           619  * Checking order refers to what order the checks will be performed in. 
000012F8                           620  * Any other code outside of the listed ones will be INVALID_OP.
000012F8                           621  ********************************************************************************
000012F8                           622  
000012F8                           623  ********************************************************************************
000012F8                           624  * Global Field Descriptions
000012F8                           625  * Size Field: Byte = 00 Word = 01 Long = 10
000012F8                           626  * EA Mode: Refer to EA Address Modes
000012F8                           627  * EA Reg: 3-bit input that is mapped to the respective binary value
000012F8                           628  ********************************************************************************
000012F8                           629  
000012F8                           630  * GROUP_0                      
000012F8                           631  ********************************************************************************
000012F8                           632  * Description: Checks for the following listed OP codes to be present or not
000012F8                           633  * Supported OP codes:
000012F8                           634  * ORI: $00, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000012F8                           635  * CMPI: $0C, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000012F8                           636  * Dynamic BCLR: $0, 11-9 Register, 8-6 %110, 5-3 EA Mode, 2-0 EA Reg
000012F8                           637  * Static BCLR: $01, 7-6 10, 5-3 EA Mode, 2-0 EA Reg
000012F8                           638  *
000012F8                           639  * Registers used: D0
000012F8                           640  *
000012F8                           641  * Precondition: First nibble has been identified as $0
000012F8                           642  *
000012F8                           643  * Postcondition: Parses proper OP code with a nibble value of $0 or finds an
000012F8                           644  * invalid OP code. After a successful parse loading for EA values will be done
000012F8                           645  * through a subroutine.
000012F8                           646  * 
000012F8                           647  * Unsupported OP codes:
000012F8                           648  * ORI_TO_CCR, ORI_TO_SR, ANDI_TO_CCR, ANDI_TO_SR, ANDI, SUBI, ADDI, EORI_TO_CCR
000012F8                           649  * EORI_TO_SR, EORI, STATIC_BTST, STATIC_BCHG, STATIC_BSET, DYNAMIC_BTST,
000012F8                           650  * DYNAMIC_BCHG, DYNAMIC_BSET, MOVEP 
000012F8                           651  ********************************************************************************
000012F8                           652  C_GROUP_0:
000012F8  48E7 C000                653      MOVEM.L D0-D1, -(SP)            ;Backup registers
000012FC                           654      
000012FC                           655  *Unsupported OP codes that are fully static in bits
000012FC                           656  CHECK_OP_ORI_TO_CCR:
000012FC  3038 4000                657      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001300  B07C 003C                658      CMP.W #$003C,D0                 ;Compare the direct full bits
00001304  6700 01B4                659      BEQ GROUP0_INVALID              ;INVALID OP code found
00001308  6600 0002                660      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
0000130C                           661      
0000130C                           662  CHECK_OP_ORI_TO_SR:
0000130C  3038 4000                663      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001310  B07C 007C                664      CMP.W #$007C,D0                 ;Compare the direct full bits
00001314  6700 01A4                665      BEQ GROUP0_INVALID              ;INVALID OP code found
00001318  6600 0002                666      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
0000131C                           667      
0000131C                           668  CHECK_OP_ANDI_TO_CCR:
0000131C  3038 4000                669      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001320  B07C 023C                670      CMP.W #$023C,D0                 ;Compare the direct full bits
00001324  6700 0194                671      BEQ GROUP0_INVALID              ;INVALID OP code found
00001328  6600 0002                672      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
0000132C                           673      
0000132C                           674  CHECK_OP_ANDI_TO_SR:
0000132C  3038 4000                675      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001330  B07C 027C                676      CMP.W #$027C,D0                 ;Compare the direct full bits
00001334  6700 0184                677      BEQ GROUP0_INVALID              ;INVALID OP code found
00001338  6600 0022                678      BNE CHECK_OP_ANDI               ;Check next routine
0000133C                           679  
0000133C                           680  CHECK_OP_EORI_TO_CCR:
0000133C  3038 4000                681      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001340  B07C 0A3C                682      CMP.W #$0A3C,D0                 ;Compare the direct full bits
00001344  6700 0174                683      BEQ GROUP0_INVALID              ;INVALID OP code found
00001348  6600 0002                684      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
0000134C                           685      
0000134C                           686  CHECK_OP_EORI_TO_SR:
0000134C  3038 4000                687      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001350  B07C 0A7C                688      CMP.W #$0A7C,D0                 ;Compare the direct full bits
00001354  6700 0164                689      BEQ GROUP0_INVALID              ;INVALID OP code found
00001358  6600 0002                690      BNE CHECK_OP_ANDI               ;Check next routine
0000135C                           691      
0000135C                           692  *Unsupported OP codes to check with partial static bits
0000135C                           693  CHECK_OP_ANDI:
0000135C  3038 4000                694      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001360  0240 FF00                695      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001364  B07C 0200                696      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
00001368  6700 0150                697      BEQ GROUP0_INVALID              ;INVALID OP code found
0000136C  6600 0002                698      BNE CHECK_OP_SUBI               Check next routine
00001370                           699      
00001370                           700  CHECK_OP_SUBI:
00001370  3038 4000                701      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001374  0240 FF00                702      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001378  B07C 0400                703      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
0000137C  6700 013C                704      BEQ GROUP0_INVALID              ;INVALID OP code found
00001380  6600 0002                705      BNE CHECK_OP_ADDI               ;Check next routine
00001384                           706  
00001384                           707  CHECK_OP_ADDI:
00001384  3038 4000                708      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001388  0240 FF00                709      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000138C  B07C 0600                710      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00001390  6700 0128                711      BEQ GROUP0_INVALID              ;INVALID OP code found
00001394  6600 0002                712      BNE CHECK_OP_EORI               ;Check next routine 
00001398                           713  
00001398                           714  CHECK_OP_EORI:
00001398  3038 4000                715      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000139C  0240 FF00                716      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000013A0  B07C 0A00                717      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
000013A4  6700 0114                718      BEQ GROUP0_INVALID              ;INVALID OP code found
000013A8  6600 0002                719      BNE CHECK_OP_STATIC_BTST        ;Check next routine
000013AC                           720      
000013AC                           721  CHECK_OP_STATIC_BTST:
000013AC  3038 4000                722      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013B0  0240 FFC0                723      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013B4  B07C 0800                724      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
000013B8  6700 0100                725      BEQ GROUP0_INVALID              ;INVALID OP code found
000013BC  6600 0002                726      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
000013C0                           727      
000013C0                           728  CHECK_OP_STATIC_BCHG:
000013C0  3038 4000                729      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013C4  0240 FFC0                730      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013C8  B07C 0840                731      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
000013CC  6700 00EC                732      BEQ GROUP0_INVALID              ;INVALID OP code found
000013D0  6600 0002                733      BNE CHECK_OP_STATIC_BSET        ;Check next routine
000013D4                           734  
000013D4                           735  CHECK_OP_STATIC_BSET:
000013D4  3038 4000                736      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013D8  0240 FFC0                737      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013DC  B07C 08C0                738      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
000013E0  6700 00D8                739      BEQ GROUP0_INVALID              ;INVALID OP code found   
000013E4  6600 0002                740      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
000013E8                           741  
000013E8                           742  CHECK_OP_DYNAMIC_BTST:
000013E8  3038 4000                743      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013EC  0240 F1C0                744      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
000013F0  B07C 0100                745      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
000013F4  6700 00C4                746      BEQ GROUP0_INVALID              ;INVALID OP code found
000013F8  6600 0002                747      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
000013FC                           748  
000013FC                           749  CHECK_OP_DYNAMIC_BCHG:
000013FC  3038 4000                750      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001400  0240 F1C0                751      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001404  B07C 0140                752      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00001408  6700 00B0                753      BEQ GROUP0_INVALID              ;INVALID OP code found
0000140C  6600 0002                754      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001410                           755      
00001410                           756  CHECK_OP_DYNAMIC_BSET:
00001410                           757  
00001410  3038 4000                758      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001414  0240 F1C0                759      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001418  B07C 01C0                760      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
0000141C  6700 0006                761      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001420  6600 001C                762      BNE     CHECK_OP_MOVEP          ;Check next routine
00001424                           763  
00001424                           764  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00001424  3038 4000                765      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001428  323C 000A                766      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
0000142C  E368                     767      LSL.W   D1,D0                   ;Shift out 10 bits left 
0000142E  E268                     768      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001430  E648                     769      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00001432  B07C 0001                770      CMP.W   #$1,D0                  ;Compare bits to D0
00001436  6700 0006                771      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
0000143A  6600 007E                772      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid                                                    
0000143E                           773      
0000143E                           774  CHECK_OP_MOVEP:
0000143E  3038 4000                775      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001442  0240 F138                776      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00001446  B07C 0108                777      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
0000144A  6700 08A6                778      BEQ INVALID_OP                  ;INVALID OP code found
0000144E  6600 0002                779      BNE CHECK_OP_ORI                ;Check next routine
00001452                           780  
00001452                           781  *Supported OP code checks
00001452                           782  CHECK_OP_ORI:
00001452  3038 4000                783      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001456  0240 FF00                784      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
0000145A  B07C 0000                785      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
0000145E  6600 000C                786      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00001462  4EB9 00001D20            787      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
00001468  6000 0056                788      BRA     GROUP0_SUCCESS          ;Finish routine
0000146C                           789      
0000146C                           790  CHECK_OP_CMPI:
0000146C  3038 4000                791      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001470  0240 FF00                792      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001474  B07C 0C00                793      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
00001478  6600 000C                794      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
0000147C  4EB9 00001D30            795      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00001482  6000 003C                796      BRA     GROUP0_SUCCESS          ;Finish routine
00001486                           797      
00001486                           798  CHECK_OP_STATIC_BCLR:
00001486  3038 4000                799      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000148A  0240 FF00                800      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
0000148E  B07C 0800                801      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00001492  6600 000C                802      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00001496  4EB9 00001D40            803      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
0000149C  6000 0022                804      BRA     GROUP0_SUCCESS          ;Finish routine
000014A0                           805      
000014A0                           806  CHECK_OP_DYNAMIC_BCLR:
000014A0  3038 4000                807      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000014A4  0240 0180                808      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
000014A8  B07C 0180                809      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
000014AC  6600 000C                810      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
000014B0  4EB9 00001D50            811      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
000014B6  6000 0008                812      BRA     GROUP0_SUCCESS          ;Finish routine
000014BA                           813  
000014BA                           814  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
000014BA  4EB9 00001CF2            815      JSR INVALID_OP                  ;INVALID OP code found
000014C0                           816      
000014C0                           817  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
000014C0  4CDF 0003                818      MOVEM.L (SP)+,D0-D1             ;Restore registers
000014C4  4E75                     819      RTS                             ;Return to stack
000014C6                           820      
000014C6                           821  * GROUP_1                      
000014C6                           822  ********************************************************************************
000014C6                           823  * Supported OP code:
000014C6                           824  * MOVE.B: $1, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
000014C6                           825  ********************************************************************************
000014C6                           826  C_GROUP_1:
000014C6  48E7 C000                827      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
000014CA                           828  
000014CA                           829  CHECK_OP_MOVE_B:
000014CA  3038 4000                830      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
000014CE  0240 F000                831      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
000014D2  B07C 1000                832      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
000014D6  6600 000C                833      BNE     GROUP1_INVALID          ;Invalid OP code has been found
000014DA  4EB9 00001D60            834      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
000014E0  6000 0008                835      BRA     GROUP1_SUCCESS          ;Finish routine
000014E4                           836      
000014E4                           837  GROUP1_INVALID:
000014E4  4EB9 00001CF2            838      JSR INVALID_OP                  ;Invalid OP code found
000014EA                           839      
000014EA                           840  GROUP1_SUCCESS:
000014EA  4CDF 0003                841      MOVEM.L (SP)+,D0-D1             ;Restore register
000014EE  4E75                     842      RTS                             ;Return to stack
000014F0                           843  * GROUP_2
000014F0                           844  ********************************************************************************
000014F0                           845  * Supported OP codes:
000014F0                           846  * MOVEA.L: $2, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
000014F0                           847  * MOVE.L: $2, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
000014F0                           848  ********************************************************************************
000014F0                           849  C_GROUP_2:
000014F0  48E7 E000                850      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
000014F4                           851  
000014F4                           852  CHECK_OP_MOVEA_L:
000014F4  3038 4000                853      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
000014F8  0240 F000                854      ANDI.W #$F000,D0                ;Mask relevant bits to D0
000014FC  B07C 2000                855      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001500  4EF9 00001506            856      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00001506                           857      
00001506                           858  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00001506  3038 4000                859      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
0000150A  323C 0007                860      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
0000150E  E368                     861      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001510  E268                     862      LSR.W    D1,D0                  ;Reposition the bits
00001512  323C 0006                863      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00001516  E268                     864      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00001518  3400                     865      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
0000151A  B47C 0001                866      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
0000151E  6600 000C                867      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00001522  4EB9 00001D70            868      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00001528  6000 0022                869      BRA     GROUP2_SUCCESS          ;Finish routine
0000152C                           870      
0000152C                           871      
0000152C                           872  CHECK_OP_MOVE_L:
0000152C  3038 4000                873      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001530  0240 F000                874      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001534  B07C 2000                875      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001538  6600 000C                876      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
0000153C  4EB9 00001D80            877      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00001542  6000 0008                878      BRA GROUP2_SUCCESS              ;Finish routine
00001546                           879      
00001546                           880  GROUP2_INVALID:    
00001546  4EB9 00001CF2            881      JSR INVALID_OP                  ;Invalid OP code found
0000154C                           882      
0000154C                           883  GROUP2_SUCCESS:
0000154C  4CDF 0007                884      MOVEM.L (SP)+,D0-D2             ;Restore register
00001550  4E75                     885      RTS                             ;Return to stack
00001552                           886  * GROUP_3
00001552                           887  ********************************************************************************
00001552                           888  * Supported OP codes:
00001552                           889  * MOVEA.W: $3, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
00001552                           890  * MOVE.W: $3, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00001552                           891  ********************************************************************************
00001552                           892  C_GROUP_3:
00001552  48E7 E000                893      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001556                           894      
00001556                           895  CHECK_OP_MOVEA_W:
00001556  3038 4000                896      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
0000155A  0240 F000                897      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
0000155E  B07C 3000                898      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001562  4EF9 00001568            899      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
00001568                           900  
00001568                           901      
00001568                           902  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
00001568  3038 4000                903      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
0000156C  323C 0007                904      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00001570  E368                     905      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00001572  E268                     906      LSR.W    D1,D0                 ;Reposition the bits
00001574  323C 0006                907      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
00001578  E268                     908      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
0000157A  3400                     909      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
0000157C  B47C 0001                910      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00001580  6600 000C                911      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00001584  4EB9 00001D90            912      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
0000158A  6000 0022                913      BRA      GROUP3_SUCCESS        ;Finish routine
0000158E                           914      
0000158E                           915  CHECK_OP_MOVE_W:
0000158E  3038 4000                916      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001592  0240 F000                917      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001596  B07C 3000                918      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
0000159A  6600 000C                919      BNE      GROUP3_INVALID        ;INVALID OP code found
0000159E  4EB9 00001DA0            920      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
000015A4  6000 0008                921      BRA      GROUP3_SUCCESS        ;Finish routine
000015A8                           922      
000015A8                           923  GROUP3_INVALID:
000015A8  4EB9 00001CF2            924      JSR INVALID_OP                 ;INVALID OP code found
000015AE                           925  
000015AE                           926  GROUP3_SUCCESS:
000015AE  4CDF 0007                927      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
000015B2  4E75                     928      RTS                            ;Return to stack
000015B4                           929  
000015B4                           930  * GROUP_4
000015B4                           931  ********************************************************************************
000015B4                           932  * Supported OP codes:
000015B4                           933  * LEA: $4, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
000015B4                           934  * JSR: $4E, 7-6 %10, 5-3 EA Mode, 2-0 EA Reg 
000015B4                           935  * RTS: $4E75
000015B4                           936  * NEG: $44, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000015B4                           937  * MOVEM: $4, 11 %1, 10 %D, 9-7 %001, 6 S, 5-3 EA Mode, 2-0 EA Reg
000015B4                           938  * %D = 0 , Register to Memory, 1 Memory to Register
000015B4                           939  * Unsupported OP codes: MOVE_FROM_SR, MOVE_TO_CCR, MOVE_TO_SR, NEGX, CLR, NOT
000015B4                           940  * EXT, NBCD, SWAP, PEA, ILLEGAL, TAS, TST, TRAP, LINK, UNLK, MOVE_USP, RESET,
000015B4                           941  * NOP, STOP, RTE, TRAPV, RTR, JMP, CHK
000015B4                           942  ********************************************************************************
000015B4                           943  C_GROUP_4:
000015B4  2F00                     944      MOVE.L  D0,-(SP)            ;Save registers
000015B6                           945      
000015B6                           946  *Unsupported OP codes to check that are full static bits
000015B6                           947  CHECK_OP_STOP:
000015B6  3038 4000                948      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015BA  B07C 4E72                949      CMP.W  #$4E72,D0                ;Compare the appropriate bits
000015BE  6700 0266                950      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015C2  6600 0002                951      BNE    CHECK_OP_RESET           ;Check next OP code
000015C6                           952      
000015C6                           953  CHECK_OP_RESET:
000015C6  3038 4000                954      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015CA  B07C 4E70                955      CMP.W  #$4E70,D0                ;Compare the appropriate bits
000015CE  6700 0256                956      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015D2  6600 0002                957      BNE    CHECK_OP_NOP             ;Check next OP code
000015D6                           958      
000015D6                           959  CHECK_OP_NOP:
000015D6  3038 4000                960      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015DA  B07C 4E71                961      CMP.W  #$4E71,D0                ;Compare the appropriate bits
000015DE  6700 0246                962      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015E2  6600 0002                963      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
000015E6                           964      
000015E6                           965  CHECK_OP_ILLEGAL:
000015E6  3038 4000                966      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015EA  B07C 4AFC                967      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
000015EE  6700 0236                968      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015F2  6600 0002                969      BNE    CHECK_OP_RTE             ;Check next OP code
000015F6                           970      
000015F6                           971  CHECK_OP_RTE:    
000015F6  3038 4000                972      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015FA  B07C 4E73                973      CMP.W #$4E73,D0                 ;Compare the appropriate bits
000015FE  6700 0226                974      BEQ   GROUP4_INVALID            ;INVALID OP code found
00001602  6600 0002                975      BNE   CHECK_OP_TRAPV            ;Check next OP code
00001606                           976      
00001606                           977  CHECK_OP_TRAPV:
00001606  3038 4000                978      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000160A  B07C 4E76                979      CMP.W  #$4E76,D0                ;Compare the appropriate bits
0000160E  6700 0216                980      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001612  6600 0002                981      BNE    CHECK_OP_RTR             ;Check next OP code
00001616                           982      
00001616                           983  CHECK_OP_RTR:
00001616  3038 4000                984      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000161A  B07C 4E77                985      CMP.W #$4E77,D0                 ;Compare the appropriate bits
0000161E  6700 0206                986      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001622  6600 0002                987      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00001626                           988  
00001626                           989  
00001626                           990  *Unsupported OP codes to check that have partial static bits
00001626                           991  CHECK_OP_MOVE_FROM_SR:
00001626  3038 4000                992      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000162A  0240 FFC0                993      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
0000162E  B07C 40C0                994      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00001632  6700 01F2                995      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00001636  6600 0002                996      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
0000163A                           997      
0000163A                           998  CHECK_OP_MOVE_TO_CCR:
0000163A  3038 4000                999      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000163E  0240 FFC0               1000      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001642  B07C 44C0               1001      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00001646  6700 01DE               1002      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000164A  6600 0002               1003      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
0000164E                          1004      
0000164E                          1005  CHECK_OP_MOVE_TO_SR:
0000164E  3038 4000               1006      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001652  0240 FFC0               1007      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001656  B07C 46C0               1008      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
0000165A  6700 01CA               1009      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000165E  6600 0002               1010      BNE    CHECK_OP_NEGX            ;Check next OP code
00001662                          1011      
00001662                          1012  CHECK_OP_NEGX:
00001662  3038 4000               1013      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
00001666  0240 FF00               1014      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000166A  B07C 4000               1015      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
0000166E  6700 01B6               1016      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001672  6600 0002               1017      BNE    CHECK_OP_CLR             ;Check next OP code
00001676                          1018      
00001676                          1019  CHECK_OP_CLR:
00001676  3038 4000               1020      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000167A  0240 FF00               1021      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000167E  B07C 4200               1022      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00001682  6700 01A2               1023      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001686  6600 0002               1024      BNE    CHECK_OP_NOT             ;Check next OP code
0000168A                          1025      
0000168A                          1026  CHECK_OP_NOT:
0000168A  3038 4000               1027      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000168E  0240 FF00               1028      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001692  B07C 4600               1029      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00001696  6700 018E               1030      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000169A  6600 0002               1031      BNE    CHECK_OP_EXT             ;Check next OP code
0000169E                          1032      
0000169E                          1033  CHECK_OP_EXT:
0000169E  3038 4000               1034      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016A2  0240 FF80               1035      ANDI.W #$FF80,D0                ;Mask relevant bits to D0
000016A6  B07C 4880               1036      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
000016AA  6700 017A               1037      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
000016AE  6600 001C               1038      BNE    CHECK_OP_NBCD            ;Check next OP code
000016B2                          1039  
000016B2                          1040  BIT_CHECK_EXT:    
000016B2  3038 4000               1041      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
000016B6  323C 000A               1042      MOVE.W #10,D1
000016BA  E368                    1043      LSL.W  D1,D0
000016BC  E068                    1044      LSR.W  D0,D0
000016BE  E648                    1045      LSR.W  #3,D0
000016C0  B078 0000               1046      CMP.W  %000,D0
000016C4  6700 0160               1047      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
000016C8  6600 0142               1048      BNE    CHECK_OP_MOVEM           ;This is the only other possibility 
000016CC                          1049      
000016CC                          1050  CHECK_OP_NBCD:
000016CC  3038 4000               1051      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016D0  0240 FFC0               1052      ANDI.W #$FFC0,D0            
000016D4  B07C 4800               1053      CMP.W  #$4800,D0
000016D8  6700 014C               1054      BEQ    GROUP4_INVALID
000016DC  6600 0002               1055      BNE    CHECK_OP_SWAP
000016E0                          1056      
000016E0                          1057  CHECK_OP_SWAP:                  ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
000016E0  3038 4000               1058      MOVE.W CUR_OP_CODE,D0       ;Move current instruction set into D0
000016E4  0240 FF48               1059      ANDI.W #$FF48,D0
000016E8  B07C 4840               1060      CMP.W  #$4840,D0
000016EC  6700 0138               1061      BEQ    GROUP4_INVALID
000016F0  6600 0002               1062      BNE    CHECK_OP_PEA
000016F4                          1063   
000016F4                          1064  CHECK_OP_PEA:               ; This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
000016F4  3038 4000               1065      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000016F8  0240 FF40               1066      ANDI.W #$FF40,D0
000016FC  B07C 4840               1067      CMP.W  #$4840,D0
00001700  6700 0124               1068      BEQ    GROUP4_INVALID
00001704  6600 0002               1069      BNE    CHECK_OP_TAS
00001708                          1070      
00001708                          1071  CHECK_OP_TAS:
00001708  3038 4000               1072      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000170C  0240 FFC0               1073      ANDI.W #$FFC0,D0
00001710  B07C 4AC0               1074      CMP.W  #$4AC0,D0
00001714  6700 0110               1075      BEQ    GROUP4_INVALID
00001718  6600 0002               1076      BNE    CHECK_OP_TST
0000171C                          1077  
0000171C                          1078  CHECK_OP_TST:               ; This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
0000171C  3038 4000               1079      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001720  0240 FF00               1080      ANDI.W #$FF00,D0
00001724  B07C 4A00               1081      CMP.W  #$4A00,D0
00001728  6700 00FC               1082      BEQ    GROUP4_INVALID
0000172C  6600 0002               1083      BNE    CHECK_OP_TRAP
00001730                          1084      
00001730                          1085  CHECK_OP_TRAP:
00001730  3038 4000               1086      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001734  0240 FFF0               1087      ANDI.W #$FFF0,D0
00001738  B07C 4E40               1088      CMP.W  #$4E40,D0
0000173C  6700 00E8               1089      BEQ    GROUP4_INVALID
00001740  6600 0002               1090      BNE    CHECK_OP_LINK
00001744                          1091      
00001744                          1092  CHECK_OP_LINK:
00001744  3038 4000               1093      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001748  0240 FFF8               1094      ANDI.W #$FFF8,D0
0000174C  B07C 4E50               1095      CMP.W  #$4E50,D0
00001750  6700 00D4               1096      BEQ    GROUP4_INVALID
00001754  6600 0002               1097      BNE    CHECK_OP_UNLK
00001758                          1098  
00001758                          1099  CHECK_OP_UNLK:
00001758  3038 4000               1100      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000175C  0240 FFF8               1101      ANDI.W #$FFF8,D0
00001760  B07C 4E58               1102      CMP.W  #$4E58,D0
00001764  6700 00C0               1103      BEQ    GROUP4_INVALID
00001768  6600 0002               1104      BNE    CHECK_OP_MOVE_USP
0000176C                          1105      
0000176C                          1106  CHECK_OP_MOVE_USP:
0000176C  3038 4000               1107      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001770  0240 FFF0               1108      ANDI.W #$FFF0,D0
00001774  B07C 4E60               1109      CMP.W  #$4E60,D0
00001778  6700 00AC               1110      BEQ    GROUP4_INVALID
0000177C  6600 0002               1111      BNE    CHECK_OP_JMP
00001780                          1112  
00001780                          1113  CHECK_OP_JMP:
00001780  3038 4000               1114       MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001784  0240 FFC0               1115       ANDI.W #$FFC0,D0
00001788  B07C 4EC0               1116       CMP.W  #$4EC0,D0
0000178C  6700 0098               1117       BEQ    GROUP4_INVALID
00001790  6600 0002               1118       BNE    CHECK_OP_CHK
00001794                          1119       
00001794                          1120  CHECK_OP_CHK:
00001794  3038 4000               1121      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001798  0240 F1C0               1122      ANDI.W  #$F1C0,D0
0000179C  B07C 4180               1123      CMP.W   #$4180,D0
000017A0  6700 0550               1124      BEQ     INVALID_OP
000017A4  6600 0002               1125      BNE     CHECK_OP_RTS
000017A8                          1126  
000017A8                          1127  *Supported OP codes to check
000017A8                          1128  CHECK_OP_RTS:
000017A8  3038 4000               1129      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017AC  B07C 4E75               1130      CMP.W  #$4E75,D0
000017B0  6600 000C               1131      BNE    CHECK_OP_LEA
000017B4  4EB9 00001DC0           1132      JSR    PRINT_OP_RTS
000017BA  6000 0070               1133      BRA    GROUP4_SUCCESS              ;Finish routine
000017BE                          1134   
000017BE                          1135  CHECK_OP_LEA:
000017BE  3038 4000               1136      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017C2  0240 F1C0               1137      ANDI.W #$F1C0,D0
000017C6  B07C 41C0               1138      CMP.W  #$41C0,D0
000017CA  6600 000C               1139      BNE    CHECK_OP_JSR
000017CE  4EB9 00001DD0           1140      JSR    PRINT_OP_LEA
000017D4  6000 0056               1141      BRA    GROUP4_SUCCESS              ;Finish routine
000017D8                          1142   
000017D8                          1143  CHECK_OP_JSR:
000017D8  3038 4000               1144      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017DC  0240 FFC0               1145      ANDI.W #$FFC0,D0
000017E0  B07C 4E80               1146      CMP.W  #$4E80,D0
000017E4  6600 000C               1147      BNE    CHECK_OP_NEG
000017E8  4EB9 00001DB0           1148      JSR    PRINT_OP_JSR
000017EE  6000 003C               1149      BRA    GROUP4_SUCCESS              ;Finish routine
000017F2                          1150      
000017F2                          1151  CHECK_OP_NEG:
000017F2  3038 4000               1152      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017F6  0240 FF00               1153      ANDI.W #$FF00,D0
000017FA  B07C 4400               1154      CMP.W  #$4400,D0
000017FE  6600 000C               1155      BNE    CHECK_OP_MOVEM
00001802  4EB9 00001DE0           1156      JSR    PRINT_OP_NEG
00001808  6000 0022               1157      BRA    GROUP4_SUCCESS              ;Finish routine
0000180C                          1158  
0000180C                          1159      
0000180C                          1160  **************** COME BACK TO FINISH UP SIZE **********************************
0000180C                          1161  CHECK_OP_MOVEM:
0000180C  3038 4000               1162      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001810  0240 FB80               1163      ANDI.W #$FB80,D0
00001814  B07C 4880               1164      CMP.W  #$4880,D0
00001818  6600 04D8               1165      BNE    INVALID_OP       ;If no code is found, it is invalid
0000181C  4EB9 00001DF0           1166      JSR    PRINT_OP_MOVEM_W
00001822  6000 0008               1167      BRA    GROUP4_SUCCESS
00001826                          1168      
00001826                          1169  GROUP4_INVALID:
00001826  4EB9 00001CF2           1170      JSR INVALID_OP
0000182C                          1171  
0000182C                          1172  GROUP4_SUCCESS:
0000182C  4CDF 0001               1173      MOVEM.L (SP)+,D0 
00001830  4E75                    1174      RTS
00001832                          1175  * GROUP_5
00001832                          1176  ********************************************************************************
00001832                          1177  * Supported OP code:
00001832                          1178  * SUBQ: $5, 11-9 DATA, 8 %1, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00001832                          1179  * Unsupported OP codes: ADDQ, Scc, DBcc
00001832                          1180  * Validation checking:
00001832                          1181  * Check against, ADDQ, Scc, DBcc
00001832                          1182  ********************************************************************************
00001832                          1183  C_GROUP_5:
00001832  48E7 8000               1184      MOVEM.L D0,-(SP)         ;Save registers to stack
00001836                          1185  *Unsupported OP codes
00001836                          1186  CHECK_OP_DBcc:               ;These are ordered first due to checking bits 7-6
00001836  3038 4000               1187      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000183A  0240 F0C8               1188      ANDI.W #$F0C8,D0
0000183E  B07C 50C8               1189      CMP.W  #$50C8,D0
00001842  6700 0048               1190      BEQ    GROUP5_INVALID
00001846  6600 0002               1191      BNE    CHECK_OP_Scc 
0000184A                          1192  
0000184A                          1193  CHECK_OP_Scc:
0000184A  3038 4000               1194      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000184E  0240 F0C0               1195      ANDI.W #$F0C0,D0 
00001852  B07C 50C0               1196      CMP.W  #$50C0,D0
00001856  6700 0034               1197      BEQ     GROUP5_INVALID
0000185A  6600 0002               1198      BNE     CHECK_OP_ADDQ
0000185E                          1199  
0000185E                          1200  CHECK_OP_ADDQ:
0000185E  3038 4000               1201      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001862  0240 F100               1202      ANDI.W #$F100,D0
00001866  B07C 5000               1203      CMP.W  #$5000,D0
0000186A  6700 0020               1204      BEQ    GROUP5_INVALID
0000186E  6600 0002               1205      BNE    CHECK_OP_SUBQ
00001872                          1206  
00001872                          1207  *Supported OP code   
00001872                          1208  CHECK_OP_SUBQ     
00001872  3038 4000               1209      MOVE.W  CUR_OP_CODE,D0  ;Actual check for SUBQ
00001876  0240 F100               1210      ANDI.W #$F100,D0        ;Bitmask check for SUBQ
0000187A  B07C 5100               1211      CMP.W  #$5100,D0        ;Compare the proper value
0000187E  6600 000C               1212      BNE    GROUP5_INVALID       ;Else the operand is invalid
00001882  4EB9 00001E10           1213      JSR    PRINT_OP_SUBQ    ;If equal print it out
00001888  6000 0008               1214      BRA    GROUP5_SUCCESS   ;Finish routine
0000188C                          1215      
0000188C                          1216  GROUP5_INVALID: 
0000188C  4EB9 00001CF2           1217      JSR INVALID_OP          ;INVALID OP has been found
00001892                          1218  
00001892                          1219  GROUP5_SUCCESS:
00001892  4CDF 0001               1220      MOVEM.L (SP)+,D0        ;Restore registers from stack
00001896  4E75                    1221      RTS                     ;Return to stack
00001898                          1222      
00001898                          1223  * GROUP_6
00001898                          1224  ********************************************************************************
00001898                          1225  * Supported OP codes
00001898                          1226  * BRA: $60, 7-0 8-Bit Displacement
00001898                          1227  * Bcc: $6, 11-8 Condition, 7-0 8-Bit Displacement
00001898                          1228  *   Branch: <Condition>   
00001898                          1229  *   BCS: %0101          
00001898                          1230  *   BGE: %1100      
00001898                          1231  *   BLT: %1101  
00001898                          1232  *   BVC: %1000
00001898                          1233  *   
00001898                          1234  *   MOVE.W #%0110010100000000   ;BCS
00001898                          1235  *   MOVE.W #%0110110001010101   ;BGE
00001898                          1236  *   MVE.W #%0110110110101010    ;BLT
00001898                          1237  *   MOVE.W #%0110100001010101   ;BVC
00001898                          1238  * Unsupported OP code: BSR
00001898                          1239  ********************************************************************************
00001898                          1240  C_GROUP_6:
00001898  48E7 8000               1241      MOVEM.L D0,-(SP)        ;Save register to stack
0000189C                          1242  *Unsupported OP code
0000189C                          1243  CHECK_OP_BSR:
0000189C  3038 4000               1244      MOVE.W  CUR_OP_CODE,D0
000018A0  0240 FF00               1245      ANDI.W  #$FF00,D0
000018A4  B07C 6100               1246      CMP.W   #$6100,D0
000018A8  6700 0088               1247      BEQ     GROUP6_INVALID
000018AC  6600 0002               1248      BNE     CHECK_OP_BRA
000018B0                          1249      
000018B0                          1250  *Supported OP codes
000018B0                          1251  CHECK_OP_BRA:
000018B0  3038 4000               1252      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0       
000018B4  0240 FF00               1253      ANDI.W  #$FF00,D0
000018B8  B07C 6000               1254      CMP.W   #$6000,D0
000018BC  6600 000C               1255      BNE     CHECK_OP_BCS
000018C0  4EB9 00001E60           1256      JSR     PRINT_OP_BRA
000018C6  6000 0070               1257      BRA     GROUP6_SUCCESS
000018CA                          1258      
000018CA                          1259  CHECK_OP_BCS:
000018CA  3038 4000               1260      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000018CE  0240 FF00               1261      ANDI.W #$FF00,D0
000018D2  B07C 6500               1262      CMP.W  #$6500,D0 
000018D6  6600 000C               1263      BNE    CHECK_OP_BGE
000018DA  4EB9 00001E20           1264      JSR    PRINT_OP_BCS
000018E0  6000 0056               1265      BRA    GROUP6_SUCCESS
000018E4                          1266  
000018E4                          1267      
000018E4                          1268  CHECK_OP_BGE:
000018E4  3038 4000               1269      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000018E8  0240 FF00               1270      ANDI.W #$FF00,D0
000018EC  B07C 6C00               1271      CMP.W  #$6C00,D0 
000018F0  6600 000C               1272      BNE    CHECK_OP_BLT
000018F4  4EB9 00001E30           1273      JSR    PRINT_OP_BGE
000018FA  6000 003C               1274      BRA    GROUP6_SUCCESS
000018FE                          1275      
000018FE                          1276      
000018FE                          1277  CHECK_OP_BLT:
000018FE  3038 4000               1278      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001902  0240 FF00               1279      ANDI.W #$FF00,D0
00001906  B07C 6D00               1280      CMP.W  #$6D00,D0 
0000190A  6600 000C               1281      BNE    CHECK_OP_BVC
0000190E  4EB9 00001E40           1282      JSR    PRINT_OP_BLT
00001914  6000 0022               1283      BRA    GROUP6_SUCCESS
00001918                          1284      
00001918                          1285  CHECK_OP_BVC:
00001918  3038 4000               1286      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000191C  0240 FF00               1287      ANDI.W #$FF00,D0
00001920  B07C 6800               1288      CMP.W  #$6800,D0 
00001924  6600 000C               1289      BNE    GROUP6_INVALID
00001928  4EB9 00001E50           1290      JSR    PRINT_OP_BVC
0000192E  6000 0008               1291      BRA    GROUP6_SUCCESS
00001932                          1292      
00001932                          1293  GROUP6_INVALID:
00001932  4EB9 00001CF2           1294      JSR    INVALID_OP    
00001938                          1295          
00001938                          1296  GROUP6_SUCCESS:
00001938  4CDF 0001               1297      MOVEM.L (SP)+,D0
0000193C  4E75                    1298      RTS
0000193E                          1299      
0000193E                          1300  *GROUP_7
0000193E                          1301  ********************************************************************************
0000193E                          1302  * Currently no OP codes here are supported. MOVEQ is the only code in this group
0000193E                          1303  * Unsupported OP code: MOVEQ
0000193E                          1304  ********************************************************************************
0000193E                          1305  C_GROUP_7:
0000193E  48E7 8000               1306      MOVEM.L D0,-(SP)        ;Save register to stack
00001942                          1307      
00001942                          1308  CHECK_OP_MOVEQ
00001942  3038 4000               1309      MOVE.W CUR_OP_CODE,D0
00001946  0240 F100               1310      ANDI.W #$F100,D0
0000194A  B07C 7000               1311      CMP.W  #$7000,D0
0000194E  6600 0006               1312      BNE    GROUP7_INVALID
00001952  6700 0008               1313      BEQ    GROUP7_SUCCESS
00001956                          1314      
00001956                          1315  GROUP7_INVALID:
00001956  4EB9 00001CF2           1316      JSR INVALID_OP
0000195C                          1317      
0000195C                          1318  GROUP7_SUCCESS:    
0000195C  4CDF 0001               1319      MOVEM.L (SP)+,D0
00001960  4E75                    1320      RTS
00001962                          1321  * GROUP_8
00001962                          1322  ********************************************************************************
00001962                          1323  * Supported OP code:
00001962                          1324  * DIVS: $8, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00001962                          1325  * OR: $80, 7-6 Size, 5-3 EA Mode, 2-0 EA Register
00001962                          1326  * Unsupported OP codes: DIVU, SBCD
00001962                          1327  ********************************************************************************
00001962                          1328  C_GROUP_8:
00001962  48E7 8000               1329      MOVEM.L D0,-(SP)
00001966                          1330  *Unsupported OP codes
00001966                          1331  CHECK_OP_DIVU:
00001966  3038 4000               1332      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
0000196A  0240 F1C0               1333      ANDI.W  #$F1C0,D0
0000196E  B07C 80C0               1334      CMP.W   #$80C0,D0
00001972  6700 0038               1335      BEQ     GROUP8_INVALID
00001976  6600 0002               1336      BNE     CHECK_OP_SBCD 
0000197A                          1337  
0000197A                          1338  CHECK_OP_SBCD:
0000197A  3038 4000               1339      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
0000197E  0240 F1F0               1340      ANDI.W  #$F1F0,D0
00001982  B07C 8100               1341      CMP.W   #$8100,D0
00001986  6700 0024               1342      BEQ     GROUP8_INVALID
0000198A  6600 0002               1343      BNE     CHECK_OP_DIVS
0000198E                          1344      
0000198E                          1345  *Supported OP codes
0000198E                          1346  CHECK_OP_DIVS:
0000198E  3038 4000               1347      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
00001992  0240 F1C0               1348      ANDI.W  #$F1C0,D0
00001996  B07C 81C0               1349      CMP.W   #$81C0,D0
0000199A  6700 04D4               1350      BEQ     PRINT_OP_DIVS
0000199E  6600 0002               1351      BNE     CHECK_OP_OR
000019A2                          1352      
000019A2                          1353  CHECK_OP_OR:              ;At this point only remaining $8 code is OR
000019A2  4EB9 00001E80           1354      JSR     PRINT_OP_OR
000019A8  6000 0008               1355      BRA     GROUP8_SUCCESS
000019AC                          1356  GROUP8_INVALID:
000019AC  4EB9 00001CF2           1357       JSR    INVALID_OP
000019B2                          1358       
000019B2                          1359  GROUP8_SUCCESS:
000019B2  4CDF 0001               1360       MOVEM.L (SP)+,D0
000019B6  4E75                    1361       RTS
000019B8                          1362       
000019B8                          1363  * GROUP_9                      
000019B8                          1364  ********************************************************************************
000019B8                          1365  * Supported OP code:
000019B8                          1366  * SUB: $9, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
000019B8                          1367  * Unsupported OP codes: SUBX, SUBA
000019B8                          1368  ********************************************************************************
000019B8                          1369  C_GROUP_9:
000019B8  48E7 C000               1370      MOVEM.L D0-D1,-(SP)     ;Save the registers
000019BC                          1371  CHECK_OP_SUBA:             ;Check SUBA first as it has static bits
000019BC  3038 4000               1372      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
000019C0  0240 F0C0               1373      ANDI.W  #$F0C0,D0
000019C4  B07C 90C0               1374      CMP.W   #$90C0,D0
000019C8  6700 0328               1375      BEQ     INVALID_OP
000019CC  6600 0002               1376      BNE     CHECK_OP_SUBX
000019D0                          1377  
000019D0                          1378  CHECK_OP_SUBX:
000019D0  3038 4000               1379      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
000019D4  0240 F130               1380      ANDI.W  #$F130,D0
000019D8  B07C 9100               1381      CMP.W   #$9100,D0
000019DC  6700 0006               1382      BEQ     BIT_CHECK_SUBX
000019E0  6600 0026               1383      BNE     GROUP9_INVALID     ;Cannot be a valid OP code here
000019E4                          1384      
000019E4                          1385  BIT_CHECK_SUBX:    
000019E4  3038 4000               1386      MOVE.W  CUR_OP_CODE,D0      ;Move current instruction set into D0
000019E8  323C 0007               1387      MOVE.W  #7,D1               ;Prepare a shift of 7 bits into D1
000019EC  E368                    1388      LSL.W   D1,D0               ;Shift left 7 bits truncate 15-9 bits
000019EE  E268                    1389      LSR.W   D1,D0               ;Reposition D0
000019F0  E848                    1390      LSR.W   #4,D0               ;Truncate 4 right most bits to
000019F2  0240 FF18               1391      ANDI.W  #$FF18,D0           ;Compare remaining static bits
000019F6  B07C 0018               1392      CMP.W   #$0018,D0           ;If equal to this value it's SUBX
000019FA  6700 000C               1393      BEQ     GROUP9_INVALID      ;INVALID OP code found
000019FE  6600 0002               1394      BNE     CHECK_OP_SUB        ;Not can only be SUB here
00001A02                          1395      
00001A02                          1396  CHECK_OP_SUB:                   ;At this point only remaining $9 is SUB
00001A02  4EF9 00001E90           1397      JMP     PRINT_OP_SUB
00001A08                          1398  
00001A08                          1399  GROUP9_INVALID:
00001A08  6000 02E8               1400      BRA     INVALID_OP
00001A0C                          1401      
00001A0C                          1402  GROUP9_SUCCESS:
00001A0C  4CDF 0003               1403      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001A10  4E75                    1404      RTS                         ;Return to stack
00001A12                          1405  
00001A12                          1406  *GROUP_A
00001A12                          1407  ********************************************************************************
00001A12                          1408  * Currently no OP codes here are supported. There are no current OP codes here.
00001A12                          1409  ********************************************************************************
00001A12                          1410  C_GROUP_A:
00001A12  4EB9 00001CF2           1411      JSR INVALID_OP
00001A18  4E75                    1412      RTS
00001A1A                          1413      
00001A1A                          1414  * GROUP_B                     
00001A1A                          1415  ********************************************************************************
00001A1A                          1416  * Supported OP codes:
00001A1A                          1417  * EOR: $B, 11-9 Reg, 8 %1, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A1A                          1418  * CMP: $B, 11-9 Reg, 8 %0, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A1A                          1419  * The specific bit difference is listed 
00001A1A                          1420  * Unsupported OP codes: CMPM, CMPA
00001A1A                          1421  ********************************************************************************
00001A1A                          1422  C_GROUP_B:
00001A1A  48E7 8000               1423      MOVEM.L D0,-(SP)         ;Save current registers to stack
00001A1E                          1424      
00001A1E                          1425  CHECK_OP_CMPM
00001A1E  3038 4000               1426      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A22  0240 F138               1427      ANDI.W  #$F138,D0
00001A26  B07C B108               1428      CMP.W   #$B108,D0
00001A2A  6700 0042               1429      BEQ     GROUPB_INVALID
00001A2E  6600 0002               1430      BNE     CHECK_OP_CMPA
00001A32                          1431      
00001A32                          1432  CHECK_OP_CMPA:
00001A32  3038 4000               1433      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A36  0240 F0C0               1434      ANDI.W  #$F0C0,D0
00001A3A  B07C B0C0               1435      CMP.W   #$B0C0,D0
00001A3E  6700 002E               1436      BEQ     GROUPB_INVALID
00001A42  6600 0002               1437      BNE     CHECK_OP_EOR
00001A46                          1438      
00001A46                          1439  CHECK_OP_EOR:
00001A46  3038 4000               1440      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A4A  0240 F100               1441      ANDI.W  #$F100,D0
00001A4E  B07C B100               1442      CMP.W   #$B100,D0
00001A52  6700 044C               1443      BEQ     PRINT_OP_EOR
00001A56  6600 0002               1444      BNE     CHECK_OP_CMP
00001A5A                          1445      
00001A5A                          1446  CHECK_OP_CMP:
00001A5A  3038 4000               1447      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A5E  0240 F100               1448      ANDI.W  #$F100,D0
00001A62  B07C B000               1449      CMP.W   #$B000,D0
00001A66  6700 0448               1450      BEQ     PRINT_OP_CMP
00001A6A  6600 0002               1451      BNE     GROUPB_INVALID
00001A6E                          1452  
00001A6E                          1453  GROUPB_INVALID:
00001A6E  4EB9 00001CF2           1454      JSR     INVALID_OP           ;INVALID OP has been found 
00001A74                          1455   
00001A74                          1456  GROUPB_SUCCESS:
00001A74  4CDF 0001               1457      MOVEM.L (SP)+,D0         ;Restore registers from stack
00001A78  4E75                    1458      RTS                      ;Return to stack
00001A7A                          1459  * GROUP_C                     
00001A7A                          1460  ********************************************************************************
00001A7A                          1461  * Supported OP code:
00001A7A                          1462  * MULS: $C, 11-8 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00001A7A                          1463  * Note: EXG OP mode has to be 01000, 01001, 10001, as such can never be 11 for
00001A7A                          1464  * bits 7-6
00001A7A                          1465  * Unsupported OP codes: MULU, ABCD, EXG, AND
00001A7A                          1466  ********************************************************************************
00001A7A                          1467  C_GROUP_C:
00001A7A                          1468  *Unsupported OP codes
00001A7A  48E7 C000               1469      MOVEM.L D0-D1,-(SP)
00001A7E                          1470      
00001A7E                          1471  CHECK_OP_MULU:
00001A7E  3038 4000               1472      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A82  0240 F1C0               1473      ANDI.W  #$F1C0,D0
00001A86  B07C C0C0               1474      CMP.W   #$C0C0,D0
00001A8A  6700 0078               1475      BEQ     GROUPC_INVALID
00001A8E  6600 0002               1476      BNE     CHECK_OP_ABCD
00001A92                          1477   
00001A92                          1478  CHECK_OP_ABCD:
00001A92  3038 4000               1479      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A96  0240 F1F0               1480      ANDI.W  #$F1F0,D0
00001A9A  B07C C100               1481      CMP.W   #$C100,D0
00001A9E  6700 0064               1482      BEQ     GROUPC_INVALID
00001AA2  6600 0002               1483      BNE     CHECK_OP_EXG
00001AA6                          1484   
00001AA6                          1485  CHECK_OP_EXG:
00001AA6  3038 4000               1486      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AAA  0240 F130               1487      ANDI.W  #$F130,D0
00001AAE  B07C C100               1488      CMP.W   #$C100,D0
00001AB2  6700 0006               1489      BEQ     BIT_CHECK_EXG
00001AB6  6600 003C               1490      BNE     CHECK_OP_AND
00001ABA                          1491                          
00001ABA                          1492  BIT_CHECK_EXG:                 ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
00001ABA  3038 4000               1493      MOVE.W  CUR_OP_CODE,D0
00001ABE  323C 0008               1494      MOVE.W  #8,D1
00001AC2  E368                    1495      LSL.W   D1,D0
00001AC4  E268                    1496      LSR.W   D1,D0
00001AC6  EC48                    1497      LSR.W   #6,D0
00001AC8  0240 FFF3               1498      ANDI.W  #$FFF3,D0
00001ACC  B07C 0003               1499      CMP.W   #$0003,D0          ;This bit then equals MULS
00001AD0  6700 000E               1500      BEQ     CHECK_OP_MULS
00001AD4  B07C 0000               1501      CMP.W   #$0000,D0          ;Second comparison to check if OP mode bit is valid
00001AD8  6700 001A               1502      BEQ     CHECK_OP_AND       ;If it's 0 it could be OP_AND
00001ADC  6600 0026               1503      BNE     GROUPC_INVALID         ;Otherwise it's EXG (01,10 op bits)
00001AE0                          1504  *Supported OP code
00001AE0                          1505  CHECK_OP_MULS:
00001AE0  3038 4000               1506      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AE4  0240 F1C0               1507      ANDI.W #$F1C0,D0
00001AE8  B07C C1C0               1508      CMP.W  #$C1C0,D0
00001AEC  6700 03D2               1509      BEQ    PRINT_OP_MULS
00001AF0  6600 0002               1510      BNE    CHECK_OP_AND          ; OP_AND is completely dynamic outside of first nibble
00001AF4                          1511  
00001AF4                          1512  *Odd completely dynamic unsupported OP code    
00001AF4                          1513  CHECK_OP_AND:                 ;This would be the only possible OP code left after CHECK_OP_MULS
00001AF4  3038 4000               1514      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AF8  0240 F000               1515      ANDI.W  #$F000,D0
00001AFC  B07C C000               1516      CMP.W   #$C000,D0
00001B00  6700 0002               1517      BEQ     GROUPC_INVALID
00001B04                          1518      
00001B04                          1519  GROUPC_INVALID:
00001B04  4EB9 00001CF2           1520      JSR     INVALID_OP
00001B0A                          1521      
00001B0A                          1522  GROUPC_SUCCESS:
00001B0A  4CDF 0003               1523      MOVEM.L (SP)+,D0-D1
00001B0E  4E75                    1524      RTS
00001B10                          1525      
00001B10                          1526  * GROUP_D                     
00001B10                          1527  ********************************************************************************
00001B10                          1528  * Supported OP codes:
00001B10                          1529  * ADD: $D, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001B10                          1530  * ADDA: $D, 11- 9 Reg, 8-6 OPMODE, 7-6 %11, 5-3 EA Mode, 2-0 EA Reg
00001B10                          1531  * The specific bit difference is listed out in the OPMODE field.
00001B10                          1532  * Unsupported: ADDX
00001B10                          1533  ********************************************************************************
00001B10                          1534  C_GROUP_D:
00001B10  48E7 8000               1535      MOVEM.L D0,-(SP)        ;Save registers to stack
00001B14                          1536      
00001B14                          1537  CHECK_OP_ADDX:
00001B14  3038 4000               1538      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B18  0240 F130               1539      ANDI.W #$F130,D0
00001B1C  B07C D100               1540      CMP.W  #$D100,D0
00001B20  6700 0024               1541      BEQ    GROUPD_INVALID
00001B24  6600 0002               1542      BNE    CHECK_OP_ADDA
00001B28                          1543  
00001B28                          1544  CHECK_OP_ADDA:
00001B28  3038 4000               1545      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B2C  0240 F0C0               1546      ANDI.W #$F0C0,D0
00001B30  B07C D0C0               1547      CMP.W  #$D0C0,D0
00001B34  6700 03AA               1548      BEQ    PRINT_OP_ADDA
00001B38  6600 0002               1549      BNE    CHECK_OP_ADD
00001B3C                          1550  
00001B3C                          1551  CHECK_OP_ADD:
00001B3C  4EB9 00001ED0           1552      JSR PRINT_OP_ADD        ;Only remaining OP in $D is ADD
00001B42  6000 0008               1553      BRA GROUPD_SUCCESS
00001B46                          1554      
00001B46                          1555  GROUPD_INVALID:
00001B46  4EB9 00001CF2           1556      JSR INVALID_OP
00001B4C                          1557      
00001B4C                          1558  GROUPD_SUCCESS:
00001B4C  4CDF 0001               1559      MOVEM.L (SP)+,D0        ;Restore registers from stack
00001B50  4E75                    1560      RTS                     ;Return to stack
00001B52                          1561      
00001B52                          1562  * GROUP_E                     
00001B52                          1563  ********************************************************************************
00001B52                          1564  * Supported:
00001B52                          1565  * LSR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001B52                          1566  * LSL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001B52                          1567  * ASR: $E, $0, 8 %0, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001B52                          1568  * ASL: $E, $0, 8 %1, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001B52                          1569  * ROR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001B52                          1570  * ROL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001B52                          1571  * Count/Reg for LSR/LSL refers to shift count, where 0 = shift count of 8, 1-7 
00001B52                          1572  * refers to the respective value when i/r = 0. If i/r = 1, data register in the 
00001B52                          1573  * Count/Reg field specifies the shift count.  
00001B52                          1574  * For directional bit at 8, R = 0, L = 1
00001B52                          1575  * Count/Reg for ROR/ROL specifies rotate count instead of shift count.
00001B52                          1576  *
00001B52                          1577  * Split into ROT and NO_ROT groups first to make identifying easier.
00001B52                          1578  * Unsupported: ROXL, ROXR
00001B52                          1579  ********************************************************************************
00001B52                          1580  C_GROUP_E:
00001B52  48E7 8000               1581      MOVEM.L D0,-(SP)
00001B56                          1582  *Unsupported OP codes
00001B56                          1583  CHECK_OP_ROXR_NO_ROT:
00001B56  3038 4000               1584      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B5A  0240 FFC0               1585      ANDI.W #$FFC0,D0
00001B5E  B07C E4C0               1586      CMP.W  #$E4C0,D0
00001B62  6700 017A               1587      BEQ    GROUPE_INVALID
00001B66  6600 0002               1588      BNE    CHECK_OP_ROXL_NO_ROT
00001B6A                          1589  
00001B6A                          1590  CHECK_OP_ROXL_NO_ROT:
00001B6A  3038 4000               1591      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B6E  0240 FFC0               1592      ANDI.W #$FFC0,D0
00001B72  B07C E5C0               1593      CMP.W  #$E5C0,D0
00001B76  6700 0166               1594      BEQ    GROUPE_INVALID
00001B7A  6600 0002               1595      BNE    CHECK_OP_ROR_NO_ROT
00001B7E                          1596  
00001B7E                          1597  *Supported OP codes
00001B7E                          1598  CHECK_OP_ROR_NO_ROT:
00001B7E  3038 4000               1599      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B82  0240 FFC0               1600      ANDI.W #$FFC0,D0
00001B86  B07C E6C0               1601      CMP.W  #$E6C0,D0
00001B8A  6600 000C               1602      BNE    CHECK_OP_ROL_NO_ROT
00001B8E  4EB9 00001F40           1603      JSR    PRINT_OP_ROR
00001B94  6000 014E               1604      BRA    GROUPE_SUCCESS
00001B98                          1605      
00001B98                          1606  CHECK_OP_ROL_NO_ROT:
00001B98  3038 4000               1607      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B9C  0240 FFC0               1608      ANDI.W #$FFC0,D0
00001BA0  B07C E7C0               1609      CMP.W  #$E7C0,D0
00001BA4  6600 000C               1610      BNE    CHECK_OP_LSR_NO_ROT
00001BA8  4EB9 00001F30           1611      JSR    PRINT_OP_ROL
00001BAE  6000 0134               1612      BRA    GROUPE_SUCCESS
00001BB2                          1613   
00001BB2                          1614  CHECK_OP_LSR_NO_ROT:
00001BB2  3038 4000               1615      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BB6  0240 FFC0               1616      ANDI.W #$FFC0,D0
00001BBA  B07C E2C0               1617      CMP.W  #$E2C0,D0
00001BBE  6600 000C               1618      BNE    CHECK_OP_LSL_NO_ROT
00001BC2  4EB9 00001F00           1619      JSR    PRINT_OP_LSR
00001BC8  6000 011A               1620      BRA    GROUPE_SUCCESS
00001BCC                          1621  
00001BCC                          1622  CHECK_OP_LSL_NO_ROT:
00001BCC  3038 4000               1623      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BD0  0240 FFC0               1624      ANDI.W #$FFC0,D0
00001BD4  B07C E3C0               1625      CMP.W  #$E3C0,D0
00001BD8  6600 000C               1626      BNE    CHECK_OP_ASR_NO_ROT
00001BDC  4EB9 00001EF0           1627      JSR    PRINT_OP_LSL
00001BE2  6000 0100               1628      BRA    GROUPE_SUCCESS
00001BE6                          1629  
00001BE6                          1630  CHECK_OP_ASR_NO_ROT:
00001BE6  3038 4000               1631      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BEA  0240 FFC0               1632      ANDI.W #$FFC0,D0
00001BEE  B07C E0C0               1633      CMP.W  #$E0C0,D0
00001BF2  6600 000C               1634      BNE    CHECK_OP_ASL_NO_ROT
00001BF6  4EB9 00001F10           1635      JSR    PRINT_OP_ASR
00001BFC  6000 00E6               1636      BRA    GROUPE_SUCCESS
00001C00                          1637              
00001C00                          1638  CHECK_OP_ASL_NO_ROT:
00001C00  3038 4000               1639      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C04  0240 FFC0               1640      ANDI.W #$FFC0,D0
00001C08  B07C E1C0               1641      CMP.W  #$E1C0,D0
00001C0C  6600 000C               1642      BNE    CHECK_OP_ROXR
00001C10  4EB9 00001F20           1643      JSR    PRINT_OP_ASL
00001C16  6000 00CC               1644      BRA    GROUPE_SUCCESS
00001C1A                          1645  
00001C1A                          1646  *Unsupported OP codes
00001C1A                          1647  CHECK_OP_ROXR:
00001C1A  3038 4000               1648      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C1E  0240 F118               1649      ANDI.W #$F118,D0
00001C22  B07C E010               1650      CMP.W  #$E010,D0
00001C26  6700 00B6               1651      BEQ    GROUPE_INVALID
00001C2A  6600 0002               1652      BNE    CHECK_OP_ROXL
00001C2E                          1653      
00001C2E                          1654  CHECK_OP_ROXL:
00001C2E  3038 4000               1655      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C32  0240 F118               1656      ANDI.W #$F118,D0
00001C36  B07C E110               1657      CMP.W  #$E110,D0
00001C3A  6700 00A2               1658      BEQ    GROUPE_INVALID
00001C3E  6600 0002               1659      BNE    CHECK_OP_ROR
00001C42                          1660      
00001C42                          1661  *Supported OP codes
00001C42                          1662  CHECK_OP_ROR:
00001C42  3038 4000               1663      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C46  0240 F118               1664      ANDI.W #$F118,D0
00001C4A  B07C E018               1665      CMP.W  #$E018,D0
00001C4E  6600 000C               1666      BNE    CHECK_OP_ROL
00001C52  4EB9 00001F40           1667      JSR    PRINT_OP_ROR
00001C58  6000 008A               1668      BRA    GROUPE_SUCCESS
00001C5C                          1669  
00001C5C                          1670  CHECK_OP_ROL:
00001C5C  3038 4000               1671      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C60  0240 F118               1672      ANDI.W #$F118,D0
00001C64  B07C E118               1673      CMP.W  #$E118,D0
00001C68  6600 000C               1674      BNE    CHECK_OP_LSR
00001C6C  4EB9 00001F30           1675      JSR    PRINT_OP_ROL
00001C72  6000 0070               1676      BRA    GROUPE_SUCCESS
00001C76                          1677      
00001C76                          1678  CHECK_OP_LSR:
00001C76  3038 4000               1679      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C7A  0240 F118               1680      ANDI.W #$F118,D0
00001C7E  B07C E008               1681      CMP.W  #$E008,D0
00001C82  6600 000C               1682      BNE    CHECK_OP_LSL
00001C86  4EB9 00001F00           1683      JSR    PRINT_OP_LSR
00001C8C  6000 0056               1684      BRA    GROUPE_SUCCESS
00001C90                          1685  
00001C90                          1686  CHECK_OP_LSL:
00001C90  3038 4000               1687      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C94  0240 F118               1688      ANDI.W #$F118,D0
00001C98  B07C E108               1689      CMP.W  #$E108,D0
00001C9C  6600 000C               1690      BNE    CHECK_OP_ASR
00001CA0  4EB9 00001EF0           1691      JSR    PRINT_OP_LSL
00001CA6  6000 003C               1692      BRA    GROUPE_SUCCESS
00001CAA                          1693  
00001CAA                          1694  CHECK_OP_ASR:
00001CAA  3038 4000               1695      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CAE  0240 F118               1696      ANDI.W #$F118,D0
00001CB2  B07C E000               1697      CMP.W  #$E000,D0
00001CB6  6600 000C               1698      BNE    CHECK_OP_ASL
00001CBA  4EB9 00001F10           1699      JSR    PRINT_OP_ASR
00001CC0  6000 0022               1700      BRA    GROUPE_SUCCESS
00001CC4                          1701  
00001CC4                          1702  CHECK_OP_ASL:
00001CC4  3038 4000               1703      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CC8  0240 F118               1704      ANDI.W #$F118,D0
00001CCC  B07C E100               1705      CMP.W  #$E100,D0
00001CD0  6600 000C               1706      BNE    GROUPE_INVALID      ;Last possible OP code
00001CD4  4EB9 00001F20           1707      JSR    PRINT_OP_ASL
00001CDA  6000 0008               1708      BRA    GROUPE_SUCCESS
00001CDE                          1709  
00001CDE                          1710  GROUPE_INVALID:
00001CDE  4EB9 00001CF2           1711      JSR     INVALID_OP
00001CE4                          1712      
00001CE4                          1713  GROUPE_SUCCESS:
00001CE4  4CDF 0001               1714      MOVEM.L (SP)+,D0
00001CE8  4E75                    1715      RTS
00001CEA                          1716  * GROUP_F
00001CEA                          1717  ********************************************************************************
00001CEA                          1718  * Currently no OP codes here are supported. There are no OP codes here
00001CEA                          1719  ********************************************************************************
00001CEA                          1720  C_GROUP_F:
00001CEA  4EB9 00001CF2           1721      JSR INVALID_OP
00001CF0  4E75                    1722      RTS
00001CF2                          1723      
00001CF2                          1724  * INVALID_OP                     
00001CF2                          1725  ********************************************************************************
00001CF2                          1726  * Any value that is not covered in the above groups would be considered invalid. 
00001CF2                          1727  * The following values in the first nibble would also indicate that the 
00001CF2                          1728  * operand codes is already invalid: $7, $A, $F.
00001CF2                          1729  * For unsupported OP codes, display DATA $WXYZ   
00001CF2                          1730  * THIS WILL NEED TO BE CHANGED TO DISPLAY: 1000 DATA $WXYZ IN THE FUTURE
00001CF2                          1731  ********************************************************************************
00001CF2                          1732  INVALID_OP:  ; Prints DATA for invalid op, THIS SHOULD BE SETTING THE IS_VALID BIT TO 0
00001CF2  23FC 00001F58 00002038  1733      MOVE.L #P_INVALID_OP, Arg_AddStrToBuffer_String
00001CFC  4EB9 00001D0E           1734      JSR PRINT_TO_BUFFER
00001D02  11FC 0000 10B5          1735      MOVE.B #0,IS_VALID
00001D08  4E75                    1736      RTS
00001D0A                          1737      
00001D0A                          1738  READ_NEXT_INSTRUCTION: ; Needs to read next instruction set {PLACEHOLDER}
00001D0A  FFFF FFFF               1739      SIMHALT
00001D0E                          1740  
00001D0E                          1741  ********************** PRINTING ROUTINES **************************************
00001D0E                          1742  * Description: These routines are to print the associated op codes, by placing
00001D0E                          1743  * them in the appropriate area to the buffer
00001D0E                          1744  *
00001D0E                          1745  * Registers used: A1 for loading, A6 for EA parsing.
00001D0E                          1746  *
00001D0E                          1747  * Precondition: The relevant opcode has been identified correctly.
00001D0E                          1748  *
00001D0E                          1749  * Postcondition: Prints out the associated opcode to the buffer.
00001D0E                          1750  
00001D0E                          1751  * THIS NEEDS TO BE RETOOLED TO PRINT TO BUFFER NOT TO CONSOLE
00001D0E                          1752  *******************************************************************************
00001D0E                          1753  
00001D0E                          1754  * Prints the loaded item into G_BUFFER
00001D0E                          1755  PRINT_TO_BUFFER:
00001D0E  23FC 00004100 0000203C  1756      MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer
00001D18  4EB9 00002046           1757      JSR AddStrToBuffer
00001D1E  4E75                    1758      RTS
00001D20                          1759      
00001D20                          1760  
00001D20                          1761  ****************************** GROUP 0 **************************************** 
00001D20                          1762  PRINT_OP_ORI:
00001D20  23FC 00001F75 00002038  1763      MOVE.L #P_OP_ORI, Arg_AddStrToBuffer_String
00001D2A  4EB8 1D0E               1764      JSR PRINT_TO_BUFFER
00001D2E  4E75                    1765      RTS
00001D30                          1766  PRINT_OP_CMPI:
00001D30  23FC 00001F79 00002038  1767      MOVE.L #P_OP_CMPI, Arg_AddStrToBuffer_String
00001D3A  4EB8 1D0E               1768      JSR PRINT_TO_BUFFER
00001D3E  4E75                    1769      RTS
00001D40                          1770  PRINT_OP_STATIC_BCLR:
00001D40  23FC 00001F7E 00002038  1771      MOVE.L #P_OP_STATIC_BCLR, Arg_AddStrToBuffer_String
00001D4A  4EB8 1D0E               1772      JSR PRINT_TO_BUFFER
00001D4E  4E75                    1773      RTS
00001D50                          1774  PRINT_OP_DYNAMIC_BCLR:
00001D50  23FC 00001F83 00002038  1775      MOVE.L #P_OP_DYNAMIC_BCLR, Arg_AddStrToBuffer_String
00001D5A  4EB8 1D0E               1776      JSR PRINT_TO_BUFFER
00001D5E  4E75                    1777      RTS
00001D60                          1778  ******************************* END OF GROUP 0 ********************************
00001D60                          1779  
00001D60                          1780  ****************************** GROUP 1 ****************************************    
00001D60                          1781  PRINT_OP_MOVEB:
00001D60  23FC 00001F88 00002038  1782      MOVE.L #P_OP_MOVEB, Arg_AddStrToBuffer_String
00001D6A  4EB8 1D0E               1783      JSR PRINT_TO_BUFFER
00001D6E  4E75                    1784      RTS
00001D70                          1785  ******************************* END OF GROUP 1 ********************************
00001D70                          1786      
00001D70                          1787  ****************************** GROUP 2 **************************************** 
00001D70                          1788  PRINT_OP_MOVEA_L:
00001D70  23FC 00001F90 00002038  1789      MOVE.L #P_OP_MOVEA_L, Arg_AddStrToBuffer_String
00001D7A  4EB8 1D0E               1790      JSR PRINT_TO_BUFFER
00001D7E  4E75                    1791      RTS
00001D80                          1792  PRINT_OP_MOVE_L:
00001D80  23FC 00001F9C 00002038  1793      MOVE.L #P_OP_MOVE_L, Arg_AddStrToBuffer_String
00001D8A  4EB8 1D0E               1794      JSR PRINT_TO_BUFFER
00001D8E  4E75                    1795      RTS
00001D90                          1796  ******************************* END OF GROUP 2 ********************************
00001D90                          1797      
00001D90                          1798  ****************************** GROUP 3 ****************************************    
00001D90                          1799  PRINT_OP_MOVEA_W:
00001D90  23FC 00001FA4 00002038  1800      MOVE.L #P_OP_MOVEA_W, Arg_AddStrToBuffer_String
00001D9A  4EB8 1D0E               1801      JSR PRINT_TO_BUFFER
00001D9E  4E75                    1802      RTS
00001DA0                          1803  PRINT_OP_MOVE_W:
00001DA0  23FC 00001FB0 00002038  1804      MOVE.L #P_OP_MOVE_W, Arg_AddStrToBuffer_String
00001DAA  4EB8 1D0E               1805      JSR PRINT_TO_BUFFER
00001DAE  4E75                    1806      RTS
00001DB0                          1807  ******************************* END OF GROUP 3 ********************************
00001DB0                          1808  
00001DB0                          1809  ****************************** GROUP 4 ****************************************
00001DB0                          1810  PRINT_OP_JSR:
00001DB0  23FC 00001FD4 00002038  1811      MOVE.L #P_OP_JSR, Arg_AddStrToBuffer_String
00001DBA  4EB8 1D0E               1812      JSR PRINT_TO_BUFFER
00001DBE  4E75                    1813      RTS
00001DC0                          1814  PRINT_OP_RTS:
00001DC0  23FC 00001FDC 00002038  1815      MOVE.L #P_OP_RTS, Arg_AddStrToBuffer_String
00001DCA  4EB8 1D0E               1816      JSR PRINT_TO_BUFFER
00001DCE  4E75                    1817      RTS
00001DD0                          1818  PRINT_OP_LEA:
00001DD0  23FC 00001FD0 00002038  1819      MOVE.L #P_OP_LEA, Arg_AddStrToBuffer_String
00001DDA  4EB8 1D0E               1820      JSR PRINT_TO_BUFFER
00001DDE  4E75                    1821      RTS
00001DE0                          1822  PRINT_OP_NEG:
00001DE0  23FC 00001FE0 00002038  1823      MOVE.L #P_OP_NEG, Arg_AddStrToBuffer_String
00001DEA  4EB8 1D0E               1824      JSR PRINT_TO_BUFFER
00001DEE  4E75                    1825      RTS
00001DF0                          1826  PRINT_OP_MOVEM_W:
00001DF0  23FC 00001FB8 00002038  1827      MOVE.L #P_OP_MOVEM_W, Arg_AddStrToBuffer_String
00001DFA  4EB8 1D0E               1828      JSR PRINT_TO_BUFFER
00001DFE  4E75                    1829      RTS
00001E00                          1830  PRINT_OP_MOVEM_L:
00001E00  23FC 00001FC4 00002038  1831      MOVE.L #P_OP_MOVEM_L, Arg_AddStrToBuffer_String
00001E0A  4EB8 1D0E               1832      JSR PRINT_TO_BUFFER
00001E0E  4E75                    1833      RTS
00001E10                          1834  ******************************* END OF GROUP 4 ********************************
00001E10                          1835      
00001E10                          1836  ****************************** GROUP 5 ****************************************
00001E10                          1837  PRINT_OP_SUBQ:
00001E10  23FC 00001FE4 00002038  1838      MOVE.L #P_OP_SUBQ, Arg_AddStrToBuffer_String
00001E1A  4EB8 1D0E               1839      JSR PRINT_TO_BUFFER
00001E1E  4E75                    1840      RTS
00001E20                          1841  ******************************* END OF GROUP 5 ********************************
00001E20                          1842  
00001E20                          1843  ****************************** GROUP 6 ****************************************
00001E20                          1844  PRINT_OP_BCS:
00001E20  23FC 00001FED 00002038  1845      MOVE.L #P_OP_BCS, Arg_AddStrToBuffer_String
00001E2A  4EB8 1D0E               1846      JSR PRINT_TO_BUFFER
00001E2E  4E75                    1847      RTS
00001E30                          1848  PRINT_OP_BGE:
00001E30  23FC 00001FF1 00002038  1849      MOVE.L #P_OP_BGE, Arg_AddStrToBuffer_String
00001E3A  4EB8 1D0E               1850      JSR PRINT_TO_BUFFER
00001E3E  4E75                    1851      RTS
00001E40                          1852  PRINT_OP_BLT:
00001E40  23FC 00001FF5 00002038  1853      MOVE.L #P_OP_BLT, Arg_AddStrToBuffer_String
00001E4A  4EB8 1D0E               1854      JSR PRINT_TO_BUFFER
00001E4E  4E75                    1855      RTS
00001E50                          1856  PRINT_OP_BVC:
00001E50  23FC 00001FF9 00002038  1857      MOVE.L #P_OP_BVC, Arg_AddStrToBuffer_String
00001E5A  4EB8 1D0E               1858      JSR PRINT_TO_BUFFER
00001E5E  4E75                    1859      RTS
00001E60                          1860  PRINT_OP_BRA:
00001E60  23FC 00001FE9 00002038  1861      MOVE.L #P_OP_BRA, Arg_AddStrToBuffer_String
00001E6A  4EB8 1D0E               1862      JSR PRINT_TO_BUFFER
00001E6E  4E75                    1863      RTS
00001E70                          1864  ******************************* END OF GROUP 6 ********************************
00001E70                          1865  
00001E70                          1866  ****************************** GROUP 7 ****************************************
00001E70                          1867  * No currently supported OP codes to print here.
00001E70                          1868  ******************************* END OF GROUP 7 ********************************
00001E70                          1869  
00001E70                          1870  ****************************** GROUP 8 ****************************************
00001E70                          1871  PRINT_OP_DIVS:
00001E70  23FC 00001FFD 00002038  1872      MOVE.L #P_OP_DIVS, Arg_AddStrToBuffer_String
00001E7A  4EB8 1D0E               1873      JSR PRINT_TO_BUFFER
00001E7E  4E75                    1874      RTS
00001E80                          1875  PRINT_OP_OR:
00001E80  23FC 00002002 00002038  1876      MOVE.L #P_OP_OR, Arg_AddStrToBuffer_String
00001E8A  4EB8 1D0E               1877      JSR PRINT_TO_BUFFER
00001E8E  4E75                    1878      RTS
00001E90                          1879  ******************************* END OF GROUP 8 ********************************
00001E90                          1880  
00001E90                          1881  ****************************** GROUP 9 ****************************************
00001E90                          1882  PRINT_OP_SUB:
00001E90  23FC 00002005 00002038  1883      MOVE.L #P_OP_SUB, Arg_AddStrToBuffer_String
00001E9A  4EB8 1D0E               1884      JSR PRINT_TO_BUFFER
00001E9E  4E75                    1885      RTS
00001EA0                          1886  ******************************* END OF GROUP 9 ********************************
00001EA0                          1887  
00001EA0                          1888  ****************************** GROUP A ****************************************
00001EA0                          1889  * No currently supported OP codes to print here.
00001EA0                          1890  ******************************* END OF GROUP A ********************************
00001EA0                          1891  
00001EA0                          1892  ****************************** GROUP B ****************************************
00001EA0                          1893  PRINT_OP_EOR:
00001EA0  23FC 00002009 00002038  1894      MOVE.L #P_OP_EOR, Arg_AddStrToBuffer_String
00001EAA  4EB8 1D0E               1895      JSR PRINT_TO_BUFFER
00001EAE  4E75                    1896      RTS
00001EB0                          1897  PRINT_OP_CMP:
00001EB0  23FC 0000200D 00002038  1898      MOVE.L #P_OP_CMP, Arg_AddStrToBuffer_String
00001EBA  4EB8 1D0E               1899      JSR PRINT_TO_BUFFER
00001EBE  4E75                    1900      RTS
00001EC0                          1901  ******************************* END OF GROUP B ********************************
00001EC0                          1902  
00001EC0                          1903  ****************************** GROUP C ****************************************
00001EC0                          1904  PRINT_OP_MULS:
00001EC0  23FC 00002011 00002038  1905      MOVE.L #P_OP_MULS, Arg_AddStrToBuffer_String
00001ECA  4EB8 1D0E               1906      JSR PRINT_TO_BUFFER
00001ECE  4E75                    1907      RTS
00001ED0                          1908  ******************************* END OF GROUP C ********************************
00001ED0                          1909  
00001ED0                          1910  ****************************** GROUP D ****************************************
00001ED0                          1911  PRINT_OP_ADD:
00001ED0  23FC 0000201B 00002038  1912      MOVE.L #P_OP_ADD, Arg_AddStrToBuffer_String
00001EDA  4EB8 1D0E               1913      JSR PRINT_TO_BUFFER
00001EDE  4E75                    1914      RTS
00001EE0                          1915  PRINT_OP_ADDA:
00001EE0  23FC 00002016 00002038  1916      MOVE.L #P_OP_ADDA, Arg_AddStrToBuffer_String
00001EEA  4EB8 1D0E               1917      JSR PRINT_TO_BUFFER
00001EEE  4E75                    1918      RTS
00001EF0                          1919  
00001EF0                          1920  ******************************* END OF GROUP D ********************************
00001EF0                          1921  
00001EF0                          1922  ****************************** GROUP E ****************************************
00001EF0                          1923  PRINT_OP_LSL:
00001EF0  23FC 00002023 00002038  1924      MOVE.L #P_OP_LSL, Arg_AddStrToBuffer_String
00001EFA  4EB8 1D0E               1925      JSR PRINT_TO_BUFFER
00001EFE  4E75                    1926      RTS
00001F00                          1927  PRINT_OP_LSR:
00001F00  23FC 0000201F 00002038  1928      MOVE.L #P_OP_LSR, Arg_AddStrToBuffer_String
00001F0A  4EB8 1D0E               1929      JSR PRINT_TO_BUFFER
00001F0E  4E75                    1930      RTS
00001F10                          1931  PRINT_OP_ASR:
00001F10  23FC 00002027 00002038  1932      MOVE.L #P_OP_ASR, Arg_AddStrToBuffer_String
00001F1A  4EB8 1D0E               1933      JSR PRINT_TO_BUFFER
00001F1E  4E75                    1934      RTS
00001F20                          1935  PRINT_OP_ASL:
00001F20  23FC 0000202B 00002038  1936      MOVE.L #P_OP_ASL, Arg_AddStrToBuffer_String
00001F2A  4EB8 1D0E               1937      JSR PRINT_TO_BUFFER
00001F2E  4E75                    1938      RTS
00001F30                          1939  PRINT_OP_ROL:
00001F30  23FC 00002033 00002038  1940      MOVE.L #P_OP_ROL, Arg_AddStrToBuffer_String
00001F3A  4EB8 1D0E               1941      JSR PRINT_TO_BUFFER
00001F3E  4E75                    1942      RTS
00001F40                          1943  PRINT_OP_ROR:
00001F40  23FC 0000202F 00002038  1944      MOVE.L #P_OP_ROR, Arg_AddStrToBuffer_String
00001F4A  4EB8 1D0E               1945      JSR PRINT_TO_BUFFER
00001F4E  4E75                    1946      RTS
00001F50                          1947  ******************************* END OF GROUP E ********************************
00001F50                          1948  
00001F50                          1949  ****************************** GROUP F ****************************************
00001F50                          1950  * No currently supported OP codes to print here.
00001F50                          1951  ******************************* END OF GROUP F ********************************
00001F50                          1952  
00001F50                          1953  
00001F50                          1954  
00001F50                          1955  PRINT_OP:   ;Prints current op code byte
00001F50                          1956      ;MOVE.W (A4),(A1)       ; NEEDS TO USE G_BUFFER LATER
00001F50  103C 000D               1957      MOVE.B #13,D0
00001F54  4E4F                    1958      TRAP #15
00001F56  4E75                    1959      RTS
00001F58                          1960  ******************* END OF PRINTING ROUTINES **********************************
00001F58                          1961  
00001F58                          1962  ******************* END OF JMP LABELS *****************************************
00001F58                          1963  
00001F58                          1964  ******************* DATA CONSTANT PRINTS **************************************
00001F58                          1965  * Formatting is as follows: P_OP_<OPCODE>, where P = Print, OP = Operation,
00001F58                          1966  * <OPCODE> is any valid operand
00001F58                          1967  
00001F58= 44 41 54 41 20 20 ...   1968  P_INVALID_OP    DC.B    'DATA   ',0
00001F60= 46 6F 75 6E 64 20 ...   1969  OP_FOUND        DC.B    'Found OP',0 ; this should be taken out later
00001F69= 2E 42 20 00             1970  P_SIZE_B        DC.B    '.B ',0
00001F6D= 2E 57 20 00             1971  P_SIZE_W        DC.B    '.W ',0
00001F71= 2E 4C 20 00             1972  P_SIZE_L        DC.B    '.L ',0
00001F75= 4F 52 49 00             1973  P_OP_ORI        DC.B    'ORI',0
00001F79= 43 4D 50 49 00          1974  P_OP_CMPI       DC.B    'CMPI',0
00001F7E= 42 43 4C 52 00          1975  P_OP_STATIC_BCLR     DC.B    'BCLR',0
00001F83= 42 43 4C 52 00          1976  P_OP_DYNAMIC_BCLR     DC.B    'BCLR',0
00001F88= 4D 4F 56 45 2E 42 ...   1977  P_OP_MOVEB      DC.B    'MOVE.B ',0
00001F90= 4D 4F 56 45 41 2E ...   1978  P_OP_MOVEA_L    DC.B    'MOVEA.L    ',0 
00001F9C= 4D 4F 56 45 2E 4C ...   1979  P_OP_MOVE_L     DC.B    'MOVE.L ',0
00001FA4= 4D 4F 56 45 41 2E ...   1980  P_OP_MOVEA_W    DC.B    'MOVEA.W    ',0
00001FB0= 4D 4F 56 45 2E 57 ...   1981  P_OP_MOVE_W     DC.B    'MOVE.W ',0
00001FB8= 4D 4F 56 45 4D 2E ...   1982  P_OP_MOVEM_W    DC.B    'MOVEM.W    ',0
00001FC4= 4D 4F 56 45 4D 2E ...   1983  P_OP_MOVEM_L    DC.B    'MOVEM.L    ',0
00001FD0= 4C 45 41 00             1984  P_OP_LEA        DC.B    'LEA',0
00001FD4= 4A 53 52 00             1985  P_OP_JSR        DC.B    'JSR',0
00001FD8= 4E 4F 50 00             1986  P_OP_NOP        DC.B    'NOP',0
00001FDC= 52 54 53 00             1987  P_OP_RTS        DC.B    'RTS',0
00001FE0= 4E 45 47 00             1988  P_OP_NEG        DC.B    'NEG',0
00001FE4= 53 55 42 51 00          1989  P_OP_SUBQ       DC.B    'SUBQ',0
00001FE9= 42 52 41 00             1990  P_OP_BRA        DC.B    'BRA',0
00001FED= 42 43 53 00             1991  P_OP_BCS        DC.B    'BCS',0
00001FF1= 42 47 45 00             1992  P_OP_BGE        DC.B    'BGE',0
00001FF5= 42 4C 54 00             1993  P_OP_BLT        DC.B    'BLT',0
00001FF9= 42 56 43 00             1994  P_OP_BVC        DC.B    'BVC',0
00001FFD= 44 49 56 53 00          1995  P_OP_DIVS       DC.B    'DIVS',0
00002002= 4F 52 00                1996  P_OP_OR         DC.B    'OR',0
00002005= 53 55 42 00             1997  P_OP_SUB        DC.B    'SUB',0
00002009= 45 4F 52 00             1998  P_OP_EOR        DC.B    'EOR',0
0000200D= 43 4D 50 00             1999  P_OP_CMP        DC.B    'CMP',0
00002011= 4D 55 4C 53 00          2000  P_OP_MULS       DC.B    'MULS',0
00002016= 41 44 44 41 00          2001  P_OP_ADDA       DC.B    'ADDA',0
0000201B= 41 44 44 00             2002  P_OP_ADD        DC.B    'ADD',0
0000201F= 4C 53 52 00             2003  P_OP_LSR        DC.B    'LSR',0
00002023= 4C 53 4C 00             2004  P_OP_LSL        DC.B    'LSL',0
00002027= 41 53 52 00             2005  P_OP_ASR        DC.B    'ASR',0
0000202B= 41 53 4C 00             2006  P_OP_ASL        DC.B    'ASL',0
0000202F= 52 4F 52 00             2007  P_OP_ROR        DC.B    'ROR',0
00002033= 52 4F 4C 00             2008  P_OP_ROL        DC.B    'ROL',0
00002037                          2009  ***************** END OF DATA CONSTANT PRINTS ***********************************
00002037                          2010   
00002037                          2011  
00002037                          2012  **
00002037                          2013  * AddStrToBuffer
00002037                          2014  **
00002037                          2015  * Adds the given NULL-terminated string to the specified buffer.
00002037                          2016  *
00002037                          2017  * Default buffer length is 80 characters, but can be modified in the argument
00002037                          2018  * variables.
00002037                          2019  *
00002037                          2020  * If the buffer length is exceeded, either due to lack of a NULL character or
00002037                          2021  * an incorrectly specified length, 1 is returned. Otherwise, 0 is returned to
00002037                          2022  * indicate success.
00002037                          2023  *
00002037                          2024  **
00002037                          2025  * @param Arg_AddStrToBuffer_String              Pointer to string
00002037                          2026  * @param Arg_AddStrToBuffer_Buffer              Pointer to buffer
00002037                          2027  * @param Arg_AddStrToBuffer_BufferLength        Length of buffer (default 80 chars)
00002037                          2028  * @return Ret_AddStrToBuffer_Success            0 if successful, 1 otherwise.
00002037                          2029  * @branch _AddStrToBuffer_FindBufferNullLoop    Loop to find NULL in buffer
00002037                          2030  * @branch _AddStrToBuffer_AddLoop               Loop to add string to buffer
00002037                          2031  * @branch _AddStrToBuffer_Success               Branch when string successfully added
00002037                          2032  * @branch _AddStrToBuffer_StringLengthExceeded  Branch when length exceeded (either string or buffer)
00002037                          2033  * @branch _AddStrToBuffer_End                   End of subroutine
00002037                          2034  **
00002038                          2035  Arg_AddStrToBuffer_String           DS.L    1
0000203C                          2036  Arg_AddStrToBuffer_Buffer           DS.L    1
00002040= 00000050                2037  Arg_AddStrToBuffer_BufferLength     DC.L    80
00002044                          2038  Ret_AddStrToBuffer_Success          DS.B    1
00002045                          2039  
00002046                          2040  AddStrToBuffer:                     DS.W    0
00002046  48E7 C0C0               2041      MOVEM.L     D0-D1/A0-A1, -(SP)                  * Backup registers to stack
0000204A                          2042  
0000204A  2078 2038               2043      MOVE.L      Arg_AddStrToBuffer_String, A0       * Load string pointer
0000204E  2278 203C               2044      MOVE.L      Arg_AddStrToBuffer_Buffer, A1       * Load buffer pointer
00002052  2038 2040               2045      MOVE.L      Arg_AddStrToBuffer_BufferLength, D0 * Load buffer length
00002056  4278 2044               2046      CLR.W       Ret_AddStrToBuffer_Success          * Clear success bit
0000205A  4281                    2047      CLR.L       D1                                  * Clear loop counter
0000205C                          2048  
0000205C                          2049  _AddStrToBuffer_BufferLoop
0000205C  0C11 0000               2050      CMPI.B      #0, (A1)                            * If buffer char is NULL
00002060  6700 000E               2051      BEQ         _AddStrToBuffer_AddLoop             * Start adding string to bufer
00002064                          2052      
00002064  B280                    2053      CMP.L       D0, D1                              * If counter >= max length
00002066  6C00 0026               2054      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
0000206A                          2055      
0000206A  5289                    2056      ADDQ.L      #1, A1                              * Go to next character
0000206C  5201                    2057      ADDQ.B      #1, D1                              * Increment counter
0000206E  60EC                    2058      BRA         _AddStrToBuffer_BufferLoop          * Loop back
00002070                          2059      
00002070                          2060  _AddStrToBuffer_AddLoop
00002070  0C10 0000               2061      CMPI.B      #0, (A0)                            * If string char is NULL
00002074  6700 0010               2062      BEQ         _AddStrToBuffer_Success             * String successfully added
00002078                          2063      
00002078  B200                    2064      CMP.B       D0, D1                              * If counter >= max length
0000207A  6C00 0012               2065      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
0000207E                          2066      
0000207E  12D8                    2067      MOVE.B      (A0)+, (A1)+                        * Move string char to buffer char
00002080  528C                    2068      ADDQ.L      #1, A4
00002082  5201                    2069      ADDQ.B      #1, D1                              * Increment counter
00002084  60EA                    2070      BRA         _AddStrToBuffer_AddLoop             * Loop back
00002086                          2071  
00002086                          2072  _AddStrToBuffer_Success
00002086  12BC 0000               2073      MOVE.B      #0, (A1)                            * Add NULL to end of string
0000208A  6000 0008               2074      BRA         _AddStrToBuffer_End                 * Finish subroutine
0000208E                          2075  
0000208E                          2076  _AddStrToBuffer_LengthExceeded
0000208E  31FC 0001 2044          2077      MOVE.W      #1, Ret_AddStrToBuffer_Success      * Invalidate success bit
00002094                          2078  
00002094                          2079  _AddStrToBuffer_End
00002094  4CDF 0303               2080      MOVEM.L     (SP)+, D0-D1/A0-A1                  * Restore registers from stack
00002098  4E75                    2081      RTS                  
0000209A                          2082      
0000209A                          2083      END START                                   ; THIS SHOULD BE REMOVED FOR FULL INTEGRATION

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS             1059
ADDSTRTOBUFFER      2046
ARG_ADDSTRTOBUFFER_BUFFER  203C
ARG_ADDSTRTOBUFFER_BUFFERLENGTH  2040
ARG_ADDSTRTOBUFFER_STRING  2038
BIT_CHECK_EXG       1ABA
BIT_CHECK_EXT       16B2
BIT_CHECK_MOVEP     1424
BIT_CHECK_SUBX      19E4
B_BUFFER            1009
CHECK_OP_ABCD       1A92
CHECK_OP_ADD        1B3C
CHECK_OP_ADDA       1B28
CHECK_OP_ADDI       1384
CHECK_OP_ADDQ       185E
CHECK_OP_ADDX       1B14
CHECK_OP_AND        1AF4
CHECK_OP_ANDI       135C
CHECK_OP_ANDI_TO_CCR  131C
CHECK_OP_ANDI_TO_SR  132C
CHECK_OP_ASL        1CC4
CHECK_OP_ASL_NO_ROT  1C00
CHECK_OP_ASR        1CAA
CHECK_OP_ASR_NO_ROT  1BE6
CHECK_OP_BCS        18CA
CHECK_OP_BGE        18E4
CHECK_OP_BLT        18FE
CHECK_OP_BRA        18B0
CHECK_OP_BSR        189C
CHECK_OP_BVC        1918
CHECK_OP_CHK        1794
CHECK_OP_CLR        1676
CHECK_OP_CMP        1A5A
CHECK_OP_CMPA       1A32
CHECK_OP_CMPI       146C
CHECK_OP_CMPM       1A1E
CHECK_OP_DBCC       1836
CHECK_OP_DIVS       198E
CHECK_OP_DIVU       1966
CHECK_OP_DYNAMIC_BCHG  13FC
CHECK_OP_DYNAMIC_BCLR  14A0
CHECK_OP_DYNAMIC_BSET  1410
CHECK_OP_DYNAMIC_BTST  13E8
CHECK_OP_EOR        1A46
CHECK_OP_EORI       1398
CHECK_OP_EORI_TO_CCR  133C
CHECK_OP_EORI_TO_SR  134C
CHECK_OP_EXG        1AA6
CHECK_OP_EXT        169E
CHECK_OP_ILLEGAL    15E6
CHECK_OP_JMP        1780
CHECK_OP_JSR        17D8
CHECK_OP_LEA        17BE
CHECK_OP_LINK       1744
CHECK_OP_LSL        1C90
CHECK_OP_LSL_NO_ROT  1BCC
CHECK_OP_LSR        1C76
CHECK_OP_LSR_NO_ROT  1BB2
CHECK_OP_MOVEA_L    14F4
CHECK_OP_MOVEA_W    1556
CHECK_OP_MOVEM      180C
CHECK_OP_MOVEP      143E
CHECK_OP_MOVEQ      1942
CHECK_OP_MOVE_B     14CA
CHECK_OP_MOVE_FROM_SR  1626
CHECK_OP_MOVE_L     152C
CHECK_OP_MOVE_TO_CCR  163A
CHECK_OP_MOVE_TO_SR  164E
CHECK_OP_MOVE_USP   176C
CHECK_OP_MOVE_W     158E
CHECK_OP_MULS       1AE0
CHECK_OP_MULU       1A7E
CHECK_OP_NBCD       16CC
CHECK_OP_NEG        17F2
CHECK_OP_NEGX       1662
CHECK_OP_NOP        15D6
CHECK_OP_NOT        168A
CHECK_OP_OR         19A2
CHECK_OP_ORI        1452
CHECK_OP_ORI_TO_CCR  12FC
CHECK_OP_ORI_TO_SR  130C
CHECK_OP_PEA        16F4
CHECK_OP_RESET      15C6
CHECK_OP_ROL        1C5C
CHECK_OP_ROL_NO_ROT  1B98
CHECK_OP_ROR        1C42
CHECK_OP_ROR_NO_ROT  1B7E
CHECK_OP_ROXL       1C2E
CHECK_OP_ROXL_NO_ROT  1B6A
CHECK_OP_ROXR       1C1A
CHECK_OP_ROXR_NO_ROT  1B56
CHECK_OP_RTE        15F6
CHECK_OP_RTR        1616
CHECK_OP_RTS        17A8
CHECK_OP_SBCD       197A
CHECK_OP_SCC        184A
CHECK_OP_STATIC_BCHG  13C0
CHECK_OP_STATIC_BCLR  1486
CHECK_OP_STATIC_BSET  13D4
CHECK_OP_STATIC_BTST  13AC
CHECK_OP_STOP       15B6
CHECK_OP_SUB        1A02
CHECK_OP_SUBA       19BC
CHECK_OP_SUBI       1370
CHECK_OP_SUBQ       1872
CHECK_OP_SUBX       19D0
CHECK_OP_SWAP       16E0
CHECK_OP_TAS        1708
CHECK_OP_TRAP       1730
CHECK_OP_TRAPV      1606
CHECK_OP_TST        171C
CHECK_OP_UNLK       1758
COMMA               1061
CR                  1063
CUR_OP_CODE         4000
C_GROUP_0           12F8
C_GROUP_1           14C6
C_GROUP_2           14F0
C_GROUP_3           1552
C_GROUP_4           15B4
C_GROUP_5           1832
C_GROUP_6           1898
C_GROUP_7           193E
C_GROUP_8           1962
C_GROUP_9           19B8
C_GROUP_A           1A12
C_GROUP_B           1A1A
C_GROUP_C           1A7A
C_GROUP_D           1B10
C_GROUP_E           1B52
C_GROUP_F           1CEA
DATA                105A
EA_BUFFER           1065
EA_SIZE             1008
END_ADDRESS         5000
FIND_2_BIT_SIZE_TO_EA  1222
FIND_3_BIT_REG_TO_EA  1238
FIND_MOVEA_L_DIFFERENCE  1506
FIND_MOVEA_W_DIFF   1568
FIND_TRAILING_BITS_TO_EA  1294
FIRST_3             1004
FOURTH_3            1007
GROUP0_INVALID      14BA
GROUP0_SUCCESS      14C0
GROUP1_INVALID      14E4
GROUP1_SUCCESS      14EA
GROUP2_INVALID      1546
GROUP2_SUCCESS      154C
GROUP3_INVALID      15A8
GROUP3_SUCCESS      15AE
GROUP4_INVALID      1826
GROUP4_SUCCESS      182C
GROUP5_INVALID      188C
GROUP5_SUCCESS      1892
GROUP6_INVALID      1932
GROUP6_SUCCESS      1938
GROUP7_INVALID      1956
GROUP7_SUCCESS      195C
GROUP8_INVALID      19AC
GROUP8_SUCCESS      19B2
GROUP9_INVALID      1A08
GROUP9_SUCCESS      1A0C
GROUPB_INVALID      1A6E
GROUPB_SUCCESS      1A74
GROUPC_INVALID      1B04
GROUPC_SUCCESS      1B0A
GROUPD_INVALID      1B46
GROUPD_SUCCESS      1B4C
GROUPE_INVALID      1CDE
GROUPE_SUCCESS      1CE4
GROUP_0             10DC
GROUP_1             10EE
GROUP_2             1100
GROUP_3             1112
GROUP_4             1124
GROUP_5             1136
GROUP_6             1148
GROUP_7             115A
GROUP_8             116C
GROUP_9             117E
GROUP_A             1190
GROUP_B             11A2
GROUP_C             11B4
GROUP_D             11C6
GROUP_E             11D8
GROUP_F             11EA
G_BUFFER            4100
HEX_SIGN            105D
IMMDTE_VALU         105E
INVALID_OP          1CF2
IS_VALID            10B5
LF                  1064
LOAD_OP_CODE        10C4
MINUS_SIGN          1060
MNEMONIC            1000
MOVE_AND_MOVEA_PARSE_EA  124E
MOVE_LAST_6_BITS_TO_EA  1200
OP_FOUND            1F60
OP_JSR_DONE         11F8
OP_JSR_ROUTINE      10D4
PARSE_EA_CONSTANT_BITS  12AA
PLUS_SIGN           105F
PRINT_OP            1F50
PRINT_OP_ADD        1ED0
PRINT_OP_ADDA       1EE0
PRINT_OP_ASL        1F20
PRINT_OP_ASR        1F10
PRINT_OP_BCS        1E20
PRINT_OP_BGE        1E30
PRINT_OP_BLT        1E40
PRINT_OP_BRA        1E60
PRINT_OP_BVC        1E50
PRINT_OP_CMP        1EB0
PRINT_OP_CMPI       1D30
PRINT_OP_DIVS       1E70
PRINT_OP_DYNAMIC_BCLR  1D50
PRINT_OP_EOR        1EA0
PRINT_OP_JSR        1DB0
PRINT_OP_LEA        1DD0
PRINT_OP_LSL        1EF0
PRINT_OP_LSR        1F00
PRINT_OP_MOVEA_L    1D70
PRINT_OP_MOVEA_W    1D90
PRINT_OP_MOVEB      1D60
PRINT_OP_MOVEM_L    1E00
PRINT_OP_MOVEM_W    1DF0
PRINT_OP_MOVE_L     1D80
PRINT_OP_MOVE_W     1DA0
PRINT_OP_MULS       1EC0
PRINT_OP_NEG        1DE0
PRINT_OP_OR         1E80
PRINT_OP_ORI        1D20
PRINT_OP_ROL        1F30
PRINT_OP_ROR        1F40
PRINT_OP_RTS        1DC0
PRINT_OP_STATIC_BCLR  1D40
PRINT_OP_SUB        1E90
PRINT_OP_SUBQ       1E10
PRINT_TO_BUFFER     1D0E
PTHSIS_CLSD         105C
PTHSIS_OPEN         105B
P_INVALID_OP        1F58
P_OP_ADD            201B
P_OP_ADDA           2016
P_OP_ASL            202B
P_OP_ASR            2027
P_OP_BCS            1FED
P_OP_BGE            1FF1
P_OP_BLT            1FF5
P_OP_BRA            1FE9
P_OP_BVC            1FF9
P_OP_CMP            200D
P_OP_CMPI           1F79
P_OP_DIVS           1FFD
P_OP_DYNAMIC_BCLR   1F83
P_OP_EOR            2009
P_OP_JSR            1FD4
P_OP_LEA            1FD0
P_OP_LSL            2023
P_OP_LSR            201F
P_OP_MOVEA_L        1F90
P_OP_MOVEA_W        1FA4
P_OP_MOVEB          1F88
P_OP_MOVEM_L        1FC4
P_OP_MOVEM_W        1FB8
P_OP_MOVE_L         1F9C
P_OP_MOVE_W         1FB0
P_OP_MULS           2011
P_OP_NEG            1FE0
P_OP_NOP            1FD8
P_OP_OR             2002
P_OP_ORI            1F75
P_OP_ROL            2033
P_OP_ROR            202F
P_OP_RTS            1FDC
P_OP_STATIC_BCLR    1F7E
P_OP_SUB            2005
P_OP_SUBQ           1FE4
P_SIZE_B            1F69
P_SIZE_L            1F71
P_SIZE_W            1F6D
READ_NEXT_INSTRUCTION  1D0A
RET_ADDSTRTOBUFFER_SUCCESS  2044
SECOND_3            1005
SPACE               1062
START               10B6
START_ADDRESS       4000
THIRD_3             1006
TRAILING_SIZE       1002
_ADDSTRTOBUFFER_ADDLOOP  2070
_ADDSTRTOBUFFER_BUFFERLOOP  205C
_ADDSTRTOBUFFER_END  2094
_ADDSTRTOBUFFER_LENGTHEXCEEDED  208E
_ADDSTRTOBUFFER_SUCCESS  2086
