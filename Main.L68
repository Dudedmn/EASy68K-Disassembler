00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/2/2019 4:24:45 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler for 422
00000000                             3  * Written by : Daniel, Denny, Fahad
00000000                             4  * Date       :
00000000                             5  * 
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of 
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  * 
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't reorg the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format: 
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  START:
00001000                            22      ***********************************************************
00001000                            23      * Code demo for printing strings to console & file is here
00001000                            24      * Pay close attention to:
00001000                            25      *   (1) the detailed comments, 
00001000                            26      *   (2) how to build a (Callee-Saved) method
00001000                            27      *   (3) how to call that method using JSR (return with RTS)
00001000                            28      ***********************************************************
00001000                            29      
00001000                            30      ;LEA DATACHECK,A1
00001000                            31      ;JSR check_DATA
00001000                            32  
00001000                            33      **************************************************
00001000                            34      *Your disassembler code goes here
00001000                            35      **************************************************
00001000                            36  ***************TEST NOP   
00001000  323C 4E71                 37      MOVE.W #%0100111001110001,D1
00001004  43F9 000010F2             38      LEA NOPCHECK,A1
0000100A  4EB9 00001024             39      JSR check_NOP
00001010                            40  ***************TEST RTS
00001010  323C 4E75                 41      MOVE.W #%0100111001110101,D1
00001014  43F9 00001109             42      LEA RTSCHECK,A1
0000101A  4EB9 0000102E             43      JSR check_RTS
00001020                            44      
00001020                            45      
00001020  FFFF FFFF                 46      SIMHALT
00001024                            47      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00001024                            48      ;load start and end address as longs
00001024                            49      
00001024                            50      ;loop from start to end, printing out the instruction or DATA if not recognized 
00001024                            51      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00001024                            52  
00001024                            53  
00001024                            54  *********************************************************************************
00001024                            55  * Method Name: check_NOP
00001024                            56  * Description: Looks for the Binary code of NOP or 0100111001110001 or $4E71 in hex.
00001024                            57  * If the value is found, then print out NOP. Otherwise simply RTS.
00001024                            58  * Preconditions:  D1 has some sort of binary input.
00001024                            59  * Postconditions: 'NOP' is printed to console if NOP binary value is found.
00001024                            60  *********************************************************************************
00001024                            61  check_NOP:
00001024  0C41 4E71                 62          CMPI #$4E71, D1
00001028  6700 000E                 63          BEQ PRINT_NOP
0000102C  4E75                      64          RTS
0000102E                            65  *********************************************************************************
0000102E                            66  * Method Name: check_RTS
0000102E                            67  * Description: Looks for the binary value of RTS $4E75 from data register D1 and
0000102E                            68  * compares the value of RTS to D1. If it equals it prints 'RTS' otherwise it will
0000102E                            69  * only RTS.
0000102E                            70  * Preconditions:  Some value in D1
0000102E                            71  * Postconditions: Prints 'RTS' in the console if found, otherwise just RTS
0000102E                            72  *********************************************************************************
0000102E                            73  check_RTS:
0000102E  0C41 4E75                 74          CMPI #$4E75, D1
00001032  6700 0010                 75          BEQ  PRINT_RST
00001036  4E75                      76          RTS
00001038                            77  *********************************************************************************
00001038                            78  * Method Name: TrapTask13
00001038                            79  * Description: Creates a file if none exists, and appends bytes to that file
00001038                            80  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001038                            81  *   change this code.
00001038                            82  *
00001038                            83  * Calling Convention: Callee-Saved 
00001038                            84  *
00001038                            85  * Preconditions & Method Input:
00001038                            86  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001038                            87  *
00001038                            88  * Postconditions & Output:
00001038                            89  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001038                            90  *   See 'Output.txt' in directory for the results, also piped to the console
00001038                            91  *
00001038                            92  *
00001038                            93  *  A2 holds a pointer to null terminated string to write (input)
00001038                            94  *  A3 points to the null-terminated file name
00001038                            95  *  D3 holds the number of bytes already in the file to write
00001038                            96  *
00001038                            97  *  D5 holds number of bytes to write
00001038                            98  ********************************************************************************
00001038                            99  toSave REG D0-D5/A2-A3
00001038                           100  
00001038                           101  PRINT_NOP:
00001038  43F9 000010EE            102      LEA PRINTNOP, A1        ; buffer of chars to write
0000103E  4EB9 00001050            103      JSR TrapTask13
00001044                           104  
00001044                           105  PRINT_RST:
00001044  43F9 000010E9            106      LEA PRINTRTS, A1        ; buffer of chars to write
0000104A  4EB9 00001050            107      JSR TrapTask13
00001050                           108      
00001050                           109  
00001050                           110  TrapTask13:
00001050                           111      *******************************************************************
00001050                           112      * Method initialization, regsiter spilling, parameter saving, etc.
00001050                           113      *******************************************************************
00001050  48E7 FC30                114      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00001054                           115        
00001054  2449                     116      MOVEA.L A1, A2 ; save this buffer to write
00001056  47F9 00001120            117      LEA outFilename, A3  ; save this for later, too
0000105C                           118        
0000105C  303C 0032                119      move #50,d0   
00001060  4E4F                     120      trap #15 ; close all files, suggested to begin any IO 
00001062                           121      *******************************************************************
00001062                           122      * End Method Init
00001062                           123      *******************************************************************
00001062                           124  
00001062                           125      ******************************************************************************************
00001062                           126      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001062                           127      ******************************************************************************************
00001062  4285                     128      CLR.L D5 *D5 is now the number of bytes to write
00001064                           129  nullLoop:
00001064  1019                     130      MOVE.B (A1)+, D0
00001066  0C00 0000                131      CMPI.B #0,D0  * compare to null
0000106A  6700 0006                132      BEQ findNullLoopDone
0000106E  5245                     133      ADDI.W #1, D5
00001070  60F2                     134      BRA nullLoop
00001072                           135      
00001072                           136  findNullLoopDone:
00001072  224B                     137      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001074                           138      
00001074                           139      ;check if file exists, and open with task 51 if so, otherwise 52
00001074                           140      ;(precondition here is A1 points to the null-terminated filename )
00001074  103C 0033                141      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001078  4E4F                     142      trap #15
0000107A                           143        
0000107A                           144      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001080  103C 0034                145          MOVE.B #52, D0             ; open new file (52 is new)
00001084  4E4F                     146          trap #15
00001086                           147      endi
00001086                           148      
00001086                           149      ********************************************************************************************************* 
00001086                           150      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001086                           151      *    (first, count number of bytes already in the file to obtain seek position)
00001086                           152      *********************************************************************************************************
00001086  4283                     153      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001088  7401                     154      MOVE.L #1, D2 ; read one byte at a time
0000108A  43F9 0000112B            155      LEA byteRead, A1
00001090                           156      
00001090                           157  countLoop:
00001090  103C 0035                158      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00001094  4E4F                     159      trap #15
00001096                           160      
00001096  0C40 0001                161      CMPI.W #1,D0  ;1 == EOF
0000109A  6700 0006                162      BEQ countDone
0000109E  5243                     163      ADDI #1, D3
000010A0  60EE                     164      BRA countLoop
000010A2                           165      
000010A2                           166  countDone:    
000010A2                           167      * close this file
000010A2  303C 0038                168       move #56,d0  
000010A6  4E4F                     169       trap #15 
000010A8                           170       
000010A8                           171       * reopen the target file
000010A8  224B                     172       MOVE.L A3,A1
000010AA  303C 0033                173       MOVE #51, D0
000010AE  4E4F                     174       trap #15
000010B0                           175       
000010B0                           176      * seek to right position, then continue with writing
000010B0  2403                     177      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000010B2  303C 0037                178      MOVE #55, D0  ; position file task
000010B6  4E4F                     179      trap #15
000010B8                           180  
000010B8                           181      ******************************************************************************
000010B8                           182      * Actually write the buffer to the file, after caculating the number of bytes 
000010B8                           183      *  to write and after seeking to the right location in the file for append
000010B8                           184      ******************************************************************************
000010B8                           185  
000010B8  2405                     186      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000010BA                           187      ; assumes A0 hasnt changed since handed to this method      
000010BA  224A                     188      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000010BC                           189      ; assumes file ID is still stored in D1.L  
000010BC  103C 0036                190      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000010C0  4E4F                     191      trap #15
000010C2                           192  
000010C2                           193      ; add a newline to the file output
000010C2  43F9 000010E6            194      LEA NEWLINE, A1
000010C8  103C 0036                195      MOVE.B #54, D0 
000010CC  143C 0002                196      MOVE.B #2,D2  ; kills # of bytes to write from input param
000010D0  4E4F                     197      trap #15
000010D2                           198      
000010D2                           199      ; finally, close only this file
000010D2  103C 0038                200      MOVE.B #56, D0 ; close file task
000010D6  4E4F                     201      trap #15
000010D8                           202    
000010D8                           203      ; report to screen
000010D8  224A                     204      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000010DA  103C 000D                205      MOVE.B #13, D0
000010DE  4E4F                     206      trap #15
000010E0                           207        
000010E0                           208      ; restore context
000010E0  4CDF 0C3F                209      MOVEM.L (SP)+, toSave
000010E4                           210      
000010E4  4E75                     211      RTS
000010E6                           212      
000010E6                           213  * Required variables and constants go here for your Disassembler
000010E6  =0000000D                214  CR                  EQU $0D
000010E6  =0000000A                215  LF                  EQU $0A
000010E6= 0D 0A 00                 216  NEWLINE             DC.B CR,LF,0  
000010E9= 44 41 54 41 00           217  PRINTRTS            DC.B 'DATA',0
000010EE= 4E 4F 50 00              218  PRINTNOP            DC.B 'NOP',0
000010F2= 43 68 65 63 6B 69 ...    219  NOPCHECK            DC.B 'Checking input for NOP',0
00001109= 43 68 65 63 6B 69 ...    220  RTSCHECK            DC.B 'Checking input for RTS',0
00001120= 4F 75 74 70 75 74 ...    221  outFilename         DC.B 'Output.txt',0
0000112B                           222  byteRead            DS.B 1
0000112C                           223  
0000112C                           224     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BYTEREAD            112B
CHECK_NOP           1024
CHECK_RTS           102E
COUNTDONE           10A2
COUNTLOOP           1090
CR                  D
FINDNULLLOOPDONE    1072
LF                  A
NEWLINE             10E6
NOPCHECK            10F2
NULLLOOP            1064
OUTFILENAME         1120
PRINTNOP            10EE
PRINTRTS            10E9
PRINT_NOP           1038
PRINT_RST           1044
RTSCHECK            1109
START               1000
TOSAVE              C3F
TRAPTASK13          1050
_00000000           1086
