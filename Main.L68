00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 2/28/2019 4:32:43 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler Skeleton 
00000000                             3  * Written by : You, and you should change all default comments
00000000                             4  * Date       :
00000000                             5  * 
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of 
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  * 
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't reorg the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format: 
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  START:
00001000                            22      ***********************************************************
00001000                            23      * Code demo for printing strings to console & file is here
00001000                            24      * Pay close attention to:
00001000                            25      *   (1) the detailed comments, 
00001000                            26      *   (2) how to build a (Callee-Saved) method
00001000                            27      *   (3) how to call that method using JSR (return with RTS)
00001000                            28      ***********************************************************
00001000                            29      
00001000                            30      ;LEA DATACHECK,A1
00001000                            31      ;JSR check_DATA
00001000                            32  
00001000                            33      **************************************************
00001000                            34      *Your disassembler code goes here
00001000                            35      **************************************************
00001000  32B8 4E71                 36      MOVE.W %0100111001110001, (A1)
00001004  43F9 000010E4             37      LEA NOPCHECK,A1
0000100A  4EB9 00001014             38      JSR check_NOP
00001010                            39  
00001010                            40      
00001010                            41      
00001010                            42      
00001010                            43      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00001010                            44      ;load start and end address as longs
00001010                            45      
00001010                            46      ;loop from start to end, printing out the instruction or DATA if not recognized 
00001010                            47      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00001010                            48  
00001010  FFFF FFFF                 49      SIMHALT
00001014                            50  
00001014                            51  *********************************************************************************
00001014                            52  * Method Name: Check for NOP Operation
00001014                            53  * Description: Looks for the Binary code of NOP or 0100111001110001 or $4E71 in hex
00001014                            54  *
00001014                            55  * Preconditions:  D1 has the inputted value of NOP
00001014                            56  * Postconditions: NOP is printed
00001014                            57  *********************************************************************************
00001014                            58  check_NOP:
00001014  0C41 4E71                 59          CMPI #%0100111001110001, D1
00001018  6700 0010                 60          BEQ PRINT_NOP
0000101C  0C41 4E71                 61          CMPI #$4E71, D1
00001020  6700 0008                 62          BEQ PRINT_NOP
00001024  4E75                      63          RTS
00001026                            64  *********************************************************************************
00001026                            65  * Method Name: check_DATA
00001026                            66  * Description:    Checks the validity of a binary input
00001026                            67  *
00001026                            68  * Preconditions:  TBA
00001026                            69  * Postconditions: TBA
00001026                            70  *********************************************************************************
00001026                            71  check_DATA:
00001026  4E71                      72          NOP
00001028  4E75                      73          RTS
0000102A                            74  *********************************************************************************
0000102A                            75  * Method Name: TrapTask13
0000102A                            76  * Description: Creates a file if none exists, and appends bytes to that file
0000102A                            77  *   while also echoing the written bytes to the screen.  You shouldn't need to
0000102A                            78  *   change this code.
0000102A                            79  *
0000102A                            80  * Calling Convention: Callee-Saved 
0000102A                            81  *
0000102A                            82  * Preconditions & Method Input:
0000102A                            83  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000102A                            84  *
0000102A                            85  * Postconditions & Output:
0000102A                            86  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000102A                            87  *   See 'Output.txt' in directory for the results, also piped to the console
0000102A                            88  *
0000102A                            89  *
0000102A                            90  *  A2 holds a pointer to null terminated string to write (input)
0000102A                            91  *  A3 points to the null-terminated file name
0000102A                            92  *  D3 holds the number of bytes already in the file to write
0000102A                            93  *
0000102A                            94  *  D5 holds number of bytes to write
0000102A                            95  ********************************************************************************
0000102A                            96  toSave REG D0-D5/A2-A3
0000102A                            97  
0000102A                            98  PRINT_NOP:
0000102A  43F9 000010E0             99      LEA PRINTNOP, A1        ; buffer of chars to write
00001030  4EB9 00001042            100      JSR TrapTask13
00001036                           101  
00001036                           102  PRINT_DATA:
00001036  43F9 000010DB            103      LEA PRINTDATA, A1        ; buffer of chars to write
0000103C  4EB9 00001042            104      JSR TrapTask13
00001042                           105      
00001042                           106  
00001042                           107  TrapTask13:
00001042                           108      *******************************************************************
00001042                           109      * Method initialization, regsiter spilling, parameter saving, etc.
00001042                           110      *******************************************************************
00001042  48E7 FC30                111      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00001046                           112        
00001046  2449                     113      MOVEA.L A1, A2 ; save this buffer to write
00001048  47F9 00001119            114      LEA outFilename, A3  ; save this for later, too
0000104E                           115        
0000104E  303C 0032                116      move #50,d0   
00001052  4E4F                     117      trap #15 ; close all files, suggested to begin any IO 
00001054                           118      *******************************************************************
00001054                           119      * End Method Init
00001054                           120      *******************************************************************
00001054                           121  
00001054                           122      ******************************************************************************************
00001054                           123      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001054                           124      ******************************************************************************************
00001054  4285                     125      CLR.L D5 *D5 is now the number of bytes to write
00001056                           126  nullLoop:
00001056  1019                     127      MOVE.B (A1)+, D0
00001058  0C00 0000                128      CMPI.B #0,D0  * compare to null
0000105C  6700 0006                129      BEQ findNullLoopDone
00001060  5245                     130      ADDI.W #1, D5
00001062  60F2                     131      BRA nullLoop
00001064                           132      
00001064                           133  findNullLoopDone:
00001064  224B                     134      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001066                           135      
00001066                           136      ;check if file exists, and open with task 51 if so, otherwise 52
00001066                           137      ;(precondition here is A1 points to the null-terminated filename )
00001066  103C 0033                138      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
0000106A  4E4F                     139      trap #15
0000106C                           140        
0000106C                           141      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001072  103C 0034                142          MOVE.B #52, D0             ; open new file (52 is new)
00001076  4E4F                     143          trap #15
00001078                           144      endi
00001078                           145      
00001078                           146      ********************************************************************************************************* 
00001078                           147      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001078                           148      *    (first, count number of bytes already in the file to obtain seek position)
00001078                           149      *********************************************************************************************************
00001078  4283                     150      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
0000107A  7401                     151      MOVE.L #1, D2 ; read one byte at a time
0000107C  43F9 00001124            152      LEA byteRead, A1
00001082                           153      
00001082                           154  countLoop:
00001082  103C 0035                155      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00001086  4E4F                     156      trap #15
00001088                           157      
00001088  0C40 0001                158      CMPI.W #1,D0  ;1 == EOF
0000108C  6700 0006                159      BEQ countDone
00001090  5243                     160      ADDI #1, D3
00001092  60EE                     161      BRA countLoop
00001094                           162      
00001094                           163  countDone:    
00001094                           164      * close this file
00001094  303C 0038                165       move #56,d0  
00001098  4E4F                     166       trap #15 
0000109A                           167       
0000109A                           168       * reopen the target file
0000109A  224B                     169       MOVE.L A3,A1
0000109C  303C 0033                170       MOVE #51, D0
000010A0  4E4F                     171       trap #15
000010A2                           172       
000010A2                           173      * seek to right position, then continue with writing
000010A2  2403                     174      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000010A4  303C 0037                175      MOVE #55, D0  ; position file task
000010A8  4E4F                     176      trap #15
000010AA                           177  
000010AA                           178      ******************************************************************************
000010AA                           179      * Actually write the buffer to the file, after caculating the number of bytes 
000010AA                           180      *  to write and after seeking to the right location in the file for append
000010AA                           181      ******************************************************************************
000010AA                           182  
000010AA  2405                     183      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000010AC                           184      ; assumes A0 hasnt changed since handed to this method      
000010AC  224A                     185      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000010AE                           186      ; assumes file ID is still stored in D1.L  
000010AE  103C 0036                187      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000010B2  4E4F                     188      trap #15
000010B4                           189  
000010B4                           190      ; add a newline to the file output
000010B4  43F9 000010D8            191      LEA NEWLINE, A1
000010BA  103C 0036                192      MOVE.B #54, D0 
000010BE  143C 0002                193      MOVE.B #2,D2  ; kills # of bytes to write from input param
000010C2  4E4F                     194      trap #15
000010C4                           195      
000010C4                           196      ; finally, close only this file
000010C4  103C 0038                197      MOVE.B #56, D0 ; close file task
000010C8  4E4F                     198      trap #15
000010CA                           199    
000010CA                           200      ; report to screen
000010CA  224A                     201      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000010CC  103C 000D                202      MOVE.B #13, D0
000010D0  4E4F                     203      trap #15
000010D2                           204        
000010D2                           205      ; restore context
000010D2  4CDF 0C3F                206      MOVEM.L (SP)+, toSave
000010D6                           207      
000010D6  4E75                     208      RTS
000010D8                           209      
000010D8                           210  * Required variables and constants go here for your Disassembler
000010D8  =0000000D                211  CR                  EQU $0D
000010D8  =0000000A                212  LF                  EQU $0A
000010D8= 0D 0A 00                 213  NEWLINE             DC.B CR,LF,0  
000010DB= 44 41 54 41 00           214  PRINTDATA           DC.B 'DATA',0
000010E0= 4E 4F 50 00              215  PRINTNOP            DC.B 'NOP',0
000010E4= 43 68 65 63 6B 69 ...    216  NOPCHECK            DC.B  'Checking input for NOP',0
000010FB= 43 68 65 63 6B 69 ...    217  DATACHECK           DC.B  'Checking input for valid data',0
00001119= 4F 75 74 70 75 74 ...    218  outFilename         DC.B 'Output.txt',0
00001124                           219  byteRead            DS.B 1
00001125                           220  
00001125                           221     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BYTEREAD            1124
CHECK_DATA          1026
CHECK_NOP           1014
COUNTDONE           1094
COUNTLOOP           1082
CR                  D
DATACHECK           10FB
FINDNULLLOOPDONE    1064
LF                  A
NEWLINE             10D8
NOPCHECK            10E4
NULLLOOP            1056
OUTFILENAME         1119
PRINTDATA           10DB
PRINTNOP            10E0
PRINT_DATA          1036
PRINT_NOP           102A
START               1000
TOSAVE              C3F
TRAPTASK13          1042
_00000000           1078
