00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/4/2019 4:20:51 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler Skeleton 
00000000                             3  * Written by : You, and you should change all default comments
00000000                             4  * Date       :
00000000                             5  * 
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of 
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  * 
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't reorg the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format: 
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  
00001000                            22  *declare the variable startaddr with size 1 long
00001000                            23  STARTADDR   DS.L        1                       * The starting address to decode from
00001004                            24  
00001004                            25  
00001004                            26  START:
00001004                            27      ***********************************************************
00001004                            28      * Code demo for printing strings to console & file is here
00001004                            29      * Pay close attention to:
00001004                            30      *   (1) the detailed comments, 
00001004                            31      *   (2) how to build a (Callee-Saved) method
00001004                            32      *   (3) how to call that method using JSR (return with RTS)
00001004                            33      ***********************************************************
00001004  43F9 00001125             34      LEA MSG1, A1        ; buffer of chars to write
0000100A  4EB9 00001044             35      JSR TrapTask13
00001010                            36      
00001010                            37      * Read input from the user as string
00001010                            38      * and save it in A1
00001010  103C 0002                 39      MOVE.B #2, D0
00001014  4E4F                      40      TRAP #15
00001016                            41      
00001016                            42      * Convernt the string in A1 to hex
00001016                            43      * and store it in D7
00001016  4EB9 000010DA             44      JSR AsciiToHex
0000101C                            45      
0000101C                            46      * Move the long value in D7 
0000101C                            47      * to the variable STARTADDR
0000101C  21C7 1000                 48      MOVE.L D7, STARTADDR
00001020                            49  
00001020                            50      
00001020  43F9 00001148             51      LEA MSG2, A1        ; buffer of chars to write    
00001026  4EB9 00001044             52      JSR TrapTask13
0000102C                            53  
0000102C  43F9 00001175             54      LEA ascii_val, A1
00001032  4EB9 000010DA             55      JSR AsciiToHex     ;  example of how to convert ascii to hex
00001038                            56  
00001038                            57      **************************************************
00001038                            58      *Your disassembler code goes here
00001038                            59      **************************************************
00001038                            60      
00001038                            61      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00001038                            62      ;load start and end address as longs
00001038                            63      
00001038                            64      ;loop from start to end, printing out the instruction or DATA if not recognized 
00001038                            65      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00001038                            66  
00001038  FFFF FFFF                 67      SIMHALT
0000103C                            68  
0000103C                            69  *********************************************************************************
0000103C                            70  * Method Name: yourDisassemblerFirstMethodHere
0000103C                            71  * Description: call this method from your code above; see the examples above on
0000103C                            72  *   how to call methods and use them profusely as you build your final project
0000103C                            73  *
0000103C                            74  * Preconditions:  TBA
0000103C                            75  * Postconditions: TBA
0000103C                            76  *********************************************************************************
0000103C                            77  method1:
0000103C  4E71                      78          NOP
0000103E  4E75                      79          RTS
00001040                            80  *********************************************************************************
00001040                            81  * Method Name: yourDisassemblerSecondMethodHere
00001040                            82  * Description:    TBA
00001040                            83  *
00001040                            84  * Preconditions:  TBA
00001040                            85  * Postconditions: TBA
00001040                            86  *********************************************************************************
00001040                            87  method2:
00001040  4E71                      88          NOP
00001042  4E75                      89          RTS
00001044                            90  *********************************************************************************
00001044                            91  * Method Name: TrapTask13
00001044                            92  * Description: Creates a file if none exists, and appends bytes to that file
00001044                            93  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001044                            94  *   change this code.
00001044                            95  *
00001044                            96  * Calling Convention: Callee-Saved 
00001044                            97  *
00001044                            98  * Preconditions & Method Input:
00001044                            99  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001044                           100  *
00001044                           101  * Postconditions & Output:
00001044                           102  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001044                           103  *   See 'Output.txt' in directory for the results, also piped to the console
00001044                           104  *
00001044                           105  *
00001044                           106  *  A2 holds a pointer to null terminated string to write (input)
00001044                           107  *  A3 points to the null-terminated file name
00001044                           108  *  D3 holds the number of bytes already in the file to write
00001044                           109  *
00001044                           110  *  D5 holds number of bytes to write
00001044                           111  ********************************************************************************
00001044                           112  toSave REG D0-D5/A2-A3
00001044                           113  TrapTask13:
00001044                           114      *******************************************************************
00001044                           115      * Method initialization, regsiter spilling, parameter saving, etc.
00001044                           116      *******************************************************************
00001044  48E7 FC30                117      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00001048                           118        
00001048  2449                     119      MOVEA.L A1, A2 ; save this buffer to write
0000104A  47F9 00001169            120      LEA outFilename, A3  ; save this for later, too
00001050                           121        
00001050  303C 0032                122      move #50,d0   
00001054  4E4F                     123      trap #15 ; close all files, suggested to begin any IO 
00001056                           124      *******************************************************************
00001056                           125      * End Method Init
00001056                           126      *******************************************************************
00001056                           127  
00001056                           128      ******************************************************************************************
00001056                           129      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001056                           130      ******************************************************************************************
00001056  4285                     131      CLR.L D5 *D5 is now the number of bytes to write
00001058                           132  nullLoop:
00001058  1019                     133      MOVE.B (A1)+, D0
0000105A  0C00 0000                134      CMPI.B #0,D0  * compare to null
0000105E  6700 0006                135      BEQ findNullLoopDone
00001062  5245                     136      ADDI.W #1, D5
00001064  60F2                     137      BRA nullLoop
00001066                           138      
00001066                           139  findNullLoopDone:
00001066  224B                     140      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001068                           141      
00001068                           142      ;check if file exists, and open with task 51 if so, otherwise 52
00001068                           143      ;(precondition here is A1 points to the null-terminated filename )
00001068  103C 0033                144      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
0000106C  4E4F                     145      trap #15
0000106E                           146        
0000106E                           147      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001074  103C 0034                148          MOVE.B #52, D0             ; open new file (52 is new)
00001078  4E4F                     149          trap #15
0000107A                           150      endi
0000107A                           151      
0000107A                           152      ********************************************************************************************************* 
0000107A                           153      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
0000107A                           154      *    (first, count number of bytes already in the file to obtain seek position)
0000107A                           155      *********************************************************************************************************
0000107A  4283                     156      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
0000107C  7401                     157      MOVE.L #1, D2 ; read one byte at a time
0000107E  43F9 00001174            158      LEA byteRead, A1
00001084                           159      
00001084                           160  countLoop:
00001084  103C 0035                161      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00001088  4E4F                     162      trap #15
0000108A                           163      
0000108A  0C40 0001                164      CMPI.W #1,D0  ;1 == EOF
0000108E  6700 0006                165      BEQ countDone
00001092  5243                     166      ADDI #1, D3
00001094  60EE                     167      BRA countLoop
00001096                           168      
00001096                           169  countDone:    
00001096                           170      * close this file
00001096  303C 0038                171       move #56,d0  
0000109A  4E4F                     172       trap #15 
0000109C                           173       
0000109C                           174       * reopen the target file
0000109C  224B                     175       MOVE.L A3,A1
0000109E  303C 0033                176       MOVE #51, D0
000010A2  4E4F                     177       trap #15
000010A4                           178       
000010A4                           179      * seek to right position, then continue with writing
000010A4  2403                     180      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000010A6  303C 0037                181      MOVE #55, D0  ; position file task
000010AA  4E4F                     182      trap #15
000010AC                           183  
000010AC                           184      ******************************************************************************
000010AC                           185      * Actually write the buffer to the file, after caculating the number of bytes 
000010AC                           186      *  to write and after seeking to the right location in the file for append
000010AC                           187      ******************************************************************************
000010AC                           188  
000010AC  2405                     189      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000010AE                           190      ; assumes A0 hasnt changed since handed to this method      
000010AE  224A                     191      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000010B0                           192      ; assumes file ID is still stored in D1.L  
000010B0  103C 0036                193      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000010B4  4E4F                     194      trap #15
000010B6                           195  
000010B6                           196      ; add a newline to the file output
000010B6  43F9 00001122            197      LEA NEWLINE, A1
000010BC  103C 0036                198      MOVE.B #54, D0 
000010C0  143C 0002                199      MOVE.B #2,D2  ; kills # of bytes to write from input param
000010C4  4E4F                     200      trap #15
000010C6                           201      
000010C6                           202      ; finally, close only this file
000010C6  103C 0038                203      MOVE.B #56, D0 ; close file task
000010CA  4E4F                     204      trap #15
000010CC                           205    
000010CC                           206      ; report to screen
000010CC  224A                     207      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000010CE  103C 000D                208      MOVE.B #13, D0
000010D2  4E4F                     209      trap #15
000010D4                           210        
000010D4                           211      ; restore context
000010D4  4CDF 0C3F                212      MOVEM.L (SP)+, toSave
000010D8                           213      
000010D8  4E75                     214      RTS
000010DA                           215      
000010DA                           216      
000010DA                           217  *----------------------------------------------------------------------------------
000010DA                           218  * Method Name: AsciiToHex
000010DA                           219  * Written by : Berger, Modified by Nash
000010DA                           220  * Date       : 3/1/2019
000010DA                           221  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000010DA                           222  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000010DA                           223  *              its (4b each) equivalent hex value 
000010DA                           224  *  
000010DA                           225  *  Preconditions & Input
000010DA                           226  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000010DA                           227  *       This function calls another function (strip_ascii)
000010DA                           228  *
000010DA                           229  *  Postconditions & Output
000010DA                           230  *       D7 (output) holds the converted value 
000010DA                           231  *       Caller-Saved : D0 is temp, D6 is a loop var
000010DA                           232  *----------------------------------------------------------------------------------
000010DA                           233  AsciiToHexRegList REG D0,D6
000010DA                           234  AsciiToHex     
000010DA  48E7 8000                235      MOVEM.L asciiToHexRegList, -(SP)  *save context
000010DE  4287                     236      CLR.L D7 * clear our return value
000010E0  7C08                     237      MOVE.L #8, D6 ; and set up our loop counter
000010E2                           238  
000010E2                           239  chrLoop
000010E2  1019                     240      MOVE.B (A1)+,D0 * Get the first byte
000010E4  4EB9 000010FC            241      jsr strip_ascii * Get rid of the ascii code    
000010EA  8E40                     242      OR.W D0,D7 * Load the bits into D7
000010EC                           243      
000010EC  5306                     244      subI.B #1,D6  *decrement our loop variable
000010EE  6700 0006                245      BEQ chrDone   *skip shifting if we are done
000010F2                           246      
000010F2  E987                     247      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
000010F4  60EC                     248      BRA chrLoop
000010F6                           249  
000010F6                           250  chrDone
000010F6  4CDF 0001                251      MOVEM.L (SP)+,asciiToHexRegList 
000010FA  4E75                     252      RTS
000010FC                           253  
000010FC                           254  
000010FC                           255  **********************************************************************
000010FC                           256  * SUBROUTINE: strip_ascii
000010FC                           257  * remove the ascii code from the digits 0-9,a-f, or A-F
000010FC                           258  * Input Parameters: <D0> = ascii code
000010FC                           259  *
000010FC                           260  * Return parameters: D0.B = number 0...F, returned as 00...0F
000010FC                           261  * Registers used internally: D0
000010FC                           262  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
000010FC                           263  *
000010FC                           264  ***********************************************************************
000010FC                           265  strip_ascii
000010FC  B03C 0039                266        CMP.B #$39,D0 * Is it in range of 0-9?
00001100  6F00 001A                267        BLE sub30 * Its a number
00001104  B03C 0046                268        CMP.B #$46,D0 * Is is A...F?
00001108  6F00 000A                269        BLE sub37 * Its A...F
0000110C  0400 0057                270        SUB.B #$57,D0 * Its a...f
00001110  6000 000E                271        BRA ret_sa * Go back
00001114  0400 0037                272  sub37 SUB.B #$37,D0 * Strip 37
00001118  6000 0006                273        BRA ret_sa * Go back
0000111C  0400 0030                274  sub30 SUB.B #$30,D0 * Strip 30
00001120  4E75                     275  ret_sa RTS * Go back
00001122                           276  
00001122                           277      
00001122                           278  * Required variables and constants go here for your Disassembler
00001122  =0000000D                279  CR                  EQU $0D
00001122  =0000000A                280  LF                  EQU $0A
00001122= 0D 0A 00                 281  NEWLINE             DC.B CR,LF,0  
00001125= 50 6C 65 61 73 65 ...    282  MSG1                DC.B 'Please enter the starting address:',0
00001148= 50 6C 65 61 73 65 ...    283  MSG2                DC.B 'Please enter the ending address:',0
00001169= 4F 75 74 70 75 74 ...    284  outFilename         DC.B 'Output.txt',0
00001174                           285  byteRead            DS.B 1
00001175= 31 41 30 30 31 41 ...    286  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
0000117D                           287  
0000117D                           288  
0000117D                           289     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCIITOHEX          10DA
ASCIITOHEXREGLIST   1
ASCII_VAL           1175
BYTEREAD            1174
CHRDONE             10F6
CHRLOOP             10E2
COUNTDONE           1096
COUNTLOOP           1084
CR                  D
FINDNULLLOOPDONE    1066
LF                  A
METHOD1             103C
METHOD2             1040
MSG1                1125
MSG2                1148
NEWLINE             1122
NULLLOOP            1058
OUTFILENAME         1169
RET_SA              1120
START               1004
STARTADDR           1000
STRIP_ASCII         10FC
SUB30               111C
SUB37               1114
TOSAVE              C3F
TRAPTASK13          1044
_00000000           107A
