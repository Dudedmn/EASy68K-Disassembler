000010A4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/17/2019 7:36:35 PM

00000000                             1  **--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler in Motorola 68k
00000000                             3  * Written by : TEAM REEE Denny, Daniel, Fahad
00000000                             4  * Date       : 3/17/2019 
00000000                             5  * 
00000000                             6  * 
00000000                             7  * Description: This disassembler reverse assembles or decompiles a given
00000000                             8  * test program (with vailidity checking) from their machine code hex
00000000                             9  * equivalents to outputting them onto a console file and a log.
00000000                            10  *
00000000                            11  * This disassembler will print out <MEMORY ADDRESS> <OPERAND> <EA MODE/REG>
00000000                            12  * If the identified code is valid.
00000000                            13  *
00000000                            14  * This disassembler will print out <MEMORY ADDRESS> DATA $<INVALID HEX>
00000000                            15  * If the identified code is invalid.
00000000                            16  *---------------------------------------------------------------------------
00001000                            17      ORG    $1000    
00001000                            18  *---------------------------------------------------------------------------
00001000                            19  G_BUFFER        DS.B    80          ;Used to print out the needed letters to the buffer
00001050                            20  B_BUFFER        DS.B    80          ;Bad buffer used to load bad data
000010A0                            21  CUR_OP_CODE     DS.W    1           ;Used to determine the current 4 hex OP code
000010A2                            22  IS_VALID        DS.B    1           ;Validity bit to check if a code is valid or not
000010A3                            23                          ;1 = valid, 0 = invalid
000010A3                            24  
000010A3                            25  START:                      ;Start of the program
000010A3                            26  
000010A4  43F9 00001428             27      LEA MAIN_CONSOLE, A1            ;Loads the main message into A1
000010AA  4EB9 0000134A             28      JSR TrapTask13                 ;Prints message out to console and log
000010B0                            29  
000010B0                            30      
000010B0                            31      
000010B0                            32      ******************************************
000010B0                            33      **
000010B0                            34      **     ___         ___        /  __  
000010B0                            35      **    |__  | |    |__     |  /  /  \  
000010B0                            36      **    |    | |___ |___    | /   \__/ 
000010B0                            37      **                           
000010B0                            38      **
000010B0                            39      ** This is the beginning of the code for reading from files
000010B0                            40      ******************************************
000010B0                            41  * Attempt to open file for input
000010B0  43F9 000016FA             42          LEA     fileName,A1                    ;Name of file to open
000010B6  103C 0033                 43          MOVE.B  #51,D0                         ;Trap task #51, open existing file
000010BA  4E4F                      44          TRAP    #15                            ;Perform task
000010BC  23C1 0000171A             45          MOVE.L  D1,fileID                      ;Save file ID
000010C2                            46  
000010C2                            47  * Read string from file
000010C2  43F9 00001705             48          LEA     IO_BUFFER,A1                   ;Location of string buffer
000010C8  2239 0000171A             49          MOVE.L  fileID,D1                      ;File ID of file to read from
000010CE  4282                      50          CLR.L   D2
000010D0  343C 0014                 51          MOVE.W  #SIZE,D2                       ;Number of bytes to read
000010D4  103C 0035                 52          MOVE.B  #53,D0                         ;Trap task #53, read from file
000010D8  4E4F                      53          TRAP    #15                            ;Perform task
000010DA                            54  * Close file when finished
000010DA  103C 0038                 55          MOVE.B  #56,D0                         ;Trap task #56, close file, D1 contains fileID
000010DE  4E4F                      56          TRAP    #15                            ;Perform task
000010E0                            57  
000010E0                            58  
000010E0                            59  *Load start and end address as longs
000010E0                            60  *Start Address is in A5     
000010E0  43F9 00001705             61      LEA IO_BUFFER, A1               ;Load string or IO buffer to A1
000010E6  4EB9 000013E0             62      JSR AsciiToHex                  ;Convert ASCII to Hex
000010EC  2A47                      63      MOVE.L D7, A5                   ;Loop counter prep
000010EE                            64      
000010EE                            65  *End Address is in A6
000010EE  5489                      66      ADDA.L #2, A1                   ;Add #2 to A1
000010F0  4EB9 000013E0             67      JSR AsciiToHex                  ;Convert ASCII to Hex
000010F6  2C47                      68      MOVE.L D7, A6                   ;Loop counter prep
000010F8                            69      
000010F8                            70  VALIDATE_START_ADDRESS              ;Validates starting address
000010F8  200D                      71      MOVE.L A5, D0                   ;Move stating address to D0
000010FA                            72  *----------------------------------------------------------------------------------
000010FA                            73  * Method Name: VALIDATE_POSITIVE_ADDRESS
000010FA                            74  * Description: Checks if the start address is positive it then branches
000010FA                            75  *              to validate if the address in the Config.cfg file is even
000010FA                            76  *
000010FA                            77  *  Preconditions & Input of a start address that is even
000010FA                            78  *       A1 (input) points to a memory buffer holding 8 ASCII chars (not null-terminated) 
000010FA                            79  *       This function calls another function (strip_ascii)
000010FA                            80  *
000010FA                            81  *  Postconditions & Output
000010FA                            82  *   
000010FA                            83  *----------------------------------------------------------------------------------
000010FA                            84  VALIDATE_POSITIVE_ADDRESS
000010FA  200D                      85      MOVE.L A5, D0                   ;Move starting address to D0
000010FC  0280 80000000             86      ANDI.L #$80000000, D0           ;Checking if the start address address is positive
00001102  B0BC 00000000             87      CMP.L #0, D0                    ;Compare 0 to D0
00001108  6700 0034                 88      BEQ VALIDATE_EVEN               ;Check if the address is even
0000110C                            89      
0000110C  43F9 0000171E             90      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001112  4EB9 0000134A             91      JSR TrapTask13                             ;Use Nash's Console Output
00001118  6000 0134                 92      BRA DONE                        ;Finish routine
0000111C                            93  
0000111C                            94  VALIDATE_END_POS
0000111C  200E                      95      MOVE.L A6, D0                   ;Move ending address to D0
0000111E  0280 80000000             96      ANDI.L #$80000000, D0                  ;Checking if the end address address is positive
00001124  B0BC 00000000             97      CMP.L #0, D0                    ;Compare address to 0
0000112A  6700 0012                 98      BEQ VALIDATE_EVEN               ;Check if the end address is even
0000112E                            99      
0000112E  43F9 0000171E            100      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001134  4EB9 0000134A            101      JSR TrapTask13                             ;Use Nash's Console Output      
0000113A  6000 0112                102      BRA DONE                        ;Finish routine
0000113E                           103      
0000113E                           104  VALIDATE_EVEN
0000113E  200D                     105      MOVE.L A5, D0                   ;MOVE STARTING ADDRESS TO D0
00001140  0280 00000001            106      ANDI.L #$00000001,D0                   ;Bitmask 1 a single bit to D0
00001146  B0BC 00000000            107      CMP.L #0, D0                    ;Check if even
0000114C  6700 0012                108      BEQ MAIN_LOOP                   ;Go to the main loop if even
00001150                           109  *Handle odd addresses
00001150  43F9 0000171E            110      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001156  4EB9 0000134A            111      JSR TrapTask13                             ;Use Nash's Console Output
0000115C  6000 00F0                112      BRA DONE                        ;Finish routine
00001160                           113              
00001160                           114  
00001160                           115  
00001160                           116  *Comments are shifted if variable names get too long
00001160                           117  MAIN_LOOP                                   ;Main loop to run each instruction
00001160  49F8 1000                118           LEA G_BUFFER,A4                            ;Point G_BUFFER to A4
00001164                           119      
00001164  BDCD                     120              CMPA.L A5, A6                           ;Compare Starting to ending address
00001166  6D00 00E6                121              BLT DONE                            ;If it's less then stop the loop
0000116A                           122              
0000116A                           123  *Clear both buffers 
0000116A  23FC 00001000 000012B4   124              MOVE.L #G_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to G_BUFFER
00001174  4EB9 000012BC            125              JSR CLEAR_BUFFER                        ;Clear the buffer
0000117A                           126              
0000117A  23FC 00001050 000012B4   127              MOVE.L #B_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to B_BUFFER
00001184  4EB9 000012BC            128              JSR CLEAR_BUFFER                        ;Clear the buffer
0000118A                           129              
0000118A                           130  *Add address to both buffers
0000118A                           131              
0000118A  23CD 000012DC            132              MOVE.L A5, NUMBER_TO_CONVERT                ;The current address is stored to A5, we need to convert it to load it in the buffers.
00001190  13FC 0008 000012E0       133              MOVE.B #8, CHARNUM_TO_CONVERT               ;This specifies the number of characters that needs to be converted.
00001198  4EB9 000012EA            134              JSR CONVERT_HEX_TO_STRING                   ;Convert hex to string
0000119E                           135              
0000119E  23FC 000012E1 00001252   136              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER ;Prepare the string buffer with the converted hex string
000011A8  23FC 00001000 00001256   137              MOVE.L #G_BUFFER, BUFFER_POINTER                   ;Point G_BUFFER to the print buffer
000011B2  4EB9 00001260            138              JSR AddStrToBuffer                      ;Add the string to the print buffer
000011B8                           139      
000011B8  31DD 10A0                140              MOVE.W (A5)+, CUR_OP_CODE                   ;Read the current opcode
000011BC  4EF9 0000173E            141              JMP OP_JSR_Routine                      ;Run main OP code routine
000011C2                           142  
000011C2                           143  *********************************
000011C2                           144  *Checks if its valid print or invalid
000011C2                           145  * @pre checks invalid
000011C2                           146  * @post Branches to the respective branch
000011C2                           147  ************************************
000011C2                           148  check_print
000011C2  0C38 0001 10A2           149              CMP.B #1,IS_VALID                       ;Check if IS_VALID is set to 1
000011C8  6700 0006                150              BEQ   print_instruction                 ;If it's valid do print_instruction
000011CC  6600 000E                151              BNE   print_data                        ;If it's invalid do print_data
000011D0                           152              
000011D0                           153  print_instruction                               ;Prints the data in G_BUFFER
000011D0                           154  *Print the opcode if valid
000011D0  43F8 1000                155              LEA G_BUFFER,A1                     ;Points A1 to G_BUFFER
000011D4  4EB9 0000134A            156              JSR TrapTask13                          ;Use Nash's console output
000011DA  6084                     157              BRA MAIN_LOOP                           ;Go back to the main loop
000011DC                           158   
000011DC                           159  *Otherwise print data
000011DC                           160  print_data  
000011DC  23CD 000012DC            161              MOVE.L A5, NUMBER_TO_CONVERT                    ;The current address is stored to A5, we need to convert it to load it in the buffers.
000011E2  13FC 0008 000012E0       162              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
000011EA  4EB9 000012EA            163              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
000011F0  23FC 000012E1 00001252   164              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Point the string buffer to the converted hex
000011FA                           165              
000011FA  23FC 00001050 00001256   166              MOVE.L #B_BUFFER, BUFFER_POINTER                    ;Prepare the string buffer with the valid data
00001204  4EB9 00001260            167              JSR AddStrToBuffer                          ;Add the string to the print buffer
0000120A                           168  *Add bad data to bad buffer
0000120A  23FC 000027A4 00001252   169              MOVE.L #P_INVALID_OP, STRING_BUFFER_POINTER         ;Prepare the string buffer with the invalid data
00001214  4EB9 00001260            170              JSR AddStrToBuffer                          ;Add the string to the print buffer
0000121A                           171              
0000121A  33F8 10A0 000012DC       172              MOVE.W CUR_OP_CODE, NUMBER_TO_CONVERT               ;The current address is stored to A5, we need to convert it to load it in the buffers.
00001222  13FC 0008 000012E0       173              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
0000122A  4EB9 000012EA            174              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
00001230                           175              
00001230  23FC 000012E1 00001252   176              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Prepare the string buffer with the converted hex string
0000123A  4EB9 00001260            177              JSR AddStrToBuffer                          ;Add the converted hex to buffer
00001240                           178              
00001240  43F8 1050                179              LEA B_BUFFER,A1                         ;Point A1 to the bad buffer
00001244  4EB9 0000134A            180              JSR TrapTask13                              ;Use Nash's console output
0000124A  6000 FF14                181              BRA MAIN_LOOP                               ;Go back to the main loop
0000124E                           182  
0000124E                           183  
0000124E                           184  DONE                                            ;We're finished at this point reading all the files
0000124E  FFFF FFFF                185              SIMHALT                                 ;Halt the simulation
00001252                           186              
00001252                           187  **
00001252                           188  * AddStrToBuffer
00001252                           189  *****************************************************************************
00001252                           190  * Description: Adds the a defined string constant into a buffer to print out
00001252                           191  * Places a NULL terminating string to start with a default buffer length of 80.
00001252                           192  *
00001252                           193  * If the buffer length is exceeded, where length was improperly specified or no
00001252                           194  * NULL terminating string was found, return 1, else return 0 for success.
00001252                           195  *
00001252                           196  * Additional Constants/Subroutines used:
00001252                           197  * STRING_BUFFER_POINTER                 ;String pointer
00001252                           198  * BUFFER_POINTER                        ;Buffer pointer
00001252                           199  * BUFFER_POINTER_LENGTH                 ;Buffer length, 80 chars by default
00001252                           200  * BUFFER_ADD_SUCCESS                    ;0 = success, 1 = failure
00001252                           201  * FIND_NULL_IN_BUFFER                   ;Find NULL in buffer with a loop
00001252                           202  * STRING_BUFFER_ADD_LOOP                    ;Add a string to the buffer with a loop
00001252                           203  * STRING_ADD_SUCCESS                       ;Routine to run when string is added successfully
00001252                           204  * BUFFER_LENGTH_FAIL                    ;Routine to run when buffer length is exceeded
00001252                           205  * BUFFER_STRING_END                     ;Subroutine is finished
00001252                           206  *****************************************************************************
00001252                           207  * Constant definitions:
00001252                           208  STRING_BUFFER_POINTER   DS.L    1
00001256                           209  BUFFER_POINTER      DS.L    1
0000125A= 00000050                 210  BUFFER_POINTER_LENGTH   DC.L    80
0000125E                           211  BUFFER_ADD_SUCCESS      DS.B    1
0000125F                           212  
00001260                           213  AddStrToBuffer:           DS.W    0                   ;Reserve a word
00001260  48E7 C0C0                214      MOVEM.L     D0-D1/A0-A1, -(SP)              ;Save registers to stack
00001264                           215      
00001264  2078 1252                216      MOVE.L      STRING_BUFFER_POINTER,A0        ;Load string pointer to A0
00001268  2278 1256                217      MOVE.L      BUFFER_POINTER, A1          ;Load buffer pointer to A1
0000126C  2038 125A                218      MOVE.L      BUFFER_POINTER_LENGTH, D0       ;Load buffer length to D0
00001270  4278 125E                219      CLR.W       BUFFER_ADD_SUCCESS          ;Clear any prior success bit
00001274  4281                     220      CLR.L       D1                      ;Clear any prior loop counts
00001276                           221  
00001276                           222  STRING_BUFFER_LOOP
00001276  0C11 0000                223      CMPI.B      #0, (A1)                    ;Check if buffer char is NULL or not
0000127A  6700 000E                224      BEQ         STRING_BUFFER_ADD_LOOP          ;If a 0 is found, start adding string(s) to the buffer
0000127E                           225      
0000127E  B280                     226      CMP.L       D0, D1                  ;Check if the counter is more than the max length
00001280  6C00 0026                227      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
00001284                           228      
00001284  5289                     229      ADDQ.L      #1, A1                  ;Increment to the next character
00001286  5201                     230      ADDQ.B      #1, D1                  ;Increment loop counter
00001288  60EC                     231      BRA         STRING_BUFFER_LOOP          ;Loop back again
0000128A                           232      
0000128A                           233  STRING_BUFFER_ADD_LOOP
0000128A  0C10 0000                234      CMPI.B      #0, (A0)                       ;Check is the string char is NULL
0000128E  6700 0010                235      BEQ         STRING_ADD_SUCCESS          ;String has been added successfully
00001292                           236      
00001292  B200                     237      CMP.B       D0, D1                  ;Check if the counter is more than the max length
00001294  6C00 0012                238      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
00001298                           239      
00001298  12D8                     240      MOVE.B      (A0)+,(A1)+             ;Add string to the buffer
0000129A  5201                     241      ADDQ.B      #1, D1                  ;Increment loop counter
0000129C  524C                     242      ADDQ.W      #1, A4                  ;Increment G_BUFFER counter
0000129E  60EA                     243      BRA         STRING_BUFFER_ADD_LOOP          ;Loop back again
000012A0                           244  
000012A0                           245  STRING_ADD_SUCCESS
000012A0  12BC 0000                246      MOVE.B      #0,(A1)                 ;Place NULL terminating 0 at the end
000012A4  6000 0008                247      BRA         BUFFER_STRING_END               ;Finish subroutine
000012A8                           248  
000012A8                           249  BUFFER_LENGTH_EXCEEDED
000012A8  31FC 0001 125E           250      MOVE.W      #1, BUFFER_ADD_SUCCESS          ;BUFFER failed to add
000012AE                           251  
000012AE                           252  BUFFER_STRING_END
000012AE  4CDF 0303                253      MOVEM.L     (SP)+, D0-D1/A0-A1          ;Restore registers from stack
000012B2  4E75                     254      RTS                                     ;Return to stack
000012B4                           255  **************************************************************************
000012B4                           256  * CLEAR_BUFFER
000012B4                           257  *****************************************************************************
000012B4                           258  * Description: Clears the defined buffer area with NULL terminating 0s
000012B4                           259  * The default size is 80 bytes
000012B4                           260  *
000012B4                           261  * Additional Constants/Subroutines used:
000012B4                           262  * CLEAR_BUFFER_POINTER                  ;Buffer pointer
000012B4                           263  * CLEAR_BUFFER_LENGTH                   ;Length of buffer, default 80 bytes
000012B4                           264  * CLEAR_BUFFER_LOOP                     ;Buffer loop
000012B4                           265  * CLEAR_BUFFER_END                      ;Finish subroutine
000012B4                           266  *****************************************************************************
000012B4                           267  * Constant definitions:
000012B4                           268  CLEAR_BUFFER_POINTER    DS.L    1
000012B8= 00000050                 269  CLEAR_BUFFER_LENGTH     DC.L    80
000012BC                           270  
000012BC                           271  CLEAR_BUFFER:           DS.W    0                  ;Reserve a word
000012BC  48E7 C080                272      MOVEM.L     D0-D1/A0, -(SP)             ;Save registers to stack
000012C0  2078 12B4                273      MOVEA.L     CLEAR_BUFFER_POINTER, A0        ;Load buffer address to A0
000012C4  2038 12B8                274      MOVE.L      CLEAR_BUFFER_LENGTH, D0         ;Load buffer length to D0
000012C8  4281                     275      CLR.L       D1                      ;Clear any prior loop counter
000012CA                           276      
000012CA                           277  CLEAR_BUFFER_LOOP
000012CA  B280                     278      CMP.L       D0, D1                  ;Check if the counter is more than the max length
000012CC  6C00 0008                279      BGE         CLEAR_BUFFER_END                ;Finish subroutine
000012D0                           280      
000012D0  4218                     281      CLR.B       (A0)+                   ;Clear current character in clear buffer
000012D2  5241                     282      ADDQ        #1, D1                  ;Increment loop counter
000012D4  60F4                     283      BRA         CLEAR_BUFFER_LOOP               ;Loop back again
000012D6                           284      
000012D6                           285  CLEAR_BUFFER_END
000012D6  4CDF 0103                286      MOVEM.L     (SP)+, D0-D1/A0             ;Restore registers from stack
000012DA  4E75                     287      RTS                         ;Return to stack
000012DC                           288  
000012DC                           289  
000012DC                           290  **
000012DC                           291  * CONVERT_HEX_TO_STRING
000012DC                           292  *****************************************************************************
000012DC                           293  * Description: Converts a given number to a hexadecimal string by the specified 
000012DC                           294  * length. A null terminating string is added after (0). Conversion starts from the
000012DC                           295  * rightmost bit.
000012DC                           296  *
000012DC                           297  * Default length of conversion is 8, but can be changed.
000012DC                           298  
000012DC                           299  * Additional Constants/Subroutines used:
000012DC                           300  * NUMBER_TO_CONVERT                     ;Number to convert
000012DC                           301  * CHARNUM_TO_CONVERT                    ;Character numbers to convert, valid range is 0-8
000012DC                           302  * CONVERTED_HEX_STRING                  ;Converted hexadecimal character string
000012DC                           303  * CHECK_POSITIVE_LENGTH                 ;Routine to check for positive length
000012DC                           304  * CHECK_VALID_LENGTH                    ;Routine to check for valid length
000012DC                           305  * DIGIT_LOOP                            ;Looping through each digit
000012DC                           306  * CONVERT_TO_HEX_LETTER                 ;Routine to convert to hex letter
000012DC                           307  * ADD_CHAR_TO_STRING                    ;Adds a character to the string
000012DC                           308  *****************************************************************************
000012DC                           309  * Constant definitions:
000012DC                           310  NUMBER_TO_CONVERT       DS.L    1
000012E0= 08                       311  CHARNUM_TO_CONVERT      DC.B    8
000012E1                           312  CONVERTED_HEX_STRING    DS.B    9
000012EA                           313  
000012EA                           314  CONVERT_HEX_TO_STRING:  DS.W    0                 ;Reserve a word       
000012EA  48E7 F0C0                315      MOVEM.L     D0-D3/A0-A1, -(SP)          ;Save registers to stack
000012EE  4281                     316      CLR.L       D1                      ;Clear any prior number from D1
000012F0  4280                     317      CLR.L       D0                      ;Clear any prior number from D0
000012F2  2038 12DC                318      MOVE.L      NUMBER_TO_CONVERT, D0           ;Load number to D0
000012F6  1238 12E0                319      MOVE.B      CHARNUM_TO_CONVERT, D1          ;Load length to D1
000012FA  207C 000012E1            320      MOVEA.L     #CONVERTED_HEX_STRING, A0       ;Load string address to convert
00001300                           321      
00001300  0C01 0001                322      CMPI.B      #1, D1                  ;Check if D1 is one or not
00001304  6C00 0004                323      BGE         CHECK_POSITIVE_LENGTH           ;Check the length of the number
00001308  7201                     324      MOVEQ       #1, D1                  ;Move number 1 to D1 otherwise
0000130A                           325      
0000130A                           326  CHECK_POSITIVE_LENGTH                   ;Checks the positive length
0000130A  0C01 0008                327      CMPI.B      #8, D1                  ;Check if the length is 8 or not
0000130E  6F00 0004                328      BLE         CHECK_VALID_LENGTH          ;If it's less find and check the length
00001312  7208                     329      MOVEQ       #8, D1                  ;Move number 8 into the length
00001314                           330      
00001314                           331  CHECK_VALID_LENGTH                      ;Checks to see if the length is valid
00001314  2248                     332      MOVEA.L     A0, A1                  ;A0 contains start number, A1 contains current number
00001316  D2C1                     333      ADDA.W      D1, A1                  ;Go to the last digit
00001318  4211                     334      CLR.B       (A1)                    ;Make the last digit NULL or 0
0000131A  740F                     335      MOVEQ       #$0F,D2                 ;Bitmask last hex or nibble
0000131C                           336      
0000131C                           337  DIGIT_LOOP
0000131C  1600                     338      MOVE.B      D0, D3                  ;Get 2 hex chars from number
0000131E  C602                     339      AND.B       D2, D3                  ;Mask to get last hex char
00001320                           340      
00001320  0C03 0009                341      CMPI.B      #9, D3                  ;Check if the value is over 9
00001324  6E00 000A                342      BGT         CONVERT_TO_HEX_LETTER           ;If so, it must be a letter, convert the letter
00001328                           343      
00001328  0603 0030                344      ADDI.B      #'0', D3                       ;Get the ASCII value for 0-9
0000132C  6000 000A                345      BRA         ADD_CHAR_TO_STRING          ;Add char to the string
00001330                           346  
00001330                           347  CONVERT_TO_HEX_LETTER
00001330  0403 000A                348      SUBI.B      #10, D3                 ;Subtract 10 first to get correct ASCII
00001334  0603 0041                349      ADDI.B      #'A', D3                    ;Get the ASCII value for letters A-F
00001338                           350  
00001338                           351  ADD_CHAR_TO_STRING
00001338  1303                     352      MOVE.B      D3, -(A1)                   ;Add char to string and decrement pointer
0000133A  E888                     353      LSR.L       #4, D0                  ;Shift the 4 bits to the right
0000133C  B3C8                     354      CMPA.L      A0, A1                  ;Check if the current pointer is greater than starting string
0000133E  6EDC                     355      BGT         DIGIT_LOOP                     ;If so, loop back
00001340  42B8 12DC                356      CLR.L  NUMBER_TO_CONVERT                          ;Clear any prior number  
00001344                           357      
00001344  4CDF 030F                358      MOVEM.L     (SP)+, D0-D3/A0-A1             ;Restore registers from stack
00001348  4E75                     359      RTS                         ;Finish subroutine
0000134A                           360  
0000134A                           361  
0000134A                           362  ******************************************* START OF NASH CODE ******************   
0000134A                           363  *********************************************************************************
0000134A                           364  * Method Name: TrapTask13
0000134A                           365  * Description: Creates a file if none exists, and appends bytes to that file
0000134A                           366  *   while also echoing the written bytes to the screen.  You shouldn't need to
0000134A                           367  *   change this code.
0000134A                           368  *
0000134A                           369  * Calling Convention: Callee-Saved 
0000134A                           370  *
0000134A                           371  * Preconditions & Method Input:
0000134A                           372  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000134A                           373  *
0000134A                           374  * Postconditions & Output:
0000134A                           375  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000134A                           376  *   See 'Output.txt' in directory for the results, also piped to the console
0000134A                           377  *
0000134A                           378  *
0000134A                           379  *  A2 holds a pointer to null terminated string to write (input)
0000134A                           380  *  A3 points to the null-terminated file name
0000134A                           381  *  D3 holds the number of bytes already in the file to write
0000134A                           382  *
0000134A                           383  *  D5 holds number of bytes to write
0000134A                           384  ********************************************************************************
0000134A                           385  toSave REG D0-D5/A2-A3
0000134A                           386  TrapTask13:
0000134A                           387      *******************************************************************
0000134A                           388      * Method initialization, register spilling, parameter saving, etc.
0000134A                           389      *******************************************************************
0000134A  48E7 FC30                390      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
0000134E                           391        
0000134E  2449                     392      MOVEA.L A1, A2 ; save this buffer to write
00001350  47F9 000016DA            393      LEA outFilename, A3  ; save this for later, too
00001356                           394        
00001356  303C 0032                395      move #50,d0   
0000135A  4E4F                     396      trap #15 ; close all files, suggested to begin any IO 
0000135C                           397      *******************************************************************
0000135C                           398      * End Method Init
0000135C                           399      *******************************************************************
0000135C                           400  
0000135C                           401      ******************************************************************************************
0000135C                           402      * Calculate the number of bytes to write by searching for the null in the target buffer A0
0000135C                           403      ******************************************************************************************
0000135C  4285                     404      CLR.L D5 *D5 is now the number of bytes to write
0000135E                           405  nullLoop:
0000135E  1019                     406      MOVE.B (A1)+, D0
00001360  0C00 0000                407      CMPI.B #0,D0  * compare to null
00001364  6700 0006                408      BEQ findNullLoopDone
00001368  5245                     409      ADDI.W #1, D5
0000136A  60F2                     410      BRA nullLoop
0000136C                           411      
0000136C                           412  findNullLoopDone:
0000136C  224B                     413      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
0000136E                           414      
0000136E                           415      ;check if file exists, and open with task 51 if so, otherwise 52
0000136E                           416      ;(precondition here is A1 points to the null-terminated filename )
0000136E  103C 0033                417      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001372  4E4F                     418      trap #15
00001374                           419        
00001374                           420      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
0000137A  103C 0034                421          MOVE.B #52, D0             ; open new file (52 is new)
0000137E  4E4F                     422          trap #15
00001380                           423      endi
00001380                           424      
00001380                           425      ********************************************************************************************************* 
00001380                           426      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001380                           427      *    (first, count number of bytes already in the file to obtain seek position)
00001380                           428      *********************************************************************************************************
00001380  4283                     429      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001382  7401                     430      MOVE.L #1, D2 ; read one byte at a time
00001384  43F9 000016F1            431      LEA byteRead, A1
0000138A                           432      
0000138A                           433  countLoop:
0000138A  103C 0035                434      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
0000138E  4E4F                     435      trap #15
00001390                           436      
00001390  0C40 0001                437      CMPI.W #1,D0  ;1 == EOF
00001394  6700 0006                438      BEQ countDone
00001398  5243                     439      ADDI #1, D3
0000139A  60EE                     440      BRA countLoop
0000139C                           441      
0000139C                           442  countDone:    
0000139C                           443      * close this file
0000139C  303C 0038                444       move #56,d0  
000013A0  4E4F                     445       trap #15 
000013A2                           446       
000013A2                           447       * reopen the target file
000013A2  224B                     448       MOVE.L A3,A1
000013A4  303C 0033                449       MOVE #51, D0
000013A8  4E4F                     450       trap #15
000013AA                           451       
000013AA                           452      * seek to right position, then continue with writing
000013AA  2403                     453      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000013AC  303C 0037                454      MOVE #55, D0  ; position file task
000013B0  4E4F                     455      trap #15
000013B2                           456  
000013B2                           457      ******************************************************************************
000013B2                           458      * Actually write the buffer to the file, after calculating the number of bytes 
000013B2                           459      *  to write and after seeking to the right location in the file for append
000013B2                           460      ******************************************************************************
000013B2                           461  
000013B2  2405                     462      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000013B4                           463      ; assumes A0 hasnt changed since handed to this method      
000013B4  224A                     464      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000013B6                           465      ; assumes file ID is still stored in D1.L  
000013B6  103C 0036                466      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000013BA  4E4F                     467      trap #15
000013BC                           468  
000013BC                           469      ; add a newline to the file output
000013BC  43F9 000016D4            470      LEA NEWLINE, A1
000013C2  103C 0036                471      MOVE.B #54, D0 
000013C6  143C 0002                472      MOVE.B #2,D2  ; kills # of bytes to write from input param
000013CA  4E4F                     473      trap #15
000013CC                           474      
000013CC                           475      ; finally, close only this file
000013CC  103C 0038                476      MOVE.B #56, D0 ; close file task
000013D0  4E4F                     477      trap #15
000013D2                           478    
000013D2                           479      ; report to screen
000013D2  224A                     480      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000013D4  103C 000D                481      MOVE.B #13, D0
000013D8  4E4F                     482      trap #15
000013DA                           483        
000013DA                           484      ; restore context
000013DA  4CDF 0C3F                485      MOVEM.L (SP)+, toSave
000013DE                           486      
000013DE  4E75                     487      RTS
000013E0                           488      
000013E0                           489      
000013E0                           490  *----------------------------------------------------------------------------------
000013E0                           491  * Method Name: AsciiToHex
000013E0                           492  * Written by : Berger, Modified by Nash
000013E0                           493  * Date       : 3/1/2019
000013E0                           494  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000013E0                           495  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000013E0                           496  *              its (4b each) equivalent hex value 
000013E0                           497  *  
000013E0                           498  *  Preconditions & Input
000013E0                           499  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000013E0                           500  *       This function calls another function (strip_ascii)
000013E0                           501  *
000013E0                           502  *  Postconditions & Output
000013E0                           503  *       D7 (output) holds the converted value 
000013E0                           504  *       Caller-Saved : D0 is temp, D6 is a loop var
000013E0                           505  *----------------------------------------------------------------------------------
000013E0                           506  AsciiToHexRegList REG D0,D6
000013E0                           507  AsciiToHex     
000013E0  48E7 8000                508      MOVEM.L asciiToHexRegList, -(SP)  *save context
000013E4  4287                     509      CLR.L D7 * clear our return value
000013E6  7C08                     510      MOVE.L #8, D6 ; and set up our loop counter
000013E8                           511  
000013E8                           512  chrLoop
000013E8  1019                     513      MOVE.B (A1)+,D0 * Get the first byte
000013EA  4EB9 00001402            514      jsr strip_ascii * Get rid of the ascii code    
000013F0  8E40                     515      OR.W D0,D7 * Load the bits into D7
000013F2                           516      
000013F2  5306                     517      subI.B #1,D6  *decrement our loop variable
000013F4  6700 0006                518      BEQ chrDone   *skip shifting if we are done
000013F8                           519      
000013F8  E987                     520      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
000013FA  60EC                     521      BRA chrLoop
000013FC                           522  
000013FC                           523  chrDone
000013FC  4CDF 0001                524      MOVEM.L (SP)+,asciiToHexRegList 
00001400  4E75                     525      RTS
00001402                           526  
00001402                           527  
00001402                           528  **********************************************************************
00001402                           529  * SUBROUTINE: strip_ascii
00001402                           530  * remove the ascii code from the digits 0-9,a-f, or A-F
00001402                           531  * Input Parameters: <D0> = ascii code
00001402                           532  *
00001402                           533  * Return parameters: D0.B = number 0...F, returned as 00...0F
00001402                           534  * Registers used internally: D0
00001402                           535  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00001402                           536  *
00001402                           537  ***********************************************************************
00001402                           538  strip_ascii
00001402  B03C 0039                539        CMP.B #$39,D0 * Is it in range of 0-9?
00001406  6F00 001A                540        BLE sub30 * Its a number
0000140A  B03C 0046                541        CMP.B #$46,D0 * Is is A...F?
0000140E  6F00 000A                542        BLE sub37 * Its A...F
00001412  0400 0057                543        SUB.B #$57,D0 * Its a...f
00001416  6000 000E                544        BRA ret_sa * Go back
0000141A  0400 0037                545  sub37 SUB.B #$37,D0 * Strip 37
0000141E  6000 0006                546        BRA ret_sa * Go back
00001422  0400 0030                547  sub30 SUB.B #$30,D0 * Strip 30
00001426  4E75                     548  ret_sa RTS * Go back
00001428                           549  ******************************************* END OF NASH CODE ********************
00001428                           550  MAIN_CONSOLE                                                            ;Main print message
00001428                           551     
00001428= 3D 3D 3D 3D 3D 3D ...    552        DC.B '============================================================',CR,LF
00001466= 7C 7C 20 20 20 20 ...    553        DC.B '||                                                        ||',CR,LF
000014A4= 7C 7C 20 20 20 23 ...    554        DC.B '||   #####      ###    ##   ##                            ||',CR,LF
000014E2= 7C 7C 20 20 23 23 ...    555        DC.B '||  ##        ##   ##  ## ##                              ||',CR,LF
00001520= 7C 7C 20 23 23 20 ...    556        DC.B '|| ## ####     #####   ####                               ||',CR,LF
0000155E= 7C 7C 20 23 23 20 ...    557        DC.B '|| ##    ##  ##    ##  ####                               ||',CR,LF
0000159C= 7C 7C 20 23 23 20 ...    558        DC.B '|| ##    ##  ##    ##  ## ##                              ||',CR,LF
000015DA= 7C 7C 20 20 23 23 ...    559        DC.B '||  #####     ######   ##  ##                             ||',CR,LF
00001618= 7C 7C 20 20 20 20 ...    560        DC.B '||                                                        ||',CR,LF
00001656= 7C 7C 20 20 20 44 ...    561        DC.B '||   Daniel Yan, Fahad Alshehri, Denny Park               ||',CR,LF
00001694= 3D 3D 3D 3D 3D 3D ...    562        DC.B '============================================================',CR,LF,0
000016D3                           563      
000016D3                           564  * Required variables and constants go here for your Disassembler
000016D3  =0000000D                565  CR              EQU $0D                     ;Carriage return
000016D3  =0000000A                566  LF              EQU $0A                        ;Line feed
000016D4= 000D 000A 0000           567  NEWLINE         DC.W CR,LF,0                    ;Make a new line
000016DA= 44 69 73 61 73 73 ...    568  outFilename     DC.B 'DisassemblerOutput.txt',0             ;Output file
000016F1                           569  byteRead        DS.B 1                              ;Read a byte
000016F2= 31 41 30 30 31 41 ...    570  ascii_val       DC.B $31,$41,$30,$30,$31,$41,$30,$30            ;Test value $1A001A00
000016FA                           571  
000016FA                           572  * Variables and constants
000016FA  =00000014                573  SIZE            EQU     20                          ;Max string size
000016FA= 43 6F 6E 66 69 67 ...    574  fileName        DC.B    'Config.cfg',0                  ;Name of text file
00001705                           575  IO_BUFFER       DS.B    SIZE                                    ;Variable for IO buffer
0000171A                           576  fileID          DS.L    1                                   ;Variable for File ID
0000171E= 496E 7661 6C69 6...      577  INVALID_ADDRES_MESSAGE DC.W 'Invalid Hex Address' ,CR,LF,0          ;Invalid message print
00001738                           578  
00001738                           579      INCLUDE "OP_Code_Routines.x68"                      ;OP role code to include
00001738                           580  
00001738                           581  OP_SIZE         DS.B    1   ;This constant refers to the size of the current OP code 
00001739                           582  MNEMONIC        DS.B    1   ;Constant for EA, first 4 bits (15-12) of a 4 hex OP code
0000173A                           583  FIRST_3         DS.B    1   ;Constant for EA, 3 bits (11-9) of a 4 hex OP code
0000173B                           584  SECOND_3        DS.B    1   ;Constant for EA, 3 bits (8-6) of a 4 hex OP code
0000173C                           585  THIRD_3         DS.B    1   ;Constant for EA, 3 bits (5-3) of a 4 hex OP code
0000173D                           586  FOURTH_3        DS.B    1   ;Constant for EA, 3 bits (2-0) of a 4 hex OP code
0000173E                           587  
0000173E                           588  
0000173E                           589  
0000173E                           590  
0000173E                           591  OP_JSR_Routine:
0000173E  48E7 C000                592      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
00001742  3038 10A0                593      MOVE.W CUR_OP_CODE,D0          ;Move current instruction set to D0
00001746  11FC 0001 10A2           594      MOVE.B #1,IS_VALID             ;Set IS_VALID bit to 1 by default
0000174C  720C                     595      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
0000174E  E2A8                     596      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
00001750                           597  
00001750                           598  GROUP_0:                           ;$0| ORI, BCLR (static and dynamic), CMPI                  
00001750  B03C 0000                599      CMP.B   #$0,D0                 ;Compare first nibble
00001754  6600 000C                600      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
00001758  4EB9 0000197A            601      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
0000175E  6000 010C                602      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001762                           603      
00001762                           604  GROUP_1:                           ;$1| MOVE.B
00001762  B03C 0001                605      CMP.B   #$1,D0                 ;Compare first nibble
00001766  6600 000C                606      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
0000176A  4EB9 00001B58            607      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
00001770  6000 00FA                608      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001774                           609  
00001774                           610  GROUP_2:                           ;$2| MOVE.L, MOVEA.L
00001774  B03C 0002                611      CMP.B   #$2,D0                 ;Compare first nibble
00001778  6600 000C                612      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
0000177C  4EB9 00001B82            613      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
00001782  6000 00E8                614      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001786                           615  
00001786                           616  GROUP_3:                           ;$3| MOVE.W, MOVEA.W
00001786  B03C 0003                617      CMP.B   #$3,D0                 ;Compare first nibble
0000178A  6600 000C                618      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
0000178E  4EB9 00001BE4            619      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
00001794  6000 00D6                620      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001798                           621  
00001798                           622  GROUP_4:                           ;$4| LEA, JSR, RTS, NEG, MOVEM
00001798  B03C 0004                623      CMP.B   #$4,D0                 ;Compare first nibble
0000179C  6600 000C                624      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
000017A0  4EB9 00001C46            625      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
000017A6  6000 00C4                626      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017AA                           627  
000017AA                           628  
000017AA                           629  GROUP_5:                           ;$5| SUBQ
000017AA  B03C 0005                630      CMP.B   #$5,D0                 ;Compare first nibble
000017AE  6600 000C                631      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
000017B2  4EB9 00001EFE            632      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
000017B8  6000 00B2                633      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017BC                           634  
000017BC                           635  
000017BC                           636  GROUP_6:                           ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
000017BC  B03C 0006                637      CMP.B   #$6,D0                 ;Compare first nibble
000017C0  6600 000C                638      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
000017C4  4EB9 00001F68            639      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
000017CA  6000 00A0                640      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017CE                           641  
000017CE                           642  
000017CE                           643  GROUP_7:                           ;$7| Display: DATA, $WXYZ (Unsupported)
000017CE  B03C 0007                644      CMP.B   #$7,D0                 ;Compare first nibble
000017D2  6600 000C                645      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
000017D6  4EB9 000020AE            646      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
000017DC  6000 008E                647      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017E0                           648  
000017E0                           649  
000017E0                           650  GROUP_8:                           ;$8| DIVS, OR
000017E0  B03C 0008                651      CMP.B   #$8,D0                 ;Compare first nibble
000017E4  6600 000C                652      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
000017E8  4EB9 000020CE            653      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
000017EE  6000 007C                654      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017F2                           655  
000017F2                           656  
000017F2                           657  GROUP_9:                           ;$9| SUB
000017F2  B03C 0009                658      CMP.B   #$9,D0                 ;Compare first nibble
000017F6  6600 000C                659      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
000017FA  4EB9 0000212E            660      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
00001800  6000 006A                661      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001804                           662  
00001804                           663  
00001804                           664  GROUP_A:                           ;$A| Display: DATA, $WXYZ (Unsupported)
00001804  B03C 000A                665      CMP.B   #$A,D0                 ;Compare first nibble
00001808  6600 000C                666      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
0000180C  4EB9 000021A0            667      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
00001812  6000 0058                668      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001816                           669  
00001816                           670  
00001816                           671  GROUP_B:                           ;$B| EOR, CMP
00001816  B03C 000B                672      CMP.B   #$B,D0                 ;Compare first nibble
0000181A  6600 000C                673      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
0000181E  4EB9 000021A8            674      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
00001824  6000 0046                675      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001828                           676  
00001828                           677  
00001828                           678  GROUP_C:                           ;$C| MULS
00001828  B03C 000C                679      CMP.B   #$C,D0                 ;Compare first nibble
0000182C  6600 000C                680      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
00001830  4EB9 0000221C            681      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
00001836  6000 0034                682      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000183A                           683  
0000183A                           684  
0000183A                           685  GROUP_D:                           ;$D| ADD, ADDA
0000183A  B03C 000D                686      CMP.B   #$D,D0                 ;Compare first nibble
0000183E  6600 000C                687      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
00001842  4EB9 000022A0            688      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
00001848  6000 0022                689      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000184C                           690  
0000184C                           691  
0000184C                           692  GROUP_E:                           ;$E| LSR, LSL, ASR, ASL, ROL, ROR
0000184C  B03C 000E                693      CMP.B   #$E,D0                 ;Compare first nibble
00001850  6600 000C                694      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
00001854  4EB9 00002300            695      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
0000185A  6000 0010                696      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000185E                           697  
0000185E                           698  
0000185E                           699  GROUP_F:                           ;$F| Display: DATA, $WXYZ (Unsupported)
0000185E  B03C 000F                700      CMP.B   #$F,D0                 ;Compare first nibble
00001862  4EB9 000024B0            701      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
00001868  6000 0002                702      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000186C                           703  
0000186C                           704  
0000186C                           705  OP_JSR_DONE:                       ;This subroutine is only called when identification has been finished
0000186C  4CDF 0003                706           MOVEM.L (SP)+,D0-D1       ;Recover register D0
00001870  0C38 0001 10A2           707           CMP.B #1,IS_VALID         ;Checks if the IS_VALID bit is valid or not
00001876  6700 1076                708           BEQ    main_EA            ;This runs EA's routines after OP code portion is finished
0000187A  6600 F946                709           BNE    check_print        ;If not valid, skip EA routine and call IO
0000187E                           710  FIND_2_BIT_SIZE_7_TO_6:         ;Move the 2 bit size field relevant register
0000187E  48E7 C000                711      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
00001882  3038 10A0                712      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
00001886  323C 0008                713      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
0000188A  E368                     714      LSL.W    D1,D0              ;Truncate to find the 2 size bits
0000188C  E268                     715      LSR.W    D1,D0              ;Reposition the bits
0000188E  323C 0006                716      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
00001892  E268                     717      LSR.W    D1,D0              ;Truncate to shift 2 bits to a byte
00001894  11C0 1738                718      MOVE.B   D0,OP_SIZE         ;Move 2 size bits into OP_SIZE
00001898  4CDF 0003                719      MOVEM.L (SP)+,D0-D1         ;Restore registers
0000189C  4E75                     720      RTS                         ;Return to stack
0000189E                           721  
0000189E                           722  FIND_1_BIT_SIZE_6:              ;Move the 1 bit size field relevant register
0000189E  48E7 C000                723      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018A2  3038 10A0                724      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018A6  323C 0009                725      MOVE.W   #9,D1              ;Prepare 9 bit shift to D1
000018AA  E368                     726      LSL.W    D1,D0              ;Truncate to find the size bit
000018AC  E268                     727      LSR.W    D1,D0              ;Reposition the bits
000018AE  323C 0006                728      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000018B2  E268                     729      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000018B4  11C0 1738                730      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
000018B8  4CDF 0003                731      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018BC  4E75                     732      RTS                         ;Return to stack
000018BE                           733  
000018BE                           734  FIND_1_BIT_SIZE_8:         ;Move the 1 bit size field relevant register
000018BE  48E7 C000                735      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018C2  3038 10A0                736      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018C6  323C 0007                737      MOVE.W   #7,D1              ;Prepare 7 bit shift to D1
000018CA  E368                     738      LSL.W    D1,D0              ;Truncate to find the 1 size bit
000018CC  E268                     739      LSR.W    D1,D0              ;Reposition the bits
000018CE  323C 0008                740      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
000018D2  E268                     741      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000018D4  11C0 1738                742      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
000018D8  4CDF 0003                743      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018DC  4E75                     744      RTS                         ;Return to stack
000018DE                           745  
000018DE                           746  MOVE_AND_MOVEA_PARSE_EA:     ;Move the 3 bit dynamic register bits to proper register
000018DE  3038 10A0                747      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0
000018E2  323C 000A                748      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
000018E6  E368                     749      LSL.W   D1,D0            ;Truncate to find the last 6 bits
000018E8  E268                     750      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
000018EA  3E00                     751      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
000018EC  323C 0003                752      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
000018F0  E26F                     753      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
000018F2  3A07                     754      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
000018F4  323C 000D                755      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
000018F8  E368                     756      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
000018FA  E268                     757      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
000018FC  3800                     758      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
000018FE                           759      
000018FE  3038 10A0                760      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0     
00001902  323C 0004                761      MOVE.W  #4,D1            ;Prepare 4 bit shift to D1
00001906  E368                     762      LSL.W   D1,D0            ;Truncate to find bits 11-6
00001908  E268                     763      LSR.W   D1,D0            ;Reposition bits
0000190A  323C 0006                764      MOVE.W  #6,D1            ;Prepare 6 bit shift to D1
0000190E  E268                     765      LSR.W   D1,D0            ;Truncate the SRC Reg/Mode bits
00001910  323C 0003                766      MOVE.W  #3,D1            ;Prepare a 3 bit shift to D1 for DST Reg/Mode
00001914  3C00                     767      MOVE.W  D0,D6            ;Copy over the current 6 bits to D6
00001916  E268                     768      LSR.W   D1,D0            ;Truncate DST Mode  
00001918  3E00                     769      MOVE.W  D0,D7            ;Move DST Reg to D7
0000191A  323C 000D                770      MOVE.W  #13,D1             
0000191E  E36E                     771      LSL.W   D1,D6            ;Truncate 13 bits in D6
00001920  E26E                     772      LSR.W   D1,D6            ;Reposition D6
00001922                           773                               ;D6 now contains the DST Reg
00001922  4E75                     774      RTS                      ;Return to stack
00001924                           775  PARSE_EA_CONSTANT_BITS:
00001924  48E7 C000                776      MOVEM.L D0-D1,-(SP)         ;Save register to stack
00001928                           777      *MNEMONIC SHIFT
00001928  3038 10A0                778      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
0000192C  323C 000C                779      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
00001930  E268                     780      LSR.W D1,D0                 ;Shift 12 bits from D0 right
00001932  11C0 1739                781      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
00001936                           782      *FIRST_3 SHIFT
00001936  323C 0009                783      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
0000193A  3038 10A0                784      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000193E  E948                     785      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
00001940  E848                     786      LSR.W #4,D0                 ;Reposition D0
00001942  E268                     787      LSR.W  D1,D0                ;Shift D0 9 bits right
00001944  11C0 173A                788      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
00001948                           789      *SECOND_3 SHIFT
00001948  3038 10A0                790      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000194C  EF48                     791      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
0000194E  EE48                     792      LSR.W #7,D0                 ;Reposition D0
00001950  EC48                     793      LSR.W #6,D0                 ;Shift D0 6 bits right
00001952  11C0 173B                794      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
00001956                           795      *THIRD_3 SHIFT
00001956  3038 10A0                796      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000195A  E648                     797      LSR.W #3,D0                 ;Shift D0 3 bits right
0000195C  323C 000D                798      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
00001960  E368                     799      LSL.W D1,D0                 ;Truncate first 13 bits of D0
00001962  E268                     800      LSR.W D1,D0                 ;Reposition D0
00001964  11C0 173C                801      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
00001968                           802      *FOURTH_3 SHIFT
00001968  3038 10A0                803      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000196C  E368                     804      LSL.W D1,D0                 ;Grab the fourth 3-bit group
0000196E  E268                     805      LSR.W D1,D0                 ;Shift D0 back into position
00001970  11C0 173D                806      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
00001974  4CDF 0003                807      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001978  4E75                     808      RTS                         ;Return to stack
0000197A                           809  
0000197A                           810  
0000197A                           811  
0000197A                           812  
0000197A                           813  
0000197A                           814  C_GROUP_0:
0000197A  48E7 C000                815      MOVEM.L D0-D1, -(SP)            ;Backup registers
0000197E                           816      
0000197E                           817  CHECK_OP_ORI_TO_CCR:
0000197E  3038 10A0                818      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001982  B07C 003C                819      CMP.W #$003C,D0                 ;Compare the direct full bits
00001986  6700 01C4                820      BEQ GROUP0_INVALID              ;INVALID OP code found
0000198A  6600 0002                821      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
0000198E                           822      
0000198E                           823  CHECK_OP_ORI_TO_SR:
0000198E  3038 10A0                824      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001992  B07C 007C                825      CMP.W #$007C,D0                 ;Compare the direct full bits
00001996  6700 01B4                826      BEQ GROUP0_INVALID              ;INVALID OP code found
0000199A  6600 0002                827      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
0000199E                           828      
0000199E                           829  CHECK_OP_ANDI_TO_CCR:
0000199E  3038 10A0                830      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019A2  B07C 023C                831      CMP.W #$023C,D0                 ;Compare the direct full bits
000019A6  6700 01A4                832      BEQ GROUP0_INVALID              ;INVALID OP code found
000019AA  6600 0002                833      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
000019AE                           834      
000019AE                           835  CHECK_OP_ANDI_TO_SR:
000019AE  3038 10A0                836      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019B2  B07C 027C                837      CMP.W #$027C,D0                 ;Compare the direct full bits
000019B6  6700 0194                838      BEQ GROUP0_INVALID              ;INVALID OP code found
000019BA  6600 0002                839      BNE CHECK_OP_EORI_TO_CCR                ;Check next routine
000019BE                           840  
000019BE                           841  CHECK_OP_EORI_TO_CCR:
000019BE  3038 10A0                842      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019C2  B07C 0A3C                843      CMP.W #$0A3C,D0                 ;Compare the direct full bits
000019C6  6700 0184                844      BEQ GROUP0_INVALID              ;INVALID OP code found
000019CA  6600 0002                845      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
000019CE                           846      
000019CE                           847  CHECK_OP_EORI_TO_SR:
000019CE  3038 10A0                848      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019D2  B07C 0A7C                849      CMP.W #$0A7C,D0                 ;Compare the direct full bits
000019D6  6700 0174                850      BEQ GROUP0_INVALID              ;INVALID OP code found
000019DA  6600 0002                851      BNE CHECK_OP_ANDI               ;Check next routine
000019DE                           852      
000019DE                           853  CHECK_OP_ANDI:
000019DE  3038 10A0                854      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019E2  0240 FF00                855      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000019E6  B07C 0200                856      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
000019EA  6700 0160                857      BEQ GROUP0_INVALID              ;INVALID OP code found
000019EE  6600 0002                858      BNE CHECK_OP_SUBI               Check next routine
000019F2                           859      
000019F2                           860  CHECK_OP_SUBI:
000019F2  3038 10A0                861      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019F6  0240 FF00                862      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000019FA  B07C 0400                863      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
000019FE  6700 014C                864      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A02  6600 0002                865      BNE CHECK_OP_ADDI               ;Check next routine
00001A06                           866  
00001A06                           867  CHECK_OP_ADDI:
00001A06  3038 10A0                868      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A0A  0240 FF00                869      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A0E  B07C 0600                870      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00001A12  6700 0138                871      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A16  6600 0002                872      BNE CHECK_OP_EORI               ;Check next routine 
00001A1A                           873  
00001A1A                           874  CHECK_OP_EORI:
00001A1A  3038 10A0                875      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A1E  0240 FF00                876      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A22  B07C 0A00                877      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
00001A26  6700 0124                878      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A2A  6600 0002                879      BNE CHECK_OP_STATIC_BTST        ;Check next routine
00001A2E                           880      
00001A2E                           881  CHECK_OP_STATIC_BTST:
00001A2E  3038 10A0                882      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A32  0240 FFC0                883      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A36  B07C 0800                884      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
00001A3A  6700 0110                885      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A3E  6600 0002                886      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
00001A42                           887      
00001A42                           888  CHECK_OP_STATIC_BCHG:
00001A42  3038 10A0                889      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A46  0240 FFC0                890      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A4A  B07C 0840                891      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
00001A4E  6700 00FC                892      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A52  6600 0002                893      BNE CHECK_OP_STATIC_BSET        ;Check next routine
00001A56                           894  
00001A56                           895  CHECK_OP_STATIC_BSET:
00001A56  3038 10A0                896      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A5A  0240 FFC0                897      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A5E  B07C 08C0                898      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
00001A62  6700 00E8                899      BEQ GROUP0_INVALID              ;INVALID OP code found   
00001A66  6600 0002                900      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
00001A6A                           901  
00001A6A                           902  CHECK_OP_DYNAMIC_BTST:
00001A6A  3038 10A0                903      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A6E  0240 F1C0                904      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001A72  B07C 0100                905      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
00001A76  6700 00D4                906      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A7A  6600 0002                907      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
00001A7E                           908  
00001A7E                           909  CHECK_OP_DYNAMIC_BCHG:
00001A7E  3038 10A0                910      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A82  0240 F1C0                911      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001A86  B07C 0140                912      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00001A8A  6700 00C0                913      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A8E  6600 0002                914      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001A92                           915      
00001A92                           916  CHECK_OP_DYNAMIC_BSET:
00001A92                           917  
00001A92  3038 10A0                918      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001A96  0240 F1C0                919      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001A9A  B07C 01C0                920      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
00001A9E  6700 0006                921      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001AA2  6600 001C                922      BNE     CHECK_OP_MOVEP          ;Check next routine
00001AA6                           923  
00001AA6                           924  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00001AA6  3038 10A0                925      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AAA  323C 000A                926      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
00001AAE  E368                     927      LSL.W   D1,D0                   ;Shift out 10 bits left 
00001AB0  E268                     928      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001AB2  E648                     929      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00001AB4  B07C 0001                930      CMP.W   #$1,D0                  ;Compare bits to D0
00001AB8  6700 0006                931      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
00001ABC  6600 008E                932      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid
00001AC0                           933      
00001AC0                           934  CHECK_OP_MOVEP:
00001AC0  3038 10A0                935      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001AC4  0240 F138                936      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00001AC8  B07C 0108                937      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
00001ACC  6700 09EA                938      BEQ INVALID_OP                  ;INVALID OP code found
00001AD0  6600 0002                939      BNE CHECK_OP_ORI                ;Check next routine
00001AD4                           940  
00001AD4                           941  CHECK_OP_ORI:
00001AD4  3038 10A0                942      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AD8  0240 FF00                943      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001ADC  B07C 0000                944      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00001AE0  6600 0010                945      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00001AE4  4EB8 187E                946      JSR     FIND_2_BIT_SIZE_7_TO_6
00001AE8  4EB9 000024CE            947      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
00001AEE  6000 0062                948      BRA     GROUP0_SUCCESS          ;Finish routine
00001AF2                           949      
00001AF2                           950  CHECK_OP_CMPI:
00001AF2  3038 10A0                951      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AF6  0240 FF00                952      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001AFA  B07C 0C00                953      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
00001AFE  6600 0010                954      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
00001B02  4EB8 187E                955      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B06  4EB9 000024E2            956      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00001B0C  6000 0044                957      BRA     GROUP0_SUCCESS          ;Finish routine
00001B10                           958      
00001B10                           959  CHECK_OP_STATIC_BCLR:
00001B10  3038 10A0                960      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B14  0240 FF00                961      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001B18  B07C 0800                962      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00001B1C  6600 0010                963      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00001B20  4EB8 187E                964      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B24  4EB9 000024F6            965      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
00001B2A  6000 0026                966      BRA     GROUP0_SUCCESS          ;Finish routine
00001B2E                           967      
00001B2E                           968  CHECK_OP_DYNAMIC_BCLR:
00001B2E  3038 10A0                969      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B32  0240 0180                970      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
00001B36  B07C 0180                971      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
00001B3A  6600 0010                972      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
00001B3E  4EB8 187E                973      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B42  4EB9 0000250A            974      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
00001B48  6000 0008                975      BRA     GROUP0_SUCCESS          ;Finish routine
00001B4C                           976  
00001B4C                           977  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
00001B4C  4EB9 000024B8            978      JSR INVALID_OP                  ;INVALID OP code found
00001B52                           979  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
00001B52  4CDF 0003                980      MOVEM.L (SP)+,D0-D1             ;Restore registers
00001B56  4E75                     981      RTS                             ;Return to stack
00001B58                           982      
00001B58                           983  C_GROUP_1:
00001B58  48E7 C000                984      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
00001B5C                           985  
00001B5C                           986  CHECK_OP_MOVE_B:
00001B5C  3038 10A0                987      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
00001B60  0240 F000                988      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
00001B64  B07C 1000                989      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
00001B68  6600 000C                990      BNE     GROUP1_INVALID          ;Invalid OP code has been found
00001B6C  4EB9 0000251E            991      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
00001B72  6000 0008                992      BRA     GROUP1_SUCCESS          ;Finish routine
00001B76                           993      
00001B76                           994  GROUP1_INVALID:
00001B76  4EB9 000024B8            995      JSR INVALID_OP                  ;Invalid OP code found
00001B7C                           996  GROUP1_SUCCESS:
00001B7C  4CDF 0003                997      MOVEM.L (SP)+,D0-D1             ;Restore register
00001B80  4E75                     998      RTS                             ;Return to stack
00001B82                           999  C_GROUP_2:
00001B82  48E7 E000               1000      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001B86                          1001  
00001B86                          1002  CHECK_OP_MOVEA_L:
00001B86  3038 10A0               1003      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
00001B8A  0240 F000               1004      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001B8E  B07C 2000               1005      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001B92  4EF9 00001B98           1006      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00001B98                          1007      
00001B98                          1008  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00001B98  3038 10A0               1009      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
00001B9C  323C 0007               1010      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00001BA0  E368                    1011      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001BA2  E268                    1012      LSR.W    D1,D0                  ;Reposition the bits
00001BA4  323C 0006               1013      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00001BA8  E268                    1014      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00001BAA  3400                    1015      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
00001BAC  B47C 0001               1016      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00001BB0  6600 000C               1017      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00001BB4  4EB9 0000252C           1018      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00001BBA  6000 0022               1019      BRA     GROUP2_SUCCESS          ;Finish routine
00001BBE                          1020      
00001BBE                          1021      
00001BBE                          1022  CHECK_OP_MOVE_L:
00001BBE  3038 10A0               1023      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001BC2  0240 F000               1024      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001BC6  B07C 2000               1025      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001BCA  6600 000C               1026      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
00001BCE  4EB9 0000253A           1027      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00001BD4  6000 0008               1028      BRA GROUP2_SUCCESS              ;Finish routine
00001BD8                          1029      
00001BD8                          1030  GROUP2_INVALID:    
00001BD8  4EB9 000024B8           1031      JSR INVALID_OP                  ;Invalid OP code found
00001BDE                          1032  GROUP2_SUCCESS:
00001BDE  4CDF 0007               1033      MOVEM.L (SP)+,D0-D2             ;Restore register
00001BE2  4E75                    1034      RTS                             ;Return to stack
00001BE4                          1035  C_GROUP_3:
00001BE4  48E7 E000               1036      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001BE8                          1037      
00001BE8                          1038  CHECK_OP_MOVEA_W:
00001BE8  3038 10A0               1039      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001BEC  0240 F000               1040      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001BF0  B07C 3000               1041      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001BF4  4EF9 00001BFA           1042      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
00001BFA                          1043  
00001BFA                          1044      
00001BFA                          1045  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
00001BFA  3038 10A0               1046      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001BFE  323C 0007               1047      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00001C02  E368                    1048      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00001C04  E268                    1049      LSR.W    D1,D0                 ;Reposition the bits
00001C06  323C 0006               1050      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
00001C0A  E268                    1051      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
00001C0C  3400                    1052      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
00001C0E  B47C 0001               1053      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00001C12  6600 000C               1054      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00001C16  4EB9 00002548           1055      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
00001C1C  6000 0022               1056      BRA      GROUP3_SUCCESS        ;Finish routine
00001C20                          1057      
00001C20                          1058  CHECK_OP_MOVE_W:
00001C20  3038 10A0               1059      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001C24  0240 F000               1060      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001C28  B07C 3000               1061      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001C2C  6600 000C               1062      BNE      GROUP3_INVALID        ;INVALID OP code found
00001C30  4EB9 00002556           1063      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
00001C36  6000 0008               1064      BRA      GROUP3_SUCCESS        ;Finish routine
00001C3A                          1065      
00001C3A                          1066  GROUP3_INVALID:
00001C3A  4EB9 000024B8           1067      JSR INVALID_OP                 ;INVALID OP code found
00001C40                          1068  GROUP3_SUCCESS:
00001C40  4CDF 0007               1069      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
00001C44  4E75                    1070      RTS                            ;Return to stack
00001C46                          1071  
00001C46                          1072  C_GROUP_4:
00001C46  2F00                    1073      MOVE.L  D0,-(SP)            ;Save registers
00001C48                          1074      
00001C48                          1075  CHECK_OP_STOP:
00001C48  3038 10A0               1076      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C4C  B07C 4E72               1077      CMP.W  #$4E72,D0                ;Compare the appropriate bits
00001C50  6700 02A0               1078      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C54  6600 0002               1079      BNE    CHECK_OP_RESET           ;Check next OP code
00001C58                          1080      
00001C58                          1081  CHECK_OP_RESET:
00001C58  3038 10A0               1082      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C5C  B07C 4E70               1083      CMP.W  #$4E70,D0                ;Compare the appropriate bits
00001C60  6700 0290               1084      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C64  6600 0002               1085      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
00001C68                          1086          
00001C68                          1087  CHECK_OP_ILLEGAL:
00001C68  3038 10A0               1088      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C6C  B07C 4AFC               1089      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
00001C70  6700 0280               1090      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C74  6600 0002               1091      BNE    CHECK_OP_RTE             ;Check next OP code
00001C78                          1092      
00001C78                          1093  CHECK_OP_RTE:    
00001C78  3038 10A0               1094      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C7C  B07C 4E73               1095      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00001C80  6700 0270               1096      BEQ   GROUP4_INVALID            ;INVALID OP code found
00001C84  6600 0002               1097      BNE   CHECK_OP_TRAPV            ;Check next OP code
00001C88                          1098      
00001C88                          1099  CHECK_OP_TRAPV:
00001C88  3038 10A0               1100      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C8C  B07C 4E76               1101      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00001C90  6700 0260               1102      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C94  6600 0002               1103      BNE    CHECK_OP_RTR             ;Check next OP code
00001C98                          1104      
00001C98                          1105  CHECK_OP_RTR:
00001C98  3038 10A0               1106      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C9C  B07C 4E77               1107      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00001CA0  6700 0250               1108      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CA4  6600 0002               1109      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00001CA8                          1110  
00001CA8                          1111  
00001CA8                          1112  CHECK_OP_MOVE_FROM_SR:
00001CA8  3038 10A0               1113      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CAC  0240 FFC0               1114      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CB0  B07C 40C0               1115      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00001CB4  6700 023C               1116      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00001CB8  6600 0002               1117      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
00001CBC                          1118      
00001CBC                          1119  CHECK_OP_MOVE_TO_CCR:
00001CBC  3038 10A0               1120      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CC0  0240 FFC0               1121      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CC4  B07C 44C0               1122      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00001CC8  6700 0228               1123      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CCC  6600 0002               1124      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00001CD0                          1125      
00001CD0                          1126  CHECK_OP_MOVE_TO_SR:
00001CD0  3038 10A0               1127      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CD4  0240 FFC0               1128      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CD8  B07C 46C0               1129      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
00001CDC  6700 0214               1130      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CE0  6600 0002               1131      BNE    CHECK_OP_NEGX            ;Check next OP code
00001CE4                          1132      
00001CE4                          1133  CHECK_OP_NEGX:
00001CE4  3038 10A0               1134      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
00001CE8  0240 FF00               1135      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001CEC  B07C 4000               1136      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
00001CF0  6700 0200               1137      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CF4  6600 0002               1138      BNE    CHECK_OP_CLR             ;Check next OP code
00001CF8                          1139      
00001CF8                          1140  CHECK_OP_CLR:
00001CF8  3038 10A0               1141      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CFC  0240 FF00               1142      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D00  B07C 4200               1143      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00001D04  6700 01EC               1144      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D08  6600 0002               1145      BNE    CHECK_OP_NOT             ;Check next OP code
00001D0C                          1146      
00001D0C                          1147  CHECK_OP_NOT:
00001D0C  3038 10A0               1148      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D10  0240 FF00               1149      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D14  B07C 4600               1150      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00001D18  6700 01D8               1151      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D1C  6600 0002               1152      BNE    CHECK_OP_EXT             ;Check next OP code
00001D20                          1153      
00001D20                          1154  CHECK_OP_EXT:
00001D20  3038 10A0               1155      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D24  0240 FFB8               1156      ANDI.W #$FFB8,D0                ;Mask relevant bits to D0
00001D28  B07C 4880               1157      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
00001D2C  6700 01C4               1158      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
00001D30  6600 001C               1159      BNE    CHECK_OP_NBCD            ;Check next OP code
00001D34                          1160  
00001D34                          1161  BIT_CHECK_EXT:    
00001D34  3038 10A0               1162      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
00001D38  323C 000A               1163      MOVE.W #10,D1                   ;Prepare a 10 bit shift into D1
00001D3C  E368                    1164      LSL.W  D1,D0                    ;Shift D0 left 10 bits
00001D3E  E068                    1165      LSR.W  D0,D0                    ;Reposition D0
00001D40  E648                    1166      LSR.W  #3,D0                    ;Shift D0 3 bits
00001D42  B078 0000               1167      CMP.W  %000,D0                  ;Check the specific bits needed to differentiate EXT
00001D46  6700 01AA               1168      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
00001D4A  6600 015C               1169      BNE    MOVEM_BIT_SIZE_CHECK     ;This is the only other possibility 
00001D4E                          1170      
00001D4E                          1171  CHECK_OP_NBCD:
00001D4E  3038 10A0               1172      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D52  0240 FFC0               1173      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0           
00001D56  B07C 4800               1174      CMP.W  #$4800,D0                ;Compare the appropriate masked bits
00001D5A  6700 0196               1175      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D5E  6600 0002               1176      BNE    CHECK_OP_SWAP            ;Check next OP code
00001D62                          1177      
00001D62                          1178  CHECK_OP_SWAP:                      ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
00001D62  3038 10A0               1179      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D66  0240 FFF8               1180      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001D6A  B07C 4840               1181      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001D6E  6700 0182               1182      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D72  6600 0002               1183      BNE    CHECK_OP_PEA             ;Check next OP code
00001D76                          1184   
00001D76                          1185  CHECK_OP_PEA:                       ;This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
00001D76  3038 10A0               1186      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D7A  0240 FFC0               1187      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001D7E  B07C 4840               1188      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001D82  6700 016E               1189      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D86  6600 0002               1190      BNE    CHECK_OP_TAS             ;Check next OP code
00001D8A                          1191      
00001D8A                          1192  CHECK_OP_TAS:
00001D8A  3038 10A0               1193      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D8E  0240 FFC0               1194      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001D92  B07C 4AC0               1195      CMP.W  #$4AC0,D0                ;Compare the appropriate masked bits
00001D96  6700 015A               1196      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D9A  6600 0002               1197      BNE    CHECK_OP_TST             ;Check next OP code
00001D9E                          1198  
00001D9E                          1199  CHECK_OP_TST:                       ;This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
00001D9E  3038 10A0               1200      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DA2  0240 FF00               1201      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001DA6  B07C 4A00               1202      CMP.W  #$4A00,D0                ;Compare the appropriate masked bits
00001DAA  6700 0146               1203      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DAE  6600 0002               1204      BNE    CHECK_OP_TRAP            ;Check next OP code
00001DB2                          1205      
00001DB2                          1206  CHECK_OP_TRAP:
00001DB2  3038 10A0               1207      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DB6  0240 FFF0               1208      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001DBA  B07C 4E40               1209      CMP.W  #$4E40,D0                ;Compare the appropriate masked bits
00001DBE  6700 0132               1210      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DC2  6600 0002               1211      BNE    CHECK_OP_LINK            ;Check next OP code
00001DC6                          1212      
00001DC6                          1213  CHECK_OP_LINK:
00001DC6  3038 10A0               1214      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DCA  0240 FFF8               1215      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001DCE  B07C 4E50               1216      CMP.W  #$4E50,D0                ;Compare the appropriate masked bits
00001DD2  6700 011E               1217      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DD6  6600 0002               1218      BNE    CHECK_OP_UNLK            ;Check next OP code
00001DDA                          1219  
00001DDA                          1220  CHECK_OP_UNLK:
00001DDA  3038 10A0               1221      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DDE  0240 FFF8               1222      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001DE2  B07C 4E58               1223      CMP.W  #$4E58,D0                ;Compare the appropriate masked bits
00001DE6  6700 010A               1224      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DEA  6600 0002               1225      BNE    CHECK_OP_MOVE_USP        ;Check next OP
00001DEE                          1226      
00001DEE                          1227  CHECK_OP_MOVE_USP:
00001DEE  3038 10A0               1228      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DF2  0240 FFF0               1229      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001DF6  B07C 4E60               1230      CMP.W  #$4E60,D0                ;Compare the appropriate masked bits
00001DFA  6700 00F6               1231      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DFE  6600 0002               1232      BNE    CHECK_OP_JMP             ;Check next OP
00001E02                          1233  
00001E02                          1234  CHECK_OP_JMP:
00001E02  3038 10A0               1235       MOVE.W CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E06  0240 FFC0               1236       ANDI.W #$FFC0,D0               ;Mask relevant bits to D0
00001E0A  B07C 4EC0               1237       CMP.W  #$4EC0,D0               ;Compare the appropriate masked bits
00001E0E  6700 00E2               1238       BEQ    GROUP4_INVALID          ;INVALID OP code
00001E12  6600 0002               1239       BNE    CHECK_OP_CHK            ;Check next OP code
00001E16                          1240       
00001E16                          1241  CHECK_OP_CHK:
00001E16  3038 10A0               1242      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E1A  0240 F1C0               1243      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001E1E  B07C 4180               1244      CMP.W   #$4180,D0               ;Compare the appropriate masked bits
00001E22  6700 0694               1245      BEQ     INVALID_OP              ;INVALID OP code
00001E26  6600 0002               1246      BNE     CHECK_OP_NOP            ;Check next OP code
00001E2A                          1247  
00001E2A                          1248  CHECK_OP_NOP:                       ;While this code is not in the supported docs, Nash covered it in class and expects it to be implemented
00001E2A  3038 10A0               1249      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E2E  B07C 4E71               1250      CMP.W  #$4E71,D0                ;Compare the appropriate bits
00001E32  6600 000C               1251      BNE    CHECK_OP_RTS             ;Check next OP code
00001E36  4EB9 00002580           1252      JSR    PRINT_OP_NOP             ;Print out OP code
00001E3C  6000 00BA               1253      BRA    GROUP4_SUCCESS           ;Finish routine
00001E40                          1254      
00001E40                          1255  CHECK_OP_RTS:
00001E40  3038 10A0               1256      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E44  B07C 4E75               1257      CMP.W  #$4E75,D0                ;Mask exact bits for RTS    
00001E48  6600 000C               1258      BNE    CHECK_OP_LEA             ;If it's equal check next code
00001E4C  4EB9 00002572           1259      JSR    PRINT_OP_RTS             ;Print out OP code
00001E52  6000 00A4               1260      BRA    GROUP4_SUCCESS           ;Finish routine
00001E56                          1261   
00001E56                          1262  CHECK_OP_LEA:
00001E56  3038 10A0               1263      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E5A  0240 F1C0               1264      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00001E5E  B07C 41C0               1265      CMP.W  #$41C0,D0                ;Compare masked bits
00001E62  6600 000C               1266      BNE    CHECK_OP_JSR             ;Check next OP code
00001E66  4EB9 0000258E           1267      JSR    PRINT_OP_LEA             ;Print out OP code
00001E6C  6000 008A               1268      BRA    GROUP4_SUCCESS           ;Finish routine
00001E70                          1269   
00001E70                          1270  CHECK_OP_JSR:
00001E70  3038 10A0               1271      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E74  0240 FFC0               1272      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00001E78  B07C 4E80               1273      CMP.W  #$4E80,D0                ;Compare masked bits
00001E7C  6600 000C               1274      BNE    CHECK_OP_NEG             ;Check next OP code
00001E80  4EB9 00002564           1275      JSR    PRINT_OP_JSR             ;Print out OP code
00001E86  6000 0070               1276      BRA    GROUP4_SUCCESS           ;Finish routine
00001E8A                          1277      
00001E8A                          1278  CHECK_OP_NEG:
00001E8A  3038 10A0               1279      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E8E  0240 FF00               1280      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001E92  B07C 4400               1281      CMP.W  #$4400,D0                ;Compare masked bits
00001E96  6600 0010               1282      BNE    MOVEM_BIT_SIZE_CHECK     ;Check next OP code
00001E9A  4EB8 187E               1283      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size field
00001E9E  4EB9 000025A2           1284      JSR    PRINT_OP_NEG             ;Print out OP code
00001EA4  6000 0052               1285      BRA    GROUP4_SUCCESS           ;Finish routine
00001EA8                          1286      
00001EA8                          1287  MOVEM_BIT_SIZE_CHECK:
00001EA8  3038 10A0               1288      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EAC  4EB8 189E               1289      JSR    FIND_1_BIT_SIZE_6        ;Parse size for bit 6
00001EB0  0C38 0000 1738          1290      CMP.B  #%0,OP_SIZE              ;Check size bit
00001EB6  6700 0006               1291      BEQ    CHECK_OP_MOVEM_W         ;If 0 it's a word
00001EBA  6600 001C               1292      BNE    CHECK_OP_MOVEM_L         ;If 1 it's a long
00001EBE                          1293  
00001EBE                          1294  CHECK_OP_MOVEM_W:
00001EBE  3038 10A0               1295      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EC2  0240 FB80               1296      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001EC6  B07C 4880               1297      CMP.W  #$4880,D0                ;Compare masked bits
00001ECA  6600 0026               1298      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001ECE  4EB9 000025B6           1299      JSR    PRINT_OP_MOVEM_W         ;PRINT OP code
00001ED4  6000 0022               1300      BRA    GROUP4_SUCCESS           ;Finish routine
00001ED8                          1301      
00001ED8                          1302  CHECK_OP_MOVEM_L:
00001ED8  3038 10A0               1303      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EDC  0240 FB80               1304      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001EE0  B07C 4880               1305      CMP.W  #$4880,D0                ;Compare masked bits
00001EE4  6600 000C               1306      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001EE8  4EB9 000025C4           1307      JSR    PRINT_OP_MOVEM_L         ;Print OP code
00001EEE  6000 0008               1308      BRA    GROUP4_SUCCESS           ;Finish routine    
00001EF2                          1309      
00001EF2                          1310  GROUP4_INVALID:
00001EF2  4EB9 000024B8           1311      JSR INVALID_OP                  ;INVALID op code has been found, set IS_VALID to 0
00001EF8                          1312  
00001EF8                          1313  GROUP4_SUCCESS:
00001EF8  4CDF 0001               1314      MOVEM.L (SP)+,D0                ;Restore saved registers
00001EFC  4E75                    1315      RTS                             ;Return to stack
00001EFE                          1316  C_GROUP_5:
00001EFE  48E7 8000               1317      MOVEM.L D0,-(SP)                ;Save registers to stack
00001F02                          1318  CHECK_OP_DBcc:                      ;These are ordered first due to checking bits 7-6
00001F02  3038 10A0               1319      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F06  0240 F0C8               1320      ANDI.W #$F0C8,D0                ;Mask appropriate bits
00001F0A  B07C 50C8               1321      CMP.W  #$50C8,D0                ;Compare appropriate masked bits
00001F0E  6700 004C               1322      BEQ    GROUP5_INVALID           ;INVALID op code found
00001F12  6600 0002               1323      BNE    CHECK_OP_Scc             ;Check next OP code
00001F16                          1324  
00001F16                          1325  CHECK_OP_Scc:
00001F16  3038 10A0               1326      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F1A  0240 F0C0               1327      ANDI.W #$F0C0,D0                ;Mask appropriate bits
00001F1E  B07C 50C0               1328      CMP.W  #$50C0,D0                ;Compare appropriate masked bits
00001F22  6700 0038               1329      BEQ     GROUP5_INVALID          ;INVALID OP code found
00001F26  6600 0002               1330      BNE     CHECK_OP_ADDQ           ;Check next OP code
00001F2A                          1331  
00001F2A                          1332  CHECK_OP_ADDQ:
00001F2A  3038 10A0               1333      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F2E  0240 F100               1334      ANDI.W #$F100,D0                ;Mask appropriate bits
00001F32  B07C 5000               1335      CMP.W  #$5000,D0                ;Compare appropriate masked bits
00001F36  6700 0024               1336      BEQ    GROUP5_INVALID           ;INVALID OP code found
00001F3A  6600 0002               1337      BNE    CHECK_OP_SUBQ            ;Check next OP code
00001F3E                          1338  
00001F3E                          1339  CHECK_OP_SUBQ     
00001F3E  3038 10A0               1340      MOVE.W  CUR_OP_CODE,D0          ;Actual check for SUBQ
00001F42  0240 F100               1341      ANDI.W #$F100,D0                ;Bitmask check for SUBQ
00001F46  B07C 5100               1342      CMP.W  #$5100,D0                ;Compare the proper value
00001F4A  6600 0010               1343      BNE    GROUP5_INVALID           ;Else the operand is invalid
00001F4E  4EB8 187E               1344      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size bit to print
00001F52  4EB9 000025D2           1345      JSR    PRINT_OP_SUBQ            ;If equal print it out
00001F58  6000 0008               1346      BRA    GROUP5_SUCCESS           ;Finish routine
00001F5C                          1347      
00001F5C                          1348  GROUP5_INVALID: 
00001F5C  4EB9 000024B8           1349      JSR INVALID_OP                  ;INVALID OP has been found, set IS_VALID to 0
00001F62                          1350  GROUP5_SUCCESS:
00001F62  4CDF 0001               1351      MOVEM.L (SP)+,D0                ;Restore registers from stack
00001F66  4E75                    1352      RTS                             ;Return to stack
00001F68                          1353      
00001F68                          1354  C_GROUP_6:
00001F68  48E7 8000               1355      MOVEM.L D0,-(SP)            ;Save register to stack
00001F6C                          1356  CHECK_OP_BSR:
00001F6C  3038 10A0               1357      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
00001F70  0240 FF00               1358      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00001F74  B07C 6100               1359      CMP.W   #$6100,D0               ;Compare masked bits
00001F78  6700 0128               1360      BEQ     GROUP6_INVALID          ;INVALID OP code found
00001F7C  6600 0002               1361      BNE     CHECK_OP_BGT            ;Check next OP code
00001F80                          1362      
00001F80                          1363  CHECK_OP_BGT:
00001F80  3038 10A0               1364      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F84  0240 FF00               1365      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001F88  B07C 6E00               1366      CMP.W  #$6E00,D0                ;Compare masked bits
00001F8C  6700 0114               1367      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001F90  6600 0002               1368      BNE    CHECK_OP_BCC             ;Check next OP code
00001F94                          1369  
00001F94                          1370  CHECK_OP_BCC:
00001F94  3038 10A0               1371      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F98  0240 FF00               1372      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001F9C  B07C 6400               1373      CMP.W  #$6400,D0                ;Compare masked bits
00001FA0  6700 0100               1374      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FA4  6600 0002               1375      BNE    CHECK_OP_BEQ             ;Check next OP code 
00001FA8                          1376  
00001FA8                          1377  CHECK_OP_BEQ:
00001FA8  3038 10A0               1378      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FAC  0240 FF00               1379      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FB0  B07C 6700               1380      CMP.W  #$6700,D0                ;Compare masked bits
00001FB4  6700 00EC               1381      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FB8  6600 0002               1382      BNE    CHECK_OP_BHI             ;Check next OP code
00001FBC                          1383  
00001FBC                          1384  CHECK_OP_BHI:
00001FBC  3038 10A0               1385      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FC0  0240 FF00               1386      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FC4  B07C 6200               1387      CMP.W  #$6200,D0                ;Compare masked bits
00001FC8  6700 00D8               1388      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FCC  6600 0002               1389      BNE    CHECK_OP_BLS             ;Check next OP code
00001FD0                          1390  
00001FD0                          1391  CHECK_OP_BLS:
00001FD0  3038 10A0               1392      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FD4  0240 FF00               1393      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FD8  B07C 6300               1394      CMP.W  #$6300,D0                ;Compare masked bits
00001FDC  6700 00C4               1395      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FE0  6600 0002               1396      BNE    CHECK_OP_BMI             ;Check next OP code
00001FE4                          1397  
00001FE4                          1398  CHECK_OP_BMI:
00001FE4  3038 10A0               1399      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FE8  0240 FF00               1400      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FEC  B07C 6B00               1401      CMP.W  #$6B00,D0                ;Compare masked bits
00001FF0  6700 00B0               1402      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FF4  6600 0002               1403      BNE    CHECK_OP_BNE             ;Check next OP code
00001FF8                          1404  
00001FF8                          1405  CHECK_OP_BNE:
00001FF8  3038 10A0               1406      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FFC  0240 FF00               1407      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002000  B07C 6600               1408      CMP.W  #$6600,D0                ;Compare masked bits
00002004  6700 009C               1409      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002008  6600 0002               1410      BNE    CHECK_OP_BPL             ;Check next OP code    
0000200C                          1411  
0000200C                          1412  CHECK_OP_BPL:
0000200C  3038 10A0               1413      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002010  0240 FF00               1414      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002014  B07C 6A00               1415      CMP.W  #$6A00,D0                ;Compare masked bits
00002018  6700 0088               1416      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000201C  6600 0002               1417      BNE    CHECK_OP_BRA             ;Check next OP code 
00002020                          1418  
00002020                          1419  
00002020                          1420  CHECK_OP_BRA:
00002020  3038 10A0               1421      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0       
00002024  0240 FF00               1422      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00002028  B07C 6000               1423      CMP.W   #$6000,D0               ;Compare masked bits
0000202C  6600 000C               1424      BNE     CHECK_OP_BCS            ;Check next OP code
00002030  4EB9 00002636           1425      JSR     PRINT_OP_BRA            ;Print out OP code
00002036  6000 0070               1426      BRA     GROUP6_SUCCESS          ;Finish routine
0000203A                          1427      
0000203A                          1428  CHECK_OP_BCS:
0000203A  3038 10A0               1429      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000203E  0240 FF00               1430      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002042  B07C 6500               1431      CMP.W  #$6500,D0                ;Compare masked bits
00002046  6600 000C               1432      BNE    CHECK_OP_BGE             ;Check next OP code
0000204A  4EB9 000025E6           1433      JSR    PRINT_OP_BCS             ;Print out OP code
00002050  6000 0056               1434      BRA    GROUP6_SUCCESS           ;Finish routine
00002054                          1435  
00002054                          1436      
00002054                          1437  CHECK_OP_BGE:
00002054  3038 10A0               1438      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002058  0240 FF00               1439      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000205C  B07C 6C00               1440      CMP.W  #$6C00,D0                ;Compare masked bits
00002060  6600 000C               1441      BNE    CHECK_OP_BLT             ;Check next OP code
00002064  4EB9 000025FA           1442      JSR    PRINT_OP_BGE             ;Print out OP code
0000206A  6000 003C               1443      BRA    GROUP6_SUCCESS           ;Finish routine
0000206E                          1444      
0000206E                          1445      
0000206E                          1446  CHECK_OP_BLT:
0000206E  3038 10A0               1447      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002072  0240 FF00               1448      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002076  B07C 6D00               1449      CMP.W  #$6D00,D0                ;Compare masked bits
0000207A  6600 000C               1450      BNE    CHECK_OP_BVC             ;Check next OP code
0000207E  4EB9 0000260E           1451      JSR    PRINT_OP_BLT             ;Print out OP code
00002084  6000 0022               1452      BRA    GROUP6_SUCCESS           ;Finish routine
00002088                          1453      
00002088                          1454  CHECK_OP_BVC:
00002088  3038 10A0               1455      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000208C  0240 FF00               1456      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002090  B07C 6800               1457      CMP.W  #$6800,D0                ;Compare masked bits
00002094  6600 000C               1458      BNE    GROUP6_INVALID           ;Check next OP code
00002098  4EB9 00002622           1459      JSR    PRINT_OP_BVC             ;Print out OP code
0000209E  6000 0008               1460      BRA    GROUP6_SUCCESS           ;Finish routine
000020A2                          1461      
000020A2                          1462  GROUP6_INVALID:
000020A2  4EB9 000024B8           1463      JSR    INVALID_OP               ;INVALID OP code found, set IS_VALID to 0
000020A8                          1464  GROUP6_SUCCESS:
000020A8  4CDF 0001               1465      MOVEM.L (SP)+,D0                ;Restore registers from stack
000020AC  4E75                    1466      RTS                             ;Return from stack
000020AE                          1467      
000020AE                          1468  C_GROUP_7:
000020AE  48E7 8000               1469      MOVEM.L D0,-(SP)                ;Save register to stack
000020B2                          1470  CHECK_OP_MOVEQ
000020B2  3038 10A0               1471      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
000020B6  0240 F100               1472      ANDI.W  #$F100,D0               ;Mask appropriate bits
000020BA  B07C 7000               1473      CMP.W   #$7000,D0               ;Compare masked bits
000020BE  6000 0002               1474      BRA     GROUP7_INVALID          ;INVALID OP code found
000020C2                          1475  
000020C2                          1476  GROUP7_INVALID:
000020C2  4EB9 000024B8           1477      JSR     INVALID_OP              ;INVALID OP code found, set IS_VALID to 0
000020C8                          1478  GROUP7_SUCCESS:    
000020C8  4CDF 0001               1479      MOVEM.L (SP)+,D0                ;Restore registers from stack
000020CC  4E75                    1480      RTS                             ;Return from stack
000020CE                          1481  C_GROUP_8:
000020CE  48E7 8000               1482      MOVEM.L D0,-(SP)
000020D2                          1483  CHECK_OP_DIVU:
000020D2  3038 10A0               1484      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020D6  0240 F1C0               1485      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
000020DA  B07C 80C0               1486      CMP.W   #$80C0,D0               ;Compare masked bits
000020DE  6700 0042               1487      BEQ     GROUP8_INVALID          ;INVALID OP code found
000020E2  6600 0002               1488      BNE     CHECK_OP_SBCD           ;Check next OP code
000020E6                          1489  
000020E6                          1490  CHECK_OP_SBCD:
000020E6  3038 10A0               1491      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020EA  0240 F1F0               1492      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
000020EE  B07C 8100               1493      CMP.W   #$8100,D0               ;Compare masked bits
000020F2  6700 002E               1494      BEQ     GROUP8_INVALID          ;INVALID OP code found
000020F6  6600 0002               1495      BNE     CHECK_OP_DIVS           ;Check next OP code
000020FA                          1496      
000020FA                          1497  CHECK_OP_DIVS:
000020FA  3038 10A0               1498      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020FE  0240 F1C0               1499      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002102  B07C 81C0               1500      CMP.W   #$81C0,D0               ;Compare masked bits
00002106  6600 000C               1501      BNE     CHECK_OP_OR             ;Check next OP code
0000210A  4EB9 0000264A           1502      JSR     PRINT_OP_DIVS           ;OP Code found
00002110  6000 0016               1503      BRA     GROUP8_SUCCESS          ;Finish routine
00002114                          1504      
00002114                          1505  CHECK_OP_OR:                        ;At this point only remaining $8 code is OR
00002114  4EB8 187E               1506      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Finding size bit to print out
00002118  4EB9 00002658           1507      JSR     PRINT_OP_OR             ;Print out OR
0000211E  6000 0008               1508      BRA     GROUP8_SUCCESS          ;Finish routine
00002122                          1509  GROUP8_INVALID:
00002122  4EB9 000024B8           1510       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
00002128                          1511  GROUP8_SUCCESS:
00002128  4CDF 0001               1512       MOVEM.L (SP)+,D0               ;Restore register from stack
0000212C  4E75                    1513       RTS                            ;Return to stack
0000212E                          1514       
0000212E                          1515  C_GROUP_9:
0000212E  48E7 C000               1516      MOVEM.L D0-D1,-(SP)             ;Save the registers
00002132                          1517  CHECK_SIZE_BIT_FOR_SUB:
00002132  4EB8 187E               1518      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bits in 7-6
00002136  0C38 0003 1738          1519      CMP.B   #%11,OP_SIZE            ;If the bits are %11, it has to be SUBA
0000213C  6700 0006               1520      BEQ     CHECK_OP_SUBA           ;If the bits equal it must be SUBA
00002140  6600 0016               1521      BNE     CHECK_OP_SUBX           ;If the bits are not equal it could be SUBX
00002144                          1522      
00002144                          1523  CHECK_OP_SUBA:                      ;Check SUBA first as it has static bits
00002144  3038 10A0               1524      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002148  0240 F0C0               1525      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
0000214C  B07C 90C0               1526      CMP.W   #$90C0,D0               ;Compare masked bits
00002150  6700 0042               1527      BEQ     GROUP9_INVALID          ;INVALID OP has been found
00002154  6600 0002               1528      BNE     CHECK_OP_SUBX           ;Check next OP
00002158                          1529  
00002158                          1530  CHECK_OP_SUBX:
00002158  3038 10A0               1531      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000215C  0240 F130               1532      ANDI.W  #$F130,D0               ;Mask appropriate bits
00002160  B07C 9100               1533      CMP.W   #$9100,D0               ;Compare masked bits
00002164  6000 0002               1534      BRA     BIT_CHECK_SUBX          ;Checking if this code is SUBX through bit shifts
00002168                          1535      
00002168                          1536  BIT_CHECK_SUBX:    
00002168  3038 10A0               1537      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000216C  323C 0007               1538      MOVE.W  #7,D1                   ;Prepare a shift of 7 bits into D1
00002170  E368                    1539      LSL.W   D1,D0                   ;Shift left 7 bits truncate 15-9 bits
00002172  E268                    1540      LSR.W   D1,D0                   ;Reposition D0
00002174  E848                    1541      LSR.W   #4,D0                   ;Truncate 4 right most bits to
00002176  0240 FF13               1542      ANDI.W  #$FF13,D0               ;Compare remaining static bits
0000217A  B07C 0010               1543      CMP.W   #$0010,D0               ;If equal to this value it's SUBX
0000217E  6700 0014               1544      BEQ     GROUP9_INVALID          ;INVALID OP code found
00002182  6600 0002               1545      BNE     CHECK_OP_SUB            ;Not can only be SUB here
00002186                          1546      
00002186                          1547  CHECK_OP_SUB:                       ;At this point only remaining $9 is SUB
00002186  4EB8 187E               1548      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bit to print out
0000218A  4EB9 0000266C           1549      JSR     PRINT_OP_SUB            ;Print out SUB
00002190  6000 0008               1550      BRA     GROUP9_SUCCESS          ;Finish routine
00002194                          1551      
00002194                          1552  GROUP9_INVALID:
00002194  4EB9 000024B8           1553       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
0000219A                          1554  GROUP9_SUCCESS: 
0000219A  4CDF 0003               1555      MOVEM.L (SP)+,D0-D1             ;Restore registers
0000219E  4E75                    1556      RTS                             ;Return to stack
000021A0                          1557  
000021A0                          1558  C_GROUP_A:
000021A0  4EB9 000024B8           1559      JSR INVALID_OP                  ;INVALID OP code found, set IS_VALID to 0
000021A6  4E75                    1560      RTS                             ;Return to stack
000021A8                          1561      
000021A8                          1562  C_GROUP_B:
000021A8  48E7 8000               1563      MOVEM.L D0,-(SP)                ;Save current registers to stack
000021AC                          1564  CHECK_OP_CMPM
000021AC  3038 10A0               1565      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021B0  0240 F138               1566      ANDI.W  #$F138,D0               ;Mask appropriate bits
000021B4  B07C B108               1567      CMP.W   #$B108,D0               ;Compare masked bits
000021B8  6700 0056               1568      BEQ     GROUPB_INVALID          ;INVALID OP found
000021BC  6600 0002               1569      BNE     CHECK_OP_CMPA           ;Check next OP
000021C0                          1570      
000021C0                          1571  CHECK_OP_CMPA:
000021C0  3038 10A0               1572      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021C4  0240 F0C0               1573      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
000021C8  B07C B0C0               1574      CMP.W   #$B0C0,D0               ;Compare masked bits
000021CC  6700 0042               1575      BEQ     GROUPB_INVALID          ;INVALID OP found
000021D0  6600 0002               1576      BNE     CHECK_OP_EOR            ;Check next OP
000021D4                          1577  
000021D4                          1578  CHECK_OP_EOR:
000021D4  3038 10A0               1579      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021D8  0240 F100               1580      ANDI.W  #$F100,D0               ;Mask appropriate bits
000021DC  B07C B100               1581      CMP.W   #$B100,D0               ;Compare masked bits
000021E0  6600 0010               1582      BNE     CHECK_OP_CMP            ;Check next OP 
000021E4  4EB8 187E               1583      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
000021E8  4EB9 00002680           1584      JSR     PRINT_OP_EOR            ;Print out OP code
000021EE  6000 0026               1585      BRA     GROUPB_SUCCESS          ;Finish routine
000021F2                          1586      
000021F2                          1587  CHECK_OP_CMP:
000021F2  3038 10A0               1588      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021F6  0240 F100               1589      ANDI.W  #$F100,D0               ;Mask appropriate bits
000021FA  B07C B000               1590      CMP.W   #$B000,D0               ;Compare masked bits
000021FE  6600 0010               1591      BNE     GROUPB_INVALID          ;INVALID OP code found
00002202  4EB8 187E               1592      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
00002206  4EB9 00002694           1593      JSR     PRINT_OP_CMP            ;Print out OP code
0000220C  6000 0008               1594      BRA     GROUPB_SUCCESS          ;Finish routine
00002210                          1595      
00002210                          1596  GROUPB_INVALID:
00002210  4EB9 000024B8           1597      JSR     INVALID_OP              ;INVALID OP has been found, set IS_VALID to 0
00002216                          1598  GROUPB_SUCCESS:
00002216  4CDF 0001               1599      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000221A  4E75                    1600      RTS                             ;Return to stack
0000221C                          1601  C_GROUP_C:
0000221C  48E7 C000               1602      MOVEM.L D0-D1,-(SP)
00002220                          1603      
00002220                          1604  CHECK_OP_MULU:
00002220  3038 10A0               1605      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002224  0240 F1C0               1606      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002228  B07C C0C0               1607      CMP.W   #$C0C0,D0               ;Compare masked bits
0000222C  6700 0066               1608      BEQ     GROUPC_INVALID          ;INVALID OP code found
00002230  6600 0002               1609      BNE     CHECK_OP_ABCD           ;Check next OP code
00002234                          1610   
00002234                          1611  CHECK_OP_ABCD:
00002234  3038 10A0               1612      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002238  0240 F1F0               1613      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
0000223C  B07C C100               1614      CMP.W   #$C100,D0               ;Compare masked bits
00002240  6700 0052               1615      BEQ     GROUPC_INVALID          ;INVALID OP code found
00002244  6600 0002               1616      BNE     CHECK_OP_EXG            ;Check next OP code
00002248                          1617   
00002248                          1618  CHECK_OP_EXG:
00002248  6000 0002               1619      BRA     BIT_CHECK_EXG           ;Always do bit check here
0000224C                          1620                          
0000224C                          1621  BIT_CHECK_EXG:                      ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
0000224C  3038 10A0               1622      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002250  323C 0007               1623      MOVE.W  #7,D1                   ;Prepare a bit shift of 7 into D1
00002254  E368                    1624      LSL.W   D1,D0                   ;Shift D0 to 7 bits
00002256  E268                    1625      LSR.W   D1,D0                   ;Reposition D0
00002258  E848                    1626      LSR.W   #4,D0                   ;Shift D0 4 bits right
0000225A  0240 FF83               1627      ANDI.W  #$FF83,D0               ;Mask appropriate bits
0000225E  B07C 0010               1628      CMP.W   #$0010,D0               ;Bit mask static EXG bits
00002262  6700 0030               1629      BEQ     GROUPC_INVALID          ;If this equals, then OP must be EXG
00002266  6600 0002               1630      BNE     CHECK_OP_MULS           ;Otherwise it's MULS
0000226A                          1631  CHECK_OP_MULS:
0000226A  3038 10A0               1632      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000226E  0240 F1C0               1633      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00002272  B07C C1C0               1634      CMP.W  #$C1C0,D0                ;Compare masked bits
00002276  6600 000C               1635      BNE    CHECK_OP_AND             ;OP_AND is completely dynamic outside of first nibble
0000227A  4EB9 000026A8           1636      JSR    PRINT_OP_MULS            ;Print OP code
00002280  6000 0018               1637      BRA    GROUPC_SUCCESS           ;Finish routine
00002284                          1638      
00002284                          1639  CHECK_OP_AND:                       ;This would be the only possible OP code left after CHECK_OP_MULS
00002284  3038 10A0               1640      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002288  0240 F000               1641      ANDI.W  #$F000,D0               ;Mask appropriate bits
0000228C  B07C C000               1642      CMP.W   #$C000,D0               ;Compare masked bits
00002290  6000 0002               1643      BRA    GROUPC_INVALID           ;INVALID OP code found
00002294                          1644      
00002294                          1645  GROUPC_INVALID:
00002294  4EB9 000024B8           1646      JSR     INVALID_OP              ;Set IS_VALID to 0
0000229A                          1647      
0000229A                          1648  GROUPC_SUCCESS:
0000229A  4CDF 0003               1649      MOVEM.L (SP)+,D0-D1             ;Restore registers from stack
0000229E  4E75                    1650      RTS                             ;Return to stack
000022A0                          1651      
000022A0                          1652  C_GROUP_D:
000022A0  48E7 8000               1653      MOVEM.L D0,-(SP)                ;Save registers to stack
000022A4                          1654  BIT_SIZE_CHECK
000022A4  3038 10A0               1655      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
000022A8  4EB8 187E               1656      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Specific size bit checking to see if it's 11
000022AC  0C38 0003 1738          1657      CMP.B   #%11,OP_SIZE            ;If it's %11 it cannot be ADDX and is either ADDA or ADD
000022B2  6700 0024               1658      BEQ     CHECK_OP_ADDA           ;If it's equal check ADDA
000022B6  6600 0002               1659      BNE     CHECK_OP_ADDX           ;If it's not equal check ADDX
000022BA                          1660      
000022BA                          1661  CHECK_OP_ADDX:
000022BA  3038 10A0               1662      MOVE    CUR_OP_CODE,D0
000022BE  0240 F130               1663      ANDI.W #$F130,D0                ;Mask appropriate bits
000022C2  B07C D100               1664      CMP.W  #$D100,D0                ;Compare masked bits
000022C6  6700 002C               1665      BEQ    GROUPD_INVALID           ;INVALID OP code found
000022CA  6600 0002               1666      BNE    CHECK_OP_ADD             ;Check next OP code
000022CE                          1667      
000022CE                          1668  CHECK_OP_ADD:
000022CE  4EB9 000026B6           1669      JSR PRINT_OP_ADD                ;Only remaining OP in $D is ADD at this point
000022D4  6000 0024               1670      BRA GROUPD_SUCCESS              ;Finish routine
000022D8                          1671  
000022D8                          1672  CHECK_OP_ADDA:
000022D8  3038 10A0               1673      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
000022DC  0240 F0C0               1674      ANDI.W #$F0C0,D0                ;Mask applicable bits
000022E0  B07C D0C0               1675      CMP.W  #$D0C0,D0                ;Compare masked bits
000022E4  66E8                    1676      BNE    CHECK_OP_ADD             ;Check next OP code
000022E6  4EB8 18BE               1677      JSR    FIND_1_BIT_SIZE_8        ;Size bit to print
000022EA  4EB9 000026CA           1678      JSR    PRINT_OP_ADDA            ;Print out OP code
000022F0  6000 0008               1679      BRA    GROUPD_SUCCESS           ;Finish routine
000022F4                          1680      
000022F4                          1681  GROUPD_INVALID:
000022F4  4EB9 000024B8           1682      JSR INVALID_OP                  ;INVALID OP code found
000022FA                          1683  GROUPD_SUCCESS:
000022FA  4CDF 0001               1684      MOVEM.L (SP)+,D0                ;Restore registers from stack
000022FE  4E75                    1685      RTS                             ;Return to stack
00002300                          1686      
00002300                          1687  C_GROUP_E:
00002300  48E7 8000               1688      MOVEM.L D0,-(SP)
00002304                          1689  CHECK_OP_ROXR_NO_ROT:
00002304  3038 10A0               1690      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002308  0240 FFC0               1691      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000230C  B07C E4C0               1692      CMP.W  #$E4C0,D0                ;Compare masked bits
00002310  6700 0192               1693      BEQ    GROUPE_INVALID           ;INVALID OP code
00002314  6600 0002               1694      BNE    CHECK_OP_ROXL_NO_ROT     ;Check next OP code
00002318                          1695  
00002318                          1696  CHECK_OP_ROXL_NO_ROT:
00002318  3038 10A0               1697      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000231C  0240 FFC0               1698      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002320  B07C E5C0               1699      CMP.W  #$E5C0,D0                ;Compare masked bits
00002324  6700 017E               1700      BEQ    GROUPE_INVALID           ;INVALID OP code
00002328  6600 0002               1701      BNE    CHECK_OP_ROR_NO_ROT      ;Check next OP code
0000232C                          1702  
0000232C                          1703  CHECK_OP_ROR_NO_ROT:
0000232C  3038 10A0               1704      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002330  0240 FFC0               1705      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002334  B07C E6C0               1706      CMP.W  #$E6C0,D0                ;Compare masked bits
00002338  6600 000C               1707      BNE    CHECK_OP_ROL_NO_ROT      ;Check next OP code
0000233C  4EB9 00002742           1708      JSR    PRINT_OP_ROR             ;Print out OP code
00002342  6000 0166               1709      BRA    GROUPE_SUCCESS           ;Finish routine
00002346                          1710      
00002346                          1711  CHECK_OP_ROL_NO_ROT:
00002346  3038 10A0               1712      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000234A  0240 FFC0               1713      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000234E  B07C E7C0               1714      CMP.W  #$E7C0,D0                ;Compare masked bits
00002352  6600 000C               1715      BNE    CHECK_OP_LSR_NO_ROT      ;Check next OP code
00002356  4EB9 0000272E           1716      JSR    PRINT_OP_ROL             ;Print out OP code
0000235C  6000 014C               1717      BRA    GROUPE_SUCCESS           ;Finish routine
00002360                          1718   
00002360                          1719  CHECK_OP_LSR_NO_ROT:
00002360  3038 10A0               1720      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002364  0240 FFC0               1721      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002368  B07C E2C0               1722      CMP.W  #$E2C0,D0                ;Compare masked bits
0000236C  6600 000C               1723      BNE    CHECK_OP_LSL_NO_ROT      ;Check next OP code
00002370  4EB9 000026F2           1724      JSR    PRINT_OP_LSR             ;Print out OP code
00002376  6000 0132               1725      BRA    GROUPE_SUCCESS           ;Finish routine
0000237A                          1726  
0000237A                          1727  CHECK_OP_LSL_NO_ROT:
0000237A  3038 10A0               1728      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000237E  0240 FFC0               1729      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002382  B07C E3C0               1730      CMP.W  #$E3C0,D0                ;Compare masked bits
00002386  6600 000C               1731      BNE    CHECK_OP_ASR_NO_ROT      ;Check next OP code
0000238A  4EB9 000026DE           1732      JSR    PRINT_OP_LSL             ;Print out OP code
00002390  6000 0118               1733      BRA    GROUPE_SUCCESS           ;Finish routine
00002394                          1734  
00002394                          1735  CHECK_OP_ASR_NO_ROT:
00002394  3038 10A0               1736      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002398  0240 FFC0               1737      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000239C  B07C E0C0               1738      CMP.W  #$E0C0,D0                ;Compare masked bits
000023A0  6600 000C               1739      BNE    CHECK_OP_ASL_NO_ROT      ;Check next OP code
000023A4  4EB9 00002706           1740      JSR    PRINT_OP_ASR             ;Print out OP code
000023AA  6000 00FE               1741      BRA    GROUPE_SUCCESS           ;Finish routine
000023AE                          1742              
000023AE                          1743  CHECK_OP_ASL_NO_ROT:
000023AE  3038 10A0               1744      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023B2  0240 FFC0               1745      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023B6  B07C E1C0               1746      CMP.W  #$E1C0,D0                ;Compare masked bits
000023BA  6600 000C               1747      BNE    CHECK_OP_ROXR            ;Check next OP code
000023BE  4EB9 0000271A           1748      JSR    PRINT_OP_ASL             Print out OP code
000023C4  6000 00E4               1749      BRA    GROUPE_SUCCESS           ;Finish routine
000023C8                          1750  
000023C8                          1751  CHECK_OP_ROXR:
000023C8  3038 10A0               1752      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023CC  0240 F118               1753      ANDI.W #$F118,D0                ;Mask appropriate bits
000023D0  B07C E010               1754      CMP.W  #$E010,D0                ;Compare masked bits
000023D4  6700 00CE               1755      BEQ    GROUPE_INVALID           ;INVALID OP code found
000023D8  6600 0002               1756      BNE    CHECK_OP_ROXL            ;Check next OP code
000023DC                          1757      
000023DC                          1758  CHECK_OP_ROXL:
000023DC  3038 10A0               1759      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023E0  0240 F118               1760      ANDI.W #$F118,D0                ;Mask appropriate bits
000023E4  B07C E110               1761      CMP.W  #$E110,D0                ;Compare masked bits
000023E8  6700 00BA               1762      BEQ    GROUPE_INVALID           ;INVALID OP code found
000023EC  6600 0002               1763      BNE    CHECK_OP_ROR             ;Check next OP code
000023F0                          1764      
000023F0                          1765  CHECK_OP_ROR:
000023F0  3038 10A0               1766      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023F4  0240 F118               1767      ANDI.W #$F118,D0                ;Mask appropriate bits
000023F8  B07C E018               1768      CMP.W  #$E018,D0                ;Compare masked bits
000023FC  6600 0010               1769      BNE    CHECK_OP_ROL             ;Check next OP code
00002400  4EB8 187E               1770      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size bits
00002404  4EB9 00002742           1771      JSR    PRINT_OP_ROR             ;Print out OP code
0000240A  6000 009E               1772      BRA    GROUPE_SUCCESS           ;Finish routine
0000240E                          1773  
0000240E                          1774  CHECK_OP_ROL:
0000240E  3038 10A0               1775      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002412  0240 F118               1776      ANDI.W #$F118,D0                ;Mask appropriate bits
00002416  B07C E118               1777      CMP.W  #$E118,D0                ;Compare masked bits
0000241A  6600 0010               1778      BNE    CHECK_OP_LSR             ;Check next OP code
0000241E  4EB8 187E               1779      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002422  4EB9 0000272E           1780      JSR    PRINT_OP_ROL             ;Print out OP code
00002428  6000 0080               1781      BRA    GROUPE_SUCCESS           ;Finish routine
0000242C                          1782      
0000242C                          1783  CHECK_OP_LSR:
0000242C  3038 10A0               1784      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002430  0240 F118               1785      ANDI.W #$F118,D0                ;Mask appropriate bits
00002434  B07C E008               1786      CMP.W  #$E008,D0                ;Compare masked bits
00002438  6600 0010               1787      BNE    CHECK_OP_LSL             ;Check next OP code
0000243C  4EB8 187E               1788      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002440  4EB9 000026F2           1789      JSR    PRINT_OP_LSR             ;Print out OP code
00002446  6000 0062               1790      BRA    GROUPE_SUCCESS           ;Finish routine
0000244A                          1791  
0000244A                          1792  CHECK_OP_LSL:
0000244A  3038 10A0               1793      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000244E  0240 F118               1794      ANDI.W #$F118,D0                ;Mask appropriate bits
00002452  B07C E108               1795      CMP.W  #$E108,D0                ;Compare masked bits
00002456  6600 0010               1796      BNE    CHECK_OP_ASR             ;Check next OP code
0000245A  4EB8 187E               1797      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000245E  4EB9 000026DE           1798      JSR    PRINT_OP_LSL             ;Print out OP code
00002464  6000 0044               1799      BRA    GROUPE_SUCCESS           ;Finish routine
00002468                          1800  
00002468                          1801  CHECK_OP_ASR:
00002468  3038 10A0               1802      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000246C  0240 F118               1803      ANDI.W #$F118,D0                ;Mask appropriate bits
00002470  B07C E000               1804      CMP.W  #$E000,D0                ;Compare masked bits
00002474  6600 0010               1805      BNE    CHECK_OP_ASL             ;Check next OP code
00002478  4EB8 187E               1806      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000247C  4EB9 00002706           1807      JSR    PRINT_OP_ASR             ;Print out OP code
00002482  6000 0026               1808      BRA    GROUPE_SUCCESS           ;Finish routine
00002486                          1809  
00002486                          1810  CHECK_OP_ASL:
00002486  3038 10A0               1811      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000248A  0240 F118               1812      ANDI.W #$F118,D0                ;Mask appropriate bits
0000248E  B07C E100               1813      CMP.W  #$E100,D0                ;Compare masked bits
00002492  6600 0010               1814      BNE    GROUPE_INVALID           ;Last possible OP code
00002496  4EB8 187E               1815      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000249A  4EB9 0000271A           1816      JSR    PRINT_OP_ASL             ;Print out OP code
000024A0  6000 0008               1817      BRA    GROUPE_SUCCESS           ;Finish routine
000024A4                          1818  
000024A4                          1819  GROUPE_INVALID:
000024A4  4EB9 000024B8           1820      JSR     INVALID_OP              ;Set IS_VALID to 0
000024AA                          1821  GROUPE_SUCCESS:
000024AA  4CDF 0001               1822      MOVEM.L (SP)+,D0                ;Restore registers from stack
000024AE  4E75                    1823      RTS                             ;Return to stack
000024B0                          1824  C_GROUP_F:
000024B0  4EB9 000024B8           1825      JSR     INVALID_OP              ;Set IS_VALID to 0
000024B6  4E75                    1826      RTS                             ;Return to stack
000024B8                          1827      
000024B8                          1828  INVALID_OP:                         ; ONLY SETS IS_VALID TO 0
000024B8  11FC 0000 10A2          1829      MOVE.B #0,IS_VALID              ;Sets IS_VALID to 0
000024BE  4E75                    1830      RTS                             ;Return to stack
000024C0                          1831  
000024C0                          1832  
000024C0                          1833  PRINT_TO_BUFFER:
000024C0  21FC 00001000 1256      1834      MOVE.L #G_BUFFER, BUFFER_POINTER
000024C8  4EB8 1260               1835      JSR AddStrToBuffer
000024CC  4E75                    1836      RTS
000024CE                          1837      
000024CE                          1838  PRINT_OP_ORI:
000024CE  21FC 000027BC 1252      1839      MOVE.L #P_OP_ORI, STRING_BUFFER_POINTER
000024D6  4EB8 24C0               1840      JSR PRINT_TO_BUFFER
000024DA  4EB9 00002780           1841      JSR PRINT_OP_SIZE
000024E0  4E75                    1842      RTS
000024E2                          1843  PRINT_OP_CMPI:
000024E2  21FC 000027C3 1252      1844      MOVE.L #P_OP_CMPI, STRING_BUFFER_POINTER
000024EA  4EB8 24C0               1845      JSR PRINT_TO_BUFFER
000024EE  4EB9 00002780           1846      JSR PRINT_OP_SIZE
000024F4  4E75                    1847      RTS
000024F6                          1848  PRINT_OP_STATIC_BCLR:
000024F6  21FC 000027CB 1252      1849      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
000024FE  4EB8 24C0               1850      JSR PRINT_TO_BUFFER
00002502  4EB9 00002780           1851      JSR PRINT_OP_SIZE
00002508  4E75                    1852      RTS
0000250A                          1853      
0000250A                          1854  PRINT_OP_DYNAMIC_BCLR:
0000250A  21FC 000027CB 1252      1855      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
00002512  4EB8 24C0               1856      JSR PRINT_TO_BUFFER
00002516  4EB9 00002780           1857      JSR PRINT_OP_SIZE
0000251C  4E75                    1858      RTS
0000251E                          1859  
0000251E                          1860  PRINT_OP_MOVEB:
0000251E  21FC 000027D3 1252      1861      MOVE.L #P_OP_MOVEB, STRING_BUFFER_POINTER
00002526  4EB8 24C0               1862      JSR PRINT_TO_BUFFER
0000252A  4E75                    1863      RTS
0000252C                          1864      
0000252C                          1865  PRINT_OP_MOVEA_L:
0000252C  21FC 000027DE 1252      1866      MOVE.L #P_OP_MOVEA_L, STRING_BUFFER_POINTER
00002534  4EB8 24C0               1867      JSR PRINT_TO_BUFFER
00002538  4E75                    1868      RTS
0000253A                          1869  PRINT_OP_MOVE_L:
0000253A  21FC 000027EA 1252      1870      MOVE.L #P_OP_MOVE_L, STRING_BUFFER_POINTER
00002542  4EB8 24C0               1871      JSR PRINT_TO_BUFFER
00002546  4E75                    1872      RTS
00002548                          1873      
00002548                          1874  PRINT_OP_MOVEA_W:
00002548  21FC 000027F5 1252      1875      MOVE.L #P_OP_MOVEA_W, STRING_BUFFER_POINTER
00002550  4EB8 24C0               1876      JSR PRINT_TO_BUFFER
00002554  4E75                    1877      RTS
00002556                          1878  PRINT_OP_MOVE_W:
00002556  21FC 00002801 1252      1879      MOVE.L #P_OP_MOVE_W, STRING_BUFFER_POINTER
0000255E  4EB8 24C0               1880      JSR PRINT_TO_BUFFER
00002562  4E75                    1881      RTS
00002564                          1882  
00002564                          1883  PRINT_OP_JSR:
00002564  21FC 0000282B 1252      1884      MOVE.L #P_OP_JSR, STRING_BUFFER_POINTER
0000256C  4EB8 24C0               1885      JSR PRINT_TO_BUFFER
00002570  4E75                    1886      RTS
00002572                          1887  PRINT_OP_RTS:
00002572  21FC 00002839 1252      1888      MOVE.L #P_OP_RTS, STRING_BUFFER_POINTER
0000257A  4EB8 24C0               1889      JSR PRINT_TO_BUFFER
0000257E  4E75                    1890      RTS
00002580                          1891  PRINT_OP_NOP:
00002580  21FC 00002832 1252      1892      MOVE.L #P_OP_NOP, STRING_BUFFER_POINTER
00002588  4EB8 24C0               1893      JSR PRINT_TO_BUFFER
0000258C  4E75                    1894      RTS
0000258E                          1895  PRINT_OP_LEA:
0000258E  21FC 00002824 1252      1896      MOVE.L #P_OP_LEA, STRING_BUFFER_POINTER
00002596  4EB8 24C0               1897      JSR PRINT_TO_BUFFER
0000259A  4EB9 00002780           1898      JSR PRINT_OP_SIZE
000025A0  4E75                    1899      RTS
000025A2                          1900  PRINT_OP_NEG:
000025A2  21FC 00002840 1252      1901      MOVE.L #P_OP_NEG, STRING_BUFFER_POINTER
000025AA  4EB8 24C0               1902      JSR PRINT_TO_BUFFER
000025AE  4EB9 00002780           1903      JSR PRINT_OP_SIZE
000025B4  4E75                    1904      RTS
000025B6                          1905  PRINT_OP_MOVEM_W:
000025B6  21FC 0000280C 1252      1906      MOVE.L #P_OP_MOVEM_W, STRING_BUFFER_POINTER
000025BE  4EB8 24C0               1907      JSR PRINT_TO_BUFFER
000025C2  4E75                    1908      RTS
000025C4                          1909  PRINT_OP_MOVEM_L:
000025C4  21FC 00002818 1252      1910      MOVE.L #P_OP_MOVEM_L, STRING_BUFFER_POINTER
000025CC  4EB8 24C0               1911      JSR PRINT_TO_BUFFER
000025D0  4E75                    1912      RTS
000025D2                          1913      
000025D2                          1914  PRINT_OP_SUBQ:
000025D2  21FC 00002847 1252      1915      MOVE.L #P_OP_SUBQ, STRING_BUFFER_POINTER
000025DA  4EB8 24C0               1916      JSR PRINT_TO_BUFFER
000025DE  4EB9 00002780           1917      JSR PRINT_OP_SIZE
000025E4  4E75                    1918      RTS
000025E6                          1919  
000025E6                          1920  PRINT_OP_BCS:
000025E6  21FC 00002856 1252      1921      MOVE.L #P_OP_BCS, STRING_BUFFER_POINTER
000025EE  4EB8 24C0               1922      JSR PRINT_TO_BUFFER
000025F2  4EB9 00002780           1923      JSR PRINT_OP_SIZE
000025F8  4E75                    1924      RTS
000025FA                          1925  PRINT_OP_BGE:
000025FA  21FC 0000285D 1252      1926      MOVE.L #P_OP_BGE, STRING_BUFFER_POINTER
00002602  4EB8 24C0               1927      JSR PRINT_TO_BUFFER
00002606  4EB9 00002780           1928      JSR PRINT_OP_SIZE
0000260C  4E75                    1929      RTS
0000260E                          1930  PRINT_OP_BLT:
0000260E  21FC 00002864 1252      1931      MOVE.L #P_OP_BLT, STRING_BUFFER_POINTER
00002616  4EB8 24C0               1932      JSR PRINT_TO_BUFFER
0000261A  4EB9 00002780           1933      JSR PRINT_OP_SIZE
00002620  4E75                    1934      RTS
00002622                          1935  PRINT_OP_BVC:
00002622  21FC 0000286B 1252      1936      MOVE.L #P_OP_BVC, STRING_BUFFER_POINTER
0000262A  4EB8 24C0               1937      JSR PRINT_TO_BUFFER
0000262E  4EB9 00002780           1938      JSR PRINT_OP_SIZE
00002634  4E75                    1939      RTS
00002636                          1940  PRINT_OP_BRA:
00002636  21FC 0000284F 1252      1941      MOVE.L #P_OP_BRA, STRING_BUFFER_POINTER
0000263E  4EB8 24C0               1942      JSR PRINT_TO_BUFFER
00002642  4EB9 00002780           1943      JSR PRINT_OP_SIZE
00002648  4E75                    1944      RTS
0000264A                          1945  
0000264A                          1946  
0000264A                          1947  PRINT_OP_DIVS:
0000264A  21FC 00002872 1252      1948      MOVE.L #P_OP_DIVS, STRING_BUFFER_POINTER
00002652  4EB8 24C0               1949      JSR PRINT_TO_BUFFER
00002656  4E75                    1950      RTS
00002658                          1951  PRINT_OP_OR:
00002658  21FC 0000287D 1252      1952      MOVE.L #P_OP_OR, STRING_BUFFER_POINTER
00002660  4EB8 24C0               1953      JSR PRINT_TO_BUFFER
00002664  4EB9 00002780           1954      JSR PRINT_OP_SIZE
0000266A  4E75                    1955      RTS
0000266C                          1956  
0000266C                          1957  PRINT_OP_SUB:
0000266C  21FC 00002883 1252      1958      MOVE.L #P_OP_SUB, STRING_BUFFER_POINTER
00002674  4EB8 24C0               1959      JSR PRINT_TO_BUFFER
00002678  4EB9 00002780           1960      JSR PRINT_OP_SIZE
0000267E  4E75                    1961      RTS
00002680                          1962  
00002680                          1963  
00002680                          1964  PRINT_OP_EOR:
00002680  21FC 0000288A 1252      1965      MOVE.L #P_OP_EOR, STRING_BUFFER_POINTER
00002688  4EB8 24C0               1966      JSR PRINT_TO_BUFFER
0000268C  4EB9 00002780           1967      JSR PRINT_OP_SIZE
00002692  4E75                    1968      RTS
00002694                          1969  PRINT_OP_CMP:
00002694  21FC 00002891 1252      1970      MOVE.L #P_OP_CMP, STRING_BUFFER_POINTER
0000269C  4EB8 24C0               1971      JSR PRINT_TO_BUFFER
000026A0  4EB9 00002780           1972      JSR PRINT_OP_SIZE
000026A6  4E75                    1973      RTS
000026A8                          1974  
000026A8                          1975  PRINT_OP_MULS:
000026A8  21FC 00002898 1252      1976      MOVE.L #P_OP_MULS, STRING_BUFFER_POINTER
000026B0  4EB8 24C0               1977      JSR PRINT_TO_BUFFER
000026B4  4E75                    1978      RTS
000026B6                          1979  
000026B6                          1980  PRINT_OP_ADD:
000026B6  21FC 000028AB 1252      1981      MOVE.L #P_OP_ADD, STRING_BUFFER_POINTER
000026BE  4EB8 24C0               1982      JSR PRINT_TO_BUFFER
000026C2  4EB9 00002780           1983      JSR PRINT_OP_SIZE
000026C8  4E75                    1984      RTS
000026CA                          1985  PRINT_OP_ADDA:
000026CA  21FC 000028A3 1252      1986      MOVE.L #P_OP_ADDA, STRING_BUFFER_POINTER
000026D2  4EB8 24C0               1987      JSR PRINT_TO_BUFFER
000026D6  4EB9 0000279A           1988      JSR PRINT_OP_SIZE_ADDA
000026DC  4E75                    1989      RTS
000026DE                          1990  
000026DE                          1991  
000026DE                          1992  PRINT_OP_LSL:
000026DE  21FC 000028B9 1252      1993      MOVE.L #P_OP_LSL, STRING_BUFFER_POINTER
000026E6  4EB8 24C0               1994      JSR PRINT_TO_BUFFER
000026EA  4EB9 00002780           1995      JSR PRINT_OP_SIZE
000026F0  4E75                    1996      RTS
000026F2                          1997  PRINT_OP_LSR:
000026F2  21FC 000028B2 1252      1998      MOVE.L #P_OP_LSR, STRING_BUFFER_POINTER
000026FA  4EB8 24C0               1999      JSR PRINT_TO_BUFFER
000026FE  4EB9 00002780           2000      JSR PRINT_OP_SIZE
00002704  4E75                    2001      RTS
00002706                          2002  PRINT_OP_ASR:
00002706  21FC 000028C0 1252      2003      MOVE.L #P_OP_ASR, STRING_BUFFER_POINTER
0000270E  4EB8 24C0               2004      JSR PRINT_TO_BUFFER
00002712  4EB9 00002780           2005      JSR PRINT_OP_SIZE
00002718  4E75                    2006      RTS
0000271A                          2007  PRINT_OP_ASL:
0000271A  21FC 000028C7 1252      2008      MOVE.L #P_OP_ASL, STRING_BUFFER_POINTER
00002722  4EB8 24C0               2009      JSR PRINT_TO_BUFFER
00002726  4EB9 00002780           2010      JSR PRINT_OP_SIZE
0000272C  4E75                    2011      RTS
0000272E                          2012  PRINT_OP_ROL:
0000272E  21FC 000028D5 1252      2013      MOVE.L #P_OP_ROL, STRING_BUFFER_POINTER
00002736  4EB8 24C0               2014      JSR PRINT_TO_BUFFER
0000273A  4EB9 00002780           2015      JSR PRINT_OP_SIZE
00002740  4E75                    2016      RTS
00002742                          2017  PRINT_OP_ROR:
00002742  21FC 000028CE 1252      2018      MOVE.L #P_OP_ROR, STRING_BUFFER_POINTER
0000274A  4EB8 24C0               2019      JSR PRINT_TO_BUFFER
0000274E  4EB9 00002780           2020      JSR PRINT_OP_SIZE
00002754  4E75                    2021      RTS
00002756                          2022  
00002756                          2023  
00002756                          2024  PRINT_SIZE_BYTE:
00002756  21FC 000027B0 1252      2025      MOVE.L #P_SIZE_B, STRING_BUFFER_POINTER
0000275E  4EB8 24C0               2026      JSR PRINT_TO_BUFFER
00002762  4E75                    2027      RTS    
00002764                          2028  
00002764                          2029  PRINT_SIZE_WORD:
00002764  21FC 000027B4 1252      2030      MOVE.L #P_SIZE_W, STRING_BUFFER_POINTER
0000276C  4EB8 24C0               2031      JSR PRINT_TO_BUFFER
00002770  4E75                    2032      RTS
00002772                          2033      
00002772                          2034  PRINT_SIZE_LONG:
00002772  21FC 000027B8 1252      2035      MOVE.L #P_SIZE_L, STRING_BUFFER_POINTER
0000277A  4EB8 24C0               2036      JSR PRINT_TO_BUFFER
0000277E  4E75                    2037      RTS
00002780                          2038  
00002780                          2039  PRINT_OP_SIZE:                      ;Prints current OP code byte size if applicable
00002780  0C38 0000 1738          2040      CMP.B  #%00,OP_SIZE             ;Checks for byte size
00002786  67CE                    2041      BEQ    PRINT_SIZE_BYTE          ;Print .B to buffer
00002788  0C38 0001 1738          2042      CMP.B  #%01,OP_SIZE             ;Check for word size
0000278E  67D4                    2043      BEQ    PRINT_SIZE_WORD          ;Print .W to buffer
00002790  0C38 0002 1738          2044      CMP.B  #%10,OP_SIZE             ;Check for long size
00002796  67DA                    2045      BEQ    PRINT_SIZE_LONG          ;Print .L to buffer
00002798  4E75                    2046      RTS
0000279A                          2047      
0000279A                          2048  PRINT_OP_SIZE_ADDA:                 ;Special  print for ADDA
0000279A  0C38 0000 1738          2049      CMP.B #%0,OP_SIZE               ;Checks if the OP_SIZE is 0
000027A0  67C2                    2050      BEQ    PRINT_SIZE_WORD          ;If it is the size is word
000027A2  66CE                    2051      BNE    PRINT_SIZE_LONG          ;If it's not the size is long
000027A4                          2052      
000027A4                          2053  
000027A4                          2054  
000027A4                          2055  
000027A4                          2056  
000027A4= 20 20 20 44 41 54 ...   2057  P_INVALID_OP    DC.B    '   DATA   $',0
000027B0= 2E 42 20 00             2058  P_SIZE_B        DC.B    '.B ',0
000027B4= 2E 57 20 00             2059  P_SIZE_W        DC.B    '.W ',0
000027B8= 2E 4C 20 00             2060  P_SIZE_L        DC.B    '.L ',0
000027BC= 20 20 20 4F 52 49 00    2061  P_OP_ORI        DC.B    '   ORI',0
000027C3= 20 20 20 43 4D 50 ...   2062  P_OP_CMPI       DC.B    '   CMPI',0
000027CB= 20 20 20 42 43 4C ...   2063  P_OP_BCLR       DC.B    '   BCLR',0
000027D3= 20 20 20 4D 4F 56 ...   2064  P_OP_MOVEB      DC.B    '   MOVE.B ',0
000027DE= 20 20 20 4D 4F 56 ...   2065  P_OP_MOVEA_L    DC.B    '   MOVEA.L ',0 
000027EA= 20 20 20 4D 4F 56 ...   2066  P_OP_MOVE_L     DC.B    '   MOVE.L ',0
000027F5= 20 20 20 4D 4F 56 ...   2067  P_OP_MOVEA_W    DC.B    '   MOVEA.W ',0
00002801= 20 20 20 4D 4F 56 ...   2068  P_OP_MOVE_W     DC.B    '   MOVE.W ',0
0000280C= 20 20 20 4D 4F 56 ...   2069  P_OP_MOVEM_W    DC.B    '   MOVEM.W ',0
00002818= 20 20 20 4D 4F 56 ...   2070  P_OP_MOVEM_L    DC.B    '   MOVEM.L ',0
00002824= 20 20 20 4C 45 41 00    2071  P_OP_LEA        DC.B    '   LEA',0
0000282B= 20 20 20 4A 53 52 00    2072  P_OP_JSR        DC.B    '   JSR',0
00002832= 20 20 20 4E 4F 50 00    2073  P_OP_NOP        DC.B    '   NOP',0
00002839= 20 20 20 52 54 53 00    2074  P_OP_RTS        DC.B    '   RTS',0
00002840= 20 20 20 4E 45 47 00    2075  P_OP_NEG        DC.B    '   NEG',0
00002847= 20 20 20 53 55 42 ...   2076  P_OP_SUBQ       DC.B    '   SUBQ',0
0000284F= 20 20 20 42 52 41 00    2077  P_OP_BRA        DC.B    '   BRA',0
00002856= 20 20 20 42 43 53 00    2078  P_OP_BCS        DC.B    '   BCS',0
0000285D= 20 20 20 42 47 45 00    2079  P_OP_BGE        DC.B    '   BGE',0
00002864= 20 20 20 42 4C 54 00    2080  P_OP_BLT        DC.B    '   BLT',0
0000286B= 20 20 20 42 56 43 00    2081  P_OP_BVC        DC.B    '   BVC',0
00002872= 20 20 20 44 49 56 ...   2082  P_OP_DIVS       DC.B    '   DIVS.W ',0
0000287D= 20 20 20 4F 52 00       2083  P_OP_OR         DC.B    '   OR',0
00002883= 20 20 20 53 55 42 00    2084  P_OP_SUB        DC.B    '   SUB',0
0000288A= 20 20 20 45 4F 52 00    2085  P_OP_EOR        DC.B    '   EOR',0
00002891= 20 20 20 43 4D 50 00    2086  P_OP_CMP        DC.B    '   CMP',0
00002898= 20 20 20 4D 55 4C ...   2087  P_OP_MULS       DC.B    '   MULS.W ',0
000028A3= 20 20 20 41 44 44 ...   2088  P_OP_ADDA       DC.B    '   ADDA',0
000028AB= 20 20 20 41 44 44 00    2089  P_OP_ADD        DC.B    '   ADD',0
000028B2= 20 20 20 4C 53 52 00    2090  P_OP_LSR        DC.B    '   LSR',0
000028B9= 20 20 20 4C 53 4C 00    2091  P_OP_LSL        DC.B    '   LSL',0
000028C0= 20 20 20 41 53 52 00    2092  P_OP_ASR        DC.B    '   ASR',0
000028C7= 20 20 20 41 53 4C 00    2093  P_OP_ASL        DC.B    '   ASL',0
000028CE= 20 20 20 52 4F 52 00    2094  P_OP_ROR        DC.B    '   ROR',0
000028D5= 20 20 20 52 4F 4C 00    2095  P_OP_ROL        DC.B    '   ROL',0
000028DC                          2096  
000028DC                          2097  
000028DC                          2098  
000028DC                          2099  
000028DC                          2100  
000028DC                          2101  
000028DC                          2102  -------------------- end include --------------------
000028DC                          2103      INCLUDE "EA_Integrated.x68"                         ;EA role code to include
000028DC                          2104  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028DC                          2105  
000028DC                          2106  
000028DC= 41                      2107  ADDRESS         DC.B    $41
000028DD= 44                      2108  DATA            DC.B    $44
000028DE                          2109  
000028DE= 28                      2110  PTHSIS_OPEN     DC.B    $28
000028DF= 29                      2111  PTHSIS_CLSD     DC.B    $29
000028E0= 24                      2112  HEX_SIGN        DC.B    $24
000028E1= 23                      2113  IMMDTE_VALU     DC.B    $23
000028E2= 2B                      2114  PLUS_SIGN       DC.B    $2B
000028E3= 2D                      2115  MINUS_SIGN      DC.B    $2D
000028E4                          2116  
000028E4= 2C                      2117  COMMA           DC.B    $2C
000028E5= 20                      2118  SPACE           DC.B    $20
000028E6                          2119  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028E6                          2120  
000028E6                          2121  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
000028E6                          2122  TRAILING_SIZE   DS.W    1 * Size of any immediate or
000028E8                          2123                            * address values. Immediate or address
000028E8                          2124                            * value of a BYTE is still processed as
000028E8                          2125                            * WORD because the trailing bytes
000028E8                          2126                            * are represented as a word regardless.
000028E8                          2127                            * $1 = BYTE, $2 = WORD, $4 = LONG
000028E8                          2128                            
000028E8                          2129  X               DS.B    1
000028E9                          2130  Y               DS.B    1 * always X -> Y
000028EA                          2131  X_COUNTER       DS.B    1
000028EB                          2132  Y_COUNTER       DS.B    1
000028EC                          2133  FIRST_X         DS.B    1 * 0: it is first X
000028ED                          2134                            * 1: it is second X
000028ED                          2135  FIRST_Y         DS.B    1 * 0: it is first Y
000028EE                          2136                            * 1: it is second Y
000028EE                          2137  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028EE                          2138  
000028EE                          2139  main_EA:
000028EE  4EB8 1924               2140      JSR PARSE_EA_CONSTANT_BITS    
000028F2                          2141  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028F2                          2142  
000028F2                          2143  
000028F2                          2144  
000028F2                          2145  
000028F2                          2146  
000028F2                          2147  
000028F2                          2148  
000028F2                          2149  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
000028F2                          2150  
000028F2  4EB9 000028FC           2151      JSR     CHECK_XXXX
000028F8                          2152  EXT                        * Main EXT alias to finish routine
000028F8  4EF8 11C2               2153      JMP check_print 
000028FC                          2154  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028FC                          2155  
000028FC                          2156  CHECK_XXXX:
000028FC  0C38 0008 1739          2157      CMPI.B  #$8, MNEMONIC
00002902  6D00 0008               2158      BLT     CHECK_0XXX
00002906  4EF9 0000291C           2159      JMP     CHECK_1XXX
0000290C                          2160  
0000290C                          2161  CHECK_0XXX:
0000290C  0C38 0004 1739          2162      CMPI.B  #$4, MNEMONIC
00002912  6D00 004C               2163      BLT     CHECK_00XX
00002916  4EF9 0000296E           2164      JMP     CHECK_01XX
0000291C                          2165  
0000291C                          2166  CHECK_1XXX:
0000291C  0C38 0008 1739          2167      CMPI.B  #$8, MNEMONIC
00002922  6700 0308               2168      BEQ     LOAD_1000
00002926  0C38 0009 1739          2169      CMPI.B  #$9, MNEMONIC
0000292C  6700 02F8               2170      BEQ     LOAD_1001
00002930  0C38 000B 1739          2171      CMPI.B  #$B, MNEMONIC
00002936  6700 02E8               2172      BEQ     LOAD_1011
0000293A  0C38 000C 1739          2173      CMPI.B  #$C, MNEMONIC
00002940  6700 02D8               2174      BEQ     LOAD_1100
00002944  0C38 000D 1739          2175      CMPI.B  #$D, MNEMONIC
0000294A  6700 026C               2176      BEQ     LOAD_1101
0000294E  0C38 000E 1739          2177      CMPI.B  #$E, MNEMONIC
00002954  6700 0038               2178      BEQ     LOAD_1110
00002958                          2179      
00002958  4EF9 000036D6           2180      JMP     INVALID
0000295E                          2181      
0000295E  4E75                    2182      RTS
00002960                          2183  
00002960                          2184  CHECK_00XX:
00002960  0C38 0001 1739          2185      CMPI.B  #$1, MNEMONIC
00002966  6D00 0970               2186      BLT     LOAD_0000
0000296A  6C00 0AF2               2187      BGE     LOAD_00XX
0000296E                          2188  
0000296E                          2189  CHECK_01XX:
0000296E  0C38 0004 1739          2190      CMPI.B  #%0100, MNEMONIC
00002974  6700 0458               2191      BEQ     LOAD_0100
00002978  0C38 0005 1739          2192      CMPI.B  #%0101, MNEMONIC
0000297E  6700 03C4               2193      BEQ     LOAD_0101
00002982  0C38 0006 1739          2194      CMPI.B  #%0110, MNEMONIC
00002988  6700 0124               2195      BEQ     LOAD_0110
0000298C  4E75                    2196      RTS
0000298E                          2197  
0000298E                          2198  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000298E                          2199  
0000298E                          2200  
0000298E                          2201  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000298E                          2202  
0000298E                          2203  LOAD_1110:
0000298E  247C 00000000           2204              MOVEA.L #0, A2
00002994  267C 00000000           2205              MOVEA.L #0, A3
0000299A  4285                    2206              CLR.L   D5
0000299C                          2207      
0000299C  1A38 173B               2208              MOVE.B  SECOND_3, D5
000029A0  0205 0003               2209              ANDI.B  #%011, D5
000029A4                          2210      
000029A4  0C05 0003               2211              CMPI.B  #%11, D5
000029A8  6700 0006               2212              BEQ     MYBE_ASd_1
000029AC  6600 0068               2213              BNE     MYBE_ASd_2
000029B0                          2214  
000029B0  0C38 0000 173A          2215  MYBE_ASd_1  CMPI.B  #%000, FIRST_3
000029B6  6700 001C               2216              BEQ     ASd_1
000029BA  0C38 0001 173A          2217              CMPI.B  #%001, FIRST_3
000029C0  6700 0012               2218              BEQ     ASd_1 * LSd
000029C4  0C38 0003 173A          2219              CMPI.B  #%011, FIRST_3
000029CA  6700 0008               2220              BEQ     ASd_1 * ROd
000029CE  4EF9 000036D6           2221              JMP     INVALID
000029D4                          2222  
000029D4  0C38 0007 173C          2223  ASd_1       CMPI.B  #%111, THIRD_3
000029DA  6600 000C               2224              BNE     MOVEON  
000029DE  0C38 0004 173D          2225              CMPI.B  #%100, FOURTH_3
000029E4  6700 0CF0               2226              BEQ     INVALID
000029E8                          2227  
000029E8  367C 2A00               2228  MOVEON      MOVEA.W #ASd_1_BACK, A3           
000029EC  0C38 0000 173D          2229              CMPI.B  #%000, FOURTH_3
000029F2  6700 0B7A               2230              BEQ     SIZE_W
000029F6  0C38 0001 173D          2231              CMPI.B  #%001, FOURTH_3
000029FC  6700 0B78               2232              BEQ     SIZE_L
00002A00                          2233  
00002A00  1638 173C               2234  ASd_1_BACK  MOVE.B  THIRD_3, D3
00002A04  1438 173D               2235              MOVE.B  FOURTH_3, D2
00002A08                          2236              
00002A08  4EB9 000034C2           2237              JSR     LOAD_EA
00002A0E  4EB9 00003624           2238              JSR     LOAD_NEW_LINE
00002A14  4E75                    2239              RTS
00002A16                          2240  
00002A16  4285                    2241  MYBE_ASd_2  CLR.L   D5
00002A18                          2242  
00002A18  1A38 173C               2243              MOVE.B  THIRD_3, D5
00002A1C  0205 0003               2244              ANDI.B  #%011, D5
00002A20  0C05 0002               2245              CMPI.B  #%10, D5
00002A24  6600 0006               2246              BNE     ASd_2 * or LSd or ROd
00002A28  6700 0CAC               2247              BEQ     INVALID
00002A2C                          2248              
00002A2C  4285                    2249  ASd_2       CLR.L   D5
00002A2E                          2250  
00002A2E  1A38 173C               2251              MOVE.B  THIRD_3, D5
00002A32  0205 0004               2252              ANDI.B  #%100, D5
00002A36  0C05 0004               2253              CMPI.B  #%100, D5
00002A3A  6700 0048               2254              BEQ     ASd_2_REG
00002A3E  6600 0002               2255              BNE     ASd_2_IMD
00002A42                          2256              
00002A42  347C 2A68               2257  ASd_2_IMD   MOVEA.W #ASd_2_IMD_B, A2
00002A46  0C38 0000 173A          2258              CMPI.B  #%000, FIRST_3
00002A4C  6700 0006               2259              BEQ     LOAD_8
00002A50  6600 000C               2260              BNE     LOAD_FIRST3
00002A54                          2261              
00002A54  183C 0008               2262  LOAD_8      MOVE.B  #8, D4
00002A58  4EF9 000035F0           2263              JMP     LOAD_IMMDTE
00002A5E                          2264  
00002A5E  1838 173A               2265  LOAD_FIRST3 MOVE.B  FIRST_3, D4
00002A62  4EF9 000035F0           2266              JMP     LOAD_IMMDTE
00002A68                          2267  
00002A68  4EB9 00003626           2268  ASd_2_IMD_B JSR     LOAD_COMMA_SPACE
00002A6E                          2269  
00002A6E  163C 0000               2270              MOVE.B  #%000, D3
00002A72  1438 173D               2271              MOVE.B  FOURTH_3, D2
00002A76                          2272              
00002A76  4EB9 000034C2           2273              JSR     LOAD_EA
00002A7C  4EB9 00003624           2274              JSR     LOAD_NEW_LINE
00002A82  4E75                    2275              RTS
00002A84                          2276  
00002A84  163C 0000               2277  ASd_2_REG   MOVE.B  #%000, D3
00002A88  1438 173A               2278              MOVE.B  FIRST_3, D2
00002A8C                          2279              
00002A8C  4EB9 000034C2           2280              JSR     LOAD_EA
00002A92  4EB9 00003626           2281              JSR     LOAD_COMMA_SPACE
00002A98                          2282              
00002A98  163C 0000               2283              MOVE.B  #%000, D3
00002A9C  1438 173D               2284              MOVE.B  FOURTH_3, D2
00002AA0                          2285              
00002AA0  4EB9 000034C2           2286              JSR     LOAD_EA
00002AA6  4EB9 00003624           2287              JSR     LOAD_NEW_LINE
00002AAC  4E75                    2288              RTS
00002AAE                          2289  
00002AAE                          2290  
00002AAE                          2291  
00002AAE                          2292  LOAD_0110:
00002AAE  247C 00000000           2293              MOVEA.L #0, A2
00002AB4  267C 00000000           2294              MOVEA.L #0, A3
00002ABA  4285                    2295              CLR.L   D5
00002ABC  4286                    2296              CLR.L   D6
00002ABE  4284                    2297              CLR.L   D4
00002AC0                          2298  
00002AC0  0C38 0000 173A          2299              CMPI.B  #%000, FIRST_3
00002AC6  6700 0006               2300              BEQ     MYBE_BRA
00002ACA  6600 0010               2301              BNE     NOT_BRA
00002ACE  0C38 0004 173B          2302  MYBE_BRA    CMPI.B  #%100, SECOND_3
00002AD4  6D00 003A               2303              BLT     BRA
00002AD8  6C00 0002               2304              BGE     NOT_BRA
00002ADC                          2305              
00002ADC  1A38 173A               2306  NOT_BRA     MOVE.B  FIRST_3, D5
00002AE0  E305                    2307              ASL.B   #1, D5
00002AE2  1C38 173B               2308              MOVE.B  SECOND_3, D6
00002AE6  E406                    2309              ASR.B   #2, D6
00002AE8  DA06                    2310              ADD.B   D6, D5
00002AEA                          2311              
00002AEA  0C05 0005               2312              CMPI.B  #%0101, D5
00002AEE  6700 0020               2313              BEQ     BRA * CS
00002AF2  0C05 0008               2314              CMPI.B  #%1000, D5
00002AF6  6700 0018               2315              BEQ     BRA * VC
00002AFA  0C05 000C               2316              CMPI.B  #%1100, D5
00002AFE  6700 0010               2317              BEQ     BRA * GE
00002B02  0C05 000D               2318              CMPI.B  #%1101, D5
00002B06  6700 0008               2319              BEQ     BRA * LT
00002B0A                          2320              
00002B0A  4EF9 000036D6           2321              JMP     INVALID
00002B10                          2322              
00002B10                          2323              
00002B10  4285                    2324  BRA         CLR.L   D5
00002B12  4286                    2325              CLR.L   D6
00002B14                          2326  
00002B14  3A0D                    2327              MOVE.W  A5, D5 * D5 has $1002 (Starting + MNEMONICS)
00002B16  3C38 10A0               2328              MOVE.W  CUR_OP_CODE, D6
00002B1A  0246 00FF               2329              ANDI.W  #$00FF, D6 * D6 now has $E
00002B1E  0C06 0000               2330              CMPI.B  #$00, D6
00002B22  6700 0052               2331              BEQ     BRA_WORD * word. there is 4 hex trailing bits (word)
00002B26                          2332  
00002B26  0C06 00FF               2333              CMPI.B  #$FF, D6
00002B2A  6700 0010               2334              BEQ     BRA_BYTE
00002B2E  0C06 00FE               2335              CMPI.B  #$FE, D6
00002B32  6700 0008               2336              BEQ     BRA_BYTE
00002B36                          2337  
00002B36  4EF9 000036D6           2338              JMP     INVALID
00002B3C                          2339              
00002B3C  0C06 00FE               2340  BRA_BYTE    CMPI.B  #$FE, D6
00002B40  6700 0010               2341              BEQ     DOWN_ZERO
00002B44  0C06 00FF               2342              CMPI.B  #$FF, D6
00002B48  6700 0010               2343              BEQ     DOWN_ONE
00002B4C                          2344              
00002B4C  4EF9 000036D6           2345              JMP     INVALID
00002B52                          2346              
00002B52  5505                    2347  DOWN_ZERO   SUBI.B  #$2, D5 * D5 has $1000 (Starting)
00002B54  4EF9 00002B62           2348              JMP     BRA_BYTE2
00002B5A                          2349              
00002B5A  5305                    2350  DOWN_ONE    SUBI.B  #$1, D5 * D5 has $1001 (Starting + 1)
00002B5C  4EF9 00002B62           2351              JMP     BRA_BYTE2
00002B62                          2352              
00002B62  347C 2B6E               2353  BRA_BYTE2   MOVE.W  #BRA_BYTE3, A2
00002B66  3805                    2354              MOVE.W  D5, D4
00002B68  4EF9 000035CC           2355              JMP     LOAD_ABS_SHORT
00002B6E  4EB9 00003624           2356  BRA_BYTE3   JSR     LOAD_NEW_LINE
00002B74  4E75                    2357              RTS
00002B76                          2358  
00002B76  381D                    2359  BRA_WORD    MOVE.W  (A5)+, D4 * D4 now has $000E
00002B78                          2360  
00002B78  0C84 00008000           2361              CMPI.L  #$8000, D4
00002B7E  6C00 001A               2362              BGE     NEG_WORD
00002B82  6D00 0002               2363              BLT     POS_WORD
00002B86                          2364              
00002B86  347C 2B92               2365  POS_WORD    MOVE.W  #BRA_WORD_BK, A2
00002B8A  D845                    2366              ADD.W   D5, D4 * D4 now has $100E
00002B8C  4EF9 000035CC           2367              JMP     LOAD_ABS_SHORT
00002B92  4EB9 00003624           2368  BRA_WORD_BK JSR     LOAD_NEW_LINE
00002B98  4E75                    2369              RTS
00002B9A                          2370  
00002B9A  347C 2BB0               2371  NEG_WORD    MOVE.W  #BRA_WRD_BK2, A2
00002B9E  4444                    2372              NEG     D4
00002BA0                          2373              
00002BA0  B885                    2374              CMP.L   D5, D4 * $4002 vs DISPLACEMENT
00002BA2  6E00 0B32               2375              BGT     INVALID
00002BA6                          2376              
00002BA6  9A44                    2377              SUB.W   D4, D5 * D5 now has $1000 - 2cmp'ed $000E
00002BA8  3805                    2378              MOVE.W  D5, D4
00002BAA  4EF9 000035CC           2379              JMP     LOAD_ABS_SHORT
00002BB0  4EB9 00003624           2380  BRA_WRD_BK2 JSR     LOAD_NEW_LINE
00002BB6  4E75                    2381              RTS
00002BB8                          2382  
00002BB8                          2383  
00002BB8                          2384  
00002BB8                          2385  LOAD_1101:
00002BB8  0C38 0003 173B          2386              CMPI.B  #%011, SECOND_3
00002BBE  6700 0012               2387              BEQ     ADDA
00002BC2  0C38 0007 173B          2388              CMPI.B  #%111, SECOND_3
00002BC8  6700 0008               2389              BEQ     ADDA
00002BCC                          2390              
00002BCC  4EF9 00002C2C           2391              JMP     LOAD_1000
00002BD2                          2392              
00002BD2  367C 2BF0               2393  ADDA        MOVEA.W #ADDA_BACK, A3
00002BD6  4281                    2394              CLR.L   D1
00002BD8  1238 173B               2395              MOVE.B  SECOND_3, D1
00002BDC  0201 0004               2396              ANDI.B  #%100, D1
00002BE0                          2397              
00002BE0  0C01 0000               2398              CMPI.B  #%000, D1
00002BE4  6700 0988               2399              BEQ     SIZE_W
00002BE8  0C01 0004               2400              CMPI.B  #%100, D1
00002BEC  6700 0988               2401              BEQ     SIZE_L
00002BF0                          2402              
00002BF0  1638 173C               2403  ADDA_BACK   MOVE.B  THIRD_3, D3
00002BF4  1438 173D               2404              MOVE.B  FOURTH_3, D2
00002BF8                          2405  
00002BF8  4EB9 000034C2           2406              JSR     LOAD_EA
00002BFE  4EB9 00003626           2407              JSR     LOAD_COMMA_SPACE
00002C04                          2408              
00002C04  163C 0001               2409              MOVE.B  #%001, D3
00002C08  1438 173A               2410              MOVE.B  FIRST_3, D2
00002C0C                          2411              
00002C0C  4EB9 000034C2           2412              JSR     LOAD_EA
00002C12  4EB9 00003624           2413              JSR     LOAD_NEW_LINE
00002C18  4E75                    2414              RTS
00002C1A                          2415  
00002C1A                          2416  LOAD_1100:
00002C1A  4EF9 00002C2C           2417      JMP     LOAD_1000
00002C20                          2418      
00002C20                          2419  LOAD_1011:
00002C20  4EF9 00002C2C           2420      JMP     LOAD_1000
00002C26                          2421  
00002C26                          2422  
00002C26                          2423  LOAD_1001:
00002C26  4EF9 00002C2C           2424      JMP     LOAD_1000
00002C2C                          2425  
00002C2C                          2426  
00002C2C                          2427  LOAD_1000:
00002C2C  4283                    2428              CLR.L   D3
00002C2E  4282                    2429              CLR.L   D2
00002C30  267C 00000000           2430              MOVEA.L #0, A3
00002C36                          2431              
00002C36  0C38 0007 173B          2432              CMPI.B  #%111, SECOND_3
00002C3C  6700 00BA               2433              BEQ     DIVS
00002C40                          2434              
00002C40  0C38 0003 173B          2435              CMPI.B  #%011, SECOND_3
00002C46  6700 0A8E               2436              BEQ     INVALID
00002C4A                          2437              
00002C4A  0C38 0004 173B          2438              CMPI.B  #%100, SECOND_3
00002C50  6D00 0006               2439              BLT     DIR_0 * direction bit 0
00002C54  6C00 0052               2440              BGE     DIR_1 * direction bit 1
00002C58                          2441              
00002C58  4281                    2442  DIR_0       CLR.L   D1
00002C5A  1238 173B               2443              MOVE.B  SECOND_3, D1
00002C5E  0201 0003               2444              ANDI.B  #%011, D1
00002C62                          2445      
00002C62  367C 2C7E               2446              MOVEA.W #OR_BACK, A3
00002C66  0C01 0000               2447              CMPI.B  #%00, D1
00002C6A  6700 08FA               2448              BEQ     SIZE_B
00002C6E  0C01 0001               2449              CMPI.B  #%01, D1
00002C72  6700 08FA               2450              BEQ     SIZE_W
00002C76  0C01 0002               2451              CMPI.B  #%10, D1
00002C7A  6700 08FA               2452              BEQ     SIZE_L
00002C7E                          2453              
00002C7E  1638 173C               2454  OR_BACK     MOVE.B  THIRD_3, D3
00002C82  1438 173D               2455              MOVE.B  FOURTH_3, D2
00002C86                          2456  
00002C86  4EB9 000034C2           2457              JSR     LOAD_EA
00002C8C  4EB9 00003626           2458              JSR     LOAD_COMMA_SPACE
00002C92                          2459              
00002C92  163C 0000               2460              MOVE.B  #%000, D3
00002C96  1438 173A               2461              MOVE.B  FIRST_3, D2
00002C9A                          2462              
00002C9A  4EB9 000034C2           2463              JSR     LOAD_EA
00002CA0  4EB9 00003624           2464              JSR     LOAD_NEW_LINE
00002CA6  4E75                    2465              RTS
00002CA8                          2466              
00002CA8  163C 0000               2467  DIR_1       MOVE.B  #%000, D3
00002CAC  1438 173A               2468              MOVE.B  FIRST_3, D2
00002CB0                          2469              
00002CB0  4EB9 000034C2           2470              JSR     LOAD_EA
00002CB6  4EB9 00003626           2471              JSR     LOAD_COMMA_SPACE
00002CBC                          2472              
00002CBC  4281                    2473              CLR.L   D1
00002CBE  1238 173B               2474              MOVE.B  SECOND_3, D1
00002CC2  0201 0003               2475              ANDI.B  #%011, D1
00002CC6                          2476      
00002CC6  367C 2CE2               2477              MOVEA.W #OR_BACK2, A3
00002CCA  0C01 0000               2478              CMPI.B  #%00, D1
00002CCE  6700 0896               2479              BEQ     SIZE_B
00002CD2  0C01 0001               2480              CMPI.B  #%01, D1
00002CD6  6700 0896               2481              BEQ     SIZE_W
00002CDA  0C01 0002               2482              CMPI.B  #%10, D1
00002CDE  6700 0896               2483              BEQ     SIZE_L
00002CE2                          2484              
00002CE2  1638 173C               2485  OR_BACK2    MOVE.B  THIRD_3, D3
00002CE6  1438 173D               2486              MOVE.B  FOURTH_3, D2
00002CEA                          2487  
00002CEA  4EB9 000034C2           2488              JSR     LOAD_EA
00002CF0  4EB9 00003624           2489              JSR     LOAD_NEW_LINE
00002CF6  4E75                    2490              RTS    
00002CF8                          2491              
00002CF8  367C 2D1A               2492  DIVS        MOVEA.W #DIVS_BACK, A3
00002CFC  0C38 0000 173D          2493              CMPI.B  #%000, FOURTH_3
00002D02  6700 086A               2494              BEQ     SIZE_W
00002D06  0C38 0001 173D          2495              CMPI.B  #%001, FOURTH_3
00002D0C  6700 09C8               2496              BEQ     INVALID
00002D10  0C38 0004 173D          2497              CMPI.B  #%100, FOURTH_3
00002D16  6700 0856               2498              BEQ     SIZE_W
00002D1A                          2499              
00002D1A  1638 173C               2500  DIVS_BACK   MOVE.B  THIRD_3, D3
00002D1E  1438 173D               2501              MOVE.B  FOURTH_3, D2
00002D22                          2502  
00002D22  4EB9 000034C2           2503              JSR     LOAD_EA
00002D28  4EB9 00003626           2504              JSR     LOAD_COMMA_SPACE
00002D2E                          2505  
00002D2E  163C 0000               2506              MOVE.B  #%000, D3
00002D32  1438 173A               2507              MOVE.B  FIRST_3, D2
00002D36                          2508  
00002D36  4EB9 000034C2           2509              JSR     LOAD_EA
00002D3C  4EB9 00003624           2510              JSR     LOAD_NEW_LINE
00002D42  4E75                    2511              RTS
00002D44                          2512  
00002D44                          2513  
00002D44                          2514  LOAD_0101:
00002D44  4283                    2515              CLR.L   D3
00002D46  4282                    2516              CLR.L   D2
00002D48  267C 00000000           2517              MOVEA.L #0, A3
00002D4E                          2518  
00002D4E  0C38 0007 173A          2519              CMPI.B  #%111, FIRST_3
00002D54  6F00 0008               2520              BLE     MYBE_SUBQ1
00002D58  4EF9 000036D6           2521              JMP     INVALID
00002D5E                          2522              
00002D5E  0C38 0003 173B          2523  MYBE_SUBQ1  CMPI.B  #%011, SECOND_3
00002D64  6E00 0008               2524              BGT     MYBE_SUBQ2
00002D68  4EF9 000036D6           2525              JMP     INVALID
00002D6E                          2526  
00002D6E  0C38 0007 173B          2527  MYBE_SUBQ2  CMPI.B  #%111, SECOND_3
00002D74  6D00 0008               2528              BLT     SUBQ
00002D78  4EF9 000036D6           2529              JMP     INVALID
00002D7E                          2530  
00002D7E  5238 173A               2531  SUBQ        ADDI.B  #%1, FIRST_3
00002D82  1838 173A               2532              MOVE.B  FIRST_3, D4
00002D86                          2533              
00002D86  347C 2D90               2534              MOVEA.W #SUBQ_SAVED, A2
00002D8A  4EF9 000035F0           2535              JMP     LOAD_IMMDTE
00002D90                          2536              
00002D90  4EB9 00003626           2537  SUBQ_SAVED  JSR     LOAD_COMMA_SPACE
00002D96                          2538  
00002D96  367C 2DB8               2539              MOVEA.W #SUBQ_BACK, A3
00002D9A  0C38 0004 173B          2540              CMPI.B  #%100, SECOND_3
00002DA0  6700 07C4               2541              BEQ     SIZE_B
00002DA4  0C38 0005 173B          2542              CMPI.B  #%101, SECOND_3
00002DAA  6700 07C2               2543              BEQ     SIZE_W
00002DAE  0C38 0006 173B          2544              CMPI.B  #%110, SECOND_3
00002DB4  6700 07C0               2545              BEQ     SIZE_L
00002DB8                          2546              
00002DB8  1638 173C               2547  SUBQ_BACK   MOVE.B  THIRD_3, D3
00002DBC  1438 173D               2548              MOVE.B  FOURTH_3, D2
00002DC0                          2549  
00002DC0  4EB9 000034C2           2550              JSR     LOAD_EA
00002DC6  4EB9 00003624           2551              JSR     LOAD_NEW_LINE
00002DCC  4E75                    2552              RTS
00002DCE                          2553  
00002DCE                          2554  LOAD_0100:
00002DCE  4283                    2555              CLR.L   D3
00002DD0  4282                    2556              CLR.L   D2
00002DD2  267C 00000000           2557              MOVEA.L #0, A3
00002DD8                          2558  
00002DD8  0C38 0002 173A          2559              CMPI.B  #%010, FIRST_3
00002DDE  6700 0006               2560              BEQ     MYBE_NEG
00002DE2  6600 000C               2561              BNE     NOT_NEG
00002DE6  0C38 0003 173B          2562  MYBE_NEG    CMPI.B  #%011, SECOND_3
00002DEC  6D00 008E               2563              BLT     NEG
00002DF0                          2564  
00002DF0  0C38 0007 173A          2565  NOT_NEG     CMPI.B  #%111, FIRST_3
00002DF6  6700 0006               2566              BEQ     MYBE_RTS1
00002DFA  6600 0032               2567              BNE     NOT_RTS
00002DFE  0C38 0001 173B          2568  MYBE_RTS1   CMPI.B  #%001, SECOND_3
00002E04  6700 0006               2569              BEQ     MYBE_RTS2
00002E08  6600 0024               2570              BNE     NOT_RTS
00002E0C  0C38 0006 173C          2571  MYBE_RTS2   CMPI.B  #%110, THIRD_3
00002E12  6700 0006               2572              BEQ     MYBE_RTS3
00002E16  6600 0016               2573              BNE     NOT_RTS
00002E1A  0C38 0005 173D          2574  MYBE_RTS3   CMPI.B  #%101, FOURTH_3
00002E20  6700 0092               2575              BEQ     RTS
00002E24  0C38 0001 173D          2576              CMPI.B  #%001, FOURTH_3 
00002E2A  6700 0088               2577              BEQ     RTS * It's actually NOP but it's the same shit in EA perspective
00002E2E                          2578              
00002E2E  0C38 0007 173A          2579  NOT_RTS     CMPI.B  #%111, FIRST_3
00002E34  6700 0006               2580              BEQ     MYBE_JSR
00002E38  6600 000C               2581              BNE     NOT_JSR
00002E3C  0C38 0002 173B          2582  MYBE_JSR    CMPI.B  #%010, SECOND_3
00002E42  6700 0078               2583              BEQ     JSR
00002E46                          2584  
00002E46  4286                    2585  NOT_JSR     CLR.L   D6
00002E48  1C38 173A               2586              MOVE.B  FIRST_3, D6
00002E4C  0206 0005               2587              ANDI.B  #%101, D6 * Making %1X0 -> %100
00002E50  0C06 0004               2588              CMPI.B  #%100, D6
00002E54  6700 0006               2589              BEQ     MYBE_MOVEM
00002E58  6600 0012               2590              BNE     NOT_MOVEM
00002E5C                          2591              
00002E5C  1C38 173B               2592  MYBE_MOVEM  MOVE.B  SECOND_3, D6
00002E60  0206 0006               2593              ANDI.B  #%110, D6
00002E64  0C06 0002               2594              CMPI.B  #%010, D6
00002E68  6700 0080               2595              BEQ     MOVEM
00002E6C                          2596              
00002E6C  0C38 0007 173B          2597  NOT_MOVEM   CMPI.B  #%111, SECOND_3
00002E72  6700 0084               2598              BEQ     LEA
00002E76                          2599              
00002E76  4EF9 000036D6           2600              JMP     INVALID
00002E7C                          2601  
00002E7C                          2602  NEG:
00002E7C  367C 2E9E               2603              MOVEA.W #NEG_BACK, A3
00002E80  0C38 0000 173B          2604              CMPI.B  #%000, SECOND_3
00002E86  6700 06DE               2605              BEQ     SIZE_B
00002E8A  0C38 0001 173B          2606              CMPI.B  #%001, SECOND_3
00002E90  6700 06DC               2607              BEQ     SIZE_W
00002E94  0C38 0002 173B          2608              CMPI.B  #%010, SECOND_3
00002E9A  6700 06DA               2609              BEQ     SIZE_L
00002E9E                          2610              
00002E9E  1638 173C               2611  NEG_BACK    MOVE.B  THIRD_3, D3
00002EA2  1438 173D               2612              MOVE.B  FOURTH_3, D2
00002EA6                          2613  
00002EA6  4EB9 000034C2           2614              JSR     LOAD_EA
00002EAC  4EB9 00003624           2615              JSR     LOAD_NEW_LINE
00002EB2  4E75                    2616              RTS
00002EB4                          2617              
00002EB4                          2618  RTS:
00002EB4  4EB9 00003624           2619              JSR     LOAD_NEW_LINE
00002EBA  4E75                    2620              RTS
00002EBC                          2621  
00002EBC                          2622  JSR:
00002EBC  367C 2ED4               2623              MOVEA.W #JSR_BACK, A3
00002EC0  0C38 0000 173D          2624              CMPI.B  #%000, FOURTH_3
00002EC6  6700 06A6               2625              BEQ     SIZE_W
00002ECA  0C38 0001 173D          2626              CMPI.B  #%001, FOURTH_3
00002ED0  6700 06A4               2627              BEQ     SIZE_L
00002ED4                          2628              
00002ED4  1638 173C               2629  JSR_BACK    MOVE.B  THIRD_3, D3
00002ED8  1438 173D               2630              MOVE.B  FOURTH_3, D2
00002EDC                          2631              
00002EDC  4EB9 000034C2           2632              JSR     LOAD_EA
00002EE2  4EB9 00003624           2633              JSR     LOAD_NEW_LINE
00002EE8  4E75                    2634              RTS
00002EEA                          2635  
00002EEA                          2636  MOVEM:
00002EEA  4EB9 00002F44           2637              JSR     FUK_MOVEM
00002EF0  4EB9 00003624           2638              JSR     LOAD_NEW_LINE
00002EF6  4E75                    2639              RTS
00002EF8                          2640      
00002EF8                          2641  LEA:
00002EF8  367C 2F1A               2642              MOVEA.W #LEA_BACK, A3
00002EFC  0C38 0000 173D          2643              CMPI.B  #%000, FOURTH_3
00002F02  6700 066A               2644              BEQ     SIZE_W
00002F06  0C38 0001 173D          2645              CMPI.B  #%001, FOURTH_3
00002F0C  6700 0668               2646              BEQ     SIZE_L
00002F10  0C38 0004 173D          2647              CMPI.B  #%100, FOURTH_3
00002F16  6700 07BE               2648              BEQ     INVALID 
00002F1A                          2649              
00002F1A  1638 173C               2650  LEA_BACK    MOVE.B  THIRD_3, D3
00002F1E  1438 173D               2651              MOVE.B  FOURTH_3, D2
00002F22                          2652              
00002F22  4EB9 000034C2           2653              JSR     LOAD_EA
00002F28  4EB9 00003626           2654              JSR     LOAD_COMMA_SPACE
00002F2E                          2655              
00002F2E  163C 0001               2656              MOVE.B  #%001, D3
00002F32  1438 173A               2657              MOVE.B  FIRST_3, D2
00002F36                          2658              
00002F36  4EB9 000034C2           2659              JSR     LOAD_EA
00002F3C  4EB9 00003624           2660              JSR     LOAD_NEW_LINE
00002F42  4E75                    2661              RTS 
00002F44                          2662  
00002F44                          2663  FUK_MOVEM:  * Functional Utilization of Knowledge in MOVEM
00002F44  4284                    2664              CLR.L   D4
00002F46  4285                    2665              CLR.L   D5
00002F48  4286                    2666              CLR.L   D6
00002F4A  267C 00000000           2667              MOVEA.L #0, A3
00002F50                          2668              
00002F50  1C38 173A               2669              MOVE.B  FIRST_3, D6
00002F54  0206 0002               2670              ANDI.B  #%010, D6
00002F58  0C06 0002               2671              CMPI.B  #%010, D6
00002F5C  6700 0006               2672              BEQ     MOVEM_POST
00002F60  6600 00CE               2673              BNE     MOVEM_PRE
00002F64                          2674  
00002F64  0C38 0003 173C          2675  MOVEM_POST  CMPI.B  #%011, THIRD_3
00002F6A  6700 001C               2676              BEQ     MOVEM_POST2
00002F6E  0C38 0002 173C          2677              CMPI.B  #%010, THIRD_3
00002F74  6700 0012               2678              BEQ     MOVEM_POST2
00002F78  0C38 0007 173C          2679              CMPI.B  #%111, THIRD_3
00002F7E  6700 0024               2680              BEQ     MOVEM_POST3
00002F82  4EF9 000036D6           2681              JMP     INVALID
00002F88                          2682  
00002F88  1638 173C               2683  MOVEM_POST2 MOVE.B  THIRD_3, D3
00002F8C  1438 173D               2684              MOVE.B  FOURTH_3, D2
00002F90  4EB9 000034C2           2685              JSR     LOAD_EA
00002F96  4EB9 00003626           2686              JSR     LOAD_COMMA_SPACE
00002F9C                          2687  
00002F9C  4EB9 0000308E           2688              JSR     MOVEM_PARSE
00002FA2  4E75                    2689              RTS
00002FA4                          2690  
00002FA4                          2691  MOVEM_POST3 * see if new displacement doesnt exceed END_ADDRESS
00002FA4  4286                    2692              CLR.L   D6
00002FA6  3C0D                    2693              MOVE.W  A5, D6
00002FA8  5406                    2694              ADDI.B  #2, D6
00002FAA  BC4E                    2695              CMP.W   A6, D6
00002FAC  6E00 0728               2696              BGT     INVALID
00002FB0                          2697              
00002FB0                          2698              * push A5 pointer +2
00002FB0  544D                    2699              ADDA.W  #2, A5
00002FB2  0C38 0000 173D          2700              CMPI.B  #%000, FOURTH_3
00002FB8  6700 0012               2701              BEQ     MOVEM_POSTW
00002FBC  0C38 0001 173D          2702              CMPI.B  #%001, FOURTH_3
00002FC2  6700 003A               2703              BEQ     MOVEM_POSTL
00002FC6  4EF9 000036D6           2704              JMP     INVALID
00002FCC                          2705              
00002FCC                          2706  MOVEM_POSTW * see if new displacement doesnt exceed END_ADDRESS
00002FCC  4286                    2707              CLR.L   D6
00002FCE  3C0D                    2708              MOVE.W  A5, D6
00002FD0  5406                    2709              ADDI.B  #2, D6
00002FD2  BC4E                    2710              CMP.W   A6, D6
00002FD4  6E00 0700               2711              BGT     INVALID
00002FD8                          2712              
00002FD8                          2713              * munch 2
00002FD8  31FC 0002 28E6          2714              MOVE.W  #$2, TRAILING_SIZE
00002FDE  1638 173C               2715              MOVE.B  THIRD_3, D3
00002FE2  1438 173D               2716              MOVE.B  FOURTH_3, D2
00002FE6  4EB9 000034C2           2717              JSR     LOAD_EA
00002FEC  4EB9 00003626           2718              JSR     LOAD_COMMA_SPACE
00002FF2                          2719              
00002FF2                          2720              * push back -4
00002FF2  594D                    2721              SUBA.W  #4, A5
00002FF4  4EB9 0000308E           2722              JSR     MOVEM_PARSE
00002FFA                          2723              * push 2
00002FFA  544D                    2724              ADDA.W  #2, A5
00002FFC  4E75                    2725              RTS
00002FFE                          2726  
00002FFE                          2727  MOVEM_POSTL * see if new displacement doesnt exceed END_ADDRESS
00002FFE  4286                    2728              CLR.L   D6
00003000  3C0D                    2729              MOVE.W  A5, D6
00003002  5406                    2730              ADDI.B  #2, D6
00003004  BC4E                    2731              CMP.W   A6, D6
00003006  6E00 06CE               2732              BGT     INVALID         
0000300A                          2733              
0000300A                          2734              * munch 4
0000300A  31FC 0004 28E6          2735              MOVE.W  #$4, TRAILING_SIZE
00003010  1638 173C               2736              MOVE.B  THIRD_3, D3
00003014  1438 173D               2737              MOVE.B  FOURTH_3, D2
00003018  4EB9 000034C2           2738              JSR     LOAD_EA
0000301E  4EB9 00003626           2739              JSR     LOAD_COMMA_SPACE
00003024                          2740  
00003024                          2741              * push back -6
00003024  5D4D                    2742              SUBA.W  #6, A5
00003026  4EB9 0000308E           2743              JSR     MOVEM_PARSE
0000302C                          2744              * push 4
0000302C  584D                    2745              ADDA.W  #4, A5
0000302E  4E75                    2746              RTS
00003030                          2747  
00003030  4EB9 0000308E           2748  MOVEM_PRE   JSR     MOVEM_PARSE
00003036  4EB9 00003626           2749              JSR     LOAD_COMMA_SPACE
0000303C                          2750  
0000303C  367C 305A               2751              MOVEA.W #MOVEM_PRE_B, A3
00003040  0C38 0000 173D          2752              CMPI.B  #%000, FOURTH_3
00003046  6700 0526               2753              BEQ     SIZE_W
0000304A  0C38 0001 173D          2754              CMPI.B  #%001, FOURTH_3
00003050  6700 0524               2755              BEQ     SIZE_L
00003054  4EF9 000036D6           2756              JMP     INVALID
0000305A                          2757              
0000305A  0C38 0000 173C          2758  MOVEM_PRE_B CMPI.B  #%000, THIRD_3
00003060  6700 0674               2759              BEQ     INVALID
00003064  0C38 0003 173C          2760              CMPI.B  #%011, THIRD_3
0000306A  6700 066A               2761              BEQ     INVALID
0000306E  0C38 0001 173C          2762              CMPI.B  #%001, THIRD_3
00003074  6700 0660               2763              BEQ     INVALID
00003078                          2764              
00003078  1638 173C               2765              MOVE.B  THIRD_3, D3
0000307C  1438 173D               2766              MOVE.B  FOURTH_3, D2
00003080                          2767              
00003080  4EB9 000034C2           2768              JSR     LOAD_EA
00003086  4EB9 00003624           2769              JSR     LOAD_NEW_LINE
0000308C  4E75                    2770              RTS
0000308E                          2771              
0000308E                          2772  MOVEM_PARSE:
0000308E  4284                    2773              CLR.L   D4
00003090  381D                    2774              MOVE.W  (A5)+, D4 * D4 has $00FF
00003092                          2775                          
00003092  0C38 0004 173C          2776              CMPI.B  #%100, THIRD_3
00003098  6600 0006               2777              BNE     A_TO_D
0000309C  6700 002C               2778              BEQ     D_TO_A
000030A0                          2779  
000030A0  11FC 0001 28E8          2780  A_TO_D      MOVE.B  #%001, X * X = A
000030A6  11FC 0000 28E9          2781              MOVE.B  #%000, Y * Y = D
000030AC  11FC 0008 28EA          2782              MOVE.B  #$8, X_COUNTER * start from 8
000030B2  11FC 0008 28EB          2783              MOVE.B  #$8, Y_COUNTER * start from 8
000030B8  11FC 0000 28EC          2784              MOVE.B  #0, FIRST_X
000030BE  11FC 0000 28ED          2785              MOVE.B  #0, FIRST_Y
000030C4                          2786  
000030C4  4EF9 000031E6           2787              JMP     GO_A_TO_D
000030CA                          2788              
000030CA  11FC 0000 28E8          2789  D_TO_A      MOVE.B  #%000, X * X = D
000030D0  11FC 0001 28E9          2790              MOVE.B  #%001, Y * Y = A
000030D6  11FC 00FF 28EA          2791              MOVE.B  #$FF, X_COUNTER * start from -1
000030DC  11FC 00FF 28EB          2792              MOVE.B  #$FF, Y_COUNTER * start from -1
000030E2  11FC 0000 28EC          2793              MOVE.B  #0, FIRST_X
000030E8  11FC 0000 28ED          2794              MOVE.B  #0, FIRST_Y
000030EE                          2795              
000030EE  4EF9 000030F4           2796              JMP     GO_D_TO_A
000030F4                          2797  
000030F4  E35C                    2798  GO_D_TO_A   ROL.W   #1, D4
000030F6  3A04                    2799              MOVE.W  D4, D5
000030F8  0245 0001               2800              ANDI.W  #$1, D5
000030FC                          2801              
000030FC  0C38 0007 28EA          2802              CMPI.B  #7, X_COUNTER
00003102  6C00 0010               2803              BGE     ADD_Y
00003106  6D00 0002               2804              BLT     ADD_X
0000310A                          2805              
0000310A  5238 28EA               2806  ADD_X       ADDI.B  #1, X_COUNTER
0000310E  4EF9 00003124           2807              JMP     KEEP_GOING0
00003114                          2808  
00003114  5238 28EB               2809  ADD_Y       ADDI.B  #1, Y_COUNTER
00003118  11FC 0008 28EA          2810              MOVE.B  #8, X_COUNTER
0000311E  4EF9 00003124           2811              JMP     KEEP_GOING0
00003124                          2812              
00003124  0C45 0001               2813  KEEP_GOING0 CMPI.W  #$1, D5
00003128  6700 0006               2814              BEQ     BIT_ON
0000312C  6600 00AA               2815              BNE     KEEP_GOING
00003130                          2816              
00003130  0C38 0008 28EA          2817  BIT_ON      CMPI.B  #8, X_COUNTER
00003136  6600 0006               2818              BNE     ITS_X
0000313A  6700 0036               2819              BEQ     MYBE_Y
0000313E                          2820              
0000313E  1638 28E8               2821  ITS_X       MOVE.B  X, D3 * LOAD[XX_COUNTER]
00003142  1438 28EA               2822              MOVE.B  X_COUNTER, D2
00003146  4EB9 000034C2           2823              JSR     LOAD_EA
0000314C  0C38 0000 28EC          2824              CMPI.B  #0, FIRST_X
00003152  6700 0006               2825              BEQ     FST_X
00003156  6600 0012               2826              BNE     SND_X
0000315A                          2827  
0000315A  18FC 002D               2828  FST_X       MOVE.B  #$2D, (A4)+ * LOAD '-'
0000315E  11FC 0001 28EC          2829              MOVE.B  #1, FIRST_X * FIRST_X = 1
00003164  4EF9 000031D8           2830              JMP     KEEP_GOING
0000316A                          2831              
0000316A  554C                    2832  SND_X       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
0000316C  4EF9 000031D8           2833              JMP     KEEP_GOING
00003172                          2834  
00003172  0C38 0008 28EB          2835  MYBE_Y      CMPI.B  #8, Y_COUNTER
00003178  6600 0006               2836              BNE     ITS_Y
0000317C  6700 005A               2837              BEQ     KEEP_GOING
00003180                          2838  
00003180  0C38 0000 28ED          2839  ITS_Y       CMPI.B  #0, FIRST_Y
00003186  6700 001E               2840              BEQ     FST_Y1
0000318A  1638 28E9               2841  ITS_Y_BACK  MOVE.B  Y, D3 * LOAD[YY_COUNTER]
0000318E  1438 28EB               2842              MOVE.B  Y_COUNTER, D2
00003192  4EB9 000034C2           2843              JSR     LOAD_EA
00003198  0C38 0000 28ED          2844              CMPI.B  #0, FIRST_Y
0000319E  6700 0020               2845              BEQ     FST_Y2
000031A2  6600 002C               2846              BNE     SND_Y
000031A6                          2847  
000031A6  0C38 0001 28EC          2848  FST_Y1      CMPI.B  #1, FIRST_X
000031AC  6600 000E               2849              BNE     SKIP_HERE
000031B0                          2850              ;ADDA.W #2, A4 * push G_BUFFER pointer by 2
000031B0                          2851                          
000031B0  18FC 0020               2852              MOVE.B  #$20, (A4)+
000031B4  18FC 0020               2853              MOVE.B  #$20, (A4)+
000031B8                          2854  
000031B8  18FC 002F               2855              MOVE.B  #$2F, (A4)+ * LOAD '/'
000031BC  4EF8 318A               2856  SKIP_HERE   JMP     ITS_Y_BACK
000031C0                          2857  
000031C0  18FC 002D               2858  FST_Y2      MOVE.B  #$2D, (A4)+ * LOAD '-'
000031C4  11FC 0001 28ED          2859              MOVE.B  #1, FIRST_Y * FIRST_Y = 1
000031CA  4EF9 000031D8           2860              JMP     KEEP_GOING
000031D0                          2861  
000031D0  554C                    2862  SND_Y       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
000031D2  4EF9 000031D8           2863              JMP     KEEP_GOING
000031D8                          2864  
000031D8  0C38 0008 28EB          2865  KEEP_GOING  CMPI.B  #8, Y_COUNTER
000031DE  6600 FF14               2866              BNE     GO_D_TO_A
000031E2                          2867              
000031E2  544C                    2868              ADDA.W  #2, A4 * push G_BUFFER pointer by 2
000031E4  4E75                    2869              RTS
000031E6                          2870  
000031E6                          2871  
000031E6  E35C                    2872  GO_A_TO_D   ROL.W   #1, D4
000031E8  3A04                    2873              MOVE.W  D4, D5
000031EA  0245 0001               2874              ANDI.W  #$1, D5
000031EE                          2875              
000031EE  0C38 0000 28EA          2876              CMPI.B  #0, X_COUNTER
000031F4  6E00 0006               2877              BGT     SUBTRACT_X  
000031F8  6F00 000C               2878              BLE     SUBTRACT_Y  
000031FC                          2879              
000031FC  5338 28EA               2880  SUBTRACT_X  SUBI.B  #1, X_COUNTER
00003200  4EF9 00003216           2881              JMP     KEEP_GOING1
00003206                          2882  
00003206  5338 28EB               2883  SUBTRACT_Y  SUBI.B  #1, Y_COUNTER
0000320A  11FC 00FF 28EA          2884              MOVE.B  #$FF, X_COUNTER
00003210  4EF9 00003216           2885              JMP     KEEP_GOING1
00003216                          2886              
00003216  0C45 0001               2887  KEEP_GOING1 CMPI.W  #$1, D5
0000321A  6700 0006               2888              BEQ     BIT_ON2
0000321E  6600 00AA               2889              BNE     KEEP_GOING2
00003222                          2890              
00003222  0C38 00FF 28EA          2891  BIT_ON2     CMPI.B  #$FF, X_COUNTER
00003228  6600 0006               2892              BNE     ITS_X2
0000322C  6700 0036               2893              BEQ     MYBE_Y2
00003230                          2894              
00003230  1638 28E8               2895  ITS_X2      MOVE.B  X, D3 * LOAD[XX_COUNTER]
00003234  1438 28EA               2896              MOVE.B  X_COUNTER, D2
00003238  4EB9 000034C2           2897              JSR     LOAD_EA
0000323E  0C38 0000 28EC          2898              CMPI.B  #0, FIRST_X
00003244  6700 0006               2899              BEQ     FST_X2
00003248  6600 0012               2900              BNE     SND_X2
0000324C                          2901  
0000324C  18FC 002D               2902  FST_X2      MOVE.B  #$2D, (A4)+ * LOAD '-'
00003250  11FC 0001 28EC          2903              MOVE.B  #1, FIRST_X * FIRST_X = 1
00003256  4EF9 000032CA           2904              JMP     KEEP_GOING2
0000325C                          2905              
0000325C  554C                    2906  SND_X2      SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
0000325E  4EF9 000032CA           2907              JMP     KEEP_GOING2
00003264                          2908  
00003264  0C38 00FF 28EB          2909  MYBE_Y2     CMPI.B  #$FF, Y_COUNTER
0000326A  6600 0006               2910              BNE     ITS_Y2
0000326E  6700 005A               2911              BEQ     KEEP_GOING2
00003272                          2912  
00003272  0C38 0000 28ED          2913  ITS_Y2      CMPI.B  #0, FIRST_Y
00003278  6700 001E               2914              BEQ     FST_Y3
0000327C  1638 28E9               2915  ITS_Y2_BACK MOVE.B  Y, D3 * LOAD[YY_COUNTER]
00003280  1438 28EB               2916              MOVE.B  Y_COUNTER, D2
00003284  4EB9 000034C2           2917              JSR     LOAD_EA
0000328A  0C38 0000 28ED          2918              CMPI.B  #0, FIRST_Y
00003290  6700 0020               2919              BEQ     FST_Y4
00003294  6600 002C               2920              BNE     SND_Y2
00003298                          2921  
00003298  0C38 0001 28EC          2922  FST_Y3      CMPI.B  #1, FIRST_X
0000329E  6600 000E               2923              BNE     SKIP_HERE2
000032A2                          2924              ;ADDA.W #2, A4 * push G_BUFFER pointer by 2
000032A2                          2925              
000032A2  18FC 0020               2926              MOVE.B  #$20, (A4)+
000032A6  18FC 0020               2927              MOVE.B  #$20, (A4)+
000032AA                          2928              
000032AA  18FC 002F               2929              MOVE.B  #$2F, (A4)+ * LOAD '/'
000032AE  4EF8 327C               2930  SKIP_HERE2  JMP     ITS_Y2_BACK
000032B2                          2931  
000032B2  18FC 002D               2932  FST_Y4      MOVE.B  #$2D, (A4)+ * LOAD '-'
000032B6  11FC 0001 28ED          2933              MOVE.B  #1, FIRST_Y * FIRST_Y = 1
000032BC  4EF9 000032CA           2934              JMP     KEEP_GOING2
000032C2                          2935  
000032C2  554C                    2936  SND_Y2      SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
000032C4  4EF9 000032CA           2937              JMP     KEEP_GOING2
000032CA                          2938  
000032CA  0C38 00FF 28EB          2939  KEEP_GOING2 CMPI.B  #$FF, Y_COUNTER
000032D0  6600 FF14               2940              BNE     GO_A_TO_D   
000032D4                          2941              
000032D4  544C                    2942              ADDA.W  #2, A4 * push G_BUFFER pointer by 2
000032D6  4E75                    2943              RTS
000032D8                          2944  
000032D8                          2945  
000032D8                          2946  
000032D8                          2947  LOAD_0000:
000032D8  4283                    2948              CLR.L   D3
000032DA  4282                    2949              CLR.L   D2
000032DC  267C 00000000           2950              MOVEA.L #0, A3
000032E2                          2951  
000032E2  0C38 0000 173A          2952              CMPI.B  #%000, FIRST_3
000032E8  6700 0006               2953              BEQ     MYBE_ORI
000032EC  6600 000C               2954              BNE     NOT_ORI
000032F0  0C38 0003 173B          2955  MYBE_ORI    CMPI.B  #%011, SECOND_3
000032F6  6D00 0042               2956              BLT     ORI_CMPI            
000032FA                          2957  
000032FA  0C38 0006 173A          2958  NOT_ORI     CMPI.B  #%110, FIRST_3
00003300  6700 0006               2959              BEQ     MYBE_CMPI
00003304  6600 000C               2960              BNE     NOT_CMPI
00003308  0C38 0003 173B          2961  MYBE_CMPI   CMPI.B  #%011, SECOND_3
0000330E  6D00 002A               2962              BLT     ORI_CMPI
00003312                          2963              
00003312  0C38 0004 173A          2964  NOT_CMPI    CMPI.B  #%100, FIRST_3
00003318  6700 0006               2965              BEQ     MYBE_BCLR
0000331C  6600 000C               2966              BNE     NOT_BCLR
00003320  0C38 0002 173B          2967  MYBE_BCLR   CMPI.B  #%010, SECOND_3
00003326  6700 0080               2968              BEQ     BCLR
0000332A                          2969  
0000332A  0C38 0006 173B          2970  NOT_BCLR    CMPI.B  #%110, SECOND_3
00003330  6700 00E0               2971              BEQ     DYNMC_BCLR
00003334                          2972              
00003334  4EF9 000036D6           2973              JMP     INVALID
0000333A                          2974              
0000333A  367C 335C               2975  ORI_CMPI    MOVEA.W #BACK, A3
0000333E  0C38 0000 173B          2976              CMPI.B  #%000, SECOND_3
00003344  6700 0220               2977              BEQ     SIZE_B
00003348  0C38 0001 173B          2978              CMPI.B  #%001, SECOND_3
0000334E  6700 021E               2979              BEQ     SIZE_W
00003352  0C38 0002 173B          2980              CMPI.B  #%010, SECOND_3
00003358  6700 021C               2981              BEQ     SIZE_L
0000335C                          2982  
0000335C  163C 0007               2983  BACK        MOVE.B  #%111, D3
00003360  143C 0004               2984              MOVE.B  #%100, D2
00003364                          2985              
00003364  4EB9 000034C2           2986              JSR     LOAD_EA
0000336A  4EB9 00003626           2987              JSR     LOAD_COMMA_SPACE
00003370                          2988              
00003370  367C 3392               2989              MOVEA.W #BACK2, A3   
00003374  0C38 0000 173D          2990              CMPI.B  #%000, FOURTH_3
0000337A  6700 01F2               2991              BEQ     SIZE_W
0000337E  0C38 0001 173D          2992              CMPI.B  #%001, FOURTH_3
00003384  6700 01F0               2993              BEQ     SIZE_L
00003388  0C38 0004 173D          2994              CMPI.B  #%100, FOURTH_3 
0000338E  6700 0346               2995              BEQ     INVALID 
00003392                          2996  
00003392  1638 173C               2997  BACK2       MOVE.B  THIRD_3, D3
00003396  1438 173D               2998              MOVE.B  FOURTH_3, D2
0000339A                          2999          
0000339A  4EB9 000034C2           3000              JSR     LOAD_EA
000033A0  4EB9 00003624           3001              JSR     LOAD_NEW_LINE
000033A6  4E75                    3002              RTS
000033A8                          3003  
000033A8  4285                    3004  BCLR        CLR.L   D5
000033AA  4284                    3005              CLR.L   D4
000033AC  247C 00000000           3006              MOVEA.L #0, A2
000033B2                          3007  
000033B2  3A0E                    3008              MOVE.W  A6, D5
000033B4  9A4D                    3009              SUB.W   A5, D5
000033B6  0C45 0002               3010              CMPI.W  #$2, D5
000033BA  6D00 031A               3011              BLT     INVALID
000033BE                          3012  
000033BE  381D                    3013              MOVE.W  (A5)+, D4
000033C0  4284                    3014              CLR.L   D4
000033C2  381D                    3015              MOVE.W  (A5)+, D4
000033C4  0244 00FF               3016              ANDI.W  #$00FF, D4
000033C8  247C 000033D4           3017              MOVEA.L #BACK4, A2
000033CE  4EF9 000035F0           3018              JMP     LOAD_IMMDTE
000033D4                          3019              
000033D4  4EB9 00003626           3020  BACK4       JSR     LOAD_COMMA_SPACE
000033DA                          3021              
000033DA  367C 33FC               3022              MOVEA.W #BACK3, A3
000033DE  0C38 0000 173D          3023              CMPI.B  #%000, FOURTH_3
000033E4  6700 0188               3024              BEQ     SIZE_W
000033E8  0C38 0001 173D          3025              CMPI.B  #%001, FOURTH_3
000033EE  6700 0186               3026              BEQ     SIZE_L
000033F2  0C38 0004 173D          3027              CMPI.B  #%100, FOURTH_3 
000033F8  6700 02DC               3028              BEQ     INVALID 
000033FC                          3029  
000033FC  1638 173C               3030  BACK3       MOVE.B  THIRD_3, D3
00003400  1438 173D               3031              MOVE.B  FOURTH_3, D2
00003404                          3032  
00003404  4EB9 000034C2           3033              JSR     LOAD_EA
0000340A  4EB9 00003624           3034              JSR     LOAD_NEW_LINE
00003410                          3035  
00003410  4E75                    3036              RTS
00003412                          3037  
00003412  163C 0000               3038  DYNMC_BCLR  MOVE.B  #%000, D3
00003416  1438 173A               3039              MOVE.B  FIRST_3, D2
0000341A                          3040              
0000341A  4EB9 000034C2           3041              JSR     LOAD_EA
00003420  4EB9 00003626           3042              JSR     LOAD_COMMA_SPACE
00003426                          3043  
00003426  367C 3448               3044              MOVEA.W #BACK5, A3
0000342A  0C38 0000 173D          3045              CMPI.B  #%000, FOURTH_3
00003430  6700 013C               3046              BEQ     SIZE_W
00003434  0C38 0001 173D          3047              CMPI.B  #%001, FOURTH_3
0000343A  6700 013A               3048              BEQ     SIZE_L
0000343E  0C38 0004 173D          3049              CMPI.B  #%100, FOURTH_3 
00003444  6700 0290               3050              BEQ     INVALID 
00003448                          3051              
00003448  1638 173C               3052  BACK5       MOVE.B  THIRD_3, D3
0000344C  1438 173D               3053              MOVE.B  FOURTH_3, D2
00003450                          3054              
00003450  4EB9 000034C2           3055              JSR     LOAD_EA
00003456  4EB9 00003624           3056              JSR     LOAD_NEW_LINE
0000345C                          3057              
0000345C  4E75                    3058              RTS
0000345E                          3059  
0000345E                          3060  LOAD_00XX:
0000345E  4283                    3061          CLR.L   D3
00003460  4282                    3062          CLR.L   D2
00003462  267C 00000000           3063          MOVEA.L #0, A3
00003468                          3064          
00003468  367C 3480               3065          MOVEA.W #GOO, A3
0000346C  0C38 0003 1739          3066          CMPI.B  #%0011, MNEMONIC
00003472  6700 00FA               3067          BEQ     SIZE_W
00003476  0C38 0002 1739          3068          CMPI.B  #%0010, MNEMONIC
0000347C  6700 00F8               3069          BEQ     SIZE_L
00003480                          3070  
00003480  1638 173C               3071  GOO     MOVE.B  THIRD_3, D3
00003484  1438 173D               3072          MOVE.B  FOURTH_3, D2
00003488                          3073      
00003488  4EB9 000034C2           3074          JSR     LOAD_EA
0000348E  4EB9 00003626           3075          JSR     LOAD_COMMA_SPACE
00003494                          3076      
00003494  367C 34AC               3077          MOVEA.W #GOO2, A3
00003498  0C38 0000 173A          3078          CMPI.B  #%000, FIRST_3
0000349E  6700 00CE               3079          BEQ     SIZE_W
000034A2  0C38 0001 173A          3080          CMPI.B  #%001, FIRST_3
000034A8  6700 00CC               3081          BEQ     SIZE_L
000034AC                          3082      
000034AC  1638 173B               3083  GOO2    MOVE.B  SECOND_3, D3
000034B0  1438 173A               3084          MOVE.B  FIRST_3, D2
000034B4                          3085              
000034B4  4EB9 000034C2           3086          JSR     LOAD_EA
000034BA  4EB9 00003624           3087          JSR     LOAD_NEW_LINE
000034C0                          3088      
000034C0  4E75                    3089          RTS
000034C2                          3090  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000034C2                          3091  
000034C2                          3092  
000034C2                          3093  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000034C2                          3094  
000034C2                          3095  LOAD_EA:
000034C2  347C 34D2               3096          MOVEA.W #SAVED, A2 * remember to come back!
000034C6                          3097  
000034C6  0C43 0007               3098          CMPI    #%111, D3
000034CA  6D00 0008               3099          BLT     LOAD_LT_111
000034CE  6C00 0032               3100          BGE     LOAD_GE_111
000034D2                          3101      
000034D2  4E75                    3102  SAVED   RTS
000034D4                          3103  
000034D4                          3104  LOAD_LT_111:
000034D4  0C43 0000               3105      CMPI    #%000, D3 * e.g. D3
000034D8  6700 00A4               3106      BEQ     LOAD_DATA_REGISTER
000034DC  0C43 0001               3107      CMPI    #%001, D3 * e.g. A3
000034E0  6700 00AE               3108      BEQ     LOAD_ADDR_REGISTER
000034E4  0C43 0002               3109      CMPI    #%010, D3 * e.g. (A3)
000034E8  6700 00B8               3110      BEQ     LOAD_ADDRESS
000034EC  0C43 0003               3111      CMPI    #%011, D3 * e.g. (A3)+
000034F0  6700 00C2               3112      BEQ     LOAD_ADDRESS_W_POST_INC
000034F4  0C43 0004               3113      CMPI    #%100, D3 * e.g. -(A3)
000034F8  6700 00C6               3114      BEQ     LOAD_ADDRESS_W_PRE_DEC
000034FC                          3115      
000034FC  4EF9 000036D6           3116      JMP     INVALID
00003502                          3117      
00003502                          3118  LOAD_GE_111:
00003502  4285                    3119              CLR.L   D5
00003504  4284                    3120              CLR.L   D4
00003506                          3121  
00003506  3A0E                    3122              MOVE.W  A6, D5
00003508  9A4D                    3123              SUB.W   A5, D5
0000350A  BA78 28E6               3124              CMP.W   TRAILING_SIZE, D5
0000350E  6D00 01C6               3125              BLT     INVALID
00003512                          3126  
00003512  0C78 0001 28E6          3127              CMPI.W  #$1, TRAILING_SIZE
00003518  6700 0016               3128              BEQ     CHUMP_BYTE
0000351C  0C78 0002 28E6          3129              CMPI.W  #$2, TRAILING_SIZE
00003522  6700 0014               3130              BEQ     CHUMP_WORD
00003526  0C78 0004 28E6          3131              CMPI.W  #$4, TRAILING_SIZE
0000352C  6700 0012               3132              BEQ     CHUMP_LONG
00003530                          3133  
00003530  381D                    3134  CHUMP_BYTE  MOVE.W  (A5)+, D4 * Minimum 4 hex (e.g. MOVE.B #1, $2 = XXXX 0001 0002)
00003532  4EF9 00003548           3135              JMP     GO
00003538                          3136  
00003538  381D                    3137  CHUMP_WORD  MOVE.W  (A5)+, D4
0000353A  4EF9 00003548           3138              JMP     GO
00003540                          3139              
00003540  281D                    3140  CHUMP_LONG  MOVE.L  (A5)+, D4
00003542  4EF9 00003548           3141              JMP     GO
00003548                          3142  
00003548  0C42 0000               3143  GO          CMPI    #%000, D2
0000354C  6700 007E               3144              BEQ     LOAD_ABS_SHORT
00003550  0C42 0001               3145              CMPI    #%001, D2
00003554  6700 0088               3146              BEQ     LOAD_ABS_LONG
00003558  0C42 0004               3147              CMPI    #%100, D2
0000355C  6700 0092               3148              BEQ     LOAD_IMMDTE
00003560                          3149      
00003560  4EF9 000036D6           3150              JMP     INVALID
00003566                          3151  TRAILING_HELPER:            
00003566  31FC 0002 28E6          3152  SIZE_B  MOVE.W  #$2, TRAILING_SIZE
0000356C  4ED3                    3153          JMP     (A3)
0000356E                          3154  
0000356E  31FC 0002 28E6          3155  SIZE_W  MOVE.W  #$2, TRAILING_SIZE
00003574  4ED3                    3156          JMP     (A3)
00003576                          3157          
00003576  31FC 0004 28E6          3158  SIZE_L  MOVE.W  #$4, TRAILING_SIZE
0000357C  4ED3                    3159          JMP     (A3)
0000357E                          3160  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000357E                          3161  
0000357E                          3162  
0000357E                          3163  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000357E                          3164  
0000357E                          3165  LOAD_DATA_REGISTER:
0000357E  4280                    3166      CLR.L   D0
00003580                          3167      
00003580  4EB9 0000363E           3168      JSR     LOAD_D
00003586  1002                    3169      MOVE.B  D2, D0
00003588  4EB9 000036B2           3170      JSR     LOAD_NUM
0000358E  4ED2                    3171      JMP     (A2)
00003590                          3172  
00003590                          3173  LOAD_ADDR_REGISTER:
00003590  4280                    3174      CLR.L   D0
00003592                          3175  
00003592  4EB9 0000364C           3176      JSR     LOAD_A
00003598  1002                    3177      MOVE.B  D2, D0
0000359A  4EB9 000036B2           3178      JSR     LOAD_NUM
000035A0  4ED2                    3179      JMP     (A2)
000035A2                          3180  
000035A2                          3181  LOAD_ADDRESS:
000035A2  4EB9 0000365A           3182      JSR     LOAD_PTHSIS_OPEN
000035A8  4EB8 3590               3183      JSR     LOAD_ADDR_REGISTER
000035AC  4EB9 00003668           3184      JSR     LOAD_PTHSIS_CLSD
000035B2  4ED2                    3185      JMP     (A2)
000035B4                          3186  
000035B4                          3187  LOAD_ADDRESS_W_POST_INC:
000035B4  4EB8 35A2               3188      JSR     LOAD_ADDRESS
000035B8  4EB9 00003692           3189      JSR     LOAD_PLUS_SIGN
000035BE  4ED2                    3190      JMP     (A2)
000035C0                          3191  
000035C0                          3192  LOAD_ADDRESS_W_PRE_DEC:
000035C0  4EB9 000036A0           3193      JSR     LOAD_MINUS_SIGN
000035C6  4EB8 35A2               3194      JSR     LOAD_ADDRESS
000035CA  4ED2                    3195      JMP     (A2)
000035CC                          3196  
000035CC                          3197  LOAD_ABS_SHORT:
000035CC  4280                    3198      CLR.L   D0
000035CE                          3199  
000035CE  4EB9 00003676           3200      JSR     LOAD_HEX_SIGN
000035D4  3004                    3201      MOVE.W  D4, D0
000035D6  4EB9 000035FA           3202      JSR     LOAD_BYTES
000035DC  4ED2                    3203      JMP     (A2)
000035DE                          3204  
000035DE                          3205  LOAD_ABS_LONG:
000035DE  4280                    3206      CLR.L   D0
000035E0                          3207  
000035E0  4EB9 00003676           3208      JSR     LOAD_HEX_SIGN
000035E6  2004                    3209      MOVE.L  D4, D0
000035E8  4EB9 000035FA           3210      JSR     LOAD_BYTES
000035EE  4ED2                    3211      JMP     (A2)
000035F0                          3212  
000035F0                          3213  LOAD_IMMDTE:
000035F0  4EB9 00003684           3214      JSR     LOAD_IMMDTE_VALU
000035F6  4EF8 35DE               3215      JMP     LOAD_ABS_LONG
000035FA                          3216  
000035FA                          3217  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000035FA                          3218  
000035FA                          3219  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000035FA                          3220  
000035FA                          3221  LOAD_BYTES:
000035FA  4285                    3222          CLR.L   D5
000035FC  4281                    3223          CLR.L   D1
000035FE                          3224  
000035FE  2200                    3225          MOVE.L  D0, D1
00003600  1A3C 0008               3226          MOVE.B  #8, D5
00003604  0C45 0000               3227  LOOP    CMPI    #0, D5
00003608  6E00 0004               3228          BGT     ROTATE
0000360C  4E75                    3229          RTS
0000360E                          3230      
0000360E  E999                    3231  ROTATE  ROL.L   #$04, D1
00003610  1001                    3232          MOVE.B  D1, D0
00003612  0280 0000000F           3233          ANDI.L  #$0000000F, D0
00003618  4EB9 000036B2           3234          JSR     LOAD_NUM
0000361E  5345                    3235          SUBI    #1, D5
00003620  4EF8 3604               3236          JMP     LOOP        
00003624                          3237  
00003624                          3238  LOAD_NEW_LINE:
00003624                          3239      ;CLR.L   D0
00003624                          3240  
00003624                          3241      ;MOVE.B  CR, D0
00003624                          3242      ;JSR     LOAD_THIS_SHIT
00003624                          3243      ;MOVE.B  LF, D0
00003624                          3244      ;JSR     LOAD_THIS_SHIT
00003624  4E75                    3245      RTS
00003626                          3246  
00003626                          3247  LOAD_COMMA_SPACE:
00003626  4280                    3248      CLR.L   D0
00003628                          3249  
00003628  1038 28E4               3250      MOVE.B  COMMA, D0
0000362C  4EB9 000036AE           3251      JSR     LOAD_THIS_SHIT
00003632  1038 28E5               3252      MOVE.B  SPACE, D0
00003636  4EB9 000036AE           3253      JSR     LOAD_THIS_SHIT
0000363C                          3254      
0000363C  4E75                    3255      RTS
0000363E                          3256  
0000363E                          3257  LOAD_D:
0000363E  4280                    3258      CLR.L   D0
00003640                          3259  
00003640  1038 28DD               3260      MOVE.B  DATA, D0
00003644  4EB9 000036AE           3261      JSR     LOAD_THIS_SHIT
0000364A  4E75                    3262      RTS
0000364C                          3263  
0000364C                          3264  LOAD_A:
0000364C  4280                    3265      CLR.L   D0
0000364E                          3266  
0000364E  1038 28DC               3267      MOVE.B  ADDRESS, D0
00003652  4EB9 000036AE           3268      JSR     LOAD_THIS_SHIT
00003658  4E75                    3269      RTS
0000365A                          3270  
0000365A                          3271  LOAD_PTHSIS_OPEN:
0000365A  4280                    3272      CLR.L   D0
0000365C                          3273  
0000365C  1038 28DE               3274      MOVE.B  PTHSIS_OPEN, D0
00003660  4EB9 000036AE           3275      JSR     LOAD_THIS_SHIT
00003666  4E75                    3276      RTS
00003668                          3277  
00003668                          3278  LOAD_PTHSIS_CLSD:
00003668  4280                    3279      CLR.L   D0
0000366A                          3280  
0000366A  1038 28DF               3281      MOVE.B  PTHSIS_CLSD, D0
0000366E  4EB9 000036AE           3282      JSR     LOAD_THIS_SHIT
00003674  4E75                    3283      RTS
00003676                          3284  
00003676                          3285  LOAD_HEX_SIGN:
00003676  4280                    3286      CLR.L   D0
00003678                          3287  
00003678  1038 28E0               3288      MOVE.B  HEX_SIGN, D0
0000367C  4EB9 000036AE           3289      JSR     LOAD_THIS_SHIT
00003682  4E75                    3290      RTS
00003684                          3291  
00003684                          3292  LOAD_IMMDTE_VALU:
00003684  4280                    3293      CLR.L   D0
00003686                          3294  
00003686  1038 28E1               3295      MOVE.B  IMMDTE_VALU, D0
0000368A  4EB9 000036AE           3296      JSR     LOAD_THIS_SHIT
00003690  4E75                    3297      RTS
00003692                          3298  
00003692                          3299  LOAD_PLUS_SIGN:
00003692  4280                    3300      CLR.L   D0
00003694                          3301  
00003694  1038 28E2               3302      MOVE.B  PLUS_SIGN, D0
00003698  4EB9 000036AE           3303      JSR     LOAD_THIS_SHIT
0000369E  4E75                    3304      RTS
000036A0                          3305  
000036A0                          3306  LOAD_MINUS_SIGN:
000036A0  4280                    3307      CLR.L   D0
000036A2                          3308  
000036A2  1038 28E3               3309      MOVE.B  MINUS_SIGN, D0
000036A6  4EB9 000036AE           3310      JSR     LOAD_THIS_SHIT
000036AC  4E75                    3311      RTS
000036AE                          3312  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000036AE                          3313  
000036AE                          3314  
000036AE                          3315  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000036AE                          3316  LOAD_THIS_SHIT:
000036AE  18C0                    3317      MOVE.B  D0, (A4)+
000036B0  4E75                    3318      RTS
000036B2                          3319  
000036B2                          3320  LOAD_NUM:
000036B2  0C00 0009               3321      CMPI.B  #$9, D0
000036B6  6E00 0006               3322      BGT     GT
000036BA  6F00 000C               3323      BLE     LE
000036BE                          3324      
000036BE  0600 0037               3325  GT  ADDI.B  #$37, D0 * A~F
000036C2  4EF9 000036D2           3326      JMP     END
000036C8  0600 0030               3327  LE  ADDI.B  #$30, D0 * 0~9
000036CC  4EF9 000036D2           3328      JMP     END
000036D2                          3329  
000036D2  18C0                    3330  END MOVE.B  D0, (A4)+
000036D4  4E75                    3331      RTS
000036D6                          3332  
000036D6                          3333  INVALID:
000036D6  11FC 0000 10A2          3334              MOVE.B  #%0, IS_VALID
000036DC  4EF8 28F8               3335              JMP     EXT
000036E0                          3336  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000036E0                          3337  -------------------- end include --------------------
000036E0                          3338      INCLUDE "MOVEM_TEST.x68"                                ;Test program to include
000036E0                          3339      
00009000                          3340      ORG $9000
00009000                          3341      ;MOVEM.W   D1-D4/A1-A7,-(A1)
00009000                          3342  
00009000  48E1 7F00               3343      MOVEM.L   D1-D7,-(A1)
00009004                          3344  
00009004  48A1 0140               3345      MOVEM.W   A1/D7,-(A1)
00009008                          3346  
00009008  48E1 0140               3347      MOVEM.L   A1/D7,-(A1)
0000900C                          3348  
0000900C  4891 FE00               3349      MOVEM.W   A1-A7,(A1)
00009010                          3350  
00009010  48D1 00FE               3351      MOVEM.L   D1-D7,(A1)
00009014                          3352  
00009014  4891 0280               3353      MOVEM.W   A1/D7,(A1)
00009018                          3354  
00009018  48D1 0280               3355      MOVEM.L   A1/D7,(A1)
0000901C                          3356  
0000901C  4C99 FE00               3357      MOVEM.W   (A1)+,A1-A7
00009020                          3358  
00009020  4CD9 00FE               3359      MOVEM.L   (A1)+,D1-D7
00009024                          3360  
00009024  4C99 0280               3361      MOVEM.W   (A1)+,A1/D7
00009028                          3362  
00009028  4CD9 0280               3363      MOVEM.L   (A1)+,A1/D7
0000902C                          3364  
0000902C  4C91 FE00               3365      MOVEM.W   (A1),A1-A7
00009030                          3366  
00009030  4CD1 00FE               3367      MOVEM.L   (A1),D1-D7
00009034                          3368  
00009034  4C91 0280               3369      MOVEM.W   (A1),A1/D7
00009038                          3370  
00009038  4CD1 0280               3371      MOVEM.L   (A1),A1/D7
0000903C                          3372      
0000903C                          3373  
0000903C                          3374  -------------------- end include --------------------
0000903C                          3375      
0000903C                          3376      
Line 3377 WARNING: Origin value is odd (Location counter set to next highest address)
0000903C                          3377     END    START                                 ;Last line of program

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA                2BD2
ADDA_BACK           2BF0
ADDRESS             28DC
ADDSTRTOBUFFER      1260
ADD_CHAR_TO_STRING  1338
ADD_X               310A
ADD_Y               3114
ASCIITOHEX          13E0
ASCIITOHEXREGLIST   1
ASCII_VAL           16F2
ASD_1               29D4
ASD_1_BACK          2A00
ASD_2               2A2C
ASD_2_IMD           2A42
ASD_2_IMD_B         2A68
ASD_2_REG           2A84
A_TO_D              30A0
BACK                335C
BACK2               3392
BACK3               33FC
BACK4               33D4
BACK5               3448
BCLR                33A8
BIT_CHECK_EXG       224C
BIT_CHECK_EXT       1D34
BIT_CHECK_MOVEP     1AA6
BIT_CHECK_SUBX      2168
BIT_ON              3130
BIT_ON2             3222
BIT_SIZE_CHECK      22A4
BRA                 2B10
BRA_BYTE            2B3C
BRA_BYTE2           2B62
BRA_BYTE3           2B6E
BRA_WORD            2B76
BRA_WORD_BK         2B92
BRA_WRD_BK2         2BB0
BUFFER_ADD_SUCCESS  125E
BUFFER_LENGTH_EXCEEDED  12A8
BUFFER_POINTER      1256
BUFFER_POINTER_LENGTH  125A
BUFFER_STRING_END   12AE
BYTEREAD            16F1
B_BUFFER            1050
CHARNUM_TO_CONVERT  12E0
CHECK_00XX          2960
CHECK_01XX          296E
CHECK_0XXX          290C
CHECK_1XXX          291C
CHECK_OP_ABCD       2234
CHECK_OP_ADD        22CE
CHECK_OP_ADDA       22D8
CHECK_OP_ADDI       1A06
CHECK_OP_ADDQ       1F2A
CHECK_OP_ADDX       22BA
CHECK_OP_AND        2284
CHECK_OP_ANDI       19DE
CHECK_OP_ANDI_TO_CCR  199E
CHECK_OP_ANDI_TO_SR  19AE
CHECK_OP_ASL        2486
CHECK_OP_ASL_NO_ROT  23AE
CHECK_OP_ASR        2468
CHECK_OP_ASR_NO_ROT  2394
CHECK_OP_BCC        1F94
CHECK_OP_BCS        203A
CHECK_OP_BEQ        1FA8
CHECK_OP_BGE        2054
CHECK_OP_BGT        1F80
CHECK_OP_BHI        1FBC
CHECK_OP_BLS        1FD0
CHECK_OP_BLT        206E
CHECK_OP_BMI        1FE4
CHECK_OP_BNE        1FF8
CHECK_OP_BPL        200C
CHECK_OP_BRA        2020
CHECK_OP_BSR        1F6C
CHECK_OP_BVC        2088
CHECK_OP_CHK        1E16
CHECK_OP_CLR        1CF8
CHECK_OP_CMP        21F2
CHECK_OP_CMPA       21C0
CHECK_OP_CMPI       1AF2
CHECK_OP_CMPM       21AC
CHECK_OP_DBCC       1F02
CHECK_OP_DIVS       20FA
CHECK_OP_DIVU       20D2
CHECK_OP_DYNAMIC_BCHG  1A7E
CHECK_OP_DYNAMIC_BCLR  1B2E
CHECK_OP_DYNAMIC_BSET  1A92
CHECK_OP_DYNAMIC_BTST  1A6A
CHECK_OP_EOR        21D4
CHECK_OP_EORI       1A1A
CHECK_OP_EORI_TO_CCR  19BE
CHECK_OP_EORI_TO_SR  19CE
CHECK_OP_EXG        2248
CHECK_OP_EXT        1D20
CHECK_OP_ILLEGAL    1C68
CHECK_OP_JMP        1E02
CHECK_OP_JSR        1E70
CHECK_OP_LEA        1E56
CHECK_OP_LINK       1DC6
CHECK_OP_LSL        244A
CHECK_OP_LSL_NO_ROT  237A
CHECK_OP_LSR        242C
CHECK_OP_LSR_NO_ROT  2360
CHECK_OP_MOVEA_L    1B86
CHECK_OP_MOVEA_W    1BE8
CHECK_OP_MOVEM_L    1ED8
CHECK_OP_MOVEM_W    1EBE
CHECK_OP_MOVEP      1AC0
CHECK_OP_MOVEQ      20B2
CHECK_OP_MOVE_B     1B5C
CHECK_OP_MOVE_FROM_SR  1CA8
CHECK_OP_MOVE_L     1BBE
CHECK_OP_MOVE_TO_CCR  1CBC
CHECK_OP_MOVE_TO_SR  1CD0
CHECK_OP_MOVE_USP   1DEE
CHECK_OP_MOVE_W     1C20
CHECK_OP_MULS       226A
CHECK_OP_MULU       2220
CHECK_OP_NBCD       1D4E
CHECK_OP_NEG        1E8A
CHECK_OP_NEGX       1CE4
CHECK_OP_NOP        1E2A
CHECK_OP_NOT        1D0C
CHECK_OP_OR         2114
CHECK_OP_ORI        1AD4
CHECK_OP_ORI_TO_CCR  197E
CHECK_OP_ORI_TO_SR  198E
CHECK_OP_PEA        1D76
CHECK_OP_RESET      1C58
CHECK_OP_ROL        240E
CHECK_OP_ROL_NO_ROT  2346
CHECK_OP_ROR        23F0
CHECK_OP_ROR_NO_ROT  232C
CHECK_OP_ROXL       23DC
CHECK_OP_ROXL_NO_ROT  2318
CHECK_OP_ROXR       23C8
CHECK_OP_ROXR_NO_ROT  2304
CHECK_OP_RTE        1C78
CHECK_OP_RTR        1C98
CHECK_OP_RTS        1E40
CHECK_OP_SBCD       20E6
CHECK_OP_SCC        1F16
CHECK_OP_STATIC_BCHG  1A42
CHECK_OP_STATIC_BCLR  1B10
CHECK_OP_STATIC_BSET  1A56
CHECK_OP_STATIC_BTST  1A2E
CHECK_OP_STOP       1C48
CHECK_OP_SUB        2186
CHECK_OP_SUBA       2144
CHECK_OP_SUBI       19F2
CHECK_OP_SUBQ       1F3E
CHECK_OP_SUBX       2158
CHECK_OP_SWAP       1D62
CHECK_OP_TAS        1D8A
CHECK_OP_TRAP       1DB2
CHECK_OP_TRAPV      1C88
CHECK_OP_TST        1D9E
CHECK_OP_UNLK       1DDA
CHECK_POSITIVE_LENGTH  130A
CHECK_PRINT         11C2
CHECK_SIZE_BIT_FOR_SUB  2132
CHECK_VALID_LENGTH  1314
CHECK_XXXX          28FC
CHRDONE             13FC
CHRLOOP             13E8
CHUMP_BYTE          3530
CHUMP_LONG          3540
CHUMP_WORD          3538
CLEAR_BUFFER        12BC
CLEAR_BUFFER_END    12D6
CLEAR_BUFFER_LENGTH  12B8
CLEAR_BUFFER_LOOP   12CA
CLEAR_BUFFER_POINTER  12B4
COMMA               28E4
CONVERTED_HEX_STRING  12E1
CONVERT_HEX_TO_STRING  12EA
CONVERT_TO_HEX_LETTER  1330
COUNTDONE           139C
COUNTLOOP           138A
CR                  D
CUR_OP_CODE         10A0
C_GROUP_0           197A
C_GROUP_1           1B58
C_GROUP_2           1B82
C_GROUP_3           1BE4
C_GROUP_4           1C46
C_GROUP_5           1EFE
C_GROUP_6           1F68
C_GROUP_7           20AE
C_GROUP_8           20CE
C_GROUP_9           212E
C_GROUP_A           21A0
C_GROUP_B           21A8
C_GROUP_C           221C
C_GROUP_D           22A0
C_GROUP_E           2300
C_GROUP_F           24B0
DATA                28DD
DIGIT_LOOP          131C
DIR_0               2C58
DIR_1               2CA8
DIVS                2CF8
DIVS_BACK           2D1A
DONE                124E
DOWN_ONE            2B5A
DOWN_ZERO           2B52
DYNMC_BCLR          3412
D_TO_A              30CA
END                 36D2
EXT                 28F8
FILEID              171A
FILENAME            16FA
FINDNULLLOOPDONE    136C
FIND_1_BIT_SIZE_6   189E
FIND_1_BIT_SIZE_8   18BE
FIND_2_BIT_SIZE_7_TO_6  187E
FIND_MOVEA_L_DIFFERENCE  1B98
FIND_MOVEA_W_DIFF   1BFA
FIRST_3             173A
FIRST_X             28EC
FIRST_Y             28ED
FOURTH_3            173D
FST_X               315A
FST_X2              324C
FST_Y1              31A6
FST_Y2              31C0
FST_Y3              3298
FST_Y4              32B2
FUK_MOVEM           2F44
GO                  3548
GOO                 3480
GOO2                34AC
GO_A_TO_D           31E6
GO_D_TO_A           30F4
GROUP0_INVALID      1B4C
GROUP0_SUCCESS      1B52
GROUP1_INVALID      1B76
GROUP1_SUCCESS      1B7C
GROUP2_INVALID      1BD8
GROUP2_SUCCESS      1BDE
GROUP3_INVALID      1C3A
GROUP3_SUCCESS      1C40
GROUP4_INVALID      1EF2
GROUP4_SUCCESS      1EF8
GROUP5_INVALID      1F5C
GROUP5_SUCCESS      1F62
GROUP6_INVALID      20A2
GROUP6_SUCCESS      20A8
GROUP7_INVALID      20C2
GROUP7_SUCCESS      20C8
GROUP8_INVALID      2122
GROUP8_SUCCESS      2128
GROUP9_INVALID      2194
GROUP9_SUCCESS      219A
GROUPB_INVALID      2210
GROUPB_SUCCESS      2216
GROUPC_INVALID      2294
GROUPC_SUCCESS      229A
GROUPD_INVALID      22F4
GROUPD_SUCCESS      22FA
GROUPE_INVALID      24A4
GROUPE_SUCCESS      24AA
GROUP_0             1750
GROUP_1             1762
GROUP_2             1774
GROUP_3             1786
GROUP_4             1798
GROUP_5             17AA
GROUP_6             17BC
GROUP_7             17CE
GROUP_8             17E0
GROUP_9             17F2
GROUP_A             1804
GROUP_B             1816
GROUP_C             1828
GROUP_D             183A
GROUP_E             184C
GROUP_F             185E
GT                  36BE
G_BUFFER            1000
HEX_SIGN            28E0
IMMDTE_VALU         28E1
INVALID             36D6
INVALID_ADDRES_MESSAGE  171E
INVALID_OP          24B8
IO_BUFFER           1705
IS_VALID            10A2
ITS_X               313E
ITS_X2              3230
ITS_Y               3180
ITS_Y2              3272
ITS_Y2_BACK         327C
ITS_Y_BACK          318A
JSR                 2EBC
JSR_BACK            2ED4
KEEP_GOING          31D8
KEEP_GOING0         3124
KEEP_GOING1         3216
KEEP_GOING2         32CA
LE                  36C8
LEA                 2EF8
LEA_BACK            2F1A
LF                  A
LOAD_0000           32D8
LOAD_00XX           345E
LOAD_0100           2DCE
LOAD_0101           2D44
LOAD_0110           2AAE
LOAD_1000           2C2C
LOAD_1001           2C26
LOAD_1011           2C20
LOAD_1100           2C1A
LOAD_1101           2BB8
LOAD_1110           298E
LOAD_8              2A54
LOAD_A              364C
LOAD_ABS_LONG       35DE
LOAD_ABS_SHORT      35CC
LOAD_ADDRESS        35A2
LOAD_ADDRESS_W_POST_INC  35B4
LOAD_ADDRESS_W_PRE_DEC  35C0
LOAD_ADDR_REGISTER  3590
LOAD_BYTES          35FA
LOAD_COMMA_SPACE    3626
LOAD_D              363E
LOAD_DATA_REGISTER  357E
LOAD_EA             34C2
LOAD_FIRST3         2A5E
LOAD_GE_111         3502
LOAD_HEX_SIGN       3676
LOAD_IMMDTE         35F0
LOAD_IMMDTE_VALU    3684
LOAD_LT_111         34D4
LOAD_MINUS_SIGN     36A0
LOAD_NEW_LINE       3624
LOAD_NUM            36B2
LOAD_PLUS_SIGN      3692
LOAD_PTHSIS_CLSD    3668
LOAD_PTHSIS_OPEN    365A
LOAD_THIS_SHIT      36AE
LOOP                3604
MAIN_CONSOLE        1428
MAIN_EA             28EE
MAIN_LOOP           1160
MINUS_SIGN          28E3
MNEMONIC            1739
MOVEM               2EEA
MOVEM_BIT_SIZE_CHECK  1EA8
MOVEM_PARSE         308E
MOVEM_POST          2F64
MOVEM_POST2         2F88
MOVEM_POST3         2FA4
MOVEM_POSTL         2FFE
MOVEM_POSTW         2FCC
MOVEM_PRE           3030
MOVEM_PRE_B         305A
MOVEON              29E8
MOVE_AND_MOVEA_PARSE_EA  18DE
MYBE_ASD_1          29B0
MYBE_ASD_2          2A16
MYBE_BCLR           3320
MYBE_BRA            2ACE
MYBE_CMPI           3308
MYBE_JSR            2E3C
MYBE_MOVEM          2E5C
MYBE_NEG            2DE6
MYBE_ORI            32F0
MYBE_RTS1           2DFE
MYBE_RTS2           2E0C
MYBE_RTS3           2E1A
MYBE_SUBQ1          2D5E
MYBE_SUBQ2          2D6E
MYBE_Y              3172
MYBE_Y2             3264
NEG                 2E7C
NEG_BACK            2E9E
NEG_WORD            2B9A
NEWLINE             16D4
NOT_BCLR            332A
NOT_BRA             2ADC
NOT_CMPI            3312
NOT_JSR             2E46
NOT_MOVEM           2E6C
NOT_NEG             2DF0
NOT_ORI             32FA
NOT_RTS             2E2E
NULLLOOP            135E
NUMBER_TO_CONVERT   12DC
OP_JSR_DONE         186C
OP_JSR_ROUTINE      173E
OP_SIZE             1738
ORI_CMPI            333A
OR_BACK             2C7E
OR_BACK2            2CE2
OUTFILENAME         16DA
PARSE_EA_CONSTANT_BITS  1924
PLUS_SIGN           28E2
POS_WORD            2B86
PRINT_DATA          11DC
PRINT_INSTRUCTION   11D0
PRINT_OP_ADD        26B6
PRINT_OP_ADDA       26CA
PRINT_OP_ASL        271A
PRINT_OP_ASR        2706
PRINT_OP_BCS        25E6
PRINT_OP_BGE        25FA
PRINT_OP_BLT        260E
PRINT_OP_BRA        2636
PRINT_OP_BVC        2622
PRINT_OP_CMP        2694
PRINT_OP_CMPI       24E2
PRINT_OP_DIVS       264A
PRINT_OP_DYNAMIC_BCLR  250A
PRINT_OP_EOR        2680
PRINT_OP_JSR        2564
PRINT_OP_LEA        258E
PRINT_OP_LSL        26DE
PRINT_OP_LSR        26F2
PRINT_OP_MOVEA_L    252C
PRINT_OP_MOVEA_W    2548
PRINT_OP_MOVEB      251E
PRINT_OP_MOVEM_L    25C4
PRINT_OP_MOVEM_W    25B6
PRINT_OP_MOVE_L     253A
PRINT_OP_MOVE_W     2556
PRINT_OP_MULS       26A8
PRINT_OP_NEG        25A2
PRINT_OP_NOP        2580
PRINT_OP_OR         2658
PRINT_OP_ORI        24CE
PRINT_OP_ROL        272E
PRINT_OP_ROR        2742
PRINT_OP_RTS        2572
PRINT_OP_SIZE       2780
PRINT_OP_SIZE_ADDA  279A
PRINT_OP_STATIC_BCLR  24F6
PRINT_OP_SUB        266C
PRINT_OP_SUBQ       25D2
PRINT_SIZE_BYTE     2756
PRINT_SIZE_LONG     2772
PRINT_SIZE_WORD     2764
PRINT_TO_BUFFER     24C0
PTHSIS_CLSD         28DF
PTHSIS_OPEN         28DE
P_INVALID_OP        27A4
P_OP_ADD            28AB
P_OP_ADDA           28A3
P_OP_ASL            28C7
P_OP_ASR            28C0
P_OP_BCLR           27CB
P_OP_BCS            2856
P_OP_BGE            285D
P_OP_BLT            2864
P_OP_BRA            284F
P_OP_BVC            286B
P_OP_CMP            2891
P_OP_CMPI           27C3
P_OP_DIVS           2872
P_OP_EOR            288A
P_OP_JSR            282B
P_OP_LEA            2824
P_OP_LSL            28B9
P_OP_LSR            28B2
P_OP_MOVEA_L        27DE
P_OP_MOVEA_W        27F5
P_OP_MOVEB          27D3
P_OP_MOVEM_L        2818
P_OP_MOVEM_W        280C
P_OP_MOVE_L         27EA
P_OP_MOVE_W         2801
P_OP_MULS           2898
P_OP_NEG            2840
P_OP_NOP            2832
P_OP_OR             287D
P_OP_ORI            27BC
P_OP_ROL            28D5
P_OP_ROR            28CE
P_OP_RTS            2839
P_OP_SUB            2883
P_OP_SUBQ           2847
P_SIZE_B            27B0
P_SIZE_L            27B8
P_SIZE_W            27B4
RET_SA              1426
ROTATE              360E
RTS                 2EB4
SAVED               34D2
SECOND_3            173B
SIZE                14
SIZE_B              3566
SIZE_L              3576
SIZE_W              356E
SKIP_HERE           31BC
SKIP_HERE2          32AE
SND_X               316A
SND_X2              325C
SND_Y               31D0
SND_Y2              32C2
SPACE               28E5
START               10A3
STRING_ADD_SUCCESS  12A0
STRING_BUFFER_ADD_LOOP  128A
STRING_BUFFER_LOOP  1276
STRING_BUFFER_POINTER  1252
STRIP_ASCII         1402
SUB30               1422
SUB37               141A
SUBQ                2D7E
SUBQ_BACK           2DB8
SUBQ_SAVED          2D90
SUBTRACT_X          31FC
SUBTRACT_Y          3206
THIRD_3             173C
TOSAVE              C3F
TRAILING_HELPER     3566
TRAILING_SIZE       28E6
TRAPTASK13          134A
VALIDATE_END_POS    111C
VALIDATE_EVEN       113E
VALIDATE_POSITIVE_ADDRESS  10FA
VALIDATE_START_ADDRESS  10F8
X                   28E8
X_COUNTER           28EA
Y                   28E9
Y_COUNTER           28EB
_00000000           1380
