000010A4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/17/2019 6:21:04 PM

00000000                             1  **--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler in Motorola 68k
00000000                             3  * Written by : TEAM REEE Denny, Daniel, Fahad
00000000                             4  * Date       : 3/17/2019 
00000000                             5  * 
00000000                             6  * 
00000000                             7  * Description: This disassembler reverse assembles or decompiles a given
00000000                             8  * test program (with vailidity checking) from their machine code hex
00000000                             9  * equivalents to outputting them onto a console file and a log.
00000000                            10  *
00000000                            11  * This disassembler will print out <MEMORY ADDRESS> <OPERAND> <EA MODE/REG>
00000000                            12  * If the identified code is valid.
00000000                            13  *
00000000                            14  * This disassembler will print out <MEMORY ADDRESS> DATA $<INVALID HEX>
00000000                            15  * If the identified code is invalid.
00000000                            16  *---------------------------------------------------------------------------
00001000                            17      ORG    $1000    
00001000                            18  *---------------------------------------------------------------------------
00001000                            19  G_BUFFER        DS.B    80          ;Used to print out the needed letters to the buffer
00001050                            20  B_BUFFER        DS.B    80          ;Bad buffer used to load bad data
000010A0                            21  CUR_OP_CODE     DS.W    1           ;Used to determine the current 4 hex OP code
000010A2                            22  IS_VALID        DS.B    1           ;Validity bit to check if a code is valid or not
000010A3                            23                          ;1 = valid, 0 = invalid
000010A3                            24  
000010A3                            25  START:                      ;Start of the program
000010A3                            26  
000010A4  43F9 00001428             27      LEA MAIN_CONSOLE, A1            ;Loads the main message into A1
000010AA  4EB9 0000134A             28      JSR TrapTask13                 ;Prints message out to console and log
000010B0                            29  
000010B0                            30      
000010B0                            31      
000010B0                            32      ******************************************
000010B0                            33      **
000010B0                            34      **     ___         ___        /  __  
000010B0                            35      **    |__  | |    |__     |  /  /  \  
000010B0                            36      **    |    | |___ |___    | /   \__/ 
000010B0                            37      **                           
000010B0                            38      **
000010B0                            39      ** This is the beginning of the code for reading from files
000010B0                            40      ******************************************
000010B0                            41  * Attempt to open file for input
000010B0  43F9 000016FA             42          LEA     fileName,A1                    ;Name of file to open
000010B6  103C 0033                 43          MOVE.B  #51,D0                         ;Trap task #51, open existing file
000010BA  4E4F                      44          TRAP    #15                            ;Perform task
000010BC  23C1 0000171A             45          MOVE.L  D1,fileID                      ;Save file ID
000010C2                            46  
000010C2                            47  * Read string from file
000010C2  43F9 00001705             48          LEA     IO_BUFFER,A1                   ;Location of string buffer
000010C8  2239 0000171A             49          MOVE.L  fileID,D1                      ;File ID of file to read from
000010CE  4282                      50          CLR.L   D2
000010D0  343C 0014                 51          MOVE.W  #SIZE,D2                       ;Number of bytes to read
000010D4  103C 0035                 52          MOVE.B  #53,D0                         ;Trap task #53, read from file
000010D8  4E4F                      53          TRAP    #15                            ;Perform task
000010DA                            54  * Close file when finished
000010DA  103C 0038                 55          MOVE.B  #56,D0                         ;Trap task #56, close file, D1 contains fileID
000010DE  4E4F                      56          TRAP    #15                            ;Perform task
000010E0                            57  
000010E0                            58  
000010E0                            59  *Load start and end address as longs
000010E0                            60  *Start Address is in A5     
000010E0  43F9 00001705             61      LEA IO_BUFFER, A1               ;Load string or IO buffer to A1
000010E6  4EB9 000013E0             62      JSR AsciiToHex                  ;Convert ASCII to Hex
000010EC  2A47                      63      MOVE.L D7, A5                   ;Loop counter prep
000010EE                            64      
000010EE                            65  *End Address is in A6
000010EE  5489                      66      ADDA.L #2, A1                   ;Add #2 to A1
000010F0  4EB9 000013E0             67      JSR AsciiToHex                  ;Convert ASCII to Hex
000010F6  2C47                      68      MOVE.L D7, A6                   ;Loop counter prep
000010F8                            69      
000010F8                            70  VALIDATE_START_ADDRESS              ;Validates starting address
000010F8  200D                      71      MOVE.L A5, D0                   ;Move stating address to D0
000010FA                            72  *----------------------------------------------------------------------------------
000010FA                            73  * Method Name: VALIDATE_POSITIVE_ADDRESS
000010FA                            74  * Description: Checks if the start address is positive it then branches
000010FA                            75  *              to validate if the address in the Config.cfg file is even
000010FA                            76  *
000010FA                            77  *  Preconditions & Input of a start address that is even
000010FA                            78  *       A1 (input) points to a memory buffer holding 8 ASCII chars (not null-terminated) 
000010FA                            79  *       This function calls another function (strip_ascii)
000010FA                            80  *
000010FA                            81  *  Postconditions & Output
000010FA                            82  *   
000010FA                            83  *----------------------------------------------------------------------------------
000010FA                            84  VALIDATE_POSITIVE_ADDRESS
000010FA  200D                      85      MOVE.L A5, D0                   ;Move starting address to D0
000010FC  0280 80000000             86      ANDI.L #$80000000, D0           ;Checking if the start address address is positive
00001102  B0BC 00000000             87      CMP.L #0, D0                    ;Compare 0 to D0
00001108  6700 0034                 88      BEQ VALIDATE_EVEN               ;Check if the address is even
0000110C                            89      
0000110C  43F9 0000171E             90      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001112  4EB9 0000134A             91      JSR TrapTask13                             ;Use Nash's Console Output
00001118  6000 0134                 92      BRA DONE                        ;Finish routine
0000111C                            93  
0000111C                            94  VALIDATE_END_POS
0000111C  200E                      95      MOVE.L A6, D0                   ;Move ending address to D0
0000111E  0280 80000000             96      ANDI.L #$80000000, D0                  ;Checking if the end address address is positive
00001124  B0BC 00000000             97      CMP.L #0, D0                    ;Compare address to 0
0000112A  6700 0012                 98      BEQ VALIDATE_EVEN               ;Check if the end address is even
0000112E                            99      
0000112E  43F9 0000171E            100      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001134  4EB9 0000134A            101      JSR TrapTask13                             ;Use Nash's Console Output      
0000113A  6000 0112                102      BRA DONE                        ;Finish routine
0000113E                           103      
0000113E                           104  VALIDATE_EVEN
0000113E  200D                     105      MOVE.L A5, D0                   ;MOVE STARTING ADDRESS TO D0
00001140  0280 00000001            106      ANDI.L #$00000001,D0                   ;Bitmask 1 a single bit to D0
00001146  B0BC 00000000            107      CMP.L #0, D0                    ;Check if even
0000114C  6700 0012                108      BEQ MAIN_LOOP                   ;Go to the main loop if even
00001150                           109  *Handle odd addresses
00001150  43F9 0000171E            110      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001156  4EB9 0000134A            111      JSR TrapTask13                             ;Use Nash's Console Output
0000115C  6000 00F0                112      BRA DONE                        ;Finish routine
00001160                           113              
00001160                           114  
00001160                           115  
00001160                           116  *Comments are shifted if variable names get too long
00001160                           117  MAIN_LOOP                                   ;Main loop to run each instruction
00001160  49F8 1000                118           LEA G_BUFFER,A4                            ;Point G_BUFFER to A4
00001164                           119      
00001164  BDCD                     120              CMPA.L A5, A6                           ;Compare Starting to ending address
00001166  6D00 00E6                121              BLT DONE                            ;If it's less then stop the loop
0000116A                           122              
0000116A                           123  *Clear both buffers 
0000116A  23FC 00001000 000012B4   124              MOVE.L #G_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to G_BUFFER
00001174  4EB9 000012BC            125              JSR CLEAR_BUFFER                        ;Clear the buffer
0000117A                           126              
0000117A  23FC 00001050 000012B4   127              MOVE.L #B_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to B_BUFFER
00001184  4EB9 000012BC            128              JSR CLEAR_BUFFER                        ;Clear the buffer
0000118A                           129              
0000118A                           130  *Add address to both buffers
0000118A                           131              
0000118A  23CD 000012DC            132              MOVE.L A5, NUMBER_TO_CONVERT                ;The current address is stored to A5, we need to convert it to load it in the buffers.
00001190  13FC 0008 000012E0       133              MOVE.B #8, CHARNUM_TO_CONVERT               ;This specifies the number of characters that needs to be converted.
00001198  4EB9 000012EA            134              JSR CONVERT_HEX_TO_STRING                   ;Convert hex to string
0000119E                           135              
0000119E  23FC 000012E1 00001252   136              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER ;Prepare the string buffer with the converted hex string
000011A8  23FC 00001000 00001256   137              MOVE.L #G_BUFFER, BUFFER_POINTER                   ;Point G_BUFFER to the print buffer
000011B2  4EB9 00001260            138              JSR AddStrToBuffer                      ;Add the string to the print buffer
000011B8                           139      
000011B8  31DD 10A0                140              MOVE.W (A5)+, CUR_OP_CODE                   ;Read the current opcode
000011BC  4EF9 0000173E            141              JMP OP_JSR_Routine                      ;Run main OP code routine
000011C2                           142  
000011C2                           143  *********************************
000011C2                           144  *Checks if its valid print or invalid
000011C2                           145  * @pre checks invalid
000011C2                           146  * @post Branches to the respective branch
000011C2                           147  ************************************
000011C2                           148  check_print
000011C2  0C38 0001 10A2           149              CMP.B #1,IS_VALID                       ;Check if IS_VALID is set to 1
000011C8  6700 0006                150              BEQ   print_instruction                 ;If it's valid do print_instruction
000011CC  6600 000E                151              BNE   print_data                        ;If it's invalid do print_data
000011D0                           152              
000011D0                           153  print_instruction                               ;Prints the data in G_BUFFER
000011D0                           154  *Print the opcode if valid
000011D0  43F8 1000                155              LEA G_BUFFER,A1                     ;Points A1 to G_BUFFER
000011D4  4EB9 0000134A            156              JSR TrapTask13                          ;Use Nash's console output
000011DA  6084                     157              BRA MAIN_LOOP                           ;Go back to the main loop
000011DC                           158   
000011DC                           159  *Otherwise print data
000011DC                           160  print_data  
000011DC  23CD 000012DC            161              MOVE.L A5, NUMBER_TO_CONVERT                    ;The current address is stored to A5, we need to convert it to load it in the buffers.
000011E2  13FC 0008 000012E0       162              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
000011EA  4EB9 000012EA            163              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
000011F0  23FC 000012E1 00001252   164              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Point the string buffer to the converted hex
000011FA                           165              
000011FA  23FC 00001050 00001256   166              MOVE.L #B_BUFFER, BUFFER_POINTER                    ;Prepare the string buffer with the valid data
00001204  4EB9 00001260            167              JSR AddStrToBuffer                          ;Add the string to the print buffer
0000120A                           168  *Add bad data to bad buffer
0000120A  23FC 000027A4 00001252   169              MOVE.L #P_INVALID_OP, STRING_BUFFER_POINTER         ;Prepare the string buffer with the invalid data
00001214  4EB9 00001260            170              JSR AddStrToBuffer                          ;Add the string to the print buffer
0000121A                           171              
0000121A  33F8 10A0 000012DC       172              MOVE.W CUR_OP_CODE, NUMBER_TO_CONVERT               ;The current address is stored to A5, we need to convert it to load it in the buffers.
00001222  13FC 0008 000012E0       173              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
0000122A  4EB9 000012EA            174              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
00001230                           175              
00001230  23FC 000012E1 00001252   176              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Prepare the string buffer with the converted hex string
0000123A  4EB9 00001260            177              JSR AddStrToBuffer                          ;Add the converted hex to buffer
00001240                           178              
00001240  43F8 1050                179              LEA B_BUFFER,A1                         ;Point A1 to the bad buffer
00001244  4EB9 0000134A            180              JSR TrapTask13                              ;Use Nash's console output
0000124A  6000 FF14                181              BRA MAIN_LOOP                               ;Go back to the main loop
0000124E                           182  
0000124E                           183  
0000124E                           184  DONE                                            ;We're finished at this point reading all the files
0000124E  FFFF FFFF                185              SIMHALT                                 ;Halt the simulation
00001252                           186              
00001252                           187  **
00001252                           188  * AddStrToBuffer
00001252                           189  *****************************************************************************
00001252                           190  * Description: Adds the a defined string constant into a buffer to print out
00001252                           191  * Places a NULL terminating string to start with a default buffer length of 80.
00001252                           192  *
00001252                           193  * If the buffer length is exceeded, where length was improperly specified or no
00001252                           194  * NULL terminating string was found, return 1, else return 0 for success.
00001252                           195  *
00001252                           196  * Additional Constants/Subroutines used:
00001252                           197  * STRING_BUFFER_POINTER                 ;String pointer
00001252                           198  * BUFFER_POINTER                        ;Buffer pointer
00001252                           199  * BUFFER_POINTER_LENGTH                 ;Buffer length, 80 chars by default
00001252                           200  * BUFFER_ADD_SUCCESS                    ;0 = success, 1 = failure
00001252                           201  * FIND_NULL_IN_BUFFER                   ;Find NULL in buffer with a loop
00001252                           202  * STRING_BUFFER_ADD_LOOP                    ;Add a string to the buffer with a loop
00001252                           203  * STRING_ADD_SUCCESS                       ;Routine to run when string is added successfully
00001252                           204  * BUFFER_LENGTH_FAIL                    ;Routine to run when buffer length is exceeded
00001252                           205  * BUFFER_STRING_END                     ;Subroutine is finished
00001252                           206  *****************************************************************************
00001252                           207  * Constant definitions:
00001252                           208  STRING_BUFFER_POINTER   DS.L    1
00001256                           209  BUFFER_POINTER      DS.L    1
0000125A= 00000050                 210  BUFFER_POINTER_LENGTH   DC.L    80
0000125E                           211  BUFFER_ADD_SUCCESS      DS.B    1
0000125F                           212  
00001260                           213  AddStrToBuffer:           DS.W    0                   ;Reserve a word
00001260  48E7 C0C0                214      MOVEM.L     D0-D1/A0-A1, -(SP)              ;Save registers to stack
00001264                           215      
00001264  2078 1252                216      MOVE.L      STRING_BUFFER_POINTER,A0        ;Load string pointer to A0
00001268  2278 1256                217      MOVE.L      BUFFER_POINTER, A1          ;Load buffer pointer to A1
0000126C  2038 125A                218      MOVE.L      BUFFER_POINTER_LENGTH, D0       ;Load buffer length to D0
00001270  4278 125E                219      CLR.W       BUFFER_ADD_SUCCESS          ;Clear any prior success bit
00001274  4281                     220      CLR.L       D1                      ;Clear any prior loop counts
00001276                           221  
00001276                           222  STRING_BUFFER_LOOP
00001276  0C11 0000                223      CMPI.B      #0, (A1)                    ;Check if buffer char is NULL or not
0000127A  6700 000E                224      BEQ         STRING_BUFFER_ADD_LOOP          ;If a 0 is found, start adding string(s) to the buffer
0000127E                           225      
0000127E  B280                     226      CMP.L       D0, D1                  ;Check if the counter is more than the max length
00001280  6C00 0026                227      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
00001284                           228      
00001284  5289                     229      ADDQ.L      #1, A1                  ;Increment to the next character
00001286  5201                     230      ADDQ.B      #1, D1                  ;Increment loop counter
00001288  60EC                     231      BRA         STRING_BUFFER_LOOP          ;Loop back again
0000128A                           232      
0000128A                           233  STRING_BUFFER_ADD_LOOP
0000128A  0C10 0000                234      CMPI.B      #0, (A0)                       ;Check is the string char is NULL
0000128E  6700 0010                235      BEQ         STRING_ADD_SUCCESS          ;String has been added successfully
00001292                           236      
00001292  B200                     237      CMP.B       D0, D1                  ;Check if the counter is more than the max length
00001294  6C00 0012                238      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
00001298                           239      
00001298  12D8                     240      MOVE.B      (A0)+,(A1)+             ;Add string to the buffer
0000129A  5201                     241      ADDQ.B      #1, D1                  ;Increment loop counter
0000129C  524C                     242      ADDQ.W      #1, A4                  ;Increment G_BUFFER counter
0000129E  60EA                     243      BRA         STRING_BUFFER_ADD_LOOP          ;Loop back again
000012A0                           244  
000012A0                           245  STRING_ADD_SUCCESS
000012A0  12BC 0000                246      MOVE.B      #0,(A1)                 ;Place NULL terminating 0 at the end
000012A4  6000 0008                247      BRA         BUFFER_STRING_END               ;Finish subroutine
000012A8                           248  
000012A8                           249  BUFFER_LENGTH_EXCEEDED
000012A8  31FC 0001 125E           250      MOVE.W      #1, BUFFER_ADD_SUCCESS          ;BUFFER failed to add
000012AE                           251  
000012AE                           252  BUFFER_STRING_END
000012AE  4CDF 0303                253      MOVEM.L     (SP)+, D0-D1/A0-A1          ;Restore registers from stack
000012B2  4E75                     254      RTS                                     ;Return to stack
000012B4                           255  **************************************************************************
000012B4                           256  * CLEAR_BUFFER
000012B4                           257  *****************************************************************************
000012B4                           258  * Description: Clears the defined buffer area with NULL terminating 0s
000012B4                           259  * The default size is 80 bytes
000012B4                           260  *
000012B4                           261  * Additional Constants/Subroutines used:
000012B4                           262  * CLEAR_BUFFER_POINTER                  ;Buffer pointer
000012B4                           263  * CLEAR_BUFFER_LENGTH                   ;Length of buffer, default 80 bytes
000012B4                           264  * CLEAR_BUFFER_LOOP                     ;Buffer loop
000012B4                           265  * CLEAR_BUFFER_END                      ;Finish subroutine
000012B4                           266  *****************************************************************************
000012B4                           267  * Constant definitions:
000012B4                           268  CLEAR_BUFFER_POINTER    DS.L    1
000012B8= 00000050                 269  CLEAR_BUFFER_LENGTH     DC.L    80
000012BC                           270  
000012BC                           271  CLEAR_BUFFER:           DS.W    0                  ;Reserve a word
000012BC  48E7 C080                272      MOVEM.L     D0-D1/A0, -(SP)             ;Save registers to stack
000012C0  2078 12B4                273      MOVEA.L     CLEAR_BUFFER_POINTER, A0        ;Load buffer address to A0
000012C4  2038 12B8                274      MOVE.L      CLEAR_BUFFER_LENGTH, D0         ;Load buffer length to D0
000012C8  4281                     275      CLR.L       D1                      ;Clear any prior loop counter
000012CA                           276      
000012CA                           277  CLEAR_BUFFER_LOOP
000012CA  B280                     278      CMP.L       D0, D1                  ;Check if the counter is more than the max length
000012CC  6C00 0008                279      BGE         CLEAR_BUFFER_END                ;Finish subroutine
000012D0                           280      
000012D0  4218                     281      CLR.B       (A0)+                   ;Clear current character in clear buffer
000012D2  5241                     282      ADDQ        #1, D1                  ;Increment loop counter
000012D4  60F4                     283      BRA         CLEAR_BUFFER_LOOP               ;Loop back again
000012D6                           284      
000012D6                           285  CLEAR_BUFFER_END
000012D6  4CDF 0103                286      MOVEM.L     (SP)+, D0-D1/A0             ;Restore registers from stack
000012DA  4E75                     287      RTS                         ;Return to stack
000012DC                           288  
000012DC                           289  
000012DC                           290  **
000012DC                           291  * CONVERT_HEX_TO_STRING
000012DC                           292  *****************************************************************************
000012DC                           293  * Description: Converts a given number to a hexadecimal string by the specified 
000012DC                           294  * length. A null terminating string is added after (0). Conversion starts from the
000012DC                           295  * rightmost bit.
000012DC                           296  *
000012DC                           297  * Default length of conversion is 8, but can be changed.
000012DC                           298  
000012DC                           299  * Additional Constants/Subroutines used:
000012DC                           300  * NUMBER_TO_CONVERT                     ;Number to convert
000012DC                           301  * CHARNUM_TO_CONVERT                    ;Character numbers to convert, valid range is 0-8
000012DC                           302  * CONVERTED_HEX_STRING                  ;Converted hexadecimal character string
000012DC                           303  * CHECK_POSITIVE_LENGTH                 ;Routine to check for positive length
000012DC                           304  * CHECK_VALID_LENGTH                    ;Routine to check for valid length
000012DC                           305  * DIGIT_LOOP                            ;Looping through each digit
000012DC                           306  * CONVERT_TO_HEX_LETTER                 ;Routine to convert to hex letter
000012DC                           307  * ADD_CHAR_TO_STRING                    ;Adds a character to the string
000012DC                           308  *****************************************************************************
000012DC                           309  * Constant definitions:
000012DC                           310  NUMBER_TO_CONVERT       DS.L    1
000012E0= 08                       311  CHARNUM_TO_CONVERT      DC.B    8
000012E1                           312  CONVERTED_HEX_STRING    DS.B    9
000012EA                           313  
000012EA                           314  CONVERT_HEX_TO_STRING:  DS.W    0                 ;Reserve a word       
000012EA  48E7 F0C0                315      MOVEM.L     D0-D3/A0-A1, -(SP)          ;Save registers to stack
000012EE  4281                     316      CLR.L       D1                      ;Clear any prior number from D1
000012F0  4280                     317      CLR.L       D0                      ;Clear any prior number from D0
000012F2  2038 12DC                318      MOVE.L      NUMBER_TO_CONVERT, D0           ;Load number to D0
000012F6  1238 12E0                319      MOVE.B      CHARNUM_TO_CONVERT, D1          ;Load length to D1
000012FA  207C 000012E1            320      MOVEA.L     #CONVERTED_HEX_STRING, A0       ;Load string address to convert
00001300                           321      
00001300  0C01 0001                322      CMPI.B      #1, D1                  ;Check if D1 is one or not
00001304  6C00 0004                323      BGE         CHECK_POSITIVE_LENGTH           ;Check the length of the number
00001308  7201                     324      MOVEQ       #1, D1                  ;Move number 1 to D1 otherwise
0000130A                           325      
0000130A                           326  CHECK_POSITIVE_LENGTH                   ;Checks the positive length
0000130A  0C01 0008                327      CMPI.B      #8, D1                  ;Check if the length is 8 or not
0000130E  6F00 0004                328      BLE         CHECK_VALID_LENGTH          ;If it's less find and check the length
00001312  7208                     329      MOVEQ       #8, D1                  ;Move number 8 into the length
00001314                           330      
00001314                           331  CHECK_VALID_LENGTH                      ;Checks to see if the length is valid
00001314  2248                     332      MOVEA.L     A0, A1                  ;A0 contains start number, A1 contains current number
00001316  D2C1                     333      ADDA.W      D1, A1                  ;Go to the last digit
00001318  4211                     334      CLR.B       (A1)                    ;Make the last digit NULL or 0
0000131A  740F                     335      MOVEQ       #$0F,D2                 ;Bitmask last hex or nibble
0000131C                           336      
0000131C                           337  DIGIT_LOOP
0000131C  1600                     338      MOVE.B      D0, D3                  ;Get 2 hex chars from number
0000131E  C602                     339      AND.B       D2, D3                  ;Mask to get last hex char
00001320                           340      
00001320  0C03 0009                341      CMPI.B      #9, D3                  ;Check if the value is over 9
00001324  6E00 000A                342      BGT         CONVERT_TO_HEX_LETTER           ;If so, it must be a letter, convert the letter
00001328                           343      
00001328  0603 0030                344      ADDI.B      #'0', D3                       ;Get the ASCII value for 0-9
0000132C  6000 000A                345      BRA         ADD_CHAR_TO_STRING          ;Add char to the string
00001330                           346  
00001330                           347  CONVERT_TO_HEX_LETTER
00001330  0403 000A                348      SUBI.B      #10, D3                 ;Subtract 10 first to get correct ASCII
00001334  0603 0041                349      ADDI.B      #'A', D3                    ;Get the ASCII value for letters A-F
00001338                           350  
00001338                           351  ADD_CHAR_TO_STRING
00001338  1303                     352      MOVE.B      D3, -(A1)                   ;Add char to string and decrement pointer
0000133A  E888                     353      LSR.L       #4, D0                  ;Shift the 4 bits to the right
0000133C  B3C8                     354      CMPA.L      A0, A1                  ;Check if the current pointer is greater than starting string
0000133E  6EDC                     355      BGT         DIGIT_LOOP                     ;If so, loop back
00001340  42B8 12DC                356      CLR.L  NUMBER_TO_CONVERT                          ;Clear any prior number  
00001344                           357      
00001344  4CDF 030F                358      MOVEM.L     (SP)+, D0-D3/A0-A1             ;Restore registers from stack
00001348  4E75                     359      RTS                         ;Finish subroutine
0000134A                           360  
0000134A                           361  
0000134A                           362  ******************************************* START OF NASH CODE ******************   
0000134A                           363  *********************************************************************************
0000134A                           364  * Method Name: TrapTask13
0000134A                           365  * Description: Creates a file if none exists, and appends bytes to that file
0000134A                           366  *   while also echoing the written bytes to the screen.  You shouldn't need to
0000134A                           367  *   change this code.
0000134A                           368  *
0000134A                           369  * Calling Convention: Callee-Saved 
0000134A                           370  *
0000134A                           371  * Preconditions & Method Input:
0000134A                           372  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000134A                           373  *
0000134A                           374  * Postconditions & Output:
0000134A                           375  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000134A                           376  *   See 'Output.txt' in directory for the results, also piped to the console
0000134A                           377  *
0000134A                           378  *
0000134A                           379  *  A2 holds a pointer to null terminated string to write (input)
0000134A                           380  *  A3 points to the null-terminated file name
0000134A                           381  *  D3 holds the number of bytes already in the file to write
0000134A                           382  *
0000134A                           383  *  D5 holds number of bytes to write
0000134A                           384  ********************************************************************************
0000134A                           385  toSave REG D0-D5/A2-A3
0000134A                           386  TrapTask13:
0000134A                           387      *******************************************************************
0000134A                           388      * Method initialization, register spilling, parameter saving, etc.
0000134A                           389      *******************************************************************
0000134A  48E7 FC30                390      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
0000134E                           391        
0000134E  2449                     392      MOVEA.L A1, A2 ; save this buffer to write
00001350  47F9 000016DA            393      LEA outFilename, A3  ; save this for later, too
00001356                           394        
00001356  303C 0032                395      move #50,d0   
0000135A  4E4F                     396      trap #15 ; close all files, suggested to begin any IO 
0000135C                           397      *******************************************************************
0000135C                           398      * End Method Init
0000135C                           399      *******************************************************************
0000135C                           400  
0000135C                           401      ******************************************************************************************
0000135C                           402      * Calculate the number of bytes to write by searching for the null in the target buffer A0
0000135C                           403      ******************************************************************************************
0000135C  4285                     404      CLR.L D5 *D5 is now the number of bytes to write
0000135E                           405  nullLoop:
0000135E  1019                     406      MOVE.B (A1)+, D0
00001360  0C00 0000                407      CMPI.B #0,D0  * compare to null
00001364  6700 0006                408      BEQ findNullLoopDone
00001368  5245                     409      ADDI.W #1, D5
0000136A  60F2                     410      BRA nullLoop
0000136C                           411      
0000136C                           412  findNullLoopDone:
0000136C  224B                     413      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
0000136E                           414      
0000136E                           415      ;check if file exists, and open with task 51 if so, otherwise 52
0000136E                           416      ;(precondition here is A1 points to the null-terminated filename )
0000136E  103C 0033                417      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001372  4E4F                     418      trap #15
00001374                           419        
00001374                           420      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
0000137A  103C 0034                421          MOVE.B #52, D0             ; open new file (52 is new)
0000137E  4E4F                     422          trap #15
00001380                           423      endi
00001380                           424      
00001380                           425      ********************************************************************************************************* 
00001380                           426      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001380                           427      *    (first, count number of bytes already in the file to obtain seek position)
00001380                           428      *********************************************************************************************************
00001380  4283                     429      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001382  7401                     430      MOVE.L #1, D2 ; read one byte at a time
00001384  43F9 000016F1            431      LEA byteRead, A1
0000138A                           432      
0000138A                           433  countLoop:
0000138A  103C 0035                434      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
0000138E  4E4F                     435      trap #15
00001390                           436      
00001390  0C40 0001                437      CMPI.W #1,D0  ;1 == EOF
00001394  6700 0006                438      BEQ countDone
00001398  5243                     439      ADDI #1, D3
0000139A  60EE                     440      BRA countLoop
0000139C                           441      
0000139C                           442  countDone:    
0000139C                           443      * close this file
0000139C  303C 0038                444       move #56,d0  
000013A0  4E4F                     445       trap #15 
000013A2                           446       
000013A2                           447       * reopen the target file
000013A2  224B                     448       MOVE.L A3,A1
000013A4  303C 0033                449       MOVE #51, D0
000013A8  4E4F                     450       trap #15
000013AA                           451       
000013AA                           452      * seek to right position, then continue with writing
000013AA  2403                     453      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000013AC  303C 0037                454      MOVE #55, D0  ; position file task
000013B0  4E4F                     455      trap #15
000013B2                           456  
000013B2                           457      ******************************************************************************
000013B2                           458      * Actually write the buffer to the file, after calculating the number of bytes 
000013B2                           459      *  to write and after seeking to the right location in the file for append
000013B2                           460      ******************************************************************************
000013B2                           461  
000013B2  2405                     462      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000013B4                           463      ; assumes A0 hasnt changed since handed to this method      
000013B4  224A                     464      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000013B6                           465      ; assumes file ID is still stored in D1.L  
000013B6  103C 0036                466      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000013BA  4E4F                     467      trap #15
000013BC                           468  
000013BC                           469      ; add a newline to the file output
000013BC  43F9 000016D4            470      LEA NEWLINE, A1
000013C2  103C 0036                471      MOVE.B #54, D0 
000013C6  143C 0002                472      MOVE.B #2,D2  ; kills # of bytes to write from input param
000013CA  4E4F                     473      trap #15
000013CC                           474      
000013CC                           475      ; finally, close only this file
000013CC  103C 0038                476      MOVE.B #56, D0 ; close file task
000013D0  4E4F                     477      trap #15
000013D2                           478    
000013D2                           479      ; report to screen
000013D2  224A                     480      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000013D4  103C 000D                481      MOVE.B #13, D0
000013D8  4E4F                     482      trap #15
000013DA                           483        
000013DA                           484      ; restore context
000013DA  4CDF 0C3F                485      MOVEM.L (SP)+, toSave
000013DE                           486      
000013DE  4E75                     487      RTS
000013E0                           488      
000013E0                           489      
000013E0                           490  *----------------------------------------------------------------------------------
000013E0                           491  * Method Name: AsciiToHex
000013E0                           492  * Written by : Berger, Modified by Nash
000013E0                           493  * Date       : 3/1/2019
000013E0                           494  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000013E0                           495  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000013E0                           496  *              its (4b each) equivalent hex value 
000013E0                           497  *  
000013E0                           498  *  Preconditions & Input
000013E0                           499  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000013E0                           500  *       This function calls another function (strip_ascii)
000013E0                           501  *
000013E0                           502  *  Postconditions & Output
000013E0                           503  *       D7 (output) holds the converted value 
000013E0                           504  *       Caller-Saved : D0 is temp, D6 is a loop var
000013E0                           505  *----------------------------------------------------------------------------------
000013E0                           506  AsciiToHexRegList REG D0,D6
000013E0                           507  AsciiToHex     
000013E0  48E7 8000                508      MOVEM.L asciiToHexRegList, -(SP)  *save context
000013E4  4287                     509      CLR.L D7 * clear our return value
000013E6  7C08                     510      MOVE.L #8, D6 ; and set up our loop counter
000013E8                           511  
000013E8                           512  chrLoop
000013E8  1019                     513      MOVE.B (A1)+,D0 * Get the first byte
000013EA  4EB9 00001402            514      jsr strip_ascii * Get rid of the ascii code    
000013F0  8E40                     515      OR.W D0,D7 * Load the bits into D7
000013F2                           516      
000013F2  5306                     517      subI.B #1,D6  *decrement our loop variable
000013F4  6700 0006                518      BEQ chrDone   *skip shifting if we are done
000013F8                           519      
000013F8  E987                     520      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
000013FA  60EC                     521      BRA chrLoop
000013FC                           522  
000013FC                           523  chrDone
000013FC  4CDF 0001                524      MOVEM.L (SP)+,asciiToHexRegList 
00001400  4E75                     525      RTS
00001402                           526  
00001402                           527  
00001402                           528  **********************************************************************
00001402                           529  * SUBROUTINE: strip_ascii
00001402                           530  * remove the ascii code from the digits 0-9,a-f, or A-F
00001402                           531  * Input Parameters: <D0> = ascii code
00001402                           532  *
00001402                           533  * Return parameters: D0.B = number 0...F, returned as 00...0F
00001402                           534  * Registers used internally: D0
00001402                           535  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00001402                           536  *
00001402                           537  ***********************************************************************
00001402                           538  strip_ascii
00001402  B03C 0039                539        CMP.B #$39,D0 * Is it in range of 0-9?
00001406  6F00 001A                540        BLE sub30 * Its a number
0000140A  B03C 0046                541        CMP.B #$46,D0 * Is is A...F?
0000140E  6F00 000A                542        BLE sub37 * Its A...F
00001412  0400 0057                543        SUB.B #$57,D0 * Its a...f
00001416  6000 000E                544        BRA ret_sa * Go back
0000141A  0400 0037                545  sub37 SUB.B #$37,D0 * Strip 37
0000141E  6000 0006                546        BRA ret_sa * Go back
00001422  0400 0030                547  sub30 SUB.B #$30,D0 * Strip 30
00001426  4E75                     548  ret_sa RTS * Go back
00001428                           549  ******************************************* END OF NASH CODE ********************
00001428                           550  MAIN_CONSOLE                                                            ;Main print message
00001428                           551     
00001428= 3D 3D 3D 3D 3D 3D ...    552        DC.B '============================================================',CR,LF
00001466= 7C 7C 20 20 20 20 ...    553        DC.B '||                                                        ||',CR,LF
000014A4= 7C 7C 20 20 20 23 ...    554        DC.B '||   #####      ###    ##   ##                            ||',CR,LF
000014E2= 7C 7C 20 20 23 23 ...    555        DC.B '||  ##        ##   ##  ## ##                              ||',CR,LF
00001520= 7C 7C 20 23 23 20 ...    556        DC.B '|| ## ####     #####   ####                               ||',CR,LF
0000155E= 7C 7C 20 23 23 20 ...    557        DC.B '|| ##    ##  ##    ##  ####                               ||',CR,LF
0000159C= 7C 7C 20 23 23 20 ...    558        DC.B '|| ##    ##  ##    ##  ## ##                              ||',CR,LF
000015DA= 7C 7C 20 20 23 23 ...    559        DC.B '||  #####     ######   ##  ##                             ||',CR,LF
00001618= 7C 7C 20 20 20 20 ...    560        DC.B '||                                                        ||',CR,LF
00001656= 7C 7C 20 20 20 44 ...    561        DC.B '||   Daniel Yan, Fahad Alshehri, Denny Park               ||',CR,LF
00001694= 3D 3D 3D 3D 3D 3D ...    562        DC.B '============================================================',CR,LF,0
000016D3                           563      
000016D3                           564  * Required variables and constants go here for your Disassembler
000016D3  =0000000D                565  CR              EQU $0D                     ;Carriage return
000016D3  =0000000A                566  LF              EQU $0A                        ;Line feed
000016D4= 000D 000A 0000           567  NEWLINE         DC.W CR,LF,0                    ;Make a new line
000016DA= 44 69 73 61 73 73 ...    568  outFilename     DC.B 'DisassemblerOutput.txt',0             ;Output file
000016F1                           569  byteRead        DS.B 1                              ;Read a byte
000016F2= 31 41 30 30 31 41 ...    570  ascii_val       DC.B $31,$41,$30,$30,$31,$41,$30,$30            ;Test value $1A001A00
000016FA                           571  
000016FA                           572  * Variables and constants
000016FA  =00000014                573  SIZE            EQU     20                          ;Max string size
000016FA= 43 6F 6E 66 69 67 ...    574  fileName        DC.B    'Config.cfg',0                  ;Name of text file
00001705                           575  IO_BUFFER       DS.B    SIZE                                    ;Variable for IO buffer
0000171A                           576  fileID          DS.L    1                                   ;Variable for File ID
0000171E= 496E 7661 6C69 6...      577  INVALID_ADDRES_MESSAGE DC.W 'Invalid Hex Address' ,CR,LF,0          ;Invalid message print
00001738                           578  
00001738                           579      INCLUDE "OP_Code_Routines.x68"                      ;OP role code to include
00001738                           580  
00001738                           581  OP_SIZE         DS.B    1   ;This constant refers to the size of the current OP code 
00001739                           582  MNEMONIC        DS.B    1   ;Constant for EA, first 4 bits (15-12) of a 4 hex OP code
0000173A                           583  FIRST_3         DS.B    1   ;Constant for EA, 3 bits (11-9) of a 4 hex OP code
0000173B                           584  SECOND_3        DS.B    1   ;Constant for EA, 3 bits (8-6) of a 4 hex OP code
0000173C                           585  THIRD_3         DS.B    1   ;Constant for EA, 3 bits (5-3) of a 4 hex OP code
0000173D                           586  FOURTH_3        DS.B    1   ;Constant for EA, 3 bits (2-0) of a 4 hex OP code
0000173E                           587  
0000173E                           588  
0000173E                           589  
0000173E                           590  
0000173E                           591  OP_JSR_Routine:
0000173E  48E7 C000                592      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
00001742  3038 10A0                593      MOVE.W CUR_OP_CODE,D0          ;Move current instruction set to D0
00001746  11FC 0001 10A2           594      MOVE.B #1,IS_VALID             ;Set IS_VALID bit to 1 by default
0000174C  720C                     595      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
0000174E  E2A8                     596      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
00001750                           597  
00001750                           598  GROUP_0:                           ;$0| ORI, BCLR (static and dynamic), CMPI                  
00001750  B03C 0000                599      CMP.B   #$0,D0                 ;Compare first nibble
00001754  6600 000C                600      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
00001758  4EB9 0000197A            601      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
0000175E  6000 010C                602      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001762                           603      
00001762                           604  GROUP_1:                           ;$1| MOVE.B
00001762  B03C 0001                605      CMP.B   #$1,D0                 ;Compare first nibble
00001766  6600 000C                606      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
0000176A  4EB9 00001B58            607      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
00001770  6000 00FA                608      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001774                           609  
00001774                           610  GROUP_2:                           ;$2| MOVE.L, MOVEA.L
00001774  B03C 0002                611      CMP.B   #$2,D0                 ;Compare first nibble
00001778  6600 000C                612      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
0000177C  4EB9 00001B82            613      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
00001782  6000 00E8                614      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001786                           615  
00001786                           616  GROUP_3:                           ;$3| MOVE.W, MOVEA.W
00001786  B03C 0003                617      CMP.B   #$3,D0                 ;Compare first nibble
0000178A  6600 000C                618      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
0000178E  4EB9 00001BE4            619      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
00001794  6000 00D6                620      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001798                           621  
00001798                           622  GROUP_4:                           ;$4| LEA, JSR, RTS, NEG, MOVEM
00001798  B03C 0004                623      CMP.B   #$4,D0                 ;Compare first nibble
0000179C  6600 000C                624      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
000017A0  4EB9 00001C46            625      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
000017A6  6000 00C4                626      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017AA                           627  
000017AA                           628  
000017AA                           629  GROUP_5:                           ;$5| SUBQ
000017AA  B03C 0005                630      CMP.B   #$5,D0                 ;Compare first nibble
000017AE  6600 000C                631      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
000017B2  4EB9 00001EFE            632      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
000017B8  6000 00B2                633      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017BC                           634  
000017BC                           635  
000017BC                           636  GROUP_6:                           ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
000017BC  B03C 0006                637      CMP.B   #$6,D0                 ;Compare first nibble
000017C0  6600 000C                638      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
000017C4  4EB9 00001F68            639      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
000017CA  6000 00A0                640      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017CE                           641  
000017CE                           642  
000017CE                           643  GROUP_7:                           ;$7| Display: DATA, $WXYZ (Unsupported)
000017CE  B03C 0007                644      CMP.B   #$7,D0                 ;Compare first nibble
000017D2  6600 000C                645      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
000017D6  4EB9 000020AE            646      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
000017DC  6000 008E                647      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017E0                           648  
000017E0                           649  
000017E0                           650  GROUP_8:                           ;$8| DIVS, OR
000017E0  B03C 0008                651      CMP.B   #$8,D0                 ;Compare first nibble
000017E4  6600 000C                652      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
000017E8  4EB9 000020CE            653      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
000017EE  6000 007C                654      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017F2                           655  
000017F2                           656  
000017F2                           657  GROUP_9:                           ;$9| SUB
000017F2  B03C 0009                658      CMP.B   #$9,D0                 ;Compare first nibble
000017F6  6600 000C                659      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
000017FA  4EB9 0000212E            660      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
00001800  6000 006A                661      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001804                           662  
00001804                           663  
00001804                           664  GROUP_A:                           ;$A| Display: DATA, $WXYZ (Unsupported)
00001804  B03C 000A                665      CMP.B   #$A,D0                 ;Compare first nibble
00001808  6600 000C                666      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
0000180C  4EB9 000021A0            667      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
00001812  6000 0058                668      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001816                           669  
00001816                           670  
00001816                           671  GROUP_B:                           ;$B| EOR, CMP
00001816  B03C 000B                672      CMP.B   #$B,D0                 ;Compare first nibble
0000181A  6600 000C                673      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
0000181E  4EB9 000021A8            674      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
00001824  6000 0046                675      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001828                           676  
00001828                           677  
00001828                           678  GROUP_C:                           ;$C| MULS
00001828  B03C 000C                679      CMP.B   #$C,D0                 ;Compare first nibble
0000182C  6600 000C                680      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
00001830  4EB9 0000221C            681      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
00001836  6000 0034                682      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000183A                           683  
0000183A                           684  
0000183A                           685  GROUP_D:                           ;$D| ADD, ADDA
0000183A  B03C 000D                686      CMP.B   #$D,D0                 ;Compare first nibble
0000183E  6600 000C                687      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
00001842  4EB9 000022A0            688      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
00001848  6000 0022                689      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000184C                           690  
0000184C                           691  
0000184C                           692  GROUP_E:                           ;$E| LSR, LSL, ASR, ASL, ROL, ROR
0000184C  B03C 000E                693      CMP.B   #$E,D0                 ;Compare first nibble
00001850  6600 000C                694      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
00001854  4EB9 00002300            695      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
0000185A  6000 0010                696      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000185E                           697  
0000185E                           698  
0000185E                           699  GROUP_F:                           ;$F| Display: DATA, $WXYZ (Unsupported)
0000185E  B03C 000F                700      CMP.B   #$F,D0                 ;Compare first nibble
00001862  4EB9 000024B0            701      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
00001868  6000 0002                702      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000186C                           703  
0000186C                           704  
0000186C                           705  OP_JSR_DONE:                       ;This subroutine is only called when identification has been finished
0000186C  4CDF 0003                706           MOVEM.L (SP)+,D0-D1       ;Recover register D0
00001870  0C38 0001 10A2           707           CMP.B #1,IS_VALID         ;Checks if the IS_VALID bit is valid or not
00001876  6700 1076                708           BEQ    main_EA            ;This runs EA's routines after OP code portion is finished
0000187A  6600 F946                709           BNE    check_print        ;If not valid, skip EA routine and call IO
0000187E                           710  FIND_2_BIT_SIZE_7_TO_6:         ;Move the 2 bit size field relevant register
0000187E  48E7 C000                711      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
00001882  3038 10A0                712      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
00001886  323C 0008                713      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
0000188A  E368                     714      LSL.W    D1,D0              ;Truncate to find the 2 size bits
0000188C  E268                     715      LSR.W    D1,D0              ;Reposition the bits
0000188E  323C 0006                716      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
00001892  E268                     717      LSR.W    D1,D0              ;Truncate to shift 2 bits to a byte
00001894  11C0 1738                718      MOVE.B   D0,OP_SIZE         ;Move 2 size bits into OP_SIZE
00001898  4CDF 0003                719      MOVEM.L (SP)+,D0-D1         ;Restore registers
0000189C  4E75                     720      RTS                         ;Return to stack
0000189E                           721  
0000189E                           722  FIND_1_BIT_SIZE_6:              ;Move the 1 bit size field relevant register
0000189E  48E7 C000                723      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018A2  3038 10A0                724      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018A6  323C 0009                725      MOVE.W   #9,D1              ;Prepare 9 bit shift to D1
000018AA  E368                     726      LSL.W    D1,D0              ;Truncate to find the size bit
000018AC  E268                     727      LSR.W    D1,D0              ;Reposition the bits
000018AE  323C 0006                728      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000018B2  E268                     729      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000018B4  11C0 1738                730      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
000018B8  4CDF 0003                731      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018BC  4E75                     732      RTS                         ;Return to stack
000018BE                           733  
000018BE                           734  FIND_1_BIT_SIZE_8:         ;Move the 1 bit size field relevant register
000018BE  48E7 C000                735      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018C2  3038 10A0                736      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018C6  323C 0007                737      MOVE.W   #7,D1              ;Prepare 7 bit shift to D1
000018CA  E368                     738      LSL.W    D1,D0              ;Truncate to find the 1 size bit
000018CC  E268                     739      LSR.W    D1,D0              ;Reposition the bits
000018CE  323C 0008                740      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
000018D2  E268                     741      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000018D4  11C0 1738                742      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
000018D8  4CDF 0003                743      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018DC  4E75                     744      RTS                         ;Return to stack
000018DE                           745  
000018DE                           746  MOVE_AND_MOVEA_PARSE_EA:     ;Move the 3 bit dynamic register bits to proper register
000018DE  3038 10A0                747      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0
000018E2  323C 000A                748      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
000018E6  E368                     749      LSL.W   D1,D0            ;Truncate to find the last 6 bits
000018E8  E268                     750      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
000018EA  3E00                     751      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
000018EC  323C 0003                752      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
000018F0  E26F                     753      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
000018F2  3A07                     754      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
000018F4  323C 000D                755      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
000018F8  E368                     756      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
000018FA  E268                     757      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
000018FC  3800                     758      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
000018FE                           759      
000018FE  3038 10A0                760      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0     
00001902  323C 0004                761      MOVE.W  #4,D1            ;Prepare 4 bit shift to D1
00001906  E368                     762      LSL.W   D1,D0            ;Truncate to find bits 11-6
00001908  E268                     763      LSR.W   D1,D0            ;Reposition bits
0000190A  323C 0006                764      MOVE.W  #6,D1            ;Prepare 6 bit shift to D1
0000190E  E268                     765      LSR.W   D1,D0            ;Truncate the SRC Reg/Mode bits
00001910  323C 0003                766      MOVE.W  #3,D1            ;Prepare a 3 bit shift to D1 for DST Reg/Mode
00001914  3C00                     767      MOVE.W  D0,D6            ;Copy over the current 6 bits to D6
00001916  E268                     768      LSR.W   D1,D0            ;Truncate DST Mode  
00001918  3E00                     769      MOVE.W  D0,D7            ;Move DST Reg to D7
0000191A  323C 000D                770      MOVE.W  #13,D1             
0000191E  E36E                     771      LSL.W   D1,D6            ;Truncate 13 bits in D6
00001920  E26E                     772      LSR.W   D1,D6            ;Reposition D6
00001922                           773                               ;D6 now contains the DST Reg
00001922  4E75                     774      RTS                      ;Return to stack
00001924                           775  PARSE_EA_CONSTANT_BITS:
00001924  48E7 C000                776      MOVEM.L D0-D1,-(SP)         ;Save register to stack
00001928                           777      *MNEMONIC SHIFT
00001928  3038 10A0                778      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
0000192C  323C 000C                779      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
00001930  E268                     780      LSR.W D1,D0                 ;Shift 12 bits from D0 right
00001932  11C0 1739                781      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
00001936                           782      *FIRST_3 SHIFT
00001936  323C 0009                783      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
0000193A  3038 10A0                784      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000193E  E948                     785      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
00001940  E848                     786      LSR.W #4,D0                 ;Reposition D0
00001942  E268                     787      LSR.W  D1,D0                ;Shift D0 9 bits right
00001944  11C0 173A                788      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
00001948                           789      *SECOND_3 SHIFT
00001948  3038 10A0                790      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000194C  EF48                     791      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
0000194E  EE48                     792      LSR.W #7,D0                 ;Reposition D0
00001950  EC48                     793      LSR.W #6,D0                 ;Shift D0 6 bits right
00001952  11C0 173B                794      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
00001956                           795      *THIRD_3 SHIFT
00001956  3038 10A0                796      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000195A  E648                     797      LSR.W #3,D0                 ;Shift D0 3 bits right
0000195C  323C 000D                798      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
00001960  E368                     799      LSL.W D1,D0                 ;Truncate first 13 bits of D0
00001962  E268                     800      LSR.W D1,D0                 ;Reposition D0
00001964  11C0 173C                801      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
00001968                           802      *FOURTH_3 SHIFT
00001968  3038 10A0                803      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
0000196C  E368                     804      LSL.W D1,D0                 ;Grab the fourth 3-bit group
0000196E  E268                     805      LSR.W D1,D0                 ;Shift D0 back into position
00001970  11C0 173D                806      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
00001974  4CDF 0003                807      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001978  4E75                     808      RTS                         ;Return to stack
0000197A                           809  
0000197A                           810  
0000197A                           811  
0000197A                           812  
0000197A                           813  
0000197A                           814  C_GROUP_0:
0000197A  48E7 C000                815      MOVEM.L D0-D1, -(SP)            ;Backup registers
0000197E                           816      
0000197E                           817  CHECK_OP_ORI_TO_CCR:
0000197E  3038 10A0                818      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001982  B07C 003C                819      CMP.W #$003C,D0                 ;Compare the direct full bits
00001986  6700 01C4                820      BEQ GROUP0_INVALID              ;INVALID OP code found
0000198A  6600 0002                821      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
0000198E                           822      
0000198E                           823  CHECK_OP_ORI_TO_SR:
0000198E  3038 10A0                824      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001992  B07C 007C                825      CMP.W #$007C,D0                 ;Compare the direct full bits
00001996  6700 01B4                826      BEQ GROUP0_INVALID              ;INVALID OP code found
0000199A  6600 0002                827      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
0000199E                           828      
0000199E                           829  CHECK_OP_ANDI_TO_CCR:
0000199E  3038 10A0                830      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019A2  B07C 023C                831      CMP.W #$023C,D0                 ;Compare the direct full bits
000019A6  6700 01A4                832      BEQ GROUP0_INVALID              ;INVALID OP code found
000019AA  6600 0002                833      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
000019AE                           834      
000019AE                           835  CHECK_OP_ANDI_TO_SR:
000019AE  3038 10A0                836      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019B2  B07C 027C                837      CMP.W #$027C,D0                 ;Compare the direct full bits
000019B6  6700 0194                838      BEQ GROUP0_INVALID              ;INVALID OP code found
000019BA  6600 0002                839      BNE CHECK_OP_EORI_TO_CCR                ;Check next routine
000019BE                           840  
000019BE                           841  CHECK_OP_EORI_TO_CCR:
000019BE  3038 10A0                842      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019C2  B07C 0A3C                843      CMP.W #$0A3C,D0                 ;Compare the direct full bits
000019C6  6700 0184                844      BEQ GROUP0_INVALID              ;INVALID OP code found
000019CA  6600 0002                845      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
000019CE                           846      
000019CE                           847  CHECK_OP_EORI_TO_SR:
000019CE  3038 10A0                848      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019D2  B07C 0A7C                849      CMP.W #$0A7C,D0                 ;Compare the direct full bits
000019D6  6700 0174                850      BEQ GROUP0_INVALID              ;INVALID OP code found
000019DA  6600 0002                851      BNE CHECK_OP_ANDI               ;Check next routine
000019DE                           852      
000019DE                           853  CHECK_OP_ANDI:
000019DE  3038 10A0                854      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019E2  0240 FF00                855      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000019E6  B07C 0200                856      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
000019EA  6700 0160                857      BEQ GROUP0_INVALID              ;INVALID OP code found
000019EE  6600 0002                858      BNE CHECK_OP_SUBI               Check next routine
000019F2                           859      
000019F2                           860  CHECK_OP_SUBI:
000019F2  3038 10A0                861      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019F6  0240 FF00                862      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000019FA  B07C 0400                863      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
000019FE  6700 014C                864      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A02  6600 0002                865      BNE CHECK_OP_ADDI               ;Check next routine
00001A06                           866  
00001A06                           867  CHECK_OP_ADDI:
00001A06  3038 10A0                868      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A0A  0240 FF00                869      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A0E  B07C 0600                870      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00001A12  6700 0138                871      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A16  6600 0002                872      BNE CHECK_OP_EORI               ;Check next routine 
00001A1A                           873  
00001A1A                           874  CHECK_OP_EORI:
00001A1A  3038 10A0                875      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A1E  0240 FF00                876      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A22  B07C 0A00                877      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
00001A26  6700 0124                878      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A2A  6600 0002                879      BNE CHECK_OP_STATIC_BTST        ;Check next routine
00001A2E                           880      
00001A2E                           881  CHECK_OP_STATIC_BTST:
00001A2E  3038 10A0                882      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A32  0240 FFC0                883      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A36  B07C 0800                884      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
00001A3A  6700 0110                885      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A3E  6600 0002                886      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
00001A42                           887      
00001A42                           888  CHECK_OP_STATIC_BCHG:
00001A42  3038 10A0                889      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A46  0240 FFC0                890      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A4A  B07C 0840                891      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
00001A4E  6700 00FC                892      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A52  6600 0002                893      BNE CHECK_OP_STATIC_BSET        ;Check next routine
00001A56                           894  
00001A56                           895  CHECK_OP_STATIC_BSET:
00001A56  3038 10A0                896      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A5A  0240 FFC0                897      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A5E  B07C 08C0                898      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
00001A62  6700 00E8                899      BEQ GROUP0_INVALID              ;INVALID OP code found   
00001A66  6600 0002                900      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
00001A6A                           901  
00001A6A                           902  CHECK_OP_DYNAMIC_BTST:
00001A6A  3038 10A0                903      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A6E  0240 F1C0                904      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001A72  B07C 0100                905      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
00001A76  6700 00D4                906      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A7A  6600 0002                907      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
00001A7E                           908  
00001A7E                           909  CHECK_OP_DYNAMIC_BCHG:
00001A7E  3038 10A0                910      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A82  0240 F1C0                911      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001A86  B07C 0140                912      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00001A8A  6700 00C0                913      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A8E  6600 0002                914      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001A92                           915      
00001A92                           916  CHECK_OP_DYNAMIC_BSET:
00001A92                           917  
00001A92  3038 10A0                918      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001A96  0240 F1C0                919      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001A9A  B07C 01C0                920      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
00001A9E  6700 0006                921      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001AA2  6600 001C                922      BNE     CHECK_OP_MOVEP          ;Check next routine
00001AA6                           923  
00001AA6                           924  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00001AA6  3038 10A0                925      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AAA  323C 000A                926      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
00001AAE  E368                     927      LSL.W   D1,D0                   ;Shift out 10 bits left 
00001AB0  E268                     928      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001AB2  E648                     929      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00001AB4  B07C 0001                930      CMP.W   #$1,D0                  ;Compare bits to D0
00001AB8  6700 0006                931      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
00001ABC  6600 008E                932      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid
00001AC0                           933      
00001AC0                           934  CHECK_OP_MOVEP:
00001AC0  3038 10A0                935      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001AC4  0240 F138                936      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00001AC8  B07C 0108                937      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
00001ACC  6700 09EA                938      BEQ INVALID_OP                  ;INVALID OP code found
00001AD0  6600 0002                939      BNE CHECK_OP_ORI                ;Check next routine
00001AD4                           940  
00001AD4                           941  CHECK_OP_ORI:
00001AD4  3038 10A0                942      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AD8  0240 FF00                943      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001ADC  B07C 0000                944      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00001AE0  6600 0010                945      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00001AE4  4EB8 187E                946      JSR     FIND_2_BIT_SIZE_7_TO_6
00001AE8  4EB9 000024CE            947      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
00001AEE  6000 0062                948      BRA     GROUP0_SUCCESS          ;Finish routine
00001AF2                           949      
00001AF2                           950  CHECK_OP_CMPI:
00001AF2  3038 10A0                951      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AF6  0240 FF00                952      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001AFA  B07C 0C00                953      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
00001AFE  6600 0010                954      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
00001B02  4EB8 187E                955      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B06  4EB9 000024E2            956      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00001B0C  6000 0044                957      BRA     GROUP0_SUCCESS          ;Finish routine
00001B10                           958      
00001B10                           959  CHECK_OP_STATIC_BCLR:
00001B10  3038 10A0                960      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B14  0240 FF00                961      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001B18  B07C 0800                962      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00001B1C  6600 0010                963      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00001B20  4EB8 187E                964      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B24  4EB9 000024F6            965      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
00001B2A  6000 0026                966      BRA     GROUP0_SUCCESS          ;Finish routine
00001B2E                           967      
00001B2E                           968  CHECK_OP_DYNAMIC_BCLR:
00001B2E  3038 10A0                969      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B32  0240 0180                970      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
00001B36  B07C 0180                971      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
00001B3A  6600 0010                972      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
00001B3E  4EB8 187E                973      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B42  4EB9 0000250A            974      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
00001B48  6000 0008                975      BRA     GROUP0_SUCCESS          ;Finish routine
00001B4C                           976  
00001B4C                           977  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
00001B4C  4EB9 000024B8            978      JSR INVALID_OP                  ;INVALID OP code found
00001B52                           979  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
00001B52  4CDF 0003                980      MOVEM.L (SP)+,D0-D1             ;Restore registers
00001B56  4E75                     981      RTS                             ;Return to stack
00001B58                           982      
00001B58                           983  C_GROUP_1:
00001B58  48E7 C000                984      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
00001B5C                           985  
00001B5C                           986  CHECK_OP_MOVE_B:
00001B5C  3038 10A0                987      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
00001B60  0240 F000                988      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
00001B64  B07C 1000                989      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
00001B68  6600 000C                990      BNE     GROUP1_INVALID          ;Invalid OP code has been found
00001B6C  4EB9 0000251E            991      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
00001B72  6000 0008                992      BRA     GROUP1_SUCCESS          ;Finish routine
00001B76                           993      
00001B76                           994  GROUP1_INVALID:
00001B76  4EB9 000024B8            995      JSR INVALID_OP                  ;Invalid OP code found
00001B7C                           996  GROUP1_SUCCESS:
00001B7C  4CDF 0003                997      MOVEM.L (SP)+,D0-D1             ;Restore register
00001B80  4E75                     998      RTS                             ;Return to stack
00001B82                           999  C_GROUP_2:
00001B82  48E7 E000               1000      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001B86                          1001  
00001B86                          1002  CHECK_OP_MOVEA_L:
00001B86  3038 10A0               1003      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
00001B8A  0240 F000               1004      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001B8E  B07C 2000               1005      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001B92  4EF9 00001B98           1006      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00001B98                          1007      
00001B98                          1008  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00001B98  3038 10A0               1009      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
00001B9C  323C 0007               1010      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00001BA0  E368                    1011      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001BA2  E268                    1012      LSR.W    D1,D0                  ;Reposition the bits
00001BA4  323C 0006               1013      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00001BA8  E268                    1014      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00001BAA  3400                    1015      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
00001BAC  B47C 0001               1016      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00001BB0  6600 000C               1017      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00001BB4  4EB9 0000252C           1018      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00001BBA  6000 0022               1019      BRA     GROUP2_SUCCESS          ;Finish routine
00001BBE                          1020      
00001BBE                          1021      
00001BBE                          1022  CHECK_OP_MOVE_L:
00001BBE  3038 10A0               1023      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001BC2  0240 F000               1024      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001BC6  B07C 2000               1025      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001BCA  6600 000C               1026      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
00001BCE  4EB9 0000253A           1027      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00001BD4  6000 0008               1028      BRA GROUP2_SUCCESS              ;Finish routine
00001BD8                          1029      
00001BD8                          1030  GROUP2_INVALID:    
00001BD8  4EB9 000024B8           1031      JSR INVALID_OP                  ;Invalid OP code found
00001BDE                          1032  GROUP2_SUCCESS:
00001BDE  4CDF 0007               1033      MOVEM.L (SP)+,D0-D2             ;Restore register
00001BE2  4E75                    1034      RTS                             ;Return to stack
00001BE4                          1035  C_GROUP_3:
00001BE4  48E7 E000               1036      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001BE8                          1037      
00001BE8                          1038  CHECK_OP_MOVEA_W:
00001BE8  3038 10A0               1039      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001BEC  0240 F000               1040      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001BF0  B07C 3000               1041      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001BF4  4EF9 00001BFA           1042      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
00001BFA                          1043  
00001BFA                          1044      
00001BFA                          1045  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
00001BFA  3038 10A0               1046      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001BFE  323C 0007               1047      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00001C02  E368                    1048      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00001C04  E268                    1049      LSR.W    D1,D0                 ;Reposition the bits
00001C06  323C 0006               1050      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
00001C0A  E268                    1051      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
00001C0C  3400                    1052      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
00001C0E  B47C 0001               1053      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00001C12  6600 000C               1054      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00001C16  4EB9 00002548           1055      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
00001C1C  6000 0022               1056      BRA      GROUP3_SUCCESS        ;Finish routine
00001C20                          1057      
00001C20                          1058  CHECK_OP_MOVE_W:
00001C20  3038 10A0               1059      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001C24  0240 F000               1060      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001C28  B07C 3000               1061      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001C2C  6600 000C               1062      BNE      GROUP3_INVALID        ;INVALID OP code found
00001C30  4EB9 00002556           1063      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
00001C36  6000 0008               1064      BRA      GROUP3_SUCCESS        ;Finish routine
00001C3A                          1065      
00001C3A                          1066  GROUP3_INVALID:
00001C3A  4EB9 000024B8           1067      JSR INVALID_OP                 ;INVALID OP code found
00001C40                          1068  GROUP3_SUCCESS:
00001C40  4CDF 0007               1069      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
00001C44  4E75                    1070      RTS                            ;Return to stack
00001C46                          1071  
00001C46                          1072  C_GROUP_4:
00001C46  2F00                    1073      MOVE.L  D0,-(SP)            ;Save registers
00001C48                          1074      
00001C48                          1075  CHECK_OP_STOP:
00001C48  3038 10A0               1076      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C4C  B07C 4E72               1077      CMP.W  #$4E72,D0                ;Compare the appropriate bits
00001C50  6700 02A0               1078      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C54  6600 0002               1079      BNE    CHECK_OP_RESET           ;Check next OP code
00001C58                          1080      
00001C58                          1081  CHECK_OP_RESET:
00001C58  3038 10A0               1082      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C5C  B07C 4E70               1083      CMP.W  #$4E70,D0                ;Compare the appropriate bits
00001C60  6700 0290               1084      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C64  6600 0002               1085      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
00001C68                          1086          
00001C68                          1087  CHECK_OP_ILLEGAL:
00001C68  3038 10A0               1088      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C6C  B07C 4AFC               1089      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
00001C70  6700 0280               1090      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C74  6600 0002               1091      BNE    CHECK_OP_RTE             ;Check next OP code
00001C78                          1092      
00001C78                          1093  CHECK_OP_RTE:    
00001C78  3038 10A0               1094      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C7C  B07C 4E73               1095      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00001C80  6700 0270               1096      BEQ   GROUP4_INVALID            ;INVALID OP code found
00001C84  6600 0002               1097      BNE   CHECK_OP_TRAPV            ;Check next OP code
00001C88                          1098      
00001C88                          1099  CHECK_OP_TRAPV:
00001C88  3038 10A0               1100      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C8C  B07C 4E76               1101      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00001C90  6700 0260               1102      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C94  6600 0002               1103      BNE    CHECK_OP_RTR             ;Check next OP code
00001C98                          1104      
00001C98                          1105  CHECK_OP_RTR:
00001C98  3038 10A0               1106      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C9C  B07C 4E77               1107      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00001CA0  6700 0250               1108      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CA4  6600 0002               1109      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00001CA8                          1110  
00001CA8                          1111  
00001CA8                          1112  CHECK_OP_MOVE_FROM_SR:
00001CA8  3038 10A0               1113      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CAC  0240 FFC0               1114      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CB0  B07C 40C0               1115      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00001CB4  6700 023C               1116      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00001CB8  6600 0002               1117      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
00001CBC                          1118      
00001CBC                          1119  CHECK_OP_MOVE_TO_CCR:
00001CBC  3038 10A0               1120      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CC0  0240 FFC0               1121      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CC4  B07C 44C0               1122      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00001CC8  6700 0228               1123      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CCC  6600 0002               1124      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00001CD0                          1125      
00001CD0                          1126  CHECK_OP_MOVE_TO_SR:
00001CD0  3038 10A0               1127      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CD4  0240 FFC0               1128      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CD8  B07C 46C0               1129      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
00001CDC  6700 0214               1130      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CE0  6600 0002               1131      BNE    CHECK_OP_NEGX            ;Check next OP code
00001CE4                          1132      
00001CE4                          1133  CHECK_OP_NEGX:
00001CE4  3038 10A0               1134      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
00001CE8  0240 FF00               1135      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001CEC  B07C 4000               1136      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
00001CF0  6700 0200               1137      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CF4  6600 0002               1138      BNE    CHECK_OP_CLR             ;Check next OP code
00001CF8                          1139      
00001CF8                          1140  CHECK_OP_CLR:
00001CF8  3038 10A0               1141      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CFC  0240 FF00               1142      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D00  B07C 4200               1143      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00001D04  6700 01EC               1144      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D08  6600 0002               1145      BNE    CHECK_OP_NOT             ;Check next OP code
00001D0C                          1146      
00001D0C                          1147  CHECK_OP_NOT:
00001D0C  3038 10A0               1148      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D10  0240 FF00               1149      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D14  B07C 4600               1150      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00001D18  6700 01D8               1151      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D1C  6600 0002               1152      BNE    CHECK_OP_EXT             ;Check next OP code
00001D20                          1153      
00001D20                          1154  CHECK_OP_EXT:
00001D20  3038 10A0               1155      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D24  0240 FFB8               1156      ANDI.W #$FFB8,D0                ;Mask relevant bits to D0
00001D28  B07C 4880               1157      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
00001D2C  6700 01C4               1158      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
00001D30  6600 001C               1159      BNE    CHECK_OP_NBCD            ;Check next OP code
00001D34                          1160  
00001D34                          1161  BIT_CHECK_EXT:    
00001D34  3038 10A0               1162      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
00001D38  323C 000A               1163      MOVE.W #10,D1                   ;Prepare a 10 bit shift into D1
00001D3C  E368                    1164      LSL.W  D1,D0                    ;Shift D0 left 10 bits
00001D3E  E068                    1165      LSR.W  D0,D0                    ;Reposition D0
00001D40  E648                    1166      LSR.W  #3,D0                    ;Shift D0 3 bits
00001D42  B078 0000               1167      CMP.W  %000,D0                  ;Check the specific bits needed to differentiate EXT
00001D46  6700 01AA               1168      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
00001D4A  6600 015C               1169      BNE    MOVEM_BIT_SIZE_CHECK     ;This is the only other possibility 
00001D4E                          1170      
00001D4E                          1171  CHECK_OP_NBCD:
00001D4E  3038 10A0               1172      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D52  0240 FFC0               1173      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0           
00001D56  B07C 4800               1174      CMP.W  #$4800,D0                ;Compare the appropriate masked bits
00001D5A  6700 0196               1175      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D5E  6600 0002               1176      BNE    CHECK_OP_SWAP            ;Check next OP code
00001D62                          1177      
00001D62                          1178  CHECK_OP_SWAP:                      ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
00001D62  3038 10A0               1179      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D66  0240 FF48               1180      ANDI.W #$FF48,D0                ;Mask relevant bits to D0
00001D6A  B07C 4840               1181      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001D6E  6700 0182               1182      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D72  6600 0002               1183      BNE    CHECK_OP_PEA             ;Check next OP code
00001D76                          1184   
00001D76                          1185  CHECK_OP_PEA:                       ;This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
00001D76  3038 10A0               1186      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D7A  0240 FF40               1187      ANDI.W #$FF40,D0                ;Mask relevant bits to D0
00001D7E  B07C 4840               1188      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001D82  6700 016E               1189      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D86  6600 0002               1190      BNE    CHECK_OP_TAS             ;Check next OP code
00001D8A                          1191      
00001D8A                          1192  CHECK_OP_TAS:
00001D8A  3038 10A0               1193      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D8E  0240 FFC0               1194      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001D92  B07C 4AC0               1195      CMP.W  #$4AC0,D0                ;Compare the appropriate masked bits
00001D96  6700 015A               1196      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D9A  6600 0002               1197      BNE    CHECK_OP_TST             ;Check next OP code
00001D9E                          1198  
00001D9E                          1199  CHECK_OP_TST:                       ;This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
00001D9E  3038 10A0               1200      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DA2  0240 FF00               1201      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001DA6  B07C 4A00               1202      CMP.W  #$4A00,D0                ;Compare the appropriate masked bits
00001DAA  6700 0146               1203      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DAE  6600 0002               1204      BNE    CHECK_OP_TRAP            ;Check next OP code
00001DB2                          1205      
00001DB2                          1206  CHECK_OP_TRAP:
00001DB2  3038 10A0               1207      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DB6  0240 FFF0               1208      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001DBA  B07C 4E40               1209      CMP.W  #$4E40,D0                ;Compare the appropriate masked bits
00001DBE  6700 0132               1210      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DC2  6600 0002               1211      BNE    CHECK_OP_LINK            ;Check next OP code
00001DC6                          1212      
00001DC6                          1213  CHECK_OP_LINK:
00001DC6  3038 10A0               1214      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DCA  0240 FFF8               1215      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001DCE  B07C 4E50               1216      CMP.W  #$4E50,D0                ;Compare the appropriate masked bits
00001DD2  6700 011E               1217      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DD6  6600 0002               1218      BNE    CHECK_OP_UNLK            ;Check next OP code
00001DDA                          1219  
00001DDA                          1220  CHECK_OP_UNLK:
00001DDA  3038 10A0               1221      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DDE  0240 FFF8               1222      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001DE2  B07C 4E58               1223      CMP.W  #$4E58,D0                ;Compare the appropriate masked bits
00001DE6  6700 010A               1224      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DEA  6600 0002               1225      BNE    CHECK_OP_MOVE_USP        ;Check next OP
00001DEE                          1226      
00001DEE                          1227  CHECK_OP_MOVE_USP:
00001DEE  3038 10A0               1228      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DF2  0240 FFF0               1229      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001DF6  B07C 4E60               1230      CMP.W  #$4E60,D0                ;Compare the appropriate masked bits
00001DFA  6700 00F6               1231      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DFE  6600 0002               1232      BNE    CHECK_OP_JMP             ;Check next OP
00001E02                          1233  
00001E02                          1234  CHECK_OP_JMP:
00001E02  3038 10A0               1235       MOVE.W CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E06  0240 FFC0               1236       ANDI.W #$FFC0,D0               ;Mask relevant bits to D0
00001E0A  B07C 4EC0               1237       CMP.W  #$4EC0,D0               ;Compare the appropriate masked bits
00001E0E  6700 00E2               1238       BEQ    GROUP4_INVALID          ;INVALID OP code
00001E12  6600 0002               1239       BNE    CHECK_OP_CHK            ;Check next OP code
00001E16                          1240       
00001E16                          1241  CHECK_OP_CHK:
00001E16  3038 10A0               1242      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E1A  0240 F1C0               1243      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001E1E  B07C 4180               1244      CMP.W   #$4180,D0               ;Compare the appropriate masked bits
00001E22  6700 0694               1245      BEQ     INVALID_OP              ;INVALID OP code
00001E26  6600 0002               1246      BNE     CHECK_OP_NOP            ;Check next OP code
00001E2A                          1247  
00001E2A                          1248  CHECK_OP_NOP:                       ;While this code is not in the supported docs, Nash covered it in class and expects it to be implemented
00001E2A  3038 10A0               1249      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E2E  B07C 4E71               1250      CMP.W  #$4E71,D0                ;Compare the appropriate bits
00001E32  6600 000C               1251      BNE    CHECK_OP_RTS             ;Check next OP code
00001E36  4EB9 00002580           1252      JSR    PRINT_OP_NOP             ;Print out OP code
00001E3C  6000 00BA               1253      BRA    GROUP4_SUCCESS           ;Finish routine
00001E40                          1254      
00001E40                          1255  CHECK_OP_RTS:
00001E40  3038 10A0               1256      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E44  B07C 4E75               1257      CMP.W  #$4E75,D0                ;Mask exact bits for RTS    
00001E48  6600 000C               1258      BNE    CHECK_OP_LEA             ;If it's equal check next code
00001E4C  4EB9 00002572           1259      JSR    PRINT_OP_RTS             ;Print out OP code
00001E52  6000 00A4               1260      BRA    GROUP4_SUCCESS           ;Finish routine
00001E56                          1261   
00001E56                          1262  CHECK_OP_LEA:
00001E56  3038 10A0               1263      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E5A  0240 F1C0               1264      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00001E5E  B07C 41C0               1265      CMP.W  #$41C0,D0                ;Compare masked bits
00001E62  6600 000C               1266      BNE    CHECK_OP_JSR             ;Check next OP code
00001E66  4EB9 0000258E           1267      JSR    PRINT_OP_LEA             ;Print out OP code
00001E6C  6000 008A               1268      BRA    GROUP4_SUCCESS           ;Finish routine
00001E70                          1269   
00001E70                          1270  CHECK_OP_JSR:
00001E70  3038 10A0               1271      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E74  0240 FFC0               1272      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00001E78  B07C 4E80               1273      CMP.W  #$4E80,D0                ;Compare masked bits
00001E7C  6600 000C               1274      BNE    CHECK_OP_NEG             ;Check next OP code
00001E80  4EB9 00002564           1275      JSR    PRINT_OP_JSR             ;Print out OP code
00001E86  6000 0070               1276      BRA    GROUP4_SUCCESS           ;Finish routine
00001E8A                          1277      
00001E8A                          1278  CHECK_OP_NEG:
00001E8A  3038 10A0               1279      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E8E  0240 FF00               1280      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001E92  B07C 4400               1281      CMP.W  #$4400,D0                ;Compare masked bits
00001E96  6600 0010               1282      BNE    MOVEM_BIT_SIZE_CHECK     ;Check next OP code
00001E9A  4EB8 187E               1283      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size field
00001E9E  4EB9 000025A2           1284      JSR    PRINT_OP_NEG             ;Print out OP code
00001EA4  6000 0052               1285      BRA    GROUP4_SUCCESS           ;Finish routine
00001EA8                          1286      
00001EA8                          1287  MOVEM_BIT_SIZE_CHECK:
00001EA8  3038 10A0               1288      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EAC  4EB8 189E               1289      JSR    FIND_1_BIT_SIZE_6        ;Parse size for bit 6
00001EB0  0C38 0000 1738          1290      CMP.B  #%0,OP_SIZE              ;Check size bit
00001EB6  6700 0006               1291      BEQ    CHECK_OP_MOVEM_W         ;If 0 it's a word
00001EBA  6600 001C               1292      BNE    CHECK_OP_MOVEM_L         ;If 1 it's a long
00001EBE                          1293  
00001EBE                          1294  CHECK_OP_MOVEM_W:
00001EBE  3038 10A0               1295      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EC2  0240 FB80               1296      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001EC6  B07C 4880               1297      CMP.W  #$4880,D0                ;Compare masked bits
00001ECA  6600 0026               1298      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001ECE  4EB9 000025B6           1299      JSR    PRINT_OP_MOVEM_W         ;PRINT OP code
00001ED4  6000 0022               1300      BRA    GROUP4_SUCCESS           ;Finish routine
00001ED8                          1301      
00001ED8                          1302  CHECK_OP_MOVEM_L:
00001ED8  3038 10A0               1303      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EDC  0240 FB80               1304      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001EE0  B07C 4880               1305      CMP.W  #$4880,D0                ;Compare masked bits
00001EE4  6600 000C               1306      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001EE8  4EB9 000025C4           1307      JSR    PRINT_OP_MOVEM_L         ;Print OP code
00001EEE  6000 0008               1308      BRA    GROUP4_SUCCESS           ;Finish routine    
00001EF2                          1309      
00001EF2                          1310  GROUP4_INVALID:
00001EF2  4EB9 000024B8           1311      JSR INVALID_OP                  ;INVALID op code has been found, set IS_VALID to 0
00001EF8                          1312  
00001EF8                          1313  GROUP4_SUCCESS:
00001EF8  4CDF 0001               1314      MOVEM.L (SP)+,D0                ;Restore saved registers
00001EFC  4E75                    1315      RTS                             ;Return to stack
00001EFE                          1316  C_GROUP_5:
00001EFE  48E7 8000               1317      MOVEM.L D0,-(SP)                ;Save registers to stack
00001F02                          1318  CHECK_OP_DBcc:                      ;These are ordered first due to checking bits 7-6
00001F02  3038 10A0               1319      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F06  0240 F0C8               1320      ANDI.W #$F0C8,D0                ;Mask appropriate bits
00001F0A  B07C 50C8               1321      CMP.W  #$50C8,D0                ;Compare appropriate masked bits
00001F0E  6700 004C               1322      BEQ    GROUP5_INVALID           ;INVALID op code found
00001F12  6600 0002               1323      BNE    CHECK_OP_Scc             ;Check next OP code
00001F16                          1324  
00001F16                          1325  CHECK_OP_Scc:
00001F16  3038 10A0               1326      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F1A  0240 F0C0               1327      ANDI.W #$F0C0,D0                ;Mask appropriate bits
00001F1E  B07C 50C0               1328      CMP.W  #$50C0,D0                ;Compare appropriate masked bits
00001F22  6700 0038               1329      BEQ     GROUP5_INVALID          ;INVALID OP code found
00001F26  6600 0002               1330      BNE     CHECK_OP_ADDQ           ;Check next OP code
00001F2A                          1331  
00001F2A                          1332  CHECK_OP_ADDQ:
00001F2A  3038 10A0               1333      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F2E  0240 F100               1334      ANDI.W #$F100,D0                ;Mask appropriate bits
00001F32  B07C 5000               1335      CMP.W  #$5000,D0                ;Compare appropriate masked bits
00001F36  6700 0024               1336      BEQ    GROUP5_INVALID           ;INVALID OP code found
00001F3A  6600 0002               1337      BNE    CHECK_OP_SUBQ            ;Check next OP code
00001F3E                          1338  
00001F3E                          1339  CHECK_OP_SUBQ     
00001F3E  3038 10A0               1340      MOVE.W  CUR_OP_CODE,D0          ;Actual check for SUBQ
00001F42  0240 F100               1341      ANDI.W #$F100,D0                ;Bitmask check for SUBQ
00001F46  B07C 5100               1342      CMP.W  #$5100,D0                ;Compare the proper value
00001F4A  6600 0010               1343      BNE    GROUP5_INVALID           ;Else the operand is invalid
00001F4E  4EB8 187E               1344      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size bit to print
00001F52  4EB9 000025D2           1345      JSR    PRINT_OP_SUBQ            ;If equal print it out
00001F58  6000 0008               1346      BRA    GROUP5_SUCCESS           ;Finish routine
00001F5C                          1347      
00001F5C                          1348  GROUP5_INVALID: 
00001F5C  4EB9 000024B8           1349      JSR INVALID_OP                  ;INVALID OP has been found, set IS_VALID to 0
00001F62                          1350  GROUP5_SUCCESS:
00001F62  4CDF 0001               1351      MOVEM.L (SP)+,D0                ;Restore registers from stack
00001F66  4E75                    1352      RTS                             ;Return to stack
00001F68                          1353      
00001F68                          1354  C_GROUP_6:
00001F68  48E7 8000               1355      MOVEM.L D0,-(SP)            ;Save register to stack
00001F6C                          1356  CHECK_OP_BSR:
00001F6C  3038 10A0               1357      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
00001F70  0240 FF00               1358      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00001F74  B07C 6100               1359      CMP.W   #$6100,D0               ;Compare masked bits
00001F78  6700 0128               1360      BEQ     GROUP6_INVALID          ;INVALID OP code found
00001F7C  6600 0002               1361      BNE     CHECK_OP_BGT            ;Check next OP code
00001F80                          1362      
00001F80                          1363  CHECK_OP_BGT:
00001F80  3038 10A0               1364      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F84  0240 FF00               1365      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001F88  B07C 6E00               1366      CMP.W  #$6E00,D0                ;Compare masked bits
00001F8C  6700 0114               1367      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001F90  6600 0002               1368      BNE    CHECK_OP_BCC             ;Check next OP code
00001F94                          1369  
00001F94                          1370  CHECK_OP_BCC:
00001F94  3038 10A0               1371      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F98  0240 FF00               1372      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001F9C  B07C 6400               1373      CMP.W  #$6400,D0                ;Compare masked bits
00001FA0  6700 0100               1374      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FA4  6600 0002               1375      BNE    CHECK_OP_BEQ             ;Check next OP code 
00001FA8                          1376  
00001FA8                          1377  CHECK_OP_BEQ:
00001FA8  3038 10A0               1378      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FAC  0240 FF00               1379      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FB0  B07C 6700               1380      CMP.W  #$6700,D0                ;Compare masked bits
00001FB4  6700 00EC               1381      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FB8  6600 0002               1382      BNE    CHECK_OP_BHI             ;Check next OP code
00001FBC                          1383  
00001FBC                          1384  CHECK_OP_BHI:
00001FBC  3038 10A0               1385      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FC0  0240 FF00               1386      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FC4  B07C 6200               1387      CMP.W  #$6200,D0                ;Compare masked bits
00001FC8  6700 00D8               1388      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FCC  6600 0002               1389      BNE    CHECK_OP_BLS             ;Check next OP code
00001FD0                          1390  
00001FD0                          1391  CHECK_OP_BLS:
00001FD0  3038 10A0               1392      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FD4  0240 FF00               1393      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FD8  B07C 6300               1394      CMP.W  #$6300,D0                ;Compare masked bits
00001FDC  6700 00C4               1395      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FE0  6600 0002               1396      BNE    CHECK_OP_BMI             ;Check next OP code
00001FE4                          1397  
00001FE4                          1398  CHECK_OP_BMI:
00001FE4  3038 10A0               1399      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FE8  0240 FF00               1400      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FEC  B07C 6B00               1401      CMP.W  #$6B00,D0                ;Compare masked bits
00001FF0  6700 00B0               1402      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FF4  6600 0002               1403      BNE    CHECK_OP_BNE             ;Check next OP code
00001FF8                          1404  
00001FF8                          1405  CHECK_OP_BNE:
00001FF8  3038 10A0               1406      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FFC  0240 FF00               1407      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002000  B07C 6600               1408      CMP.W  #$6600,D0                ;Compare masked bits
00002004  6700 009C               1409      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002008  6600 0002               1410      BNE    CHECK_OP_BPL             ;Check next OP code    
0000200C                          1411  
0000200C                          1412  CHECK_OP_BPL:
0000200C  3038 10A0               1413      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002010  0240 FF00               1414      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002014  B07C 6A00               1415      CMP.W  #$6A00,D0                ;Compare masked bits
00002018  6700 0088               1416      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000201C  6600 0002               1417      BNE    CHECK_OP_BRA             ;Check next OP code 
00002020                          1418  
00002020                          1419  
00002020                          1420  CHECK_OP_BRA:
00002020  3038 10A0               1421      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0       
00002024  0240 FF00               1422      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00002028  B07C 6000               1423      CMP.W   #$6000,D0               ;Compare masked bits
0000202C  6600 000C               1424      BNE     CHECK_OP_BCS            ;Check next OP code
00002030  4EB9 00002636           1425      JSR     PRINT_OP_BRA            ;Print out OP code
00002036  6000 0070               1426      BRA     GROUP6_SUCCESS          ;Finish routine
0000203A                          1427      
0000203A                          1428  CHECK_OP_BCS:
0000203A  3038 10A0               1429      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000203E  0240 FF00               1430      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002042  B07C 6500               1431      CMP.W  #$6500,D0                ;Compare masked bits
00002046  6600 000C               1432      BNE    CHECK_OP_BGE             ;Check next OP code
0000204A  4EB9 000025E6           1433      JSR    PRINT_OP_BCS             ;Print out OP code
00002050  6000 0056               1434      BRA    GROUP6_SUCCESS           ;Finish routine
00002054                          1435  
00002054                          1436      
00002054                          1437  CHECK_OP_BGE:
00002054  3038 10A0               1438      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002058  0240 FF00               1439      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000205C  B07C 6C00               1440      CMP.W  #$6C00,D0                ;Compare masked bits
00002060  6600 000C               1441      BNE    CHECK_OP_BLT             ;Check next OP code
00002064  4EB9 000025FA           1442      JSR    PRINT_OP_BGE             ;Print out OP code
0000206A  6000 003C               1443      BRA    GROUP6_SUCCESS           ;Finish routine
0000206E                          1444      
0000206E                          1445      
0000206E                          1446  CHECK_OP_BLT:
0000206E  3038 10A0               1447      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002072  0240 FF00               1448      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002076  B07C 6D00               1449      CMP.W  #$6D00,D0                ;Compare masked bits
0000207A  6600 000C               1450      BNE    CHECK_OP_BVC             ;Check next OP code
0000207E  4EB9 0000260E           1451      JSR    PRINT_OP_BLT             ;Print out OP code
00002084  6000 0022               1452      BRA    GROUP6_SUCCESS           ;Finish routine
00002088                          1453      
00002088                          1454  CHECK_OP_BVC:
00002088  3038 10A0               1455      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000208C  0240 FF00               1456      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002090  B07C 6800               1457      CMP.W  #$6800,D0                ;Compare masked bits
00002094  6600 000C               1458      BNE    GROUP6_INVALID           ;Check next OP code
00002098  4EB9 00002622           1459      JSR    PRINT_OP_BVC             ;Print out OP code
0000209E  6000 0008               1460      BRA    GROUP6_SUCCESS           ;Finish routine
000020A2                          1461      
000020A2                          1462  GROUP6_INVALID:
000020A2  4EB9 000024B8           1463      JSR    INVALID_OP               ;INVALID OP code found, set IS_VALID to 0
000020A8                          1464  GROUP6_SUCCESS:
000020A8  4CDF 0001               1465      MOVEM.L (SP)+,D0                ;Restore registers from stack
000020AC  4E75                    1466      RTS                             ;Return from stack
000020AE                          1467      
000020AE                          1468  C_GROUP_7:
000020AE  48E7 8000               1469      MOVEM.L D0,-(SP)                ;Save register to stack
000020B2                          1470  CHECK_OP_MOVEQ
000020B2  3038 10A0               1471      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
000020B6  0240 F100               1472      ANDI.W  #$F100,D0               ;Mask appropriate bits
000020BA  B07C 7000               1473      CMP.W   #$7000,D0               ;Compare masked bits
000020BE  6000 0002               1474      BRA     GROUP7_INVALID          ;INVALID OP code found
000020C2                          1475  
000020C2                          1476  GROUP7_INVALID:
000020C2  4EB9 000024B8           1477      JSR     INVALID_OP              ;INVALID OP code found, set IS_VALID to 0
000020C8                          1478  GROUP7_SUCCESS:    
000020C8  4CDF 0001               1479      MOVEM.L (SP)+,D0                ;Restore registers from stack
000020CC  4E75                    1480      RTS                             ;Return from stack
000020CE                          1481  C_GROUP_8:
000020CE  48E7 8000               1482      MOVEM.L D0,-(SP)
000020D2                          1483  CHECK_OP_DIVU:
000020D2  3038 10A0               1484      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020D6  0240 F1C0               1485      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
000020DA  B07C 80C0               1486      CMP.W   #$80C0,D0               ;Compare masked bits
000020DE  6700 0042               1487      BEQ     GROUP8_INVALID          ;INVALID OP code found
000020E2  6600 0002               1488      BNE     CHECK_OP_SBCD           ;Check next OP code
000020E6                          1489  
000020E6                          1490  CHECK_OP_SBCD:
000020E6  3038 10A0               1491      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020EA  0240 F1F0               1492      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
000020EE  B07C 8100               1493      CMP.W   #$8100,D0               ;Compare masked bits
000020F2  6700 002E               1494      BEQ     GROUP8_INVALID          ;INVALID OP code found
000020F6  6600 0002               1495      BNE     CHECK_OP_DIVS           ;Check next OP code
000020FA                          1496      
000020FA                          1497  CHECK_OP_DIVS:
000020FA  3038 10A0               1498      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000020FE  0240 F1C0               1499      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002102  B07C 81C0               1500      CMP.W   #$81C0,D0               ;Compare masked bits
00002106  6600 000C               1501      BNE     CHECK_OP_OR             ;Check next OP code
0000210A  4EB9 0000264A           1502      JSR     PRINT_OP_DIVS           ;OP Code found
00002110  6000 0016               1503      BRA     GROUP8_SUCCESS          ;Finish routine
00002114                          1504      
00002114                          1505  CHECK_OP_OR:                        ;At this point only remaining $8 code is OR
00002114  4EB8 187E               1506      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Finding size bit to print out
00002118  4EB9 00002658           1507      JSR     PRINT_OP_OR             ;Print out OR
0000211E  6000 0008               1508      BRA     GROUP8_SUCCESS          ;Finish routine
00002122                          1509  GROUP8_INVALID:
00002122  4EB9 000024B8           1510       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
00002128                          1511  GROUP8_SUCCESS:
00002128  4CDF 0001               1512       MOVEM.L (SP)+,D0               ;Restore register from stack
0000212C  4E75                    1513       RTS                            ;Return to stack
0000212E                          1514       
0000212E                          1515  C_GROUP_9:
0000212E  48E7 C000               1516      MOVEM.L D0-D1,-(SP)             ;Save the registers
00002132                          1517  CHECK_SIZE_BIT_FOR_SUB:
00002132  4EB8 187E               1518      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bits in 7-6
00002136  0C38 0003 1738          1519      CMP.B   #%11,OP_SIZE            ;If the bits are %11, it has to be SUBA
0000213C  6700 0006               1520      BEQ     CHECK_OP_SUBA           ;If the bits equal it must be SUBA
00002140  6600 0016               1521      BNE     CHECK_OP_SUBX           ;If the bits are not equal it could be SUBX
00002144                          1522      
00002144                          1523  CHECK_OP_SUBA:                      ;Check SUBA first as it has static bits
00002144  3038 10A0               1524      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002148  0240 F0C0               1525      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
0000214C  B07C 90C0               1526      CMP.W   #$90C0,D0               ;Compare masked bits
00002150  6700 0042               1527      BEQ     GROUP9_INVALID          ;INVALID OP has been found
00002154  6600 0002               1528      BNE     CHECK_OP_SUBX           ;Check next OP
00002158                          1529  
00002158                          1530  CHECK_OP_SUBX:
00002158  3038 10A0               1531      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000215C  0240 F130               1532      ANDI.W  #$F130,D0               ;Mask appropriate bits
00002160  B07C 9100               1533      CMP.W   #$9100,D0               ;Compare masked bits
00002164  6000 0002               1534      BRA     BIT_CHECK_SUBX          ;Checking if this code is SUBX through bit shifts
00002168                          1535      
00002168                          1536  BIT_CHECK_SUBX:    
00002168  3038 10A0               1537      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000216C  323C 0007               1538      MOVE.W  #7,D1                   ;Prepare a shift of 7 bits into D1
00002170  E368                    1539      LSL.W   D1,D0                   ;Shift left 7 bits truncate 15-9 bits
00002172  E268                    1540      LSR.W   D1,D0                   ;Reposition D0
00002174  E848                    1541      LSR.W   #4,D0                   ;Truncate 4 right most bits to
00002176  0240 FF13               1542      ANDI.W  #$FF13,D0               ;Compare remaining static bits
0000217A  B07C 0010               1543      CMP.W   #$0010,D0               ;If equal to this value it's SUBX
0000217E  6700 0014               1544      BEQ     GROUP9_INVALID          ;INVALID OP code found
00002182  6600 0002               1545      BNE     CHECK_OP_SUB            ;Not can only be SUB here
00002186                          1546      
00002186                          1547  CHECK_OP_SUB:                       ;At this point only remaining $9 is SUB
00002186  4EB8 187E               1548      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bit to print out
0000218A  4EB9 0000266C           1549      JSR     PRINT_OP_SUB            ;Print out SUB
00002190  6000 0008               1550      BRA     GROUP9_SUCCESS          ;Finish routine
00002194                          1551      
00002194                          1552  GROUP9_INVALID:
00002194  4EB9 000024B8           1553       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
0000219A                          1554  GROUP9_SUCCESS: 
0000219A  4CDF 0003               1555      MOVEM.L (SP)+,D0-D1             ;Restore registers
0000219E  4E75                    1556      RTS                             ;Return to stack
000021A0                          1557  
000021A0                          1558  C_GROUP_A:
000021A0  4EB9 000024B8           1559      JSR INVALID_OP                  ;INVALID OP code found, set IS_VALID to 0
000021A6  4E75                    1560      RTS                             ;Return to stack
000021A8                          1561      
000021A8                          1562  C_GROUP_B:
000021A8  48E7 8000               1563      MOVEM.L D0,-(SP)                ;Save current registers to stack
000021AC                          1564  CHECK_OP_CMPM
000021AC  3038 10A0               1565      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021B0  0240 F138               1566      ANDI.W  #$F138,D0               ;Mask appropriate bits
000021B4  B07C B108               1567      CMP.W   #$B108,D0               ;Compare masked bits
000021B8  6700 0056               1568      BEQ     GROUPB_INVALID          ;INVALID OP found
000021BC  6600 0002               1569      BNE     CHECK_OP_CMPA           ;Check next OP
000021C0                          1570      
000021C0                          1571  CHECK_OP_CMPA:
000021C0  3038 10A0               1572      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021C4  0240 F0C0               1573      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
000021C8  B07C B0C0               1574      CMP.W   #$B0C0,D0               ;Compare masked bits
000021CC  6700 0042               1575      BEQ     GROUPB_INVALID          ;INVALID OP found
000021D0  6600 0002               1576      BNE     CHECK_OP_EOR            ;Check next OP
000021D4                          1577  
000021D4                          1578  CHECK_OP_EOR:
000021D4  3038 10A0               1579      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021D8  0240 F100               1580      ANDI.W  #$F100,D0               ;Mask appropriate bits
000021DC  B07C B100               1581      CMP.W   #$B100,D0               ;Compare masked bits
000021E0  6600 0010               1582      BNE     CHECK_OP_CMP            ;Check next OP 
000021E4  4EB8 187E               1583      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
000021E8  4EB9 00002680           1584      JSR     PRINT_OP_EOR            ;Print out OP code
000021EE  6000 0026               1585      BRA     GROUPB_SUCCESS          ;Finish routine
000021F2                          1586      
000021F2                          1587  CHECK_OP_CMP:
000021F2  3038 10A0               1588      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021F6  0240 F100               1589      ANDI.W  #$F100,D0               ;Mask appropriate bits
000021FA  B07C B000               1590      CMP.W   #$B000,D0               ;Compare masked bits
000021FE  6600 0010               1591      BNE     GROUPB_INVALID          ;INVALID OP code found
00002202  4EB8 187E               1592      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
00002206  4EB9 00002694           1593      JSR     PRINT_OP_CMP            ;Print out OP code
0000220C  6000 0008               1594      BRA     GROUPB_SUCCESS          ;Finish routine
00002210                          1595      
00002210                          1596  GROUPB_INVALID:
00002210  4EB9 000024B8           1597      JSR     INVALID_OP              ;INVALID OP has been found, set IS_VALID to 0
00002216                          1598  GROUPB_SUCCESS:
00002216  4CDF 0001               1599      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000221A  4E75                    1600      RTS                             ;Return to stack
0000221C                          1601  C_GROUP_C:
0000221C  48E7 C000               1602      MOVEM.L D0-D1,-(SP)
00002220                          1603      
00002220                          1604  CHECK_OP_MULU:
00002220  3038 10A0               1605      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002224  0240 F1C0               1606      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002228  B07C C0C0               1607      CMP.W   #$C0C0,D0               ;Compare masked bits
0000222C  6700 0066               1608      BEQ     GROUPC_INVALID          ;INVALID OP code found
00002230  6600 0002               1609      BNE     CHECK_OP_ABCD           ;Check next OP code
00002234                          1610   
00002234                          1611  CHECK_OP_ABCD:
00002234  3038 10A0               1612      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002238  0240 F1F0               1613      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
0000223C  B07C C100               1614      CMP.W   #$C100,D0               ;Compare masked bits
00002240  6700 0052               1615      BEQ     GROUPC_INVALID          ;INVALID OP code found
00002244  6600 0002               1616      BNE     CHECK_OP_EXG            ;Check next OP code
00002248                          1617   
00002248                          1618  CHECK_OP_EXG:
00002248  6000 0002               1619      BRA     BIT_CHECK_EXG           ;Always do bit check here
0000224C                          1620                          
0000224C                          1621  BIT_CHECK_EXG:                      ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
0000224C  3038 10A0               1622      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002250  323C 0007               1623      MOVE.W  #7,D1                   ;Prepare a bit shift of 7 into D1
00002254  E368                    1624      LSL.W   D1,D0                   ;Shift D0 to 7 bits
00002256  E268                    1625      LSR.W   D1,D0                   ;Reposition D0
00002258  E848                    1626      LSR.W   #4,D0                   ;Shift D0 4 bits right
0000225A  0240 FF83               1627      ANDI.W  #$FF83,D0               ;Mask appropriate bits
0000225E  B07C 0010               1628      CMP.W   #$0010,D0               ;Bit mask static EXG bits
00002262  6700 0030               1629      BEQ     GROUPC_INVALID          ;If this equals, then OP must be EXG
00002266  6600 0002               1630      BNE     CHECK_OP_MULS           ;Otherwise it's MULS
0000226A                          1631  CHECK_OP_MULS:
0000226A  3038 10A0               1632      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000226E  0240 F1C0               1633      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00002272  B07C C1C0               1634      CMP.W  #$C1C0,D0                ;Compare masked bits
00002276  6600 000C               1635      BNE    CHECK_OP_AND             ;OP_AND is completely dynamic outside of first nibble
0000227A  4EB9 000026A8           1636      JSR    PRINT_OP_MULS            ;Print OP code
00002280  6000 0018               1637      BRA    GROUPC_SUCCESS           ;Finish routine
00002284                          1638      
00002284                          1639  CHECK_OP_AND:                       ;This would be the only possible OP code left after CHECK_OP_MULS
00002284  3038 10A0               1640      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002288  0240 F000               1641      ANDI.W  #$F000,D0               ;Mask appropriate bits
0000228C  B07C C000               1642      CMP.W   #$C000,D0               ;Compare masked bits
00002290  6000 0002               1643      BRA    GROUPC_INVALID           ;INVALID OP code found
00002294                          1644      
00002294                          1645  GROUPC_INVALID:
00002294  4EB9 000024B8           1646      JSR     INVALID_OP              ;Set IS_VALID to 0
0000229A                          1647      
0000229A                          1648  GROUPC_SUCCESS:
0000229A  4CDF 0003               1649      MOVEM.L (SP)+,D0-D1             ;Restore registers from stack
0000229E  4E75                    1650      RTS                             ;Return to stack
000022A0                          1651      
000022A0                          1652  C_GROUP_D:
000022A0  48E7 8000               1653      MOVEM.L D0,-(SP)                ;Save registers to stack
000022A4                          1654  BIT_SIZE_CHECK
000022A4  3038 10A0               1655      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
000022A8  4EB8 187E               1656      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Specific size bit checking to see if it's 11
000022AC  0C38 0003 1738          1657      CMP.B   #%11,OP_SIZE            ;If it's %11 it cannot be ADDX and is either ADDA or ADD
000022B2  6700 0024               1658      BEQ     CHECK_OP_ADDA           ;If it's equal check ADDA
000022B6  6600 0002               1659      BNE     CHECK_OP_ADDX           ;If it's not equal check ADDX
000022BA                          1660      
000022BA                          1661  CHECK_OP_ADDX:
000022BA  3038 10A0               1662      MOVE    CUR_OP_CODE,D0
000022BE  0240 F130               1663      ANDI.W #$F130,D0                ;Mask appropriate bits
000022C2  B07C D100               1664      CMP.W  #$D100,D0                ;Compare masked bits
000022C6  6700 002C               1665      BEQ    GROUPD_INVALID           ;INVALID OP code found
000022CA  6600 0002               1666      BNE    CHECK_OP_ADD             ;Check next OP code
000022CE                          1667      
000022CE                          1668  CHECK_OP_ADD:
000022CE  4EB9 000026B6           1669      JSR PRINT_OP_ADD                ;Only remaining OP in $D is ADD at this point
000022D4  6000 0024               1670      BRA GROUPD_SUCCESS              ;Finish routine
000022D8                          1671  
000022D8                          1672  CHECK_OP_ADDA:
000022D8  3038 10A0               1673      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
000022DC  0240 F0C0               1674      ANDI.W #$F0C0,D0                ;Mask applicable bits
000022E0  B07C D0C0               1675      CMP.W  #$D0C0,D0                ;Compare masked bits
000022E4  66E8                    1676      BNE    CHECK_OP_ADD             ;Check next OP code
000022E6  4EB8 18BE               1677      JSR    FIND_1_BIT_SIZE_8        ;Size bit to print
000022EA  4EB9 000026CA           1678      JSR    PRINT_OP_ADDA            ;Print out OP code
000022F0  6000 0008               1679      BRA    GROUPD_SUCCESS           ;Finish routine
000022F4                          1680      
000022F4                          1681  GROUPD_INVALID:
000022F4  4EB9 000024B8           1682      JSR INVALID_OP                  ;INVALID OP code found
000022FA                          1683  GROUPD_SUCCESS:
000022FA  4CDF 0001               1684      MOVEM.L (SP)+,D0                ;Restore registers from stack
000022FE  4E75                    1685      RTS                             ;Return to stack
00002300                          1686      
00002300                          1687  C_GROUP_E:
00002300  48E7 8000               1688      MOVEM.L D0,-(SP)
00002304                          1689  CHECK_OP_ROXR_NO_ROT:
00002304  3038 10A0               1690      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002308  0240 FFC0               1691      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000230C  B07C E4C0               1692      CMP.W  #$E4C0,D0                ;Compare masked bits
00002310  6700 0192               1693      BEQ    GROUPE_INVALID           ;INVALID OP code
00002314  6600 0002               1694      BNE    CHECK_OP_ROXL_NO_ROT     ;Check next OP code
00002318                          1695  
00002318                          1696  CHECK_OP_ROXL_NO_ROT:
00002318  3038 10A0               1697      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000231C  0240 FFC0               1698      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002320  B07C E5C0               1699      CMP.W  #$E5C0,D0                ;Compare masked bits
00002324  6700 017E               1700      BEQ    GROUPE_INVALID           ;INVALID OP code
00002328  6600 0002               1701      BNE    CHECK_OP_ROR_NO_ROT      ;Check next OP code
0000232C                          1702  
0000232C                          1703  CHECK_OP_ROR_NO_ROT:
0000232C  3038 10A0               1704      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002330  0240 FFC0               1705      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002334  B07C E6C0               1706      CMP.W  #$E6C0,D0                ;Compare masked bits
00002338  6600 000C               1707      BNE    CHECK_OP_ROL_NO_ROT      ;Check next OP code
0000233C  4EB9 00002742           1708      JSR    PRINT_OP_ROR             ;Print out OP code
00002342  6000 0166               1709      BRA    GROUPE_SUCCESS           ;Finish routine
00002346                          1710      
00002346                          1711  CHECK_OP_ROL_NO_ROT:
00002346  3038 10A0               1712      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000234A  0240 FFC0               1713      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000234E  B07C E7C0               1714      CMP.W  #$E7C0,D0                ;Compare masked bits
00002352  6600 000C               1715      BNE    CHECK_OP_LSR_NO_ROT      ;Check next OP code
00002356  4EB9 0000272E           1716      JSR    PRINT_OP_ROL             ;Print out OP code
0000235C  6000 014C               1717      BRA    GROUPE_SUCCESS           ;Finish routine
00002360                          1718   
00002360                          1719  CHECK_OP_LSR_NO_ROT:
00002360  3038 10A0               1720      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002364  0240 FFC0               1721      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002368  B07C E2C0               1722      CMP.W  #$E2C0,D0                ;Compare masked bits
0000236C  6600 000C               1723      BNE    CHECK_OP_LSL_NO_ROT      ;Check next OP code
00002370  4EB9 000026F2           1724      JSR    PRINT_OP_LSR             ;Print out OP code
00002376  6000 0132               1725      BRA    GROUPE_SUCCESS           ;Finish routine
0000237A                          1726  
0000237A                          1727  CHECK_OP_LSL_NO_ROT:
0000237A  3038 10A0               1728      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000237E  0240 FFC0               1729      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002382  B07C E3C0               1730      CMP.W  #$E3C0,D0                ;Compare masked bits
00002386  6600 000C               1731      BNE    CHECK_OP_ASR_NO_ROT      ;Check next OP code
0000238A  4EB9 000026DE           1732      JSR    PRINT_OP_LSL             ;Print out OP code
00002390  6000 0118               1733      BRA    GROUPE_SUCCESS           ;Finish routine
00002394                          1734  
00002394                          1735  CHECK_OP_ASR_NO_ROT:
00002394  3038 10A0               1736      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002398  0240 FFC0               1737      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000239C  B07C E0C0               1738      CMP.W  #$E0C0,D0                ;Compare masked bits
000023A0  6600 000C               1739      BNE    CHECK_OP_ASL_NO_ROT      ;Check next OP code
000023A4  4EB9 00002706           1740      JSR    PRINT_OP_ASR             ;Print out OP code
000023AA  6000 00FE               1741      BRA    GROUPE_SUCCESS           ;Finish routine
000023AE                          1742              
000023AE                          1743  CHECK_OP_ASL_NO_ROT:
000023AE  3038 10A0               1744      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023B2  0240 FFC0               1745      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023B6  B07C E1C0               1746      CMP.W  #$E1C0,D0                ;Compare masked bits
000023BA  6600 000C               1747      BNE    CHECK_OP_ROXR            ;Check next OP code
000023BE  4EB9 0000271A           1748      JSR    PRINT_OP_ASL             Print out OP code
000023C4  6000 00E4               1749      BRA    GROUPE_SUCCESS           ;Finish routine
000023C8                          1750  
000023C8                          1751  CHECK_OP_ROXR:
000023C8  3038 10A0               1752      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023CC  0240 F118               1753      ANDI.W #$F118,D0                ;Mask appropriate bits
000023D0  B07C E010               1754      CMP.W  #$E010,D0                ;Compare masked bits
000023D4  6700 00CE               1755      BEQ    GROUPE_INVALID           ;INVALID OP code found
000023D8  6600 0002               1756      BNE    CHECK_OP_ROXL            ;Check next OP code
000023DC                          1757      
000023DC                          1758  CHECK_OP_ROXL:
000023DC  3038 10A0               1759      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023E0  0240 F118               1760      ANDI.W #$F118,D0                ;Mask appropriate bits
000023E4  B07C E110               1761      CMP.W  #$E110,D0                ;Compare masked bits
000023E8  6700 00BA               1762      BEQ    GROUPE_INVALID           ;INVALID OP code found
000023EC  6600 0002               1763      BNE    CHECK_OP_ROR             ;Check next OP code
000023F0                          1764      
000023F0                          1765  CHECK_OP_ROR:
000023F0  3038 10A0               1766      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023F4  0240 F118               1767      ANDI.W #$F118,D0                ;Mask appropriate bits
000023F8  B07C E018               1768      CMP.W  #$E018,D0                ;Compare masked bits
000023FC  6600 0010               1769      BNE    CHECK_OP_ROL             ;Check next OP code
00002400  4EB8 187E               1770      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size bits
00002404  4EB9 00002742           1771      JSR    PRINT_OP_ROR             ;Print out OP code
0000240A  6000 009E               1772      BRA    GROUPE_SUCCESS           ;Finish routine
0000240E                          1773  
0000240E                          1774  CHECK_OP_ROL:
0000240E  3038 10A0               1775      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002412  0240 F118               1776      ANDI.W #$F118,D0                ;Mask appropriate bits
00002416  B07C E118               1777      CMP.W  #$E118,D0                ;Compare masked bits
0000241A  6600 0010               1778      BNE    CHECK_OP_LSR             ;Check next OP code
0000241E  4EB8 187E               1779      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002422  4EB9 0000272E           1780      JSR    PRINT_OP_ROL             ;Print out OP code
00002428  6000 0080               1781      BRA    GROUPE_SUCCESS           ;Finish routine
0000242C                          1782      
0000242C                          1783  CHECK_OP_LSR:
0000242C  3038 10A0               1784      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002430  0240 F118               1785      ANDI.W #$F118,D0                ;Mask appropriate bits
00002434  B07C E008               1786      CMP.W  #$E008,D0                ;Compare masked bits
00002438  6600 0010               1787      BNE    CHECK_OP_LSL             ;Check next OP code
0000243C  4EB8 187E               1788      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002440  4EB9 000026F2           1789      JSR    PRINT_OP_LSR             ;Print out OP code
00002446  6000 0062               1790      BRA    GROUPE_SUCCESS           ;Finish routine
0000244A                          1791  
0000244A                          1792  CHECK_OP_LSL:
0000244A  3038 10A0               1793      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000244E  0240 F118               1794      ANDI.W #$F118,D0                ;Mask appropriate bits
00002452  B07C E108               1795      CMP.W  #$E108,D0                ;Compare masked bits
00002456  6600 0010               1796      BNE    CHECK_OP_ASR             ;Check next OP code
0000245A  4EB8 187E               1797      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000245E  4EB9 000026DE           1798      JSR    PRINT_OP_LSL             ;Print out OP code
00002464  6000 0044               1799      BRA    GROUPE_SUCCESS           ;Finish routine
00002468                          1800  
00002468                          1801  CHECK_OP_ASR:
00002468  3038 10A0               1802      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000246C  0240 F118               1803      ANDI.W #$F118,D0                ;Mask appropriate bits
00002470  B07C E000               1804      CMP.W  #$E000,D0                ;Compare masked bits
00002474  6600 0010               1805      BNE    CHECK_OP_ASL             ;Check next OP code
00002478  4EB8 187E               1806      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000247C  4EB9 00002706           1807      JSR    PRINT_OP_ASR             ;Print out OP code
00002482  6000 0026               1808      BRA    GROUPE_SUCCESS           ;Finish routine
00002486                          1809  
00002486                          1810  CHECK_OP_ASL:
00002486  3038 10A0               1811      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000248A  0240 F118               1812      ANDI.W #$F118,D0                ;Mask appropriate bits
0000248E  B07C E100               1813      CMP.W  #$E100,D0                ;Compare masked bits
00002492  6600 0010               1814      BNE    GROUPE_INVALID           ;Last possible OP code
00002496  4EB8 187E               1815      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000249A  4EB9 0000271A           1816      JSR    PRINT_OP_ASL             ;Print out OP code
000024A0  6000 0008               1817      BRA    GROUPE_SUCCESS           ;Finish routine
000024A4                          1818  
000024A4                          1819  GROUPE_INVALID:
000024A4  4EB9 000024B8           1820      JSR     INVALID_OP              ;Set IS_VALID to 0
000024AA                          1821  GROUPE_SUCCESS:
000024AA  4CDF 0001               1822      MOVEM.L (SP)+,D0                ;Restore registers from stack
000024AE  4E75                    1823      RTS                             ;Return to stack
000024B0                          1824  C_GROUP_F:
000024B0  4EB9 000024B8           1825      JSR     INVALID_OP              ;Set IS_VALID to 0
000024B6  4E75                    1826      RTS                             ;Return to stack
000024B8                          1827      
000024B8                          1828  INVALID_OP:                         ; ONLY SETS IS_VALID TO 0
000024B8  11FC 0000 10A2          1829      MOVE.B #0,IS_VALID              ;Sets IS_VALID to 0
000024BE  4E75                    1830      RTS                             ;Return to stack
000024C0                          1831  
000024C0                          1832  
000024C0                          1833  PRINT_TO_BUFFER:
000024C0  21FC 00001000 1256      1834      MOVE.L #G_BUFFER, BUFFER_POINTER
000024C8  4EB8 1260               1835      JSR AddStrToBuffer
000024CC  4E75                    1836      RTS
000024CE                          1837      
000024CE                          1838  PRINT_OP_ORI:
000024CE  21FC 000027BC 1252      1839      MOVE.L #P_OP_ORI, STRING_BUFFER_POINTER
000024D6  4EB8 24C0               1840      JSR PRINT_TO_BUFFER
000024DA  4EB9 00002780           1841      JSR PRINT_OP_SIZE
000024E0  4E75                    1842      RTS
000024E2                          1843  PRINT_OP_CMPI:
000024E2  21FC 000027C3 1252      1844      MOVE.L #P_OP_CMPI, STRING_BUFFER_POINTER
000024EA  4EB8 24C0               1845      JSR PRINT_TO_BUFFER
000024EE  4EB9 00002780           1846      JSR PRINT_OP_SIZE
000024F4  4E75                    1847      RTS
000024F6                          1848  PRINT_OP_STATIC_BCLR:
000024F6  21FC 000027CB 1252      1849      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
000024FE  4EB8 24C0               1850      JSR PRINT_TO_BUFFER
00002502  4EB9 00002780           1851      JSR PRINT_OP_SIZE
00002508  4E75                    1852      RTS
0000250A                          1853      
0000250A                          1854  PRINT_OP_DYNAMIC_BCLR:
0000250A  21FC 000027CB 1252      1855      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
00002512  4EB8 24C0               1856      JSR PRINT_TO_BUFFER
00002516  4EB9 00002780           1857      JSR PRINT_OP_SIZE
0000251C  4E75                    1858      RTS
0000251E                          1859  
0000251E                          1860  PRINT_OP_MOVEB:
0000251E  21FC 000027D3 1252      1861      MOVE.L #P_OP_MOVEB, STRING_BUFFER_POINTER
00002526  4EB8 24C0               1862      JSR PRINT_TO_BUFFER
0000252A  4E75                    1863      RTS
0000252C                          1864      
0000252C                          1865  PRINT_OP_MOVEA_L:
0000252C  21FC 000027DE 1252      1866      MOVE.L #P_OP_MOVEA_L, STRING_BUFFER_POINTER
00002534  4EB8 24C0               1867      JSR PRINT_TO_BUFFER
00002538  4E75                    1868      RTS
0000253A                          1869  PRINT_OP_MOVE_L:
0000253A  21FC 000027EA 1252      1870      MOVE.L #P_OP_MOVE_L, STRING_BUFFER_POINTER
00002542  4EB8 24C0               1871      JSR PRINT_TO_BUFFER
00002546  4E75                    1872      RTS
00002548                          1873      
00002548                          1874  PRINT_OP_MOVEA_W:
00002548  21FC 000027F5 1252      1875      MOVE.L #P_OP_MOVEA_W, STRING_BUFFER_POINTER
00002550  4EB8 24C0               1876      JSR PRINT_TO_BUFFER
00002554  4E75                    1877      RTS
00002556                          1878  PRINT_OP_MOVE_W:
00002556  21FC 00002801 1252      1879      MOVE.L #P_OP_MOVE_W, STRING_BUFFER_POINTER
0000255E  4EB8 24C0               1880      JSR PRINT_TO_BUFFER
00002562  4E75                    1881      RTS
00002564                          1882  
00002564                          1883  PRINT_OP_JSR:
00002564  21FC 0000282B 1252      1884      MOVE.L #P_OP_JSR, STRING_BUFFER_POINTER
0000256C  4EB8 24C0               1885      JSR PRINT_TO_BUFFER
00002570  4E75                    1886      RTS
00002572                          1887  PRINT_OP_RTS:
00002572  21FC 00002839 1252      1888      MOVE.L #P_OP_RTS, STRING_BUFFER_POINTER
0000257A  4EB8 24C0               1889      JSR PRINT_TO_BUFFER
0000257E  4E75                    1890      RTS
00002580                          1891  PRINT_OP_NOP:
00002580  21FC 00002832 1252      1892      MOVE.L #P_OP_NOP, STRING_BUFFER_POINTER
00002588  4EB8 24C0               1893      JSR PRINT_TO_BUFFER
0000258C  4E75                    1894      RTS
0000258E                          1895  PRINT_OP_LEA:
0000258E  21FC 00002824 1252      1896      MOVE.L #P_OP_LEA, STRING_BUFFER_POINTER
00002596  4EB8 24C0               1897      JSR PRINT_TO_BUFFER
0000259A  4EB9 00002780           1898      JSR PRINT_OP_SIZE
000025A0  4E75                    1899      RTS
000025A2                          1900  PRINT_OP_NEG:
000025A2  21FC 00002840 1252      1901      MOVE.L #P_OP_NEG, STRING_BUFFER_POINTER
000025AA  4EB8 24C0               1902      JSR PRINT_TO_BUFFER
000025AE  4EB9 00002780           1903      JSR PRINT_OP_SIZE
000025B4  4E75                    1904      RTS
000025B6                          1905  PRINT_OP_MOVEM_W:
000025B6  21FC 0000280C 1252      1906      MOVE.L #P_OP_MOVEM_W, STRING_BUFFER_POINTER
000025BE  4EB8 24C0               1907      JSR PRINT_TO_BUFFER
000025C2  4E75                    1908      RTS
000025C4                          1909  PRINT_OP_MOVEM_L:
000025C4  21FC 00002818 1252      1910      MOVE.L #P_OP_MOVEM_L, STRING_BUFFER_POINTER
000025CC  4EB8 24C0               1911      JSR PRINT_TO_BUFFER
000025D0  4E75                    1912      RTS
000025D2                          1913      
000025D2                          1914  PRINT_OP_SUBQ:
000025D2  21FC 00002847 1252      1915      MOVE.L #P_OP_SUBQ, STRING_BUFFER_POINTER
000025DA  4EB8 24C0               1916      JSR PRINT_TO_BUFFER
000025DE  4EB9 00002780           1917      JSR PRINT_OP_SIZE
000025E4  4E75                    1918      RTS
000025E6                          1919  
000025E6                          1920  PRINT_OP_BCS:
000025E6  21FC 00002856 1252      1921      MOVE.L #P_OP_BCS, STRING_BUFFER_POINTER
000025EE  4EB8 24C0               1922      JSR PRINT_TO_BUFFER
000025F2  4EB9 00002780           1923      JSR PRINT_OP_SIZE
000025F8  4E75                    1924      RTS
000025FA                          1925  PRINT_OP_BGE:
000025FA  21FC 0000285D 1252      1926      MOVE.L #P_OP_BGE, STRING_BUFFER_POINTER
00002602  4EB8 24C0               1927      JSR PRINT_TO_BUFFER
00002606  4EB9 00002780           1928      JSR PRINT_OP_SIZE
0000260C  4E75                    1929      RTS
0000260E                          1930  PRINT_OP_BLT:
0000260E  21FC 00002864 1252      1931      MOVE.L #P_OP_BLT, STRING_BUFFER_POINTER
00002616  4EB8 24C0               1932      JSR PRINT_TO_BUFFER
0000261A  4EB9 00002780           1933      JSR PRINT_OP_SIZE
00002620  4E75                    1934      RTS
00002622                          1935  PRINT_OP_BVC:
00002622  21FC 0000286B 1252      1936      MOVE.L #P_OP_BVC, STRING_BUFFER_POINTER
0000262A  4EB8 24C0               1937      JSR PRINT_TO_BUFFER
0000262E  4EB9 00002780           1938      JSR PRINT_OP_SIZE
00002634  4E75                    1939      RTS
00002636                          1940  PRINT_OP_BRA:
00002636  21FC 0000284F 1252      1941      MOVE.L #P_OP_BRA, STRING_BUFFER_POINTER
0000263E  4EB8 24C0               1942      JSR PRINT_TO_BUFFER
00002642  4EB9 00002780           1943      JSR PRINT_OP_SIZE
00002648  4E75                    1944      RTS
0000264A                          1945  
0000264A                          1946  
0000264A                          1947  PRINT_OP_DIVS:
0000264A  21FC 00002872 1252      1948      MOVE.L #P_OP_DIVS, STRING_BUFFER_POINTER
00002652  4EB8 24C0               1949      JSR PRINT_TO_BUFFER
00002656  4E75                    1950      RTS
00002658                          1951  PRINT_OP_OR:
00002658  21FC 0000287D 1252      1952      MOVE.L #P_OP_OR, STRING_BUFFER_POINTER
00002660  4EB8 24C0               1953      JSR PRINT_TO_BUFFER
00002664  4EB9 00002780           1954      JSR PRINT_OP_SIZE
0000266A  4E75                    1955      RTS
0000266C                          1956  
0000266C                          1957  PRINT_OP_SUB:
0000266C  21FC 00002883 1252      1958      MOVE.L #P_OP_SUB, STRING_BUFFER_POINTER
00002674  4EB8 24C0               1959      JSR PRINT_TO_BUFFER
00002678  4EB9 00002780           1960      JSR PRINT_OP_SIZE
0000267E  4E75                    1961      RTS
00002680                          1962  
00002680                          1963  
00002680                          1964  PRINT_OP_EOR:
00002680  21FC 0000288A 1252      1965      MOVE.L #P_OP_EOR, STRING_BUFFER_POINTER
00002688  4EB8 24C0               1966      JSR PRINT_TO_BUFFER
0000268C  4EB9 00002780           1967      JSR PRINT_OP_SIZE
00002692  4E75                    1968      RTS
00002694                          1969  PRINT_OP_CMP:
00002694  21FC 00002891 1252      1970      MOVE.L #P_OP_CMP, STRING_BUFFER_POINTER
0000269C  4EB8 24C0               1971      JSR PRINT_TO_BUFFER
000026A0  4EB9 00002780           1972      JSR PRINT_OP_SIZE
000026A6  4E75                    1973      RTS
000026A8                          1974  
000026A8                          1975  PRINT_OP_MULS:
000026A8  21FC 00002898 1252      1976      MOVE.L #P_OP_MULS, STRING_BUFFER_POINTER
000026B0  4EB8 24C0               1977      JSR PRINT_TO_BUFFER
000026B4  4E75                    1978      RTS
000026B6                          1979  
000026B6                          1980  PRINT_OP_ADD:
000026B6  21FC 000028AB 1252      1981      MOVE.L #P_OP_ADD, STRING_BUFFER_POINTER
000026BE  4EB8 24C0               1982      JSR PRINT_TO_BUFFER
000026C2  4EB9 00002780           1983      JSR PRINT_OP_SIZE
000026C8  4E75                    1984      RTS
000026CA                          1985  PRINT_OP_ADDA:
000026CA  21FC 000028A3 1252      1986      MOVE.L #P_OP_ADDA, STRING_BUFFER_POINTER
000026D2  4EB8 24C0               1987      JSR PRINT_TO_BUFFER
000026D6  4EB9 0000279A           1988      JSR PRINT_OP_SIZE_ADDA
000026DC  4E75                    1989      RTS
000026DE                          1990  
000026DE                          1991  
000026DE                          1992  PRINT_OP_LSL:
000026DE  21FC 000028B9 1252      1993      MOVE.L #P_OP_LSL, STRING_BUFFER_POINTER
000026E6  4EB8 24C0               1994      JSR PRINT_TO_BUFFER
000026EA  4EB9 00002780           1995      JSR PRINT_OP_SIZE
000026F0  4E75                    1996      RTS
000026F2                          1997  PRINT_OP_LSR:
000026F2  21FC 000028B2 1252      1998      MOVE.L #P_OP_LSR, STRING_BUFFER_POINTER
000026FA  4EB8 24C0               1999      JSR PRINT_TO_BUFFER
000026FE  4EB9 00002780           2000      JSR PRINT_OP_SIZE
00002704  4E75                    2001      RTS
00002706                          2002  PRINT_OP_ASR:
00002706  21FC 000028C0 1252      2003      MOVE.L #P_OP_ASR, STRING_BUFFER_POINTER
0000270E  4EB8 24C0               2004      JSR PRINT_TO_BUFFER
00002712  4EB9 00002780           2005      JSR PRINT_OP_SIZE
00002718  4E75                    2006      RTS
0000271A                          2007  PRINT_OP_ASL:
0000271A  21FC 000028C7 1252      2008      MOVE.L #P_OP_ASL, STRING_BUFFER_POINTER
00002722  4EB8 24C0               2009      JSR PRINT_TO_BUFFER
00002726  4EB9 00002780           2010      JSR PRINT_OP_SIZE
0000272C  4E75                    2011      RTS
0000272E                          2012  PRINT_OP_ROL:
0000272E  21FC 000028D5 1252      2013      MOVE.L #P_OP_ROL, STRING_BUFFER_POINTER
00002736  4EB8 24C0               2014      JSR PRINT_TO_BUFFER
0000273A  4EB9 00002780           2015      JSR PRINT_OP_SIZE
00002740  4E75                    2016      RTS
00002742                          2017  PRINT_OP_ROR:
00002742  21FC 000028CE 1252      2018      MOVE.L #P_OP_ROR, STRING_BUFFER_POINTER
0000274A  4EB8 24C0               2019      JSR PRINT_TO_BUFFER
0000274E  4EB9 00002780           2020      JSR PRINT_OP_SIZE
00002754  4E75                    2021      RTS
00002756                          2022  
00002756                          2023  
00002756                          2024  PRINT_SIZE_BYTE:
00002756  21FC 000027B0 1252      2025      MOVE.L #P_SIZE_B, STRING_BUFFER_POINTER
0000275E  4EB8 24C0               2026      JSR PRINT_TO_BUFFER
00002762  4E75                    2027      RTS    
00002764                          2028  
00002764                          2029  PRINT_SIZE_WORD:
00002764  21FC 000027B4 1252      2030      MOVE.L #P_SIZE_W, STRING_BUFFER_POINTER
0000276C  4EB8 24C0               2031      JSR PRINT_TO_BUFFER
00002770  4E75                    2032      RTS
00002772                          2033      
00002772                          2034  PRINT_SIZE_LONG:
00002772  21FC 000027B8 1252      2035      MOVE.L #P_SIZE_L, STRING_BUFFER_POINTER
0000277A  4EB8 24C0               2036      JSR PRINT_TO_BUFFER
0000277E  4E75                    2037      RTS
00002780                          2038  
00002780                          2039  PRINT_OP_SIZE:                      ;Prints current OP code byte size if applicable
00002780  0C38 0000 1738          2040      CMP.B  #%00,OP_SIZE             ;Checks for byte size
00002786  67CE                    2041      BEQ    PRINT_SIZE_BYTE          ;Print .B to buffer
00002788  0C38 0001 1738          2042      CMP.B  #%01,OP_SIZE             ;Check for word size
0000278E  67D4                    2043      BEQ    PRINT_SIZE_WORD          ;Print .W to buffer
00002790  0C38 0002 1738          2044      CMP.B  #%10,OP_SIZE             ;Check for long size
00002796  67DA                    2045      BEQ    PRINT_SIZE_LONG          ;Print .L to buffer
00002798  4E75                    2046      RTS
0000279A                          2047      
0000279A                          2048  PRINT_OP_SIZE_ADDA:                 ;Special  print for ADDA
0000279A  0C38 0000 1738          2049      CMP.B #%0,OP_SIZE               ;Checks if the OP_SIZE is 0
000027A0  67C2                    2050      BEQ    PRINT_SIZE_WORD          ;If it is the size is word
000027A2  66CE                    2051      BNE    PRINT_SIZE_LONG          ;If it's not the size is long
000027A4                          2052      
000027A4                          2053  
000027A4                          2054  
000027A4                          2055  
000027A4                          2056  
000027A4= 20 20 20 44 41 54 ...   2057  P_INVALID_OP    DC.B    '   DATA   $',0
000027B0= 2E 42 20 00             2058  P_SIZE_B        DC.B    '.B ',0
000027B4= 2E 57 20 00             2059  P_SIZE_W        DC.B    '.W ',0
000027B8= 2E 4C 20 00             2060  P_SIZE_L        DC.B    '.L ',0
000027BC= 20 20 20 4F 52 49 00    2061  P_OP_ORI        DC.B    '   ORI',0
000027C3= 20 20 20 43 4D 50 ...   2062  P_OP_CMPI       DC.B    '   CMPI',0
000027CB= 20 20 20 42 43 4C ...   2063  P_OP_BCLR       DC.B    '   BCLR',0
000027D3= 20 20 20 4D 4F 56 ...   2064  P_OP_MOVEB      DC.B    '   MOVE.B ',0
000027DE= 20 20 20 4D 4F 56 ...   2065  P_OP_MOVEA_L    DC.B    '   MOVEA.L ',0 
000027EA= 20 20 20 4D 4F 56 ...   2066  P_OP_MOVE_L     DC.B    '   MOVE.L ',0
000027F5= 20 20 20 4D 4F 56 ...   2067  P_OP_MOVEA_W    DC.B    '   MOVEA.W ',0
00002801= 20 20 20 4D 4F 56 ...   2068  P_OP_MOVE_W     DC.B    '   MOVE.W ',0
0000280C= 20 20 20 4D 4F 56 ...   2069  P_OP_MOVEM_W    DC.B    '   MOVEM.W ',0
00002818= 20 20 20 4D 4F 56 ...   2070  P_OP_MOVEM_L    DC.B    '   MOVEM.L ',0
00002824= 20 20 20 4C 45 41 00    2071  P_OP_LEA        DC.B    '   LEA',0
0000282B= 20 20 20 4A 53 52 00    2072  P_OP_JSR        DC.B    '   JSR',0
00002832= 20 20 20 4E 4F 50 00    2073  P_OP_NOP        DC.B    '   NOP',0
00002839= 20 20 20 52 54 53 00    2074  P_OP_RTS        DC.B    '   RTS',0
00002840= 20 20 20 4E 45 47 00    2075  P_OP_NEG        DC.B    '   NEG',0
00002847= 20 20 20 53 55 42 ...   2076  P_OP_SUBQ       DC.B    '   SUBQ',0
0000284F= 20 20 20 42 52 41 00    2077  P_OP_BRA        DC.B    '   BRA',0
00002856= 20 20 20 42 43 53 00    2078  P_OP_BCS        DC.B    '   BCS',0
0000285D= 20 20 20 42 47 45 00    2079  P_OP_BGE        DC.B    '   BGE',0
00002864= 20 20 20 42 4C 54 00    2080  P_OP_BLT        DC.B    '   BLT',0
0000286B= 20 20 20 42 56 43 00    2081  P_OP_BVC        DC.B    '   BVC',0
00002872= 20 20 20 44 49 56 ...   2082  P_OP_DIVS       DC.B    '   DIVS.W ',0
0000287D= 20 20 20 4F 52 00       2083  P_OP_OR         DC.B    '   OR',0
00002883= 20 20 20 53 55 42 00    2084  P_OP_SUB        DC.B    '   SUB',0
0000288A= 20 20 20 45 4F 52 00    2085  P_OP_EOR        DC.B    '   EOR',0
00002891= 20 20 20 43 4D 50 00    2086  P_OP_CMP        DC.B    '   CMP',0
00002898= 20 20 20 4D 55 4C ...   2087  P_OP_MULS       DC.B    '   MULS.W ',0
000028A3= 20 20 20 41 44 44 ...   2088  P_OP_ADDA       DC.B    '   ADDA',0
000028AB= 20 20 20 41 44 44 00    2089  P_OP_ADD        DC.B    '   ADD',0
000028B2= 20 20 20 4C 53 52 00    2090  P_OP_LSR        DC.B    '   LSR',0
000028B9= 20 20 20 4C 53 4C 00    2091  P_OP_LSL        DC.B    '   LSL',0
000028C0= 20 20 20 41 53 52 00    2092  P_OP_ASR        DC.B    '   ASR',0
000028C7= 20 20 20 41 53 4C 00    2093  P_OP_ASL        DC.B    '   ASL',0
000028CE= 20 20 20 52 4F 52 00    2094  P_OP_ROR        DC.B    '   ROR',0
000028D5= 20 20 20 52 4F 4C 00    2095  P_OP_ROL        DC.B    '   ROL',0
000028DC                          2096  
000028DC                          2097  
000028DC                          2098  
000028DC                          2099  
000028DC                          2100  
000028DC                          2101  -------------------- end include --------------------
000028DC                          2102      INCLUDE "EA_Integrated.x68"                         ;EA role code to include
000028DC                          2103  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028DC                          2104  
000028DC                          2105  
000028DC= 41                      2106  ADDRESS         DC.B    $41
000028DD= 44                      2107  DATA            DC.B    $44
000028DE                          2108  
000028DE= 28                      2109  PTHSIS_OPEN     DC.B    $28
000028DF= 29                      2110  PTHSIS_CLSD     DC.B    $29
000028E0= 24                      2111  HEX_SIGN        DC.B    $24
000028E1= 23                      2112  IMMDTE_VALU     DC.B    $23
000028E2= 2B                      2113  PLUS_SIGN       DC.B    $2B
000028E3= 2D                      2114  MINUS_SIGN      DC.B    $2D
000028E4                          2115  
000028E4= 2C                      2116  COMMA           DC.B    $2C
000028E5= 20                      2117  SPACE           DC.B    $20
000028E6                          2118  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028E6                          2119  
000028E6                          2120  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
000028E6                          2121  TRAILING_SIZE   DS.W    1 * Size of any immediate or
000028E8                          2122                            * address values. Immediate or address
000028E8                          2123                            * value of a BYTE is still processed as
000028E8                          2124                            * WORD because the trailing bytes
000028E8                          2125                            * are represented as a word regardless.
000028E8                          2126                            * $1 = BYTE, $2 = WORD, $4 = LONG
000028E8                          2127                            
000028E8                          2128  X               DS.B    1
000028E9                          2129  Y               DS.B    1 * always X -> Y
000028EA                          2130  X_COUNTER       DS.B    1
000028EB                          2131  Y_COUNTER       DS.B    1
000028EC                          2132  FIRST_X         DS.B    1 * 0: it is first X
000028ED                          2133                            * 1: it is second X
000028ED                          2134  FIRST_Y         DS.B    1 * 0: it is first Y
000028EE                          2135                            * 1: it is second Y
000028EE                          2136  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028EE                          2137  
000028EE                          2138  main_EA:
000028EE  4EB8 1924               2139      JSR PARSE_EA_CONSTANT_BITS    
000028F2                          2140  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028F2                          2141  
000028F2                          2142  
000028F2                          2143  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028F2                          2144  
000028F2                          2145  
000028F2                          2146  
000028F2                          2147  
000028F2                          2148  
000028F2                          2149  
000028F2                          2150  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
000028F2                          2151  
000028F2  4EB9 000028FC           2152      JSR     CHECK_XXXX
000028F8                          2153  EXT                        * Main EXT alias to finish routine
000028F8  4EF8 11C2               2154      JMP check_print 
000028FC                          2155  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000028FC                          2156  
000028FC                          2157  CHECK_XXXX:
000028FC  0C38 0008 1739          2158      CMPI.B  #$8, MNEMONIC
00002902  6D00 0008               2159      BLT     CHECK_0XXX
00002906  4EF9 0000291C           2160      JMP     CHECK_1XXX
0000290C                          2161  
0000290C                          2162  CHECK_0XXX:
0000290C  0C38 0004 1739          2163      CMPI.B  #$4, MNEMONIC
00002912  6D00 004C               2164      BLT     CHECK_00XX
00002916  4EF9 0000296E           2165      JMP     CHECK_01XX
0000291C                          2166  
0000291C                          2167  CHECK_1XXX:
0000291C  0C38 0008 1739          2168      CMPI.B  #$8, MNEMONIC
00002922  6700 0308               2169      BEQ     LOAD_1000
00002926  0C38 0009 1739          2170      CMPI.B  #$9, MNEMONIC
0000292C  6700 02F8               2171      BEQ     LOAD_1001
00002930  0C38 000B 1739          2172      CMPI.B  #$B, MNEMONIC
00002936  6700 02E8               2173      BEQ     LOAD_1011
0000293A  0C38 000C 1739          2174      CMPI.B  #$C, MNEMONIC
00002940  6700 02D8               2175      BEQ     LOAD_1100
00002944  0C38 000D 1739          2176      CMPI.B  #$D, MNEMONIC
0000294A  6700 026C               2177      BEQ     LOAD_1101
0000294E  0C38 000E 1739          2178      CMPI.B  #$E, MNEMONIC
00002954  6700 0038               2179      BEQ     LOAD_1110
00002958                          2180      
00002958  4EF9 00003478           2181      JMP     INVALID
0000295E                          2182      
0000295E  4E75                    2183      RTS
00002960                          2184  
00002960                          2185  CHECK_00XX:
00002960  0C38 0001 1739          2186      CMPI.B  #$1, MNEMONIC
00002966  6D00 0712               2187      BLT     LOAD_0000
0000296A  6C00 0894               2188      BGE     LOAD_00XX
0000296E                          2189  
0000296E                          2190  CHECK_01XX:
0000296E  0C38 0004 1739          2191      CMPI.B  #%0100, MNEMONIC
00002974  6700 0458               2192      BEQ     LOAD_0100
00002978  0C38 0005 1739          2193      CMPI.B  #%0101, MNEMONIC
0000297E  6700 03C4               2194      BEQ     LOAD_0101
00002982  0C38 0006 1739          2195      CMPI.B  #%0110, MNEMONIC
00002988  6700 0124               2196      BEQ     LOAD_0110
0000298C  4E75                    2197      RTS
0000298E                          2198  
0000298E                          2199  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000298E                          2200  
0000298E                          2201  
0000298E                          2202  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000298E                          2203  
0000298E                          2204  LOAD_1110:
0000298E  247C 00000000           2205              MOVEA.L #0, A2
00002994  267C 00000000           2206              MOVEA.L #0, A3
0000299A  4285                    2207              CLR.L   D5
0000299C                          2208      
0000299C  1A38 173B               2209              MOVE.B  SECOND_3, D5
000029A0  0205 0003               2210              ANDI.B  #%011, D5
000029A4                          2211      
000029A4  0C05 0003               2212              CMPI.B  #%11, D5
000029A8  6700 0006               2213              BEQ     MYBE_ASd_1
000029AC  6600 0068               2214              BNE     MYBE_ASd_2
000029B0                          2215  
000029B0  0C38 0000 173A          2216  MYBE_ASd_1  CMPI.B  #%000, FIRST_3
000029B6  6700 001C               2217              BEQ     ASd_1
000029BA  0C38 0001 173A          2218              CMPI.B  #%001, FIRST_3
000029C0  6700 0012               2219              BEQ     ASd_1 * LSd
000029C4  0C38 0003 173A          2220              CMPI.B  #%011, FIRST_3
000029CA  6700 0008               2221              BEQ     ASd_1 * ROd
000029CE  4EF9 00003478           2222              JMP     INVALID
000029D4                          2223  
000029D4  0C38 0007 173C          2224  ASd_1       CMPI.B  #%111, THIRD_3
000029DA  6600 000C               2225              BNE     MOVEON  
000029DE  0C38 0004 173D          2226              CMPI.B  #%100, FOURTH_3
000029E4  6700 0A92               2227              BEQ     INVALID
000029E8                          2228  
000029E8  367C 2A00               2229  MOVEON      MOVEA.W #ASd_1_BACK, A3           
000029EC  0C38 0000 173D          2230              CMPI.B  #%000, FOURTH_3
000029F2  6700 091C               2231              BEQ     SIZE_W
000029F6  0C38 0001 173D          2232              CMPI.B  #%001, FOURTH_3
000029FC  6700 091A               2233              BEQ     SIZE_L
00002A00                          2234  
00002A00  1638 173C               2235  ASd_1_BACK  MOVE.B  THIRD_3, D3
00002A04  1438 173D               2236              MOVE.B  FOURTH_3, D2
00002A08                          2237              
00002A08  4EB9 00003264           2238              JSR     LOAD_EA
00002A0E  4EB9 000033C6           2239              JSR     LOAD_NEW_LINE
00002A14  4E75                    2240              RTS
00002A16                          2241  
00002A16  4285                    2242  MYBE_ASd_2  CLR.L   D5
00002A18                          2243  
00002A18  1A38 173C               2244              MOVE.B  THIRD_3, D5
00002A1C  0205 0003               2245              ANDI.B  #%011, D5
00002A20  0C05 0002               2246              CMPI.B  #%10, D5
00002A24  6600 0006               2247              BNE     ASd_2 * or LSd or ROd
00002A28  6700 0A4E               2248              BEQ     INVALID
00002A2C                          2249              
00002A2C  4285                    2250  ASd_2       CLR.L   D5
00002A2E                          2251  
00002A2E  1A38 173C               2252              MOVE.B  THIRD_3, D5
00002A32  0205 0004               2253              ANDI.B  #%100, D5
00002A36  0C05 0004               2254              CMPI.B  #%100, D5
00002A3A  6700 0048               2255              BEQ     ASd_2_REG
00002A3E  6600 0002               2256              BNE     ASd_2_IMD
00002A42                          2257              
00002A42  347C 2A68               2258  ASd_2_IMD   MOVEA.W #ASd_2_IMD_B, A2
00002A46  0C38 0000 173A          2259              CMPI.B  #%000, FIRST_3
00002A4C  6700 0006               2260              BEQ     LOAD_8
00002A50  6600 000C               2261              BNE     LOAD_FIRST3
00002A54                          2262              
00002A54  183C 0008               2263  LOAD_8      MOVE.B  #8, D4
00002A58  4EF9 00003392           2264              JMP     LOAD_IMMDTE
00002A5E                          2265  
00002A5E  1838 173A               2266  LOAD_FIRST3 MOVE.B  FIRST_3, D4
00002A62  4EF9 00003392           2267              JMP     LOAD_IMMDTE
00002A68                          2268  
00002A68  4EB9 000033C8           2269  ASd_2_IMD_B JSR     LOAD_COMMA_SPACE
00002A6E                          2270  
00002A6E  163C 0000               2271              MOVE.B  #%000, D3
00002A72  1438 173D               2272              MOVE.B  FOURTH_3, D2
00002A76                          2273              
00002A76  4EB9 00003264           2274              JSR     LOAD_EA
00002A7C  4EB9 000033C6           2275              JSR     LOAD_NEW_LINE
00002A82  4E75                    2276              RTS
00002A84                          2277  
00002A84  163C 0000               2278  ASd_2_REG   MOVE.B  #%000, D3
00002A88  1438 173A               2279              MOVE.B  FIRST_3, D2
00002A8C                          2280              
00002A8C  4EB9 00003264           2281              JSR     LOAD_EA
00002A92  4EB9 000033C8           2282              JSR     LOAD_COMMA_SPACE
00002A98                          2283              
00002A98  163C 0000               2284              MOVE.B  #%000, D3
00002A9C  1438 173D               2285              MOVE.B  FOURTH_3, D2
00002AA0                          2286              
00002AA0  4EB9 00003264           2287              JSR     LOAD_EA
00002AA6  4EB9 000033C6           2288              JSR     LOAD_NEW_LINE
00002AAC  4E75                    2289              RTS
00002AAE                          2290  
00002AAE                          2291  
00002AAE                          2292  
00002AAE                          2293  LOAD_0110:
00002AAE  247C 00000000           2294              MOVEA.L #0, A2
00002AB4  267C 00000000           2295              MOVEA.L #0, A3
00002ABA  4285                    2296              CLR.L   D5
00002ABC  4286                    2297              CLR.L   D6
00002ABE  4284                    2298              CLR.L   D4
00002AC0                          2299  
00002AC0  0C38 0000 173A          2300              CMPI.B  #%000, FIRST_3
00002AC6  6700 0006               2301              BEQ     MYBE_BRA
00002ACA  6600 0010               2302              BNE     NOT_BRA
00002ACE  0C38 0004 173B          2303  MYBE_BRA    CMPI.B  #%100, SECOND_3
00002AD4  6D00 003A               2304              BLT     BRA
00002AD8  6C00 0002               2305              BGE     NOT_BRA
00002ADC                          2306              
00002ADC  1A38 173A               2307  NOT_BRA     MOVE.B  FIRST_3, D5
00002AE0  E305                    2308              ASL.B   #1, D5
00002AE2  1C38 173B               2309              MOVE.B  SECOND_3, D6
00002AE6  E406                    2310              ASR.B   #2, D6
00002AE8  DA06                    2311              ADD.B   D6, D5
00002AEA                          2312              
00002AEA  0C05 0005               2313              CMPI.B  #%0101, D5
00002AEE  6700 0020               2314              BEQ     BRA * CS
00002AF2  0C05 0008               2315              CMPI.B  #%1000, D5
00002AF6  6700 0018               2316              BEQ     BRA * VC
00002AFA  0C05 000C               2317              CMPI.B  #%1100, D5
00002AFE  6700 0010               2318              BEQ     BRA * GE
00002B02  0C05 000D               2319              CMPI.B  #%1101, D5
00002B06  6700 0008               2320              BEQ     BRA * LT
00002B0A                          2321              
00002B0A  4EF9 00003478           2322              JMP     INVALID
00002B10                          2323              
00002B10                          2324              
00002B10  4285                    2325  BRA         CLR.L   D5
00002B12  4286                    2326              CLR.L   D6
00002B14                          2327  
00002B14  3A0D                    2328              MOVE.W  A5, D5 * D5 has $1002 (Starting + MNEMONICS)
00002B16  3C38 10A0               2329              MOVE.W  CUR_OP_CODE, D6
00002B1A  0246 00FF               2330              ANDI.W  #$00FF, D6 * D6 now has $E
00002B1E  0C06 0000               2331              CMPI.B  #$00, D6
00002B22  6700 0052               2332              BEQ     BRA_WORD * word. there is 4 hex trailing bits (word)
00002B26                          2333  
00002B26  0C06 00FF               2334              CMPI.B  #$FF, D6
00002B2A  6700 0010               2335              BEQ     BRA_BYTE
00002B2E  0C06 00FE               2336              CMPI.B  #$FE, D6
00002B32  6700 0008               2337              BEQ     BRA_BYTE
00002B36                          2338  
00002B36  4EF9 00003478           2339              JMP     INVALID
00002B3C                          2340              
00002B3C  0C06 00FE               2341  BRA_BYTE    CMPI.B  #$FE, D6
00002B40  6700 0010               2342              BEQ     DOWN_ZERO
00002B44  0C06 00FF               2343              CMPI.B  #$FF, D6
00002B48  6700 0010               2344              BEQ     DOWN_ONE
00002B4C                          2345              
00002B4C  4EF9 00003478           2346              JMP     INVALID
00002B52                          2347              
00002B52  5505                    2348  DOWN_ZERO   SUBI.B  #$2, D5 * D5 has $1000 (Starting)
00002B54  4EF9 00002B62           2349              JMP     BRA_BYTE2
00002B5A                          2350              
00002B5A  5305                    2351  DOWN_ONE    SUBI.B  #$1, D5 * D5 has $1001 (Starting + 1)
00002B5C  4EF9 00002B62           2352              JMP     BRA_BYTE2
00002B62                          2353              
00002B62  347C 2B6E               2354  BRA_BYTE2   MOVE.W  #BRA_BYTE3, A2
00002B66  3805                    2355              MOVE.W  D5, D4
00002B68  4EF9 0000336E           2356              JMP     LOAD_ABS_SHORT
00002B6E  4EB9 000033C6           2357  BRA_BYTE3   JSR     LOAD_NEW_LINE
00002B74  4E75                    2358              RTS
00002B76                          2359  
00002B76  381D                    2360  BRA_WORD    MOVE.W  (A5)+, D4 * D4 now has $000E
00002B78                          2361  
00002B78  0C84 00008000           2362              CMPI.L  #$8000, D4
00002B7E  6C00 001A               2363              BGE     NEG_WORD
00002B82  6D00 0002               2364              BLT     POS_WORD
00002B86                          2365              
00002B86  347C 2B92               2366  POS_WORD    MOVE.W  #BRA_WORD_BK, A2
00002B8A  D845                    2367              ADD.W   D5, D4 * D4 now has $100E
00002B8C  4EF9 0000336E           2368              JMP     LOAD_ABS_SHORT
00002B92  4EB9 000033C6           2369  BRA_WORD_BK JSR     LOAD_NEW_LINE
00002B98  4E75                    2370              RTS
00002B9A                          2371  
00002B9A  347C 2BB0               2372  NEG_WORD    MOVE.W  #BRA_WRD_BK2, A2
00002B9E  4444                    2373              NEG     D4
00002BA0                          2374              
00002BA0  B885                    2375              CMP.L   D5, D4 * $4002 vs DISPLACEMENT
00002BA2  6E00 08D4               2376              BGT     INVALID
00002BA6                          2377              
00002BA6  9A44                    2378              SUB.W   D4, D5 * D5 now has $1000 - 2cmp'ed $000E
00002BA8  3805                    2379              MOVE.W  D5, D4
00002BAA  4EF9 0000336E           2380              JMP     LOAD_ABS_SHORT
00002BB0  4EB9 000033C6           2381  BRA_WRD_BK2 JSR     LOAD_NEW_LINE
00002BB6  4E75                    2382              RTS
00002BB8                          2383  
00002BB8                          2384  
00002BB8                          2385  
00002BB8                          2386  LOAD_1101:
00002BB8  0C38 0003 173B          2387              CMPI.B  #%011, SECOND_3
00002BBE  6700 0012               2388              BEQ     ADDA
00002BC2  0C38 0007 173B          2389              CMPI.B  #%111, SECOND_3
00002BC8  6700 0008               2390              BEQ     ADDA
00002BCC                          2391              
00002BCC  4EF9 00002C2C           2392              JMP     LOAD_1000
00002BD2                          2393              
00002BD2  367C 2BF0               2394  ADDA        MOVEA.W #ADDA_BACK, A3
00002BD6  4281                    2395              CLR.L   D1
00002BD8  1238 173B               2396              MOVE.B  SECOND_3, D1
00002BDC  0201 0004               2397              ANDI.B  #%100, D1
00002BE0                          2398              
00002BE0  0C01 0000               2399              CMPI.B  #%000, D1
00002BE4  6700 072A               2400              BEQ     SIZE_W
00002BE8  0C01 0004               2401              CMPI.B  #%100, D1
00002BEC  6700 072A               2402              BEQ     SIZE_L
00002BF0                          2403              
00002BF0  1638 173C               2404  ADDA_BACK   MOVE.B  THIRD_3, D3
00002BF4  1438 173D               2405              MOVE.B  FOURTH_3, D2
00002BF8                          2406  
00002BF8  4EB9 00003264           2407              JSR     LOAD_EA
00002BFE  4EB9 000033C8           2408              JSR     LOAD_COMMA_SPACE
00002C04                          2409              
00002C04  163C 0001               2410              MOVE.B  #%001, D3
00002C08  1438 173A               2411              MOVE.B  FIRST_3, D2
00002C0C                          2412              
00002C0C  4EB9 00003264           2413              JSR     LOAD_EA
00002C12  4EB9 000033C6           2414              JSR     LOAD_NEW_LINE
00002C18  4E75                    2415              RTS
00002C1A                          2416  
00002C1A                          2417  LOAD_1100:
00002C1A  4EF9 00002C2C           2418      JMP     LOAD_1000
00002C20                          2419      
00002C20                          2420  LOAD_1011:
00002C20  4EF9 00002C2C           2421      JMP     LOAD_1000
00002C26                          2422  
00002C26                          2423  
00002C26                          2424  LOAD_1001:
00002C26  4EF9 00002C2C           2425      JMP     LOAD_1000
00002C2C                          2426  
00002C2C                          2427  
00002C2C                          2428  LOAD_1000:
00002C2C  4283                    2429              CLR.L   D3
00002C2E  4282                    2430              CLR.L   D2
00002C30  267C 00000000           2431              MOVEA.L #0, A3
00002C36                          2432              
00002C36  0C38 0007 173B          2433              CMPI.B  #%111, SECOND_3
00002C3C  6700 00BA               2434              BEQ     DIVS
00002C40                          2435              
00002C40  0C38 0003 173B          2436              CMPI.B  #%011, SECOND_3
00002C46  6700 0830               2437              BEQ     INVALID
00002C4A                          2438              
00002C4A  0C38 0004 173B          2439              CMPI.B  #%100, SECOND_3
00002C50  6D00 0006               2440              BLT     DIR_0 * direction bit 0
00002C54  6C00 0052               2441              BGE     DIR_1 * direction bit 1
00002C58                          2442              
00002C58  4281                    2443  DIR_0       CLR.L   D1
00002C5A  1238 173B               2444              MOVE.B  SECOND_3, D1
00002C5E  0201 0003               2445              ANDI.B  #%011, D1
00002C62                          2446      
00002C62  367C 2C7E               2447              MOVEA.W #OR_BACK, A3
00002C66  0C01 0000               2448              CMPI.B  #%00, D1
00002C6A  6700 069C               2449              BEQ     SIZE_B
00002C6E  0C01 0001               2450              CMPI.B  #%01, D1
00002C72  6700 069C               2451              BEQ     SIZE_W
00002C76  0C01 0002               2452              CMPI.B  #%10, D1
00002C7A  6700 069C               2453              BEQ     SIZE_L
00002C7E                          2454              
00002C7E  1638 173C               2455  OR_BACK     MOVE.B  THIRD_3, D3
00002C82  1438 173D               2456              MOVE.B  FOURTH_3, D2
00002C86                          2457  
00002C86  4EB9 00003264           2458              JSR     LOAD_EA
00002C8C  4EB9 000033C8           2459              JSR     LOAD_COMMA_SPACE
00002C92                          2460              
00002C92  163C 0000               2461              MOVE.B  #%000, D3
00002C96  1438 173A               2462              MOVE.B  FIRST_3, D2
00002C9A                          2463              
00002C9A  4EB9 00003264           2464              JSR     LOAD_EA
00002CA0  4EB9 000033C6           2465              JSR     LOAD_NEW_LINE
00002CA6  4E75                    2466              RTS
00002CA8                          2467              
00002CA8  163C 0000               2468  DIR_1       MOVE.B  #%000, D3
00002CAC  1438 173A               2469              MOVE.B  FIRST_3, D2
00002CB0                          2470              
00002CB0  4EB9 00003264           2471              JSR     LOAD_EA
00002CB6  4EB9 000033C8           2472              JSR     LOAD_COMMA_SPACE
00002CBC                          2473              
00002CBC  4281                    2474              CLR.L   D1
00002CBE  1238 173B               2475              MOVE.B  SECOND_3, D1
00002CC2  0201 0003               2476              ANDI.B  #%011, D1
00002CC6                          2477      
00002CC6  367C 2CE2               2478              MOVEA.W #OR_BACK2, A3
00002CCA  0C01 0000               2479              CMPI.B  #%00, D1
00002CCE  6700 0638               2480              BEQ     SIZE_B
00002CD2  0C01 0001               2481              CMPI.B  #%01, D1
00002CD6  6700 0638               2482              BEQ     SIZE_W
00002CDA  0C01 0002               2483              CMPI.B  #%10, D1
00002CDE  6700 0638               2484              BEQ     SIZE_L
00002CE2                          2485              
00002CE2  1638 173C               2486  OR_BACK2    MOVE.B  THIRD_3, D3
00002CE6  1438 173D               2487              MOVE.B  FOURTH_3, D2
00002CEA                          2488  
00002CEA  4EB9 00003264           2489              JSR     LOAD_EA
00002CF0  4EB9 000033C6           2490              JSR     LOAD_NEW_LINE
00002CF6  4E75                    2491              RTS    
00002CF8                          2492              
00002CF8  367C 2D1A               2493  DIVS        MOVEA.W #DIVS_BACK, A3
00002CFC  0C38 0000 173D          2494              CMPI.B  #%000, FOURTH_3
00002D02  6700 060C               2495              BEQ     SIZE_W
00002D06  0C38 0001 173D          2496              CMPI.B  #%001, FOURTH_3
00002D0C  6700 076A               2497              BEQ     INVALID
00002D10  0C38 0004 173D          2498              CMPI.B  #%100, FOURTH_3
00002D16  6700 05F8               2499              BEQ     SIZE_W
00002D1A                          2500              
00002D1A  1638 173C               2501  DIVS_BACK   MOVE.B  THIRD_3, D3
00002D1E  1438 173D               2502              MOVE.B  FOURTH_3, D2
00002D22                          2503  
00002D22  4EB9 00003264           2504              JSR     LOAD_EA
00002D28  4EB9 000033C8           2505              JSR     LOAD_COMMA_SPACE
00002D2E                          2506  
00002D2E  163C 0000               2507              MOVE.B  #%000, D3
00002D32  1438 173A               2508              MOVE.B  FIRST_3, D2
00002D36                          2509  
00002D36  4EB9 00003264           2510              JSR     LOAD_EA
00002D3C  4EB9 000033C6           2511              JSR     LOAD_NEW_LINE
00002D42  4E75                    2512              RTS
00002D44                          2513  
00002D44                          2514  
00002D44                          2515  LOAD_0101:
00002D44  4283                    2516              CLR.L   D3
00002D46  4282                    2517              CLR.L   D2
00002D48  267C 00000000           2518              MOVEA.L #0, A3
00002D4E                          2519  
00002D4E  0C38 0007 173A          2520              CMPI.B  #%111, FIRST_3
00002D54  6F00 0008               2521              BLE     MYBE_SUBQ1
00002D58  4EF9 00003478           2522              JMP     INVALID
00002D5E                          2523              
00002D5E  0C38 0003 173B          2524  MYBE_SUBQ1  CMPI.B  #%011, SECOND_3
00002D64  6E00 0008               2525              BGT     MYBE_SUBQ2
00002D68  4EF9 00003478           2526              JMP     INVALID
00002D6E                          2527  
00002D6E  0C38 0007 173B          2528  MYBE_SUBQ2  CMPI.B  #%111, SECOND_3
00002D74  6D00 0008               2529              BLT     SUBQ
00002D78  4EF9 00003478           2530              JMP     INVALID
00002D7E                          2531  
00002D7E  5238 173A               2532  SUBQ        ADDI.B  #%1, FIRST_3
00002D82  1838 173A               2533              MOVE.B  FIRST_3, D4
00002D86                          2534              
00002D86  347C 2D90               2535              MOVEA.W #SUBQ_SAVED, A2
00002D8A  4EF9 00003392           2536              JMP     LOAD_IMMDTE
00002D90                          2537              
00002D90  4EB9 000033C8           2538  SUBQ_SAVED  JSR     LOAD_COMMA_SPACE
00002D96                          2539  
00002D96  367C 2DB8               2540              MOVEA.W #SUBQ_BACK, A3
00002D9A  0C38 0004 173B          2541              CMPI.B  #%100, SECOND_3
00002DA0  6700 0566               2542              BEQ     SIZE_B
00002DA4  0C38 0005 173B          2543              CMPI.B  #%101, SECOND_3
00002DAA  6700 0564               2544              BEQ     SIZE_W
00002DAE  0C38 0006 173B          2545              CMPI.B  #%110, SECOND_3
00002DB4  6700 0562               2546              BEQ     SIZE_L
00002DB8                          2547              
00002DB8  1638 173C               2548  SUBQ_BACK   MOVE.B  THIRD_3, D3
00002DBC  1438 173D               2549              MOVE.B  FOURTH_3, D2
00002DC0                          2550  
00002DC0  4EB9 00003264           2551              JSR     LOAD_EA
00002DC6  4EB9 000033C6           2552              JSR     LOAD_NEW_LINE
00002DCC  4E75                    2553              RTS
00002DCE                          2554  
00002DCE                          2555  LOAD_0100:
00002DCE  4283                    2556              CLR.L   D3
00002DD0  4282                    2557              CLR.L   D2
00002DD2  267C 00000000           2558              MOVEA.L #0, A3
00002DD8                          2559  
00002DD8  0C38 0002 173A          2560              CMPI.B  #%010, FIRST_3
00002DDE  6700 0006               2561              BEQ     MYBE_NEG
00002DE2  6600 000C               2562              BNE     NOT_NEG
00002DE6  0C38 0003 173B          2563  MYBE_NEG    CMPI.B  #%011, SECOND_3
00002DEC  6D00 008E               2564              BLT     NEG
00002DF0                          2565  
00002DF0  0C38 0007 173A          2566  NOT_NEG     CMPI.B  #%111, FIRST_3
00002DF6  6700 0006               2567              BEQ     MYBE_RTS1
00002DFA  6600 0032               2568              BNE     NOT_RTS
00002DFE  0C38 0001 173B          2569  MYBE_RTS1   CMPI.B  #%001, SECOND_3
00002E04  6700 0006               2570              BEQ     MYBE_RTS2
00002E08  6600 0024               2571              BNE     NOT_RTS
00002E0C  0C38 0006 173C          2572  MYBE_RTS2   CMPI.B  #%110, THIRD_3
00002E12  6700 0006               2573              BEQ     MYBE_RTS3
00002E16  6600 0016               2574              BNE     NOT_RTS
00002E1A  0C38 0005 173D          2575  MYBE_RTS3   CMPI.B  #%101, FOURTH_3
00002E20  6700 0092               2576              BEQ     RTS
00002E24  0C38 0001 173D          2577              CMPI.B  #%001, FOURTH_3 
00002E2A  6700 0088               2578              BEQ     RTS * It's actually NOP but it's the same shit in EA perspective
00002E2E                          2579              
00002E2E  0C38 0007 173A          2580  NOT_RTS     CMPI.B  #%111, FIRST_3
00002E34  6700 0006               2581              BEQ     MYBE_JSR
00002E38  6600 000C               2582              BNE     NOT_JSR
00002E3C  0C38 0002 173B          2583  MYBE_JSR    CMPI.B  #%010, SECOND_3
00002E42  6700 0078               2584              BEQ     JSR
00002E46                          2585  
00002E46  4286                    2586  NOT_JSR     CLR.L   D6
00002E48  1C38 173A               2587              MOVE.B  FIRST_3, D6
00002E4C  0206 0005               2588              ANDI.B  #%101, D6 * Making %1X0 -> %100
00002E50  0C06 0004               2589              CMPI.B  #%100, D6
00002E54  6700 0006               2590              BEQ     MYBE_MOVEM
00002E58  6600 0012               2591              BNE     NOT_MOVEM
00002E5C                          2592              
00002E5C  1C38 173B               2593  MYBE_MOVEM  MOVE.B  SECOND_3, D6
00002E60  0206 0006               2594              ANDI.B  #%110, D6
00002E64  0C06 0002               2595              CMPI.B  #%010, D6
00002E68  6700 0080               2596              BEQ     MOVEM
00002E6C                          2597              
00002E6C  0C38 0007 173B          2598  NOT_MOVEM   CMPI.B  #%111, SECOND_3
00002E72  6700 0084               2599              BEQ     LEA
00002E76                          2600              
00002E76  4EF9 00003478           2601              JMP     INVALID
00002E7C                          2602  
00002E7C                          2603  NEG:
00002E7C  367C 2E9E               2604              MOVEA.W #NEG_BACK, A3
00002E80  0C38 0000 173B          2605              CMPI.B  #%000, SECOND_3
00002E86  6700 0480               2606              BEQ     SIZE_B
00002E8A  0C38 0001 173B          2607              CMPI.B  #%001, SECOND_3
00002E90  6700 047E               2608              BEQ     SIZE_W
00002E94  0C38 0002 173B          2609              CMPI.B  #%010, SECOND_3
00002E9A  6700 047C               2610              BEQ     SIZE_L
00002E9E                          2611              
00002E9E  1638 173C               2612  NEG_BACK    MOVE.B  THIRD_3, D3
00002EA2  1438 173D               2613              MOVE.B  FOURTH_3, D2
00002EA6                          2614  
00002EA6  4EB9 00003264           2615              JSR     LOAD_EA
00002EAC  4EB9 000033C6           2616              JSR     LOAD_NEW_LINE
00002EB2  4E75                    2617              RTS
00002EB4                          2618              
00002EB4                          2619  RTS:
00002EB4  4EB9 000033C6           2620              JSR     LOAD_NEW_LINE
00002EBA  4E75                    2621              RTS
00002EBC                          2622  
00002EBC                          2623  JSR:
00002EBC  367C 2ED4               2624              MOVEA.W #JSR_BACK, A3
00002EC0  0C38 0000 173D          2625              CMPI.B  #%000, FOURTH_3
00002EC6  6700 0448               2626              BEQ     SIZE_W
00002ECA  0C38 0001 173D          2627              CMPI.B  #%001, FOURTH_3
00002ED0  6700 0446               2628              BEQ     SIZE_L
00002ED4                          2629              
00002ED4  1638 173C               2630  JSR_BACK    MOVE.B  THIRD_3, D3
00002ED8  1438 173D               2631              MOVE.B  FOURTH_3, D2
00002EDC                          2632              
00002EDC  4EB9 00003264           2633              JSR     LOAD_EA
00002EE2  4EB9 000033C6           2634              JSR     LOAD_NEW_LINE
00002EE8  4E75                    2635              RTS
00002EEA                          2636  
00002EEA                          2637  MOVEM:
00002EEA  4EB9 00002F44           2638              JSR     FUK_MOVEM
00002EF0  4EB9 000033C6           2639              JSR     LOAD_NEW_LINE
00002EF6  4E75                    2640              RTS
00002EF8                          2641      
00002EF8                          2642  LEA:
00002EF8  367C 2F1A               2643              MOVEA.W #LEA_BACK, A3
00002EFC  0C38 0000 173D          2644              CMPI.B  #%000, FOURTH_3
00002F02  6700 040C               2645              BEQ     SIZE_W
00002F06  0C38 0001 173D          2646              CMPI.B  #%001, FOURTH_3
00002F0C  6700 040A               2647              BEQ     SIZE_L
00002F10  0C38 0004 173D          2648              CMPI.B  #%100, FOURTH_3
00002F16  6700 0560               2649              BEQ     INVALID 
00002F1A                          2650              
00002F1A  1638 173C               2651  LEA_BACK    MOVE.B  THIRD_3, D3
00002F1E  1438 173D               2652              MOVE.B  FOURTH_3, D2
00002F22                          2653              
00002F22  4EB9 00003264           2654              JSR     LOAD_EA
00002F28  4EB9 000033C8           2655              JSR     LOAD_COMMA_SPACE
00002F2E                          2656              
00002F2E  163C 0001               2657              MOVE.B  #%001, D3
00002F32  1438 173A               2658              MOVE.B  FIRST_3, D2
00002F36                          2659              
00002F36  4EB9 00003264           2660              JSR     LOAD_EA
00002F3C  4EB9 000033C6           2661              JSR     LOAD_NEW_LINE
00002F42  4E75                    2662              RTS 
00002F44                          2663  
00002F44                          2664  FUK_MOVEM:  * Functional Utilization of Knowledge in MOVEM
00002F44  4EB9 00002F4C           2665              JSR     MOVEM_PARSE
00002F4A  4E75                    2666              RTS
00002F4C                          2667  
00002F4C                          2668  MOVEM_PARSE:
00002F4C  381D                    2669              MOVE.W  (A5)+, D4 * D4 has $00FF
00002F4E                          2670              
00002F4E  11FC 00FF 28EA          2671              MOVE.B  #$FF, X_COUNTER * start from -1
00002F54  11FC 00FF 28EB          2672              MOVE.B  #$FF, Y_COUNTER * start from -1
00002F5A  11FC 0000 28EC          2673              MOVE.B  #0, FIRST_X
00002F60  11FC 0000 28ED          2674              MOVE.B  #0, FIRST_Y
00002F66                          2675              
00002F66  0C38 0004 173C          2676              CMPI.B  #%100, THIRD_3
00002F6C  6600 0006               2677              BNE     A_TO_D
00002F70  6700 0014               2678              BEQ     D_TO_A
00002F74                          2679  
00002F74  11FC 0001 28E8          2680  A_TO_D      MOVE.B  #%001, X * X = A
00002F7A  11FC 0000 28E9          2681              MOVE.B  #%000, Y * Y = D
00002F80  4EF9 00002F98           2682              JMP     NEXT_STEP
00002F86                          2683              
00002F86  11FC 0000 28E8          2684  D_TO_A      MOVE.B  #%000, X * X = D
00002F8C  11FC 0001 28E9          2685              MOVE.B  #%001, Y * Y = A
00002F92  4EF9 00002F98           2686              JMP     NEXT_STEP
00002F98                          2687  
00002F98  E35C                    2688  NEXT_STEP   ROL.W   #1, D4
00002F9A  3A04                    2689              MOVE.W  D4, D5
00002F9C  0245 0001               2690              ANDI.W  #$1, D5
00002FA0                          2691              
00002FA0  0C38 0007 28EA          2692              CMPI.B  #7, X_COUNTER
00002FA6  6C00 0010               2693              BGE     ADD_Y
00002FAA  6D00 0002               2694              BLT     ADD_X
00002FAE                          2695              
00002FAE  5238 28EA               2696  ADD_X       ADDI.B  #1, X_COUNTER
00002FB2  4EF9 00002FC8           2697              JMP     KEEP_GOING0
00002FB8                          2698  
00002FB8  5238 28EB               2699  ADD_Y       ADDI.B  #1, Y_COUNTER
00002FBC  11FC 0008 28EA          2700              MOVE.B  #8, X_COUNTER
00002FC2  4EF9 00002FC8           2701              JMP     KEEP_GOING0
00002FC8                          2702              
00002FC8  0C45 0001               2703  KEEP_GOING0 CMPI.W  #$1, D5
00002FCC  6700 0006               2704              BEQ     BIT_ON
00002FD0  6600 009A               2705              BNE     KEEP_GOING
00002FD4                          2706              
00002FD4  0C38 0008 28EA          2707  BIT_ON      CMPI.B  #8, X_COUNTER
00002FDA  6600 0006               2708              BNE     ITS_X
00002FDE  6700 0036               2709              BEQ     MYBE_Y
00002FE2                          2710              
00002FE2  1638 28E8               2711  ITS_X       MOVE.B  X, D3 * LOAD[XX_COUNTER]
00002FE6  1438 28EA               2712              MOVE.B  X_COUNTER, D2
00002FEA  4EB9 00003264           2713              JSR     LOAD_EA
00002FF0  0C38 0000 28EC          2714              CMPI.B  #0, FIRST_X
00002FF6  6700 0006               2715              BEQ     FST_X
00002FFA  6600 0012               2716              BNE     SND_X
00002FFE                          2717  
00002FFE  18FC 002D               2718  FST_X       MOVE.B  #$2D, (A4)+ * LOAD '-'
00003002  11FC 0001 28EC          2719              MOVE.B  #1, FIRST_X * FIRST_X = 1
00003008  4EF9 0000306C           2720              JMP     KEEP_GOING
0000300E                          2721              
0000300E  554C                    2722  SND_X       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
00003010  4EF9 0000306C           2723              JMP     KEEP_GOING
00003016                          2724  
00003016  0C38 0008 28EB          2725  MYBE_Y      CMPI.B  #8, Y_COUNTER
0000301C  6600 0006               2726              BNE     ITS_Y
00003020  6700 004A               2727              BEQ     KEEP_GOING
00003024                          2728  
00003024  0C38 0000 28ED          2729  ITS_Y       CMPI.B  #0, FIRST_Y
0000302A  6700 001E               2730              BEQ     FST_Y1
0000302E  1638 28E9               2731  ITS_Y_BACK  MOVE.B  Y, D3 * LOAD[YY_COUNTER]
00003032  1438 28EB               2732              MOVE.B  Y_COUNTER, D2
00003036  4EB9 00003264           2733              JSR     LOAD_EA
0000303C  0C38 0000 28ED          2734              CMPI.B  #0, FIRST_Y
00003042  6700 0010               2735              BEQ     FST_Y2
00003046  6600 001C               2736              BNE     SND_Y
0000304A                          2737  
0000304A  544C                    2738  FST_Y1      ADDA.W  #2, A4 * push G_BUFFER pointer by 2
0000304C  18FC 002F               2739              MOVE.B  #$2F, (A4)+ * LOAD '/'
00003050  4EF8 302E               2740              JMP     ITS_Y_BACK
00003054                          2741  
00003054  18FC 002D               2742  FST_Y2      MOVE.B  #$2D, (A4)+ * LOAD '-'
00003058  11FC 0001 28ED          2743              MOVE.B  #1, FIRST_Y * FIRST_Y = 1
0000305E  4EF9 0000306C           2744              JMP     KEEP_GOING
00003064                          2745  
00003064  554C                    2746  SND_Y       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
00003066  4EF9 0000306C           2747              JMP     KEEP_GOING
0000306C                          2748  
0000306C  0C38 0008 28EB          2749  KEEP_GOING  CMPI.B  #8, Y_COUNTER
00003072  6600 FF24               2750              BNE     NEXT_STEP
00003076                          2751              
00003076  544C                    2752              ADDA.W  #2, A4 * push G_BUFFER pointer by 2
00003078  4E75                    2753              RTS
0000307A                          2754  
0000307A                          2755  LOAD_0000:
0000307A  4283                    2756              CLR.L   D3
0000307C  4282                    2757              CLR.L   D2
0000307E  267C 00000000           2758              MOVEA.L #0, A3
00003084                          2759  
00003084  0C38 0000 173A          2760              CMPI.B  #%000, FIRST_3
0000308A  6700 0006               2761              BEQ     MYBE_ORI
0000308E  6600 000C               2762              BNE     NOT_ORI
00003092  0C38 0003 173B          2763  MYBE_ORI    CMPI.B  #%011, SECOND_3
00003098  6D00 0042               2764              BLT     ORI_CMPI            
0000309C                          2765  
0000309C  0C38 0006 173A          2766  NOT_ORI     CMPI.B  #%110, FIRST_3
000030A2  6700 0006               2767              BEQ     MYBE_CMPI
000030A6  6600 000C               2768              BNE     NOT_CMPI
000030AA  0C38 0003 173B          2769  MYBE_CMPI   CMPI.B  #%011, SECOND_3
000030B0  6D00 002A               2770              BLT     ORI_CMPI
000030B4                          2771              
000030B4  0C38 0004 173A          2772  NOT_CMPI    CMPI.B  #%100, FIRST_3
000030BA  6700 0006               2773              BEQ     MYBE_BCLR
000030BE  6600 000C               2774              BNE     NOT_BCLR
000030C2  0C38 0002 173B          2775  MYBE_BCLR   CMPI.B  #%010, SECOND_3
000030C8  6700 0080               2776              BEQ     BCLR
000030CC                          2777  
000030CC  0C38 0006 173B          2778  NOT_BCLR    CMPI.B  #%110, SECOND_3
000030D2  6700 00E0               2779              BEQ     DYNMC_BCLR
000030D6                          2780              
000030D6  4EF9 00003478           2781              JMP     INVALID
000030DC                          2782              
000030DC  367C 30FE               2783  ORI_CMPI    MOVEA.W #BACK, A3
000030E0  0C38 0000 173B          2784              CMPI.B  #%000, SECOND_3
000030E6  6700 0220               2785              BEQ     SIZE_B
000030EA  0C38 0001 173B          2786              CMPI.B  #%001, SECOND_3
000030F0  6700 021E               2787              BEQ     SIZE_W
000030F4  0C38 0002 173B          2788              CMPI.B  #%010, SECOND_3
000030FA  6700 021C               2789              BEQ     SIZE_L
000030FE                          2790  
000030FE  163C 0007               2791  BACK        MOVE.B  #%111, D3
00003102  143C 0004               2792              MOVE.B  #%100, D2
00003106                          2793              
00003106  4EB9 00003264           2794              JSR     LOAD_EA
0000310C  4EB9 000033C8           2795              JSR     LOAD_COMMA_SPACE
00003112                          2796              
00003112  367C 3134               2797              MOVEA.W #BACK2, A3   
00003116  0C38 0000 173D          2798              CMPI.B  #%000, FOURTH_3
0000311C  6700 01F2               2799              BEQ     SIZE_W
00003120  0C38 0001 173D          2800              CMPI.B  #%001, FOURTH_3
00003126  6700 01F0               2801              BEQ     SIZE_L
0000312A  0C38 0004 173D          2802              CMPI.B  #%100, FOURTH_3 
00003130  6700 0346               2803              BEQ     INVALID 
00003134                          2804  
00003134  1638 173C               2805  BACK2       MOVE.B  THIRD_3, D3
00003138  1438 173D               2806              MOVE.B  FOURTH_3, D2
0000313C                          2807          
0000313C  4EB9 00003264           2808              JSR     LOAD_EA
00003142  4EB9 000033C6           2809              JSR     LOAD_NEW_LINE
00003148  4E75                    2810              RTS
0000314A                          2811  
0000314A  4285                    2812  BCLR        CLR.L   D5
0000314C  4284                    2813              CLR.L   D4
0000314E  247C 00000000           2814              MOVEA.L #0, A2
00003154                          2815  
00003154  3A0E                    2816              MOVE.W  A6, D5
00003156  9A4D                    2817              SUB.W   A5, D5
00003158  0C45 0002               2818              CMPI.W  #$2, D5
0000315C  6D00 031A               2819              BLT     INVALID
00003160                          2820  
00003160  381D                    2821              MOVE.W  (A5)+, D4
00003162  4284                    2822              CLR.L   D4
00003164  381D                    2823              MOVE.W  (A5)+, D4
00003166  0244 00FF               2824              ANDI.W  #$00FF, D4
0000316A  247C 00003176           2825              MOVEA.L #BACK4, A2
00003170  4EF9 00003392           2826              JMP     LOAD_IMMDTE
00003176                          2827              
00003176  4EB9 000033C8           2828  BACK4       JSR     LOAD_COMMA_SPACE
0000317C                          2829              
0000317C  367C 319E               2830              MOVEA.W #BACK3, A3
00003180  0C38 0000 173D          2831              CMPI.B  #%000, FOURTH_3
00003186  6700 0188               2832              BEQ     SIZE_W
0000318A  0C38 0001 173D          2833              CMPI.B  #%001, FOURTH_3
00003190  6700 0186               2834              BEQ     SIZE_L
00003194  0C38 0004 173D          2835              CMPI.B  #%100, FOURTH_3 
0000319A  6700 02DC               2836              BEQ     INVALID 
0000319E                          2837  
0000319E  1638 173C               2838  BACK3       MOVE.B  THIRD_3, D3
000031A2  1438 173D               2839              MOVE.B  FOURTH_3, D2
000031A6                          2840  
000031A6  4EB9 00003264           2841              JSR     LOAD_EA
000031AC  4EB9 000033C6           2842              JSR     LOAD_NEW_LINE
000031B2                          2843  
000031B2  4E75                    2844              RTS
000031B4                          2845  
000031B4  163C 0000               2846  DYNMC_BCLR  MOVE.B  #%000, D3
000031B8  1438 173A               2847              MOVE.B  FIRST_3, D2
000031BC                          2848              
000031BC  4EB9 00003264           2849              JSR     LOAD_EA
000031C2  4EB9 000033C8           2850              JSR     LOAD_COMMA_SPACE
000031C8                          2851  
000031C8  367C 31EA               2852              MOVEA.W #BACK5, A3
000031CC  0C38 0000 173D          2853              CMPI.B  #%000, FOURTH_3
000031D2  6700 013C               2854              BEQ     SIZE_W
000031D6  0C38 0001 173D          2855              CMPI.B  #%001, FOURTH_3
000031DC  6700 013A               2856              BEQ     SIZE_L
000031E0  0C38 0004 173D          2857              CMPI.B  #%100, FOURTH_3 
000031E6  6700 0290               2858              BEQ     INVALID 
000031EA                          2859              
000031EA  1638 173C               2860  BACK5       MOVE.B  THIRD_3, D3
000031EE  1438 173D               2861              MOVE.B  FOURTH_3, D2
000031F2                          2862              
000031F2  4EB9 00003264           2863              JSR     LOAD_EA
000031F8  4EB9 000033C6           2864              JSR     LOAD_NEW_LINE
000031FE                          2865              
000031FE  4E75                    2866              RTS
00003200                          2867  
00003200                          2868  LOAD_00XX:
00003200  4283                    2869          CLR.L   D3
00003202  4282                    2870          CLR.L   D2
00003204  267C 00000000           2871          MOVEA.L #0, A3
0000320A                          2872          
0000320A  367C 3222               2873          MOVEA.W #GOO, A3
0000320E  0C38 0003 1739          2874          CMPI.B  #%0011, MNEMONIC
00003214  6700 00FA               2875          BEQ     SIZE_W
00003218  0C38 0002 1739          2876          CMPI.B  #%0010, MNEMONIC
0000321E  6700 00F8               2877          BEQ     SIZE_L
00003222                          2878  
00003222  1638 173C               2879  GOO     MOVE.B  THIRD_3, D3
00003226  1438 173D               2880          MOVE.B  FOURTH_3, D2
0000322A                          2881      
0000322A  4EB9 00003264           2882          JSR     LOAD_EA
00003230  4EB9 000033C8           2883          JSR     LOAD_COMMA_SPACE
00003236                          2884      
00003236  367C 324E               2885          MOVEA.W #GOO2, A3
0000323A  0C38 0000 173A          2886          CMPI.B  #%000, FIRST_3
00003240  6700 00CE               2887          BEQ     SIZE_W
00003244  0C38 0001 173A          2888          CMPI.B  #%001, FIRST_3
0000324A  6700 00CC               2889          BEQ     SIZE_L
0000324E                          2890      
0000324E  1638 173B               2891  GOO2    MOVE.B  SECOND_3, D3
00003252  1438 173A               2892          MOVE.B  FIRST_3, D2
00003256                          2893              
00003256  4EB9 00003264           2894          JSR     LOAD_EA
0000325C  4EB9 000033C6           2895          JSR     LOAD_NEW_LINE
00003262                          2896      
00003262  4E75                    2897          RTS
00003264                          2898  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003264                          2899  
00003264                          2900  
00003264                          2901  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003264                          2902  
00003264                          2903  LOAD_EA:
00003264  347C 3274               2904          MOVEA.W #SAVED, A2 * remember to come back!
00003268                          2905  
00003268  0C43 0007               2906          CMPI    #%111, D3
0000326C  6D00 0008               2907          BLT     LOAD_LT_111
00003270  6C00 0032               2908          BGE     LOAD_GE_111
00003274                          2909      
00003274  4E75                    2910  SAVED   RTS
00003276                          2911  
00003276                          2912  LOAD_LT_111:
00003276  0C43 0000               2913      CMPI    #%000, D3 * e.g. D3
0000327A  6700 00A4               2914      BEQ     LOAD_DATA_REGISTER
0000327E  0C43 0001               2915      CMPI    #%001, D3 * e.g. A3
00003282  6700 00AE               2916      BEQ     LOAD_ADDR_REGISTER
00003286  0C43 0002               2917      CMPI    #%010, D3 * e.g. (A3)
0000328A  6700 00B8               2918      BEQ     LOAD_ADDRESS
0000328E  0C43 0003               2919      CMPI    #%011, D3 * e.g. (A3)+
00003292  6700 00C2               2920      BEQ     LOAD_ADDRESS_W_POST_INC
00003296  0C43 0004               2921      CMPI    #%100, D3 * e.g. -(A3)
0000329A  6700 00C6               2922      BEQ     LOAD_ADDRESS_W_PRE_DEC
0000329E                          2923      
0000329E  4EF9 00003478           2924      JMP     INVALID
000032A4                          2925      
000032A4                          2926  LOAD_GE_111:
000032A4  4285                    2927              CLR.L   D5
000032A6  4284                    2928              CLR.L   D4
000032A8                          2929  
000032A8  3A0E                    2930              MOVE.W  A6, D5
000032AA  9A4D                    2931              SUB.W   A5, D5
000032AC  BA78 28E6               2932              CMP.W   TRAILING_SIZE, D5
000032B0  6D00 01C6               2933              BLT     INVALID
000032B4                          2934  
000032B4  0C78 0001 28E6          2935              CMPI.W  #$1, TRAILING_SIZE
000032BA  6700 0016               2936              BEQ     CHUMP_BYTE
000032BE  0C78 0002 28E6          2937              CMPI.W  #$2, TRAILING_SIZE
000032C4  6700 0014               2938              BEQ     CHUMP_WORD
000032C8  0C78 0004 28E6          2939              CMPI.W  #$4, TRAILING_SIZE
000032CE  6700 0012               2940              BEQ     CHUMP_LONG
000032D2                          2941  
000032D2  381D                    2942  CHUMP_BYTE  MOVE.W  (A5)+, D4 * Minimum 4 hex (e.g. MOVE.B #1, $2 = XXXX 0001 0002)
000032D4  4EF9 000032EA           2943              JMP     GO
000032DA                          2944  
000032DA  381D                    2945  CHUMP_WORD  MOVE.W  (A5)+, D4
000032DC  4EF9 000032EA           2946              JMP     GO
000032E2                          2947              
000032E2  281D                    2948  CHUMP_LONG  MOVE.L  (A5)+, D4
000032E4  4EF9 000032EA           2949              JMP     GO
000032EA                          2950  
000032EA  0C42 0000               2951  GO          CMPI    #%000, D2
000032EE  6700 007E               2952              BEQ     LOAD_ABS_SHORT
000032F2  0C42 0001               2953              CMPI    #%001, D2
000032F6  6700 0088               2954              BEQ     LOAD_ABS_LONG
000032FA  0C42 0004               2955              CMPI    #%100, D2
000032FE  6700 0092               2956              BEQ     LOAD_IMMDTE
00003302                          2957      
00003302  4EF9 00003478           2958              JMP     INVALID
00003308                          2959  TRAILING_HELPER:            
00003308  31FC 0002 28E6          2960  SIZE_B  MOVE.W  #$2, TRAILING_SIZE
0000330E  4ED3                    2961          JMP     (A3)
00003310                          2962  
00003310  31FC 0002 28E6          2963  SIZE_W  MOVE.W  #$2, TRAILING_SIZE
00003316  4ED3                    2964          JMP     (A3)
00003318                          2965          
00003318  31FC 0004 28E6          2966  SIZE_L  MOVE.W  #$4, TRAILING_SIZE
0000331E  4ED3                    2967          JMP     (A3)
00003320                          2968  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003320                          2969  
00003320                          2970  
00003320                          2971  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003320                          2972  
00003320                          2973  LOAD_DATA_REGISTER:
00003320  4280                    2974      CLR.L   D0
00003322                          2975      
00003322  4EB9 000033E0           2976      JSR     LOAD_D
00003328  1002                    2977      MOVE.B  D2, D0
0000332A  4EB9 00003454           2978      JSR     LOAD_NUM
00003330  4ED2                    2979      JMP     (A2)
00003332                          2980  
00003332                          2981  LOAD_ADDR_REGISTER:
00003332  4280                    2982      CLR.L   D0
00003334                          2983  
00003334  4EB9 000033EE           2984      JSR     LOAD_A
0000333A  1002                    2985      MOVE.B  D2, D0
0000333C  4EB9 00003454           2986      JSR     LOAD_NUM
00003342  4ED2                    2987      JMP     (A2)
00003344                          2988  
00003344                          2989  LOAD_ADDRESS:
00003344  4EB9 000033FC           2990      JSR     LOAD_PTHSIS_OPEN
0000334A  4EB8 3332               2991      JSR     LOAD_ADDR_REGISTER
0000334E  4EB9 0000340A           2992      JSR     LOAD_PTHSIS_CLSD
00003354  4ED2                    2993      JMP     (A2)
00003356                          2994  
00003356                          2995  LOAD_ADDRESS_W_POST_INC:
00003356  4EB8 3344               2996      JSR     LOAD_ADDRESS
0000335A  4EB9 00003434           2997      JSR     LOAD_PLUS_SIGN
00003360  4ED2                    2998      JMP     (A2)
00003362                          2999  
00003362                          3000  LOAD_ADDRESS_W_PRE_DEC:
00003362  4EB9 00003442           3001      JSR     LOAD_MINUS_SIGN
00003368  4EB8 3344               3002      JSR     LOAD_ADDRESS
0000336C  4ED2                    3003      JMP     (A2)
0000336E                          3004  
0000336E                          3005  LOAD_ABS_SHORT:
0000336E  4280                    3006      CLR.L   D0
00003370                          3007  
00003370  4EB9 00003418           3008      JSR     LOAD_HEX_SIGN
00003376  3004                    3009      MOVE.W  D4, D0
00003378  4EB9 0000339C           3010      JSR     LOAD_BYTES
0000337E  4ED2                    3011      JMP     (A2)
00003380                          3012  
00003380                          3013  LOAD_ABS_LONG:
00003380  4280                    3014      CLR.L   D0
00003382                          3015  
00003382  4EB9 00003418           3016      JSR     LOAD_HEX_SIGN
00003388  2004                    3017      MOVE.L  D4, D0
0000338A  4EB9 0000339C           3018      JSR     LOAD_BYTES
00003390  4ED2                    3019      JMP     (A2)
00003392                          3020  
00003392                          3021  LOAD_IMMDTE:
00003392  4EB9 00003426           3022      JSR     LOAD_IMMDTE_VALU
00003398  4EF8 3380               3023      JMP     LOAD_ABS_LONG
0000339C                          3024  
0000339C                          3025  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000339C                          3026  
0000339C                          3027  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000339C                          3028  
0000339C                          3029  LOAD_BYTES:
0000339C  4285                    3030          CLR.L   D5
0000339E  4281                    3031          CLR.L   D1
000033A0                          3032  
000033A0  2200                    3033          MOVE.L  D0, D1
000033A2  1A3C 0008               3034          MOVE.B  #8, D5
000033A6  0C45 0000               3035  LOOP    CMPI    #0, D5
000033AA  6E00 0004               3036          BGT     ROTATE
000033AE  4E75                    3037          RTS
000033B0                          3038      
000033B0  E999                    3039  ROTATE  ROL.L   #$04, D1
000033B2  1001                    3040          MOVE.B  D1, D0
000033B4  0280 0000000F           3041          ANDI.L  #$0000000F, D0
000033BA  4EB9 00003454           3042          JSR     LOAD_NUM
000033C0  5345                    3043          SUBI    #1, D5
000033C2  4EF8 33A6               3044          JMP     LOOP        
000033C6                          3045  
000033C6                          3046  LOAD_NEW_LINE:
000033C6                          3047      ;CLR.L   D0
000033C6                          3048  
000033C6                          3049      ;MOVE.B  CR, D0
000033C6                          3050      ;JSR     LOAD_THIS_SHIT
000033C6                          3051      ;MOVE.B  LF, D0
000033C6                          3052      ;JSR     LOAD_THIS_SHIT
000033C6  4E75                    3053      RTS
000033C8                          3054  
000033C8                          3055  LOAD_COMMA_SPACE:
000033C8  4280                    3056      CLR.L   D0
000033CA                          3057  
000033CA  1038 28E4               3058      MOVE.B  COMMA, D0
000033CE  4EB9 00003450           3059      JSR     LOAD_THIS_SHIT
000033D4  1038 28E5               3060      MOVE.B  SPACE, D0
000033D8  4EB9 00003450           3061      JSR     LOAD_THIS_SHIT
000033DE                          3062      
000033DE  4E75                    3063      RTS
000033E0                          3064  
000033E0                          3065  LOAD_D:
000033E0  4280                    3066      CLR.L   D0
000033E2                          3067  
000033E2  1038 28DD               3068      MOVE.B  DATA, D0
000033E6  4EB9 00003450           3069      JSR     LOAD_THIS_SHIT
000033EC  4E75                    3070      RTS
000033EE                          3071  
000033EE                          3072  LOAD_A:
000033EE  4280                    3073      CLR.L   D0
000033F0                          3074  
000033F0  1038 28DC               3075      MOVE.B  ADDRESS, D0
000033F4  4EB9 00003450           3076      JSR     LOAD_THIS_SHIT
000033FA  4E75                    3077      RTS
000033FC                          3078  
000033FC                          3079  LOAD_PTHSIS_OPEN:
000033FC  4280                    3080      CLR.L   D0
000033FE                          3081  
000033FE  1038 28DE               3082      MOVE.B  PTHSIS_OPEN, D0
00003402  4EB9 00003450           3083      JSR     LOAD_THIS_SHIT
00003408  4E75                    3084      RTS
0000340A                          3085  
0000340A                          3086  LOAD_PTHSIS_CLSD:
0000340A  4280                    3087      CLR.L   D0
0000340C                          3088  
0000340C  1038 28DF               3089      MOVE.B  PTHSIS_CLSD, D0
00003410  4EB9 00003450           3090      JSR     LOAD_THIS_SHIT
00003416  4E75                    3091      RTS
00003418                          3092  
00003418                          3093  LOAD_HEX_SIGN:
00003418  4280                    3094      CLR.L   D0
0000341A                          3095  
0000341A  1038 28E0               3096      MOVE.B  HEX_SIGN, D0
0000341E  4EB9 00003450           3097      JSR     LOAD_THIS_SHIT
00003424  4E75                    3098      RTS
00003426                          3099  
00003426                          3100  LOAD_IMMDTE_VALU:
00003426  4280                    3101      CLR.L   D0
00003428                          3102  
00003428  1038 28E1               3103      MOVE.B  IMMDTE_VALU, D0
0000342C  4EB9 00003450           3104      JSR     LOAD_THIS_SHIT
00003432  4E75                    3105      RTS
00003434                          3106  
00003434                          3107  LOAD_PLUS_SIGN:
00003434  4280                    3108      CLR.L   D0
00003436                          3109  
00003436  1038 28E2               3110      MOVE.B  PLUS_SIGN, D0
0000343A  4EB9 00003450           3111      JSR     LOAD_THIS_SHIT
00003440  4E75                    3112      RTS
00003442                          3113  
00003442                          3114  LOAD_MINUS_SIGN:
00003442  4280                    3115      CLR.L   D0
00003444                          3116  
00003444  1038 28E3               3117      MOVE.B  MINUS_SIGN, D0
00003448  4EB9 00003450           3118      JSR     LOAD_THIS_SHIT
0000344E  4E75                    3119      RTS
00003450                          3120  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003450                          3121  
00003450                          3122  
00003450                          3123  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003450                          3124  LOAD_THIS_SHIT:
00003450  18C0                    3125      MOVE.B  D0, (A4)+
00003452  4E75                    3126      RTS
00003454                          3127  
00003454                          3128  LOAD_NUM:
00003454  0C00 0009               3129      CMPI.B  #$9, D0
00003458  6E00 0006               3130      BGT     GT
0000345C  6F00 000C               3131      BLE     LE
00003460                          3132      
00003460  0600 0037               3133  GT  ADDI.B  #$37, D0 * A~F
00003464  4EF9 00003474           3134      JMP     END
0000346A  0600 0030               3135  LE  ADDI.B  #$30, D0 * 0~9
0000346E  4EF9 00003474           3136      JMP     END
00003474                          3137  
00003474  18C0                    3138  END MOVE.B  D0, (A4)+
00003476  4E75                    3139      RTS
00003478                          3140  
00003478                          3141  INVALID:
00003478  11FC 0000 10A2          3142              MOVE.B  #%0, IS_VALID
0000347E  4EF8 28F8               3143              JMP     EXT
00003482                          3144  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003482                          3145  
00003482                          3146  
00003482                          3147  
00003482                          3148  
00003482                          3149  
00003482                          3150  -------------------- end include --------------------
00003482                          3151      INCLUDE "MOVEM_TEST.x68"                                ;Test program to include
00003482                          3152      
00009000                          3153      ORG $9000
00009000  48A1 007F               3154      MOVEM.W   A1-A7,-(A1)
00009004                          3155  
00009004  48E1 7F00               3156      MOVEM.L   D1-D7,-(A1)
00009008                          3157  
00009008  48A1 0140               3158      MOVEM.W   A1/D7,-(A1)
0000900C                          3159  
0000900C  48E1 0140               3160      MOVEM.L   A1/D7,-(A1)
00009010                          3161  
00009010  4891 FE00               3162      MOVEM.W   A1-A7,(A1)
00009014                          3163  
00009014  48D1 00FE               3164      MOVEM.L   D1-D7,(A1)
00009018                          3165  
00009018  4891 0280               3166      MOVEM.W   A1/D7,(A1)
0000901C                          3167  
0000901C  48D1 0280               3168      MOVEM.L   A1/D7,(A1)
00009020                          3169  
00009020  4C99 FE00               3170      MOVEM.W   (A1)+,A1-A7
00009024                          3171  
00009024  4CD9 00FE               3172      MOVEM.L   (A1)+,D1-D7
00009028                          3173  
00009028  4C99 0280               3174      MOVEM.W   (A1)+,A1/D7
0000902C                          3175  
0000902C  4CD9 0280               3176      MOVEM.L   (A1)+,A1/D7
00009030                          3177  
00009030  4C91 FE00               3178      MOVEM.W   (A1),A1-A7
00009034                          3179  
00009034  4CD1 00FE               3180      MOVEM.L   (A1),D1-D7
00009038                          3181  
00009038  4C91 0280               3182      MOVEM.W   (A1),A1/D7
0000903C                          3183  
0000903C  4CD1 0280               3184      MOVEM.L   (A1),A1/D7
00009040                          3185      
00009040                          3186  -------------------- end include --------------------
00009040                          3187      
00009040                          3188      
Line 3189 WARNING: Origin value is odd (Location counter set to next highest address)
00009040                          3189     END    START                                 ;Last line of program

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA                2BD2
ADDA_BACK           2BF0
ADDRESS             28DC
ADDSTRTOBUFFER      1260
ADD_CHAR_TO_STRING  1338
ADD_X               2FAE
ADD_Y               2FB8
ASCIITOHEX          13E0
ASCIITOHEXREGLIST   1
ASCII_VAL           16F2
ASD_1               29D4
ASD_1_BACK          2A00
ASD_2               2A2C
ASD_2_IMD           2A42
ASD_2_IMD_B         2A68
ASD_2_REG           2A84
A_TO_D              2F74
BACK                30FE
BACK2               3134
BACK3               319E
BACK4               3176
BACK5               31EA
BCLR                314A
BIT_CHECK_EXG       224C
BIT_CHECK_EXT       1D34
BIT_CHECK_MOVEP     1AA6
BIT_CHECK_SUBX      2168
BIT_ON              2FD4
BIT_SIZE_CHECK      22A4
BRA                 2B10
BRA_BYTE            2B3C
BRA_BYTE2           2B62
BRA_BYTE3           2B6E
BRA_WORD            2B76
BRA_WORD_BK         2B92
BRA_WRD_BK2         2BB0
BUFFER_ADD_SUCCESS  125E
BUFFER_LENGTH_EXCEEDED  12A8
BUFFER_POINTER      1256
BUFFER_POINTER_LENGTH  125A
BUFFER_STRING_END   12AE
BYTEREAD            16F1
B_BUFFER            1050
CHARNUM_TO_CONVERT  12E0
CHECK_00XX          2960
CHECK_01XX          296E
CHECK_0XXX          290C
CHECK_1XXX          291C
CHECK_OP_ABCD       2234
CHECK_OP_ADD        22CE
CHECK_OP_ADDA       22D8
CHECK_OP_ADDI       1A06
CHECK_OP_ADDQ       1F2A
CHECK_OP_ADDX       22BA
CHECK_OP_AND        2284
CHECK_OP_ANDI       19DE
CHECK_OP_ANDI_TO_CCR  199E
CHECK_OP_ANDI_TO_SR  19AE
CHECK_OP_ASL        2486
CHECK_OP_ASL_NO_ROT  23AE
CHECK_OP_ASR        2468
CHECK_OP_ASR_NO_ROT  2394
CHECK_OP_BCC        1F94
CHECK_OP_BCS        203A
CHECK_OP_BEQ        1FA8
CHECK_OP_BGE        2054
CHECK_OP_BGT        1F80
CHECK_OP_BHI        1FBC
CHECK_OP_BLS        1FD0
CHECK_OP_BLT        206E
CHECK_OP_BMI        1FE4
CHECK_OP_BNE        1FF8
CHECK_OP_BPL        200C
CHECK_OP_BRA        2020
CHECK_OP_BSR        1F6C
CHECK_OP_BVC        2088
CHECK_OP_CHK        1E16
CHECK_OP_CLR        1CF8
CHECK_OP_CMP        21F2
CHECK_OP_CMPA       21C0
CHECK_OP_CMPI       1AF2
CHECK_OP_CMPM       21AC
CHECK_OP_DBCC       1F02
CHECK_OP_DIVS       20FA
CHECK_OP_DIVU       20D2
CHECK_OP_DYNAMIC_BCHG  1A7E
CHECK_OP_DYNAMIC_BCLR  1B2E
CHECK_OP_DYNAMIC_BSET  1A92
CHECK_OP_DYNAMIC_BTST  1A6A
CHECK_OP_EOR        21D4
CHECK_OP_EORI       1A1A
CHECK_OP_EORI_TO_CCR  19BE
CHECK_OP_EORI_TO_SR  19CE
CHECK_OP_EXG        2248
CHECK_OP_EXT        1D20
CHECK_OP_ILLEGAL    1C68
CHECK_OP_JMP        1E02
CHECK_OP_JSR        1E70
CHECK_OP_LEA        1E56
CHECK_OP_LINK       1DC6
CHECK_OP_LSL        244A
CHECK_OP_LSL_NO_ROT  237A
CHECK_OP_LSR        242C
CHECK_OP_LSR_NO_ROT  2360
CHECK_OP_MOVEA_L    1B86
CHECK_OP_MOVEA_W    1BE8
CHECK_OP_MOVEM_L    1ED8
CHECK_OP_MOVEM_W    1EBE
CHECK_OP_MOVEP      1AC0
CHECK_OP_MOVEQ      20B2
CHECK_OP_MOVE_B     1B5C
CHECK_OP_MOVE_FROM_SR  1CA8
CHECK_OP_MOVE_L     1BBE
CHECK_OP_MOVE_TO_CCR  1CBC
CHECK_OP_MOVE_TO_SR  1CD0
CHECK_OP_MOVE_USP   1DEE
CHECK_OP_MOVE_W     1C20
CHECK_OP_MULS       226A
CHECK_OP_MULU       2220
CHECK_OP_NBCD       1D4E
CHECK_OP_NEG        1E8A
CHECK_OP_NEGX       1CE4
CHECK_OP_NOP        1E2A
CHECK_OP_NOT        1D0C
CHECK_OP_OR         2114
CHECK_OP_ORI        1AD4
CHECK_OP_ORI_TO_CCR  197E
CHECK_OP_ORI_TO_SR  198E
CHECK_OP_PEA        1D76
CHECK_OP_RESET      1C58
CHECK_OP_ROL        240E
CHECK_OP_ROL_NO_ROT  2346
CHECK_OP_ROR        23F0
CHECK_OP_ROR_NO_ROT  232C
CHECK_OP_ROXL       23DC
CHECK_OP_ROXL_NO_ROT  2318
CHECK_OP_ROXR       23C8
CHECK_OP_ROXR_NO_ROT  2304
CHECK_OP_RTE        1C78
CHECK_OP_RTR        1C98
CHECK_OP_RTS        1E40
CHECK_OP_SBCD       20E6
CHECK_OP_SCC        1F16
CHECK_OP_STATIC_BCHG  1A42
CHECK_OP_STATIC_BCLR  1B10
CHECK_OP_STATIC_BSET  1A56
CHECK_OP_STATIC_BTST  1A2E
CHECK_OP_STOP       1C48
CHECK_OP_SUB        2186
CHECK_OP_SUBA       2144
CHECK_OP_SUBI       19F2
CHECK_OP_SUBQ       1F3E
CHECK_OP_SUBX       2158
CHECK_OP_SWAP       1D62
CHECK_OP_TAS        1D8A
CHECK_OP_TRAP       1DB2
CHECK_OP_TRAPV      1C88
CHECK_OP_TST        1D9E
CHECK_OP_UNLK       1DDA
CHECK_POSITIVE_LENGTH  130A
CHECK_PRINT         11C2
CHECK_SIZE_BIT_FOR_SUB  2132
CHECK_VALID_LENGTH  1314
CHECK_XXXX          28FC
CHRDONE             13FC
CHRLOOP             13E8
CHUMP_BYTE          32D2
CHUMP_LONG          32E2
CHUMP_WORD          32DA
CLEAR_BUFFER        12BC
CLEAR_BUFFER_END    12D6
CLEAR_BUFFER_LENGTH  12B8
CLEAR_BUFFER_LOOP   12CA
CLEAR_BUFFER_POINTER  12B4
COMMA               28E4
CONVERTED_HEX_STRING  12E1
CONVERT_HEX_TO_STRING  12EA
CONVERT_TO_HEX_LETTER  1330
COUNTDONE           139C
COUNTLOOP           138A
CR                  D
CUR_OP_CODE         10A0
C_GROUP_0           197A
C_GROUP_1           1B58
C_GROUP_2           1B82
C_GROUP_3           1BE4
C_GROUP_4           1C46
C_GROUP_5           1EFE
C_GROUP_6           1F68
C_GROUP_7           20AE
C_GROUP_8           20CE
C_GROUP_9           212E
C_GROUP_A           21A0
C_GROUP_B           21A8
C_GROUP_C           221C
C_GROUP_D           22A0
C_GROUP_E           2300
C_GROUP_F           24B0
DATA                28DD
DIGIT_LOOP          131C
DIR_0               2C58
DIR_1               2CA8
DIVS                2CF8
DIVS_BACK           2D1A
DONE                124E
DOWN_ONE            2B5A
DOWN_ZERO           2B52
DYNMC_BCLR          31B4
D_TO_A              2F86
END                 3474
EXT                 28F8
FILEID              171A
FILENAME            16FA
FINDNULLLOOPDONE    136C
FIND_1_BIT_SIZE_6   189E
FIND_1_BIT_SIZE_8   18BE
FIND_2_BIT_SIZE_7_TO_6  187E
FIND_MOVEA_L_DIFFERENCE  1B98
FIND_MOVEA_W_DIFF   1BFA
FIRST_3             173A
FIRST_X             28EC
FIRST_Y             28ED
FOURTH_3            173D
FST_X               2FFE
FST_Y1              304A
FST_Y2              3054
FUK_MOVEM           2F44
GO                  32EA
GOO                 3222
GOO2                324E
GROUP0_INVALID      1B4C
GROUP0_SUCCESS      1B52
GROUP1_INVALID      1B76
GROUP1_SUCCESS      1B7C
GROUP2_INVALID      1BD8
GROUP2_SUCCESS      1BDE
GROUP3_INVALID      1C3A
GROUP3_SUCCESS      1C40
GROUP4_INVALID      1EF2
GROUP4_SUCCESS      1EF8
GROUP5_INVALID      1F5C
GROUP5_SUCCESS      1F62
GROUP6_INVALID      20A2
GROUP6_SUCCESS      20A8
GROUP7_INVALID      20C2
GROUP7_SUCCESS      20C8
GROUP8_INVALID      2122
GROUP8_SUCCESS      2128
GROUP9_INVALID      2194
GROUP9_SUCCESS      219A
GROUPB_INVALID      2210
GROUPB_SUCCESS      2216
GROUPC_INVALID      2294
GROUPC_SUCCESS      229A
GROUPD_INVALID      22F4
GROUPD_SUCCESS      22FA
GROUPE_INVALID      24A4
GROUPE_SUCCESS      24AA
GROUP_0             1750
GROUP_1             1762
GROUP_2             1774
GROUP_3             1786
GROUP_4             1798
GROUP_5             17AA
GROUP_6             17BC
GROUP_7             17CE
GROUP_8             17E0
GROUP_9             17F2
GROUP_A             1804
GROUP_B             1816
GROUP_C             1828
GROUP_D             183A
GROUP_E             184C
GROUP_F             185E
GT                  3460
G_BUFFER            1000
HEX_SIGN            28E0
IMMDTE_VALU         28E1
INVALID             3478
INVALID_ADDRES_MESSAGE  171E
INVALID_OP          24B8
IO_BUFFER           1705
IS_VALID            10A2
ITS_X               2FE2
ITS_Y               3024
ITS_Y_BACK          302E
JSR                 2EBC
JSR_BACK            2ED4
KEEP_GOING          306C
KEEP_GOING0         2FC8
LE                  346A
LEA                 2EF8
LEA_BACK            2F1A
LF                  A
LOAD_0000           307A
LOAD_00XX           3200
LOAD_0100           2DCE
LOAD_0101           2D44
LOAD_0110           2AAE
LOAD_1000           2C2C
LOAD_1001           2C26
LOAD_1011           2C20
LOAD_1100           2C1A
LOAD_1101           2BB8
LOAD_1110           298E
LOAD_8              2A54
LOAD_A              33EE
LOAD_ABS_LONG       3380
LOAD_ABS_SHORT      336E
LOAD_ADDRESS        3344
LOAD_ADDRESS_W_POST_INC  3356
LOAD_ADDRESS_W_PRE_DEC  3362
LOAD_ADDR_REGISTER  3332
LOAD_BYTES          339C
LOAD_COMMA_SPACE    33C8
LOAD_D              33E0
LOAD_DATA_REGISTER  3320
LOAD_EA             3264
LOAD_FIRST3         2A5E
LOAD_GE_111         32A4
LOAD_HEX_SIGN       3418
LOAD_IMMDTE         3392
LOAD_IMMDTE_VALU    3426
LOAD_LT_111         3276
LOAD_MINUS_SIGN     3442
LOAD_NEW_LINE       33C6
LOAD_NUM            3454
LOAD_PLUS_SIGN      3434
LOAD_PTHSIS_CLSD    340A
LOAD_PTHSIS_OPEN    33FC
LOAD_THIS_SHIT      3450
LOOP                33A6
MAIN_CONSOLE        1428
MAIN_EA             28EE
MAIN_LOOP           1160
MINUS_SIGN          28E3
MNEMONIC            1739
MOVEM               2EEA
MOVEM_BIT_SIZE_CHECK  1EA8
MOVEM_PARSE         2F4C
MOVEON              29E8
MOVE_AND_MOVEA_PARSE_EA  18DE
MYBE_ASD_1          29B0
MYBE_ASD_2          2A16
MYBE_BCLR           30C2
MYBE_BRA            2ACE
MYBE_CMPI           30AA
MYBE_JSR            2E3C
MYBE_MOVEM          2E5C
MYBE_NEG            2DE6
MYBE_ORI            3092
MYBE_RTS1           2DFE
MYBE_RTS2           2E0C
MYBE_RTS3           2E1A
MYBE_SUBQ1          2D5E
MYBE_SUBQ2          2D6E
MYBE_Y              3016
NEG                 2E7C
NEG_BACK            2E9E
NEG_WORD            2B9A
NEWLINE             16D4
NEXT_STEP           2F98
NOT_BCLR            30CC
NOT_BRA             2ADC
NOT_CMPI            30B4
NOT_JSR             2E46
NOT_MOVEM           2E6C
NOT_NEG             2DF0
NOT_ORI             309C
NOT_RTS             2E2E
NULLLOOP            135E
NUMBER_TO_CONVERT   12DC
OP_JSR_DONE         186C
OP_JSR_ROUTINE      173E
OP_SIZE             1738
ORI_CMPI            30DC
OR_BACK             2C7E
OR_BACK2            2CE2
OUTFILENAME         16DA
PARSE_EA_CONSTANT_BITS  1924
PLUS_SIGN           28E2
POS_WORD            2B86
PRINT_DATA          11DC
PRINT_INSTRUCTION   11D0
PRINT_OP_ADD        26B6
PRINT_OP_ADDA       26CA
PRINT_OP_ASL        271A
PRINT_OP_ASR        2706
PRINT_OP_BCS        25E6
PRINT_OP_BGE        25FA
PRINT_OP_BLT        260E
PRINT_OP_BRA        2636
PRINT_OP_BVC        2622
PRINT_OP_CMP        2694
PRINT_OP_CMPI       24E2
PRINT_OP_DIVS       264A
PRINT_OP_DYNAMIC_BCLR  250A
PRINT_OP_EOR        2680
PRINT_OP_JSR        2564
PRINT_OP_LEA        258E
PRINT_OP_LSL        26DE
PRINT_OP_LSR        26F2
PRINT_OP_MOVEA_L    252C
PRINT_OP_MOVEA_W    2548
PRINT_OP_MOVEB      251E
PRINT_OP_MOVEM_L    25C4
PRINT_OP_MOVEM_W    25B6
PRINT_OP_MOVE_L     253A
PRINT_OP_MOVE_W     2556
PRINT_OP_MULS       26A8
PRINT_OP_NEG        25A2
PRINT_OP_NOP        2580
PRINT_OP_OR         2658
PRINT_OP_ORI        24CE
PRINT_OP_ROL        272E
PRINT_OP_ROR        2742
PRINT_OP_RTS        2572
PRINT_OP_SIZE       2780
PRINT_OP_SIZE_ADDA  279A
PRINT_OP_STATIC_BCLR  24F6
PRINT_OP_SUB        266C
PRINT_OP_SUBQ       25D2
PRINT_SIZE_BYTE     2756
PRINT_SIZE_LONG     2772
PRINT_SIZE_WORD     2764
PRINT_TO_BUFFER     24C0
PTHSIS_CLSD         28DF
PTHSIS_OPEN         28DE
P_INVALID_OP        27A4
P_OP_ADD            28AB
P_OP_ADDA           28A3
P_OP_ASL            28C7
P_OP_ASR            28C0
P_OP_BCLR           27CB
P_OP_BCS            2856
P_OP_BGE            285D
P_OP_BLT            2864
P_OP_BRA            284F
P_OP_BVC            286B
P_OP_CMP            2891
P_OP_CMPI           27C3
P_OP_DIVS           2872
P_OP_EOR            288A
P_OP_JSR            282B
P_OP_LEA            2824
P_OP_LSL            28B9
P_OP_LSR            28B2
P_OP_MOVEA_L        27DE
P_OP_MOVEA_W        27F5
P_OP_MOVEB          27D3
P_OP_MOVEM_L        2818
P_OP_MOVEM_W        280C
P_OP_MOVE_L         27EA
P_OP_MOVE_W         2801
P_OP_MULS           2898
P_OP_NEG            2840
P_OP_NOP            2832
P_OP_OR             287D
P_OP_ORI            27BC
P_OP_ROL            28D5
P_OP_ROR            28CE
P_OP_RTS            2839
P_OP_SUB            2883
P_OP_SUBQ           2847
P_SIZE_B            27B0
P_SIZE_L            27B8
P_SIZE_W            27B4
RET_SA              1426
ROTATE              33B0
RTS                 2EB4
SAVED               3274
SECOND_3            173B
SIZE                14
SIZE_B              3308
SIZE_L              3318
SIZE_W              3310
SND_X               300E
SND_Y               3064
SPACE               28E5
START               10A3
STRING_ADD_SUCCESS  12A0
STRING_BUFFER_ADD_LOOP  128A
STRING_BUFFER_LOOP  1276
STRING_BUFFER_POINTER  1252
STRIP_ASCII         1402
SUB30               1422
SUB37               141A
SUBQ                2D7E
SUBQ_BACK           2DB8
SUBQ_SAVED          2D90
THIRD_3             173C
TOSAVE              C3F
TRAILING_HELPER     3308
TRAILING_SIZE       28E6
TRAPTASK13          134A
VALIDATE_END_POS    111C
VALIDATE_EVEN       113E
VALIDATE_POSITIVE_ADDRESS  10FA
VALIDATE_START_ADDRESS  10F8
X                   28E8
X_COUNTER           28EA
Y                   28E9
Y_COUNTER           28EB
_00000000           1380
