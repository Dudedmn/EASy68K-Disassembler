00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/15/2019 7:15:03 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler Skeleton 
00000000                             3  * Written by : You, and you should change all default comments
00000000                             4  * Date       : 3/9/2019 
00000000                             5  * TEAM REEE Denny, Daniel, Fahad
00000000                             6  * 
00000000                             7  * Description: This code contains a method for you to use
00000000                             8  * with your Disassembler project IO, and a short demo of 
00000000                             9  * how to call this method in the body of the "START" code.
00000000                            10  * 
00000000                            11  * Hints and Tips:
00000000                            12  *   -Follow the code commenting convention here for file & method headers
00000000                            13  *   -Don't rename this file name (Main.X68)
00000000                            14  *   -Don't reorg the start address ($1000)
00000000                            15  *   -Don't rename or edit the IO method I've provided you with here
00000000                            16  *   -Don't rename the config.cfg file or change the file format: 
00000000                            17  *    <Long_StartAddress>\CR\LF
00000000                            18  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            19  *---------------------------------------------------------------------------
00001000                            20      ORG    $1000    *Don't change this; see hints and tips above
00001000                            21  *---------------------------------------------------------------------------
00001000                            22  
00001000                            23  *declare the variable startaddr with size 1 long
00001000                            24  CURRENTADDR   DS.L        1                       * The starting address to decode from
00001004                            25  
00001004                            26  
00001004                            27  START:
00001004                            28      ***********************************************************
00001004                            29      * Code demo for printing strings to console & file is here
00001004                            30      * Pay close attention to:
00001004                            31      *   (1) the detailed comments, 
00001004                            32      *   (2) how to build a (Callee-Saved) method
00001004                            33      *   (3) how to call that method using JSR (return with RTS)
00001004                            34      ***********************************************************
00001004                            35     
00001004  43F9 000029F2             36      LEA MAIN_CONSOLE, A1
0000100A  4EB9 00002914             37      JSR TrapTask13
00001010                            38      
00001010                            39      
00001010                            40      ******************************************
00001010                            41      **
00001010                            42      **     ___         ___        /  __  
00001010                            43      **    |__  | |    |__     |  /  /  \  
00001010                            44      **    |    | |___ |___    | /   \__/ 
00001010                            45      **                           
00001010                            46      **
00001010                            47      ** This is the beggnining of the code for reading from files
00001010                            48      ******************************************
00001010                            49  
00001010                            50  
00001010                            51      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00001010                            52      
00001010                            53  
00001010                            54  ; Display description
00001010  43F9 00002CB4             55          lea     description,A1          ; location of text to display
00001016  103C 000E                 56          move.b  #14,D0                  ; trap task #14, displays null terminated string at (A1)
0000101A  4E4F                      57          trap    #15                     ; perform task
0000101C                            58  ; Attempt to open file for input
0000101C  43F9 00002D08             59          lea     fileName,A1             ; name of file to open
00001022  103C 0033                 60          move.b  #51,D0                  ; trap task #51, open existing file
00001026  4E4F                      61          trap    #15                     ; perform task
00001028  23C1 00002D58             62          move.l  D1,fileID               ; save file ID
0000102E                            63  
0000102E                            64  ; Read string from file
0000102E  43F9 00002D42             65          lea     string,A1               ; location of string buffer
00001034  2239 00002D58             66          move.l  fileID,D1               ; file ID of file to read from
0000103A  4282                      67          clr.l   D2
0000103C  343C 0014                 68          move.w  #SIZE,D2                ; number of bytes to read
00001040  103C 0035                 69          move.b  #53,D0                  ; trap task #53, read from file
00001044  4E4F                      70          trap    #15                     ; perform task
00001046                            71  ; Close file when finished
00001046  103C 0038                 72          move.b  #56,D0                  ; trap task #56, close file, D1 contains fileID
0000104A  4E4F                      73          trap    #15                     ; perform task
0000104C                            74  ; Display result label
0000104C  43F9 00002CE4             75          lea     result,A1               ; location of text to display
00001052  103C 000E                 76          move.b  #14,D0                  ; trap task #14, displays null terminated string at (A1)
00001056  4E4F                      77          trap    #15                     ; perform task
00001058                            78  ; Display string
00001058  43F9 00002D42             79          lea     string,A1               ; location of text to display
0000105E  323C 0014                 80          move.w  #SIZE,D1                ; max characters to display
00001062  103C 0000                 81          move.b  #0,D0                   ; trap task #0, displays string
00001066  4E4F                      82          trap    #15                     ; perform task
00001068                            83  ; Display success message
00001068  43F9 00002D2C             84          lea     success,A1              ; location of text to display
0000106E  103C 000E                 85          move.b  #14,D0                  ; trap task #14, displays null terminated string at (A1)
00001072  4E4F                      86          trap    #15                     ; perform task
00001074                            87      
00001074                            88      
00001074                            89  
00001074                            90  
00001074                            91      ;load start and end address as longs
00001074                            92      ; Start Address is in A5     
00001074  43F9 00002D42             93      LEA string, A1
0000107A  4EB9 000029AA             94      JSR AsciiToHex     ;  example of how to convert ascii to hex
00001080  2A47                      95      MOVE.L D7, A5
00001082                            96      
00001082                            97      ; End Address is in A6
00001082  5489                      98      ADDA.L #2, A1
00001084  4EB9 000029AA             99      JSR AsciiToHex
0000108A  2C47                     100      MOVE.L D7, A6
0000108C                           101      
0000108C                           102      
0000108C                           103      ;loop from start to end, printing out the instruction or DATA if not recognized 
0000108C                           104      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
0000108C                           105      
0000108C                           106      ;TODO : validate start and ending address 
0000108C                           107  
0000108C  BDCD                     108  mainloop    CMPA.L A5, A6
0000108E  6D00 17F2                109              BLT DONE
00001092                           110              
00001092                           111              *clear both buffers 
00001092                           112              
00001092  33DD 00004000            113              MOVE.W (A5)+, CUR_OP_CODE
00001098                           114              
00001098                           115  *-----------------------------------------------------------
00001098                           116  * Title      : OP Code routines for Disassembler
00001098                           117  * Written by : Daniel Yan
00001098                           118  * Date       : 2/28/2019, Updated 3/12/2019
00001098                           119  
00001098                           120  * Description: Disassembler routines to identify any valid
00001098                           121  * OP code dependent on current supported list.
00001098                           122  *------------------------------------------------------------
00004000                           123      ORG $4000
00004000                           124   
00004000                           125  CUR_OP_CODE     DS.W    1 * Used for Daniel's code
00004002  11F8 0012 4002           126     MOVE.B $12, $4002
00004008  11FC 0034 4004           127     MOVE.B #$34, $4004
0000400E  11FC 0012 4006           128     MOVE.B #$12, $4006
00004014  11FC 0034 4008           129     MOVE.B #$34, $4008
00004100                           130      ORG $4100
00004100                           131  G_BUFFER    DS.B 80 
00001000                           132      ORG $1000 ; Start at Address $1000
00001000                           133    
00001000                           134  
00001000                           135  
00001000                           136  MNEMONIC        DS.B    1 * First four BITS of any instruction
00001001                           137   
00001002                           138  TRAILING_SIZE   DS.W    1 * Size of any immediate or
00001004                           139                            * address values. Immediate or address
00001004                           140                            * value of a BYTE is still processed as
00001004                           141                            * WORD because the trailing bytes
00001004                           142                            * are represented as a word regardless.
00001004                           143                            * $1 = BYTE, $2 = WORD, $4 = LONG
00001004                           144  
00001004                           145  FIRST_3         DS.B    1 * First, second, third, and fourth bundles of three bits each
00001005                           146  SECOND_3        DS.B    1
00001006                           147  THIRD_3         DS.B    1
00001007                           148  FOURTH_3        DS.B    1
00001008                           149  
00001008                           150  EA_SIZE     DS.B 1
00001009                           151  
00001009                           152  B_BUFFER    DS.B 80
00001059                           153  
00001059                           154  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001059                           155  * MESSAGE VARIABLES ******************************
00001059                           156  
00001059                           157  * ASCII values for respective characters
00001059                           158  
00001059= 41                       159  ADDRESS         DC.B    $41
0000105A= 44                       160  DATA            DC.B    $44
0000105B                           161  
0000105B= 28                       162  PTHSIS_OPEN     DC.B    $28
0000105C= 29                       163  PTHSIS_CLSD     DC.B    $29
0000105D= 24                       164  HEX_SIGN        DC.B    $24
0000105E= 23                       165  IMMDTE_VALU     DC.B    $23
0000105F= 2B                       166  PLUS_SIGN       DC.B    $2B
00001060= 2D                       167  MINUS_SIGN      DC.B    $2D
00001061                           168  
00001061= 2C                       169  COMMA           DC.B    $2C
00001062= 20                       170  SPACE           DC.B    $20
00001063                           171  
00001063= 0D                       172  CR              DC.B    $D
00001064= 0A                       173  LF              DC.B    $A
00001065                           174  **************************************************
00001065                           175  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001065                           176  
00001065                           177  
00001065                           178  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001065                           179  * GLOBAL BUFFER **********************************
00001065                           180  
00001065                           181  
00001065  =00004000                182  START_ADDRESS   EQU     $4000 * Used to parse through the entire instruction
00001065  =00005000                183  END_ADDRESS     EQU     $5000
00001065                           184  
00001065                           185  EA_BUFFER       DS.B    80 * Used to load ASCII-converted EA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000010B5                           186  IS_VALID        DS.B    1 * EA-bit validity flag
000010B6                           187                            * $0 = invalid, $1 = valid
000010B6                           188  
000010B6                           189      
000010B6  49F8 4100                190      LEA G_BUFFER,A4         ;Load G_BUFFER into A4, put a pointer to it as A4
000010BA  18BC 0000                191      MOVE.B #0, (A4)         ;Move 0 to indicate where to put the loaded buffer word
000010BE                           192  
000010BE                           193      ;MOVE.L (A5)+, D0
000010BE                           194  ************** BUFFER PRINTING/LOADING EXAMPLES *************************************
000010BE                           195      ; Load the message onto A4
000010BE                           196      ;MOVE.L #P_OP_MOVEA_L_T, Arg_AddStrToBuffer_String
000010BE                           197      ;MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer 
000010BE                           198      ;JSR AddStrToBuffer
000010BE                           199      ;LEA G_BUFFER, A4   ; Load the value of the message onto the G_BUFFER
000010BE                           200      ;MOVE.L P_OP_MOVEA_L_T,(A4)+
000010BE                           201      ;MOVE.L P_OP_MOVEA_L_A_L,(A4)+
000010BE                           202      
000010BE                           203  ***************************** Input Tests ********************************************
000010BE                           204      ; indicates a test has been finished
000010BE                           205      * indicates a test hasn't been finished
000010BE                           206      
000010BE                           207      ***GROUP 0 tests**** SUPPORTED: ORI, BCLR (static, dynamic), CMPI
000010BE                           208      ;MOVE.W #%0000000000111100,CUR_OP_CODE      ;ORI TO CCR              SHOULD FAIL
000010BE                           209      ;MOVE.W #%0000000001111100,CUR_OP_CODE      ;ORI TO SR               SHOULD FAIL
000010BE                           210      ;MOVE.W #%0000000010000101,CUR_OP_CODE      ;ORI.W D5                SHOULD PASS
000010BE                           211      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO CCR             SHOULD FAIL
000010BE                           212      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO SR              SHOULD FAIL
000010BE                           213      ;MOVE.W #%0000001010000101,CUR_OP_CODE      ;ANDI.W D5               SHOULD FAIL
000010BE                           214      ;MOVE.W #%0000010010000101,CUR_OP_CODE      ;SUBI.W D5               SHOULD FAIL
000010BE                           215      ;MOVE.W #%0000011010000101,CUR_OP_CODE      ;ADDI.W D5               SHOULD FAIL
000010BE                           216      ;MOVE.W #%0000101000111100,CUR_OP_CODE      ;EORI TO CCR             SHOULD FAIL
000010BE                           217      ;MOVE.W #%0000101001111100,CUR_OP_CODE      ;EORI TO SR              SHOULD FAIL
000010BE                           218      ;MOVE.W #%0000101010000101,CUR_OP_CODE      ;EORI.W D5               SHOULD FAIL
000010BE                           219      ;MOVE.W #%0000110010000101,CUR_OP_CODE      ;CMPI.L D5               SHOULD PASS
000010BE                           220      ;MOVE.W #%0000100000000101,CUR_OP_CODE      ;STATIC BTST. B D5       SHOULD FAIL
000010BE                           221      ;MOVE.W #%0000100001000101,CUR_OP_CODE      ;STATIC BCHG .B D5       SHOULD FAIL
000010BE                           222      ;MOVE.W #%0000100010000101,CUR_OP_CODE      ;STATIC BCL R D5         SHOULD PASS
000010BE                           223      ;MOVE.W #%0000100011000101,CUR_OP_CODE      ;STATIC BS ET.B D5       SHOULD FAIL
000010BE                           224      ;MOVE.W #%0000111100000101,CUR_OP_CODE      ;DYNAMIC BTST.B D7,D5    SHOULD FAIL
000010BE                           225      ;MOVE.W #%0000111101000101,CUR_OP_CODE      ;DYNAMIC BCHG.B,D7,D5    SHOULD FAIL
000010BE                           226      ;MOVE.W #%0000101110000111,CUR_OP_CODE      ;DYNAMIC BCLR.B D7,D5    SHOULD PASS
000010BE                           227      ;MOVE.W #%0000111111000101,CUR_OP_CODE      ;DYNAMIC BSET.B D7,D5    SHOULD FAIL
000010BE                           228      ;MOVE.W #%0000111111001101,CUR_OP_CODE      ;MOVEP.L MEM TO REG, A5  SHOULD FAIL, MADE A SPECIAL CASE FOR DYNAMIC BSET BIT SHIFTING
000010BE                           229          
000010BE                           230      ***GROUP 1 tests**** SUPPORTED: MOVE.B
000010BE                           231      ;MOVE.W #%0001101000000111,CUR_OP_CODE       ;MOVE.B D5,D7           SHOULD PASS
000010BE                           232      ***GROUP 2 tests**** SUPPORTED: MOVEA.L, MOVE.L
000010BE                           233      ;MOVE.W #%0010101000000111,CUR_OP_CODE       ;MOVE.L D5,D7           SHOULD PASS
000010BE                           234      ;MOVE.W #%0010101001000111,CUR_OP_CODE       ;MOVEA.L D5,D7          SHOULD PASS
000010BE                           235      ;MOVE.W #%0010 101 000 111 100, MOVE.L #imm,D5
000010BE  31FC 2A3C 4000           236        MOVE.W #%0010101000111100,CUR_OP_CODE       ;MOVE.L #immed,D5 
000010C4                           237         
000010C4                           238      ***GROUP 3 tests**** SUPPORTED: MOVEA.W, MOVE.W
000010C4                           239      ;MOVE.W #%0011101000000111,CUR_OP_CODE       ;MOVE.W D5,D7           SHOULD PASS
000010C4                           240      ;MOVE.W #%0011101001000111,CUR_OP_CODE       ;MOVEA.W D5,D7          SHOULD PASS
000010C4                           241      
000010C4                           242      ****GROUP 4 tests**** SUPPORTED: LEA, JSR, RTS, NEG, MOVEM  
000010C4                           243      ;MOVE.W #%0100000011000101,CUR_OP_CODE       ;MOVE_FROM_SR           SHOULD FAIL
000010C4                           244      ;MOVE.W #%0100010011000101,CUR_OP_CODE       ;MOVE_TO_CCR            SHOULD FAIL
000010C4                           245      ;MOVE.W #%0100011011000101,CUR_OP_CODE       ;MOVE_TO_SR             SHOULD FAIL
000010C4                           246      ;MOVE.W #%0100000010000101,CUR_OP_CODE       ;NEGX                   SHOULD FAIL
000010C4                           247      ;MOVE.W #%0100001010000101,CUR_OP_CODE       ;CLR                    SHOULD FAIL
000010C4                           248      ;MOVE.W #%0100010001000101,CUR_OP_CODE       ;NEG                    SHOULD PASS
000010C4                           249      ;MOVE.W #%0100011010000101,CUR_OP_CODE       ;NOT                    SHOULD FAIL
000010C4                           250      ;MOVE.W #%0100100011000101,CUR_OP_CODE       ;EXT                    SHOULD FAIL
000010C4                           251      ;MOVE.W #%0100100000000101,CUR_OP_CODE       ;NBCD                   SHOULD FAIL
000010C4                           252      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;SWAP                   SHOULD FAIL
000010C4                           253      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;PEA                    SHOULD FAIL
000010C4                           254      ;MOVE.W #%0100101011111100,CUR_OP_CODE       ;ILLEGAL                SHOULD FAIL
000010C4                           255      ;MOVE.W #%0100101011000101,CUR_OP_CODE       ;TAS                    SHOULD FAIL
000010C4                           256      ;MOVE.W #%0100101010000101,CUR_OP_CODE       ;TST                    SHOULD FAIL
000010C4                           257      ;MOVE.W #%0100111001000111,CUR_OP_CODE       ;TRAP                   SHOULD FAIL
000010C4                           258      ;MOVE.W #%0100111001010101,CUR_OP_CODE       ;LINK                   SHOULD FAIL
000010C4                           259      ;MOVE.W #%0100111001011101,CUR_OP_CODE       ;UNLK                   SHOULD FAIL
000010C4                           260      ;MOVE.W #%0100111001101101,CUR_OP_CODE       ;MOVE_USP               SHOULD FAIL
000010C4                           261      ;MOVE.W #%0100111001110000,CUR_OP_CODE       ;RESET                  SHOULD FAIL
000010C4                           262      ;MOVE.W #%0100111001110001,CUR_OP_CODE       ;NOP                    SHOULD FAIL
000010C4                           263      ;MOVE.W #%0100111001110010,CUR_OP_CODE       ;STOP                   SHOULD FAIL
000010C4                           264      ;MOVE.W #%0100111001110011,CUR_OP_CODE       ;RTE                    SHOULD FAIL
000010C4                           265      ;MOVE.W #%0100111001110101,CUR_OP_CODE       ;RTS                    SHOULD PASS
000010C4                           266      ;MOVE.W #%0100111001110110,CUR_OP_CODE       ;TRAPV                  SHOULD FAIL
000010C4                           267      ;MOVE.W #%0100111001110111,CUR_OP_CODE       ;RTR                    SHOULD FAIL
000010C4                           268      ;MOVE.W #%0100111010000101,CUR_OP_CODE       ;JSR                    SHOULD PASS
000010C4                           269      ;MOVE.W #%0100111011000101,CUR_OP_CODE       ;JMP                    SHOULD FAIL
000010C4                           270      ;MOVE.W #$488E,CUR_OP_CODE                   ;MOVEM.W Reg to Mem,A6  SHOULD PASS
000010C4                           271      ;MOVE.W #$4C8E,CUR_OP_CODE                   ;MOVEM.W Mem to Reg,A6  SHOULD PASS
000010C4                           272      ;MOVE.W #$43CC,CUR_OP_CODE                   ;LEA A1,A6              SHOULD PASS
000010C4                           273      ;MOVE.W #%0100000110000101,CUR_OP_CODE       ;CHK                    SHOULD FAIL
000010C4                           274      ;MOVE.W #$4E75,CUR_OP_CODE                   ;RTS                    SHOULD PASS
000010C4                           275      ;MOVE.W #$4E71,CUR_OP_CODE                   ;NOP                    SHOULD FAIL
000010C4                           276      ;MOVE.W #$4415,CUR_OP_CODE                   ;NEG.L D5               SHOULD PASS
000010C4                           277     
000010C4                           278      *****GROUP 5 TESTS**** SUPPORTED: SUBQ
000010C4                           279      ;MOVE.W #%0101110010000101,CUR_OP_CODE        ;ADDQ                  SHOULD FAIL
000010C4                           280      ;MOVE.W #%0101110110000101,CUR_OP_CODE        ;SUBQ                  SHOULD PASS
000010C4                           281      ;MOVE.W #%0101101011000101,CUR_OP_CODE        ;Scc (SPL)             SHOULD FAIL
000010C4                           282      ;MOVE.W #%0101101011001101,CUR_OP_CODE         ;DBcc (DCPL)          SHOULD FAIL
000010C4                           283         
000010C4                           284      *****GROUP 6 TESTS********* SUPPORTED: BCS,BGE,BLT,BVC
000010C4                           285      ; DISPLACEMENT, $00 is 16 bits, $FF is 32 bits
000010C4                           286      ; DISPLACEMENT = Last 8 bits
000010C4                           287      ;MOVE.W #%0110000001010101,CUR_OP_CODE   ;BRA                        SHOULD PASS
000010C4                           288      ;MOVE.W #%0110000110101010,CUR_OP_CODE   ;BSR                        SHOULD FAIL
000010C4                           289      ;MOVE.W #%0110010100000001,CUR_OP_CODE   ;BCS                        SHOULD PASS
000010C4                           290      ;MOVE.W #%0110110001010100,CUR_OP_CODE   ;BGE                        SHOULD PASS
000010C4                           291      ;MOVE.W #%0110110110101010,CUR_OP_CODE   ;BLT                        SHOULD PASS
000010C4                           292      ;MOVE.W #%0110100001010100,CUR_OP_CODE   ;BVC                        SHOULD PASS
000010C4                           293      
000010C4                           294      *****GROUP 7 TESTS********** NONE SUPPORTED
000010C4                           295      ;MOVE.W #%0111101011110000,CUR_OP_CODE   ;MOVEQ                      SHOULD FAIL
000010C4                           296      
000010C4                           297      *****GROUP 8 TESTS********** SUPPORTED: DIVS, OR
000010C4                           298      ;MOVE.W #%1000101011000101,CUR_OP_CODE    ;DIVU                      SHOULD FAIL
000010C4                           299      ;MOVE.W #%1000101111000110,CUR_OP_CODE    ;DIVS                      SHOULD PASS
000010C4                           300      ;MOVE.W #%1000101100001111,CUR_OP_CODE    ;SBCD                      SHOULD FAIL
000010C4                           301      ;MOVE.W #%1000110101000101,CUR_OP_CODE    ;OR                        SHOULD PASS
000010C4                           302              
000010C4                           303      *****GROUP 9 TESTS********** SUPPORTED: SUB
000010C4                           304      ;MOVE.W #%1001101100000101,CUR_OP_CODE    ;SUB                       SHOULD PASS
000010C4                           305      ;MOVE.W #%1001000110001101,CUR_OP_CODE    ;SUBX                      SHOULD FAIL
000010C4                           306      ;MOVE.W #%1001101011001101,CUR_OP_CODE    ;SUBA                      SHOULD FAIL
000010C4                           307      
000010C4                           308      *****GROUP A TESTS********** NONE SUPPORTED
000010C4                           309      ;MOVE.W #%1010110101010011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010C4                           310      
000010C4                           311      *****GROUP B TESTS********** SUPPORTED: EOR, CMP
000010C4                           312      *MOVE.W #%1011101101000110,CUR_OP_CODE    ;EOR                       SHOULD PASS
000010C4                           313      *MOVE.W #%1011110101001101,CUR_OP_CODE    ;CMPM                      SHOULD FAIL
000010C4                           314      *MOVE.W #%1011010001000101,CUR_OP_CODE    ;CMP                       SHOULD PASS
000010C4                           315      *MOVE.W #%1011110011000101,CUR_OP_CODE    ;CMPA                      SHOULD FAIL
000010C4                           316      
000010C4                           317      *****GROUP C TESTS********** SUPPORTED: MULS
000010C4                           318      ;MOVE.W #%1100101011000110,CUR_OP_CODE    ;MULU                      SHOULD FAIL
000010C4                           319      ;MOVE.W #%1100101111000101,CUR_OP_CODE    ;MULS                      SHOULD PASS
000010C4                           320      ;MOVE.W #%1100101100000101,CUR_OP_CODE    ;ABCD                      SHOULD FAIL
000010C4                           321      ;MOVE.W #%1100101110001110,CUR_OP_CODE    ;EXG                       SHOULD FAIL
000010C4                           322      ;MOVE.W #%1100101001000101,CUR_OP_CODE    ;AND                       SHOULD FAIL   
000010C4                           323       
000010C4                           324      *****GROUP D TESTS********** SUPPORTED: ADD, ADDA
000010C4                           325      ;MOVE.W #%1101101101000101,CUR_OP_CODE    ;ADDX                      SHOULD FAIL
000010C4                           326      ;MOVE.W #%1101101011001101,CUR_OP_CODE    ;ADDA                      SHOULD FAIL
000010C4                           327      ;MOVE.W #%1101101001001101,CUR_OP_CODE    ;ADD                       SHOULD PASS
000010C4                           328      
000010C4                           329      *****GROUP E TESTS********** SUPPORTED: LSX, ASX, ROX
000010C4                           330      ;MOVE.W #%1110000011000101,CUR_OP_CODE    ;ASR NO_ROT                SHOULD PASS
000010C4                           331      ;MOVE.W #%1110000111000101,CUR_OP_CODE    ;ASL NO_ROT                SHOULD PASS
000010C4                           332      ;MOVE.W #%1110001011000101,CUR_OP_CODE    ;LSR NO_ROT                SHOULD PASS
000010C4                           333      ;MOVE.W #%1110001111000101,CUR_OP_CODE    ;LSL NO_ROT                SHOULD PASS
000010C4                           334      ;MOVE.W #%1110010011000101,CUR_OP_CODE    ;ROXR NO_ROT               SHOULD FAIL
000010C4                           335      ;MOVE.W #%1110010111000101,CUR_OP_CODE    ;ROXL NO_ROT               SHOULD FAIL
000010C4                           336      ;MOVE.W #%1110011011000101,CUR_OP_CODE    ;ROR NO_ROT                SHOULD PASS
000010C4                           337      ;MOVE.W #%1110011111000101,CUR_OP_CODE    ;ROL NO_ROT                SHOULD PASS    
000010C4                           338      
000010C4                           339      ;MOVE.W #%1110000001000101,CUR_OP_CODE    ;ASR                       SHOULD PASS
000010C4                           340      ;MOVE.W #%1110000101000101,CUR_OP_CODE    ;ASL                       SHOULD PASS
000010C4                           341      ;MOVE.W #%1110001001001101,CUR_OP_CODE    ;LSR                       SHOULD PASS
000010C4                           342      ;MOVE.W #%1110001101001101,CUR_OP_CODE    ;LSL                       SHOULD PASS
000010C4                           343      ;MOVE.W #%1110010001010101,CUR_OP_CODE    ;ROXR                      SHOULD FAIL
000010C4                           344      ;MOVE.W #%1110010101010101,CUR_OP_CODE    ;ROXL                      SHOULD FAIL
000010C4                           345      ;MOVE.W #%1110011001011101,CUR_OP_CODE    ;ROR                       SHOULD PASS
000010C4                           346      ;MOVE.W #%1110011101011101,CUR_OP_CODE    ;ROL                       SHOULD PASS    
000010C4                           347          
000010C4                           348      *****GROUP F TESTS********** NONE SUPPORTED
000010C4                           349      ;MOVE.W #%1111010110101011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010C4                           350      
000010C4                           351      
000010C4                           352  ************************************************************************************
000010C4                           353  * PRINTING BUFFER FUNCTION HAS BEEN FINISHED
000010C4                           354  * STATUS: 
000010C4                           355  * IDENTIFICATION FOR ALL OP CODES:      DONE
000010C4                           356  * VALIDATION TESTING FOR ALL OP CODES:  DONE
000010C4                           357  * PRINTING ALL OP CODES TO BUFFER:      NOT DONE
000010C4                           358  * PRINTING SIZE BITS OF ALL OP CODES:   NOT DONE
000010C4                           359  *-----------------------------------------------------------
000010C4                           360  *First Nibble Values (15-12)
000010C4                           361  *Value                  Operations
000010C4                           362  *$0                     GROUP_0: ORI,BCLR (static and dynamic),CMPI --- DONE
000010C4                           363  *$1                     GROUP_1: MOVE.B                             --- DONE
000010C4                           364  *$2                     GROUP_2: MOVE.L, MOVEA.L                    --- DONE
000010C4                           365  *$3                     GROUP_3: MOVE.W, MOVEA.W                    --- DONE
000010C4                           366  *$4                     GROUP_4: LEA,JSR,RTS,NEG,MOVEM              --- DONE
000010C4                           367  *$5                     GROUP_5: SUBQ                               --- DONE
000010C4                           368  *$6                     GROUP_6: Bcc(BCS,BGE,BLT,BVC), BRA          --- DONE
000010C4                           369  *$7                     GROUP_7: INVALID_OP                         --- DONE
000010C4                           370  *$8                     GROUP_8: DIVS, OR                           --- DONE
000010C4                           371  *$9                     GROUP_9: SUB                                --- DONE
000010C4                           372  *$A                     GROUP_A: INVALID_OP                         --- DONE
000010C4                           373  *$B                     GROUP_B: EOR, CMP                           --- DONE
000010C4                           374  *$C                     GROUP_C: MULS                               --- DONE
000010C4                           375  *$D                     GROUP_D: ADD, ADDA                          --- DONE
000010C4                           376  *$E                     GROUP_E: LSR, LSL, ASR, ASL, ROL, ROR       --- DONE
000010C4                           377  *$F                     GROUP_F: INVALID_OP                         --- DONE
000010C4                           378  
000010C4                           379  
000010C4                           380  * OP_JSR_Routine
000010C4                           381  **********************************************************************************
000010C4                           382  * Description: Catalog all supported OP codes into groupings based on their hex
000010C4                           383  * values. Sort the supported OP codes by looking at the first nibble for their
000010C4                           384  * grouping value. Call underlying subroutines for further identification of the
000010C4                           385  * op code.
000010C4                           386  *
000010C4                           387  * Registers used: A6,D0,D1 
000010C4                           388  *
000010C4                           389  * Precondition: Instruction set (size Word) has been loaded in the appropriate
000010C4                           390  * address to be parsed and read.
000010C4                           391  
000010C4                           392  * Postcondition: OP code has been identified as either valid or invalid. If it is
000010C4                           393  * valid, it is stored into A6 and EA parsing methods are called to pass needed
000010C4                           394  * information to EA. If invalid, DATA output will be utilized to indicate so.
000010C4                           395  **********************************************************************************
000010C4                           396  * These valid operand codes refer to the basic supported operand codes
000010C4                           397  * Groups refer to the first nibble value that is supported by the operand
000010C4                           398  LOAD_OP_CODE:
000010C4  3038 4000                399      MOVE.W CUR_OP_CODE,D0
000010C8  11FC 0001 10B5           400      MOVE.B #1,IS_VALID
000010CE  4EB9 000010D4            401      JSR OP_JSR_Routine             ;Use the JSR routine to identify the op code
000010D4                           402      
000010D4                           403  OP_JSR_Routine:
000010D4  48E7 C000                404      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
000010D8  720C                     405      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
000010DA  E2A8                     406      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
000010DC                           407  
000010DC                           408  GROUP_0:                ;$0| ORI, BCLR (static and dynamic), CMPI                  
000010DC  B03C 0000                409      CMP.B   #$0,D0                 ;Compare first nibble
000010E0  6600 000C                410      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
000010E4  4EB9 000012FA            411      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
000010EA  6000 010C                412      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000010EE                           413      
000010EE                           414  GROUP_1:                ;$1| MOVE.B
000010EE  B03C 0001                415      CMP.B   #$1,D0                 ;Compare first nibble
000010F2  6600 000C                416      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
000010F6  4EB9 000014C8            417      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
000010FC  6000 00FA                418      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001100                           419  
00001100                           420  GROUP_2:                ;$2| MOVE.L, MOVEA.L
00001100  B03C 0002                421      CMP.B   #$2,D0                 ;Compare first nibble
00001104  6600 000C                422      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
00001108  4EB9 000014F2            423      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
0000110E  6000 00E8                424      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001112                           425  
00001112                           426  GROUP_3:                ;$3| MOVE.W, MOVEA.W
00001112  B03C 0003                427      CMP.B   #$3,D0                 ;Compare first nibble
00001116  6600 000C                428      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
0000111A  4EB9 00001554            429      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
00001120  6000 00D6                430      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001124                           431  
00001124                           432  GROUP_4:                ;$4| LEA, JSR, RTS, NEG, MOVEM
00001124  B03C 0004                433      CMP.B   #$4,D0                 ;Compare first nibble
00001128  6600 000C                434      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
0000112C  4EB9 000015B6            435      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
00001132  6000 00C4                436      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001136                           437  
00001136                           438  
00001136                           439  GROUP_5:                ;$5| SUBQ
00001136  B03C 0005                440      CMP.B   #$5,D0                 ;Compare first nibble
0000113A  6600 000C                441      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
0000113E  4EB9 00001834            442      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
00001144  6000 00B2                443      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001148                           444  
00001148                           445  
00001148                           446  GROUP_6:                ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
00001148  B03C 0006                447      CMP.B   #$6,D0                 ;Compare first nibble
0000114C  6600 000C                448      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
00001150  4EB9 0000189A            449      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
00001156  6000 00A0                450      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000115A                           451  
0000115A                           452  
0000115A                           453  GROUP_7:                ;$7| Display: DATA, $WXYZ (Unsupported)
0000115A  B03C 0007                454      CMP.B   #$7,D0                 ;Compare first nibble
0000115E  6600 000C                455      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
00001162  4EB9 00001940            456      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
00001168  6000 008E                457      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000116C                           458  
0000116C                           459  
0000116C                           460  GROUP_8:                ;$8| DIVS, OR
0000116C  B03C 0008                461      CMP.B   #$8,D0                 ;Compare first nibble
00001170  6600 000C                462      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
00001174  4EB9 00001964            463      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
0000117A  6000 007C                464      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000117E                           465  
0000117E                           466  
0000117E                           467  GROUP_9:                ;$9| SUB
0000117E  B03C 0009                468      CMP.B   #$9,D0                 ;Compare first nibble
00001182  6600 000C                469      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
00001186  4EB9 000019BA            470      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
0000118C  6000 006A                471      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001190                           472  
00001190                           473  
00001190                           474  GROUP_A:                ;$A| Display: DATA, $WXYZ (Unsupported)
00001190  B03C 000A                475      CMP.B   #$A,D0                 ;Compare first nibble
00001194  6600 000C                476      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
00001198  4EB9 00001A14            477      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
0000119E  6000 0058                478      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011A2                           479  
000011A2                           480  
000011A2                           481  GROUP_B:                ;$B| EOR, CMP
000011A2  B03C 000B                482      CMP.B   #$B,D0                 ;Compare first nibble
000011A6  6600 000C                483      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
000011AA  4EB9 00001A1C            484      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
000011B0  6000 0046                485      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011B4                           486  
000011B4                           487  
000011B4                           488  GROUP_C:                ;$C| MULS
000011B4  B03C 000C                489      CMP.B   #$C,D0                 ;Compare first nibble
000011B8  6600 000C                490      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
000011BC  4EB9 00001A7C            491      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
000011C2  6000 0034                492      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011C6                           493  
000011C6                           494  
000011C6                           495  GROUP_D:                 ;$D| ADD, ADDA
000011C6  B03C 000D                496      CMP.B   #$D,D0                 ;Compare first nibble
000011CA  6600 000C                497      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
000011CE  4EB9 00001B12            498      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
000011D4  6000 0022                499      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011D8                           500  
000011D8                           501  
000011D8                           502  GROUP_E:                ;$E| LSR, LSL, ASR, ASL, ROL, ROR
000011D8  B03C 000E                503      CMP.B   #$E,D0                 ;Compare first nibble
000011DC  6600 000C                504      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
000011E0  4EB9 00001B54            505      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
000011E6  6000 0010                506      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011EA                           507  
000011EA                           508  
000011EA                           509  GROUP_F:                ;$F| Display: DATA, $WXYZ (Unsupported)
000011EA  B03C 000F                510      CMP.B   #$F,D0                 ;Compare first nibble
000011EE  4EB9 00001CEC            511      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
000011F4  6000 0002                512      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011F8                           513  
000011F8                           514  
000011F8                           515  OP_JSR_DONE:
000011F8  4CDF 0003                516           MOVEM.L (SP)+,D0-D1       ;Recover register D0
000011FC  4EF9 0000209C            517           JMP DENNY_EA_SHIT
00001202                           518  **********************************************************************************
00001202                           519  
00001202                           520  ********** EA Parsing ************************************************************
00001202                           521  
00001202                           522  * MOVE_LAST_6_BITS_TO_EA
00001202                           523  **********************************************************************************
00001202                           524  * Description: For OP codes with the last 6 bits specified as EA Mode and EA Reg,
00001202                           525  * the last 6 bits will be parsed and moved into the appropriate registers.
00001202                           526  *
00001202                           527  * Registers used: A6,D0,D1,D6,D7 
00001202                           528  
00001202                           529  * Precondition: OP code has been identified with only the last 6 bits for EA,
00001202                           530  * current instruction set is stored into A6.
00001202                           531  
00001202                           532  * Postcondition: Last 6 bits of instruction bit has been isolated and stored. Bits
00001202                           533  * for EA Mode have been stored in D7, Bits for EA Reg been stored in D6.
00001202                           534  **********************************************************************************
00001202                           535  MOVE_LAST_6_BITS_TO_EA:      ;Move last 6 bits from EA field to relevant registers
00001202                           536     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
00001202  3038 4000                537      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
00001206  323C 000A                538      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
0000120A  E368                     539      LSL.W   D1,D0            ;Truncate to find the last 6 bits
0000120C  E268                     540      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
0000120E  3E00                     541      MOVE.W  D0,D7            ;Move last 6 bits into D7
00001210  323C 0003                542      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001214  E26F                     543      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00001216  3C07                     544      MOVE.W  D7,D6            ;Move the 'upper' 3 bits into D6
00001218  323C 000D                545      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
0000121C  E368                     546      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
0000121E  E268                     547      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
00001220  3E00                     548      MOVE.W  D0,D7            ;Move the 'lower' 3 bits into D7
00001222                           549     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
00001222  4E75                     550      RTS                      ;Return to stack
00001224                           551      
00001224                           552  * FIND_2_BIT_SIZE_TO_EA
00001224                           553  **********************************************************************************
00001224                           554  * Description: For OP codes with 2 bit size fields, the 2 relevant bits (7-6) will 
00001224                           555  * be parsed and moved to the appropriate registers.
00001224                           556  *
00001224                           557  * Registers used: A6,D0,D1,D5
00001224                           558  *
00001224                           559  * Precondition: OP code has been identified with 2 size bit field for EA, current
00001224                           560  * instruction set for OP code is stored in to A6.
00001224                           561  *
00001224                           562  * Postcondition: 2 bit size field has been isolated and stored into D5.
00001224                           563  **********************************************************************************
00001224                           564  FIND_2_BIT_SIZE_TO_EA:      ;Move the 2 bit size field relevant register
00001224                           565     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001224  3038 4000                566      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
00001228  323C 0008                567      MOVE.W   #8,D1          ;Prepare 8 bit shift to D1
0000122C  E368                     568      LSL.W    D1,D0          ;Truncate to find the 2 size bits
0000122E  E268                     569      LSR.W    D1,D0          ;Reposition the bits
00001230  323C 0006                570      MOVE.W   #6,D1          ;Prepare 6 bit shift to D1
00001234  E268                     571      LSR.W    D1,D0          ;Truncate to shift 2 bits to a byte
00001236  3800                     572      MOVE.W   D0,D4          ;Move 2 size bits into D5
00001238                           573    ;  MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
00001238  4E75                     574      RTS                     ;Return to stack
0000123A                           575  **********************************************************************************
0000123A                           576  
0000123A                           577  * FIND_3_BIT_REG_TO_EA
0000123A                           578  **********************************************************************************
0000123A                           579  * Description: OP codes with a dynamic 3 bit register in bits 11-9 will be parsed
0000123A                           580  * and have those 3 bits isolated and moved to the appropriate registers.
0000123A                           581  *
0000123A                           582  * Registers used: A6,D0,D1,D5
0000123A                           583  *
0000123A                           584  * Precondition: OP code has been identified with a dynamic 3 bit register in bits
0000123A                           585  * 11-9.
0000123A                           586  *
0000123A                           587  * Postcondition: 3 bit dynamic register has been isolated and stored into D4.
0000123A                           588  **********************************************************************************
0000123A                           589  FIND_3_BIT_REG_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
0000123A                           590     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
0000123A  3038 4000                591      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
0000123E  323C 0004                592      MOVE.W   #4,D1          ;Prepare 4 bit shift to D1
00001242  E368                     593      LSL.W    D1,D0          ;Truncate to find the 2 size bits
00001244  E268                     594      LSR.W    D1,D0          ;Reposition the bits
00001246  323C 0009                595      MOVE.W   #9,D1          ;Prepare 9 bit shift to D1
0000124A  E268                     596      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
0000124C  3A00                     597      MOVE.W   D0,D5          ;Move 3 register bits into D4
0000124E                           598     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
0000124E  4E75                     599      RTS                     ;Return to stack
00001250                           600  **********************************************************************************
00001250                           601  
00001250                           602  * MOVE_AND_MOVEA_PARSE_EA
00001250                           603  **********************************************************************************
00001250                           604  * Description: Special parsing for the SRC and DST Mode/Reg for MOVE/MOVE
00001250                           605  *
00001250                           606  * Registers used: A6,D0,D1,D7,D6,D5,D4
00001250                           607  *
00001250                           608  * Precondition: OP code has been identified with either MOVE or MOVEA
00001250                           609  *
00001250                           610  * Postcondition: Store all relevant EA bits into associated register.
00001250                           611  **********************************************************************************
00001250                           612  MOVE_AND_MOVEA_PARSE_EA:       ;Move the 3 bit dynamic register bits to proper register
00001250                           613     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
00001250  3038 4000                614      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
00001254  323C 000A                615      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
00001258  E368                     616      LSL.W   D1,D0            ;Truncate to find the last 6 bits
0000125A  E268                     617      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
0000125C  3E00                     618      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
0000125E  323C 0003                619      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001262  E26F                     620      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00001264  3A07                     621      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
00001266  323C 000D                622      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
0000126A  E368                     623      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
0000126C  E268                     624      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
0000126E  3800                     625      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
00001270                           626      **************MOVING SOURCE*********** TO BE DONE LATER
00001270                           627      ; MOVE.W #%0011 011 001 001 101,(A6)              ;MOVEA.W A5,A3
00001270                           628      ; MOVE.W #%0010 011 001 001 101,D0                ;MOVEA.L A5,A3
00001270                           629       ;Expected values:
00001270                           630      ;D7, DST REG:   011
00001270                           631      ;D6, DST MODE:  001
00001270                           632      ;D5, SRC MODE:  001
00001270                           633      ;D4, SRC REG:   101
00001270                           634      ;00011001
00001270  3038 4000                635      MOVE.W CUR_OP_CODE,D0     ;Move current OP code into D0     
00001274  323C 0004                636      MOVE.W  #4,D1             ;Prepare 4 bit shift to D1
00001278  E368                     637      LSL.W   D1,D0             ;Truncate to find bits 11-6
0000127A  E268                     638      LSR.W   D1,D0             ;Reposition bits
0000127C  323C 0006                639      MOVE.W  #6,D1             ;Prepare 6 bit shift to D1
00001280  E268                     640      LSR.W   D1,D0             ;Truncate the SRC Reg/Mode bits
00001282  323C 0003                641      MOVE.W  #3,D1             ;Prepare a 3 bit shift to D1 for DST Reg/Mode
00001286  3C00                     642      MOVE.W  D0,D6             ;Copy over the current 6 bits to D6
00001288  E268                     643      LSR.W   D1,D0             ;Truncate DST Mode  
0000128A  3E00                     644      MOVE.W  D0,D7             ;Move DST Reg to D7
0000128C  323C 000D                645      MOVE.W  #13,D1             
00001290  E36E                     646      LSL.W   D1,D6             ;Truncate 13 bits in D6
00001292  E26E                     647      LSR.W   D1,D6             ;Reposition D6
00001294                           648                                ;D6 now contains the DST Reg
00001294                           649     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
00001294  4E75                     650      RTS                     ;Return to stack
00001296                           651  **********************************************************************************
00001296                           652  
00001296                           653  *FIND_TRAILING_BITS_TO_EA
00001296                           654  **********************************************************************************
00001296                           655  FIND_TRAILING_BITS_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
00001296                           656     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001296  3038 4000                657      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
0000129A  323C 0007                658      MOVE.W   #7,D1          ;Prepare 4 bit shift to D1
0000129E  E368                     659      LSL.W    D1,D0          ;Truncate to find the 2 size bits
000012A0  E268                     660      LSR.W    D1,D0          ;Reposition the bits
000012A2  323C 0006                661      MOVE.W   #6,D1          ;Prepare 9 bit shift to D1
000012A6  E268                     662      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
000012A8  3680                     663      MOVE.W   D0,(A3)          ;Move 3 register bits into D4
000012AA                           664     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
000012AA  4E75                     665      RTS                    ;Return to stack
000012AC                           666  **********************************************************************************
000012AC                           667  
000012AC                           668  *PARSE_EA_CONSTANT_BITS
000012AC                           669  **********************************************************************************
000012AC                           670  * Definition: Uses CUR_OP_CODE to shift the proper bits into the global constants
000012AC                           671  * used for EA (MNEMONIC,FIRST_3,SECOND_3,THIRD_3,FOURTH_3. Where MNEMONIC refers
000012AC                           672  * to the first 4 bits of CUR_OP_CODE (15-12), FIRST_3 refers to the first group
000012AC                           673  * of 3 bits (11-9), SECOND_3 refers to the second group of 3 bits (8-6), THIRD_3
000012AC                           674  * refers to the third group of 3 bits (5-3), and FOURTH_3 refers to the fourth
000012AC                           675  * group of 3 bits (2-0). Shifts CUR_OP_CODE bits to initialize constants.
000012AC                           676  *
000012AC                           677  * Registers used: D0,D1
000012AC                           678  *
000012AC                           679  * Precondition: CUR_OP_CODE has been set with an 4 hex instruction set
000012AC                           680  * 
000012AC                           681  * Postcondition: MNEMONIC, FIRST_3, SECOND_3, THIRD_3, FOURTH_3 have been set
000012AC                           682  * to the corresponding values.
000012AC                           683  **********************************************************************************
000012AC                           684  PARSE_EA_CONSTANT_BITS:
000012AC                           685      *MNEMONIC SHIFT
000012AC  3038 4000                686      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
000012B0  323C 000C                687      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
000012B4  E268                     688      LSR.W D1,D0                 ;Shift 12 bits from D0 right
000012B6  11C0 1000                689      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
000012BA                           690      *FIRST_3 SHIFT
000012BA  323C 0009                691      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
000012BE  3038 4000                692      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012C2  E948                     693      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
000012C4  E848                     694      LSR.W #4,D0                 ;Reposition D0
000012C6  E268                     695      LSR.W  D1,D0                ;Shift D0 9 bits right
000012C8  11C0 1004                696      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
000012CC                           697      *SECOND_3 SHIFT
000012CC  3038 4000                698      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012D0  EF48                     699      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
000012D2  EE48                     700      LSR.W #7,D0                 ;Reposition D0
000012D4  EC48                     701      LSR.W #6,D0                 ;Shift D0 6 bits right
000012D6  11C0 1005                702      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
000012DA                           703      *THIRD_3 SHIFT
000012DA  3038 4000                704      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012DE  E648                     705      LSR.W #3,D0                 ;Shift D0 3 bits right
000012E0  323C 000D                706      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
000012E4  E368                     707      LSL.W D1,D0                 ;Truncate first 13 bits of D0
000012E6  E268                     708      LSR.W D1,D0                 ;Reposition D0
000012E8  11C0 1006                709      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
000012EC                           710      *FOURTH_3 SHIFT
000012EC  3038 4000                711      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012F0  E368                     712      LSL.W D1,D0                 ;Grab the fourth 3-bit group
000012F2  E268                     713      LSR.W D1,D0                 ;Shift D0 back into position
000012F4  11C0 1007                714      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
000012F8  4E75                     715      RTS                         ;Return to stack
000012FA                           716  **********************************************************************************
000012FA                           717  ********** End of EA Parsing *****************************************************
000012FA                           718  
000012FA                           719  *******************JMP LABELS ****************************************************
000012FA                           720  * Labelling for group codes will be in the following format
000012FA                           721  
000012FA                           722  * <JMP Labelname>
000012FA                           723  ********************************************************************************
000012FA                           724  * Checking List Order (If more than one value)
000012FA                           725  * Operand1 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000012FA                           726  * Operand2 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000012FA                           727  
000012FA                           728  * Where a-b will refer to the bit corresponding bit value in the instruction
000012FA                           729  * format, and a specifier will be attached such as Size, EA Mode, SRC Reg, etc
000012FA                           730  * to clarify what a specific bit range means.
000012FA                           731  * Checking order refers to what order the checks will be performed in. 
000012FA                           732  * Any other code outside of the listed ones will be INVALID_OP.
000012FA                           733  ********************************************************************************
000012FA                           734  
000012FA                           735  ********************************************************************************
000012FA                           736  * Global Field Descriptions
000012FA                           737  * Size Field: Byte = 00 Word = 01 Long = 10
000012FA                           738  * EA Mode: Refer to EA Address Modes
000012FA                           739  * EA Reg: 3-bit input that is mapped to the respective binary value
000012FA                           740  ********************************************************************************
000012FA                           741  
000012FA                           742  * GROUP_0                      
000012FA                           743  ********************************************************************************
000012FA                           744  * Description: Checks for the following listed OP codes to be present or not
000012FA                           745  * Supported OP codes:
000012FA                           746  * ORI: $00, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000012FA                           747  * CMPI: $0C, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000012FA                           748  * Dynamic BCLR: $0, 11-9 Register, 8-6 %110, 5-3 EA Mode, 2-0 EA Reg
000012FA                           749  * Static BCLR: $01, 7-6 10, 5-3 EA Mode, 2-0 EA Reg
000012FA                           750  *
000012FA                           751  * Registers used: D0
000012FA                           752  *
000012FA                           753  * Precondition: First nibble has been identified as $0
000012FA                           754  *
000012FA                           755  * Postcondition: Parses proper OP code with a nibble value of $0 or finds an
000012FA                           756  * invalid OP code. After a successful parse loading for EA values will be done
000012FA                           757  * through a subroutine.
000012FA                           758  * 
000012FA                           759  * Unsupported OP codes:
000012FA                           760  * ORI_TO_CCR, ORI_TO_SR, ANDI_TO_CCR, ANDI_TO_SR, ANDI, SUBI, ADDI, EORI_TO_CCR
000012FA                           761  * EORI_TO_SR, EORI, STATIC_BTST, STATIC_BCHG, STATIC_BSET, DYNAMIC_BTST,
000012FA                           762  * DYNAMIC_BCHG, DYNAMIC_BSET, MOVEP 
000012FA                           763  ********************************************************************************
000012FA                           764  C_GROUP_0:
000012FA  48E7 C000                765      MOVEM.L D0-D1, -(SP)            ;Backup registers
000012FE                           766      
000012FE                           767  *Unsupported OP codes that are fully static in bits
000012FE                           768  CHECK_OP_ORI_TO_CCR:
000012FE  3038 4000                769      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001302  B07C 003C                770      CMP.W #$003C,D0                 ;Compare the direct full bits
00001306  6700 01B4                771      BEQ GROUP0_INVALID              ;INVALID OP code found
0000130A  6600 0002                772      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
0000130E                           773      
0000130E                           774  CHECK_OP_ORI_TO_SR:
0000130E  3038 4000                775      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001312  B07C 007C                776      CMP.W #$007C,D0                 ;Compare the direct full bits
00001316  6700 01A4                777      BEQ GROUP0_INVALID              ;INVALID OP code found
0000131A  6600 0002                778      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
0000131E                           779      
0000131E                           780  CHECK_OP_ANDI_TO_CCR:
0000131E  3038 4000                781      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001322  B07C 023C                782      CMP.W #$023C,D0                 ;Compare the direct full bits
00001326  6700 0194                783      BEQ GROUP0_INVALID              ;INVALID OP code found
0000132A  6600 0002                784      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
0000132E                           785      
0000132E                           786  CHECK_OP_ANDI_TO_SR:
0000132E  3038 4000                787      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001332  B07C 027C                788      CMP.W #$027C,D0                 ;Compare the direct full bits
00001336  6700 0184                789      BEQ GROUP0_INVALID              ;INVALID OP code found
0000133A  6600 0022                790      BNE CHECK_OP_ANDI               ;Check next routine
0000133E                           791  
0000133E                           792  CHECK_OP_EORI_TO_CCR:
0000133E  3038 4000                793      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001342  B07C 0A3C                794      CMP.W #$0A3C,D0                 ;Compare the direct full bits
00001346  6700 0174                795      BEQ GROUP0_INVALID              ;INVALID OP code found
0000134A  6600 0002                796      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
0000134E                           797      
0000134E                           798  CHECK_OP_EORI_TO_SR:
0000134E  3038 4000                799      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001352  B07C 0A7C                800      CMP.W #$0A7C,D0                 ;Compare the direct full bits
00001356  6700 0164                801      BEQ GROUP0_INVALID              ;INVALID OP code found
0000135A  6600 0002                802      BNE CHECK_OP_ANDI               ;Check next routine
0000135E                           803      
0000135E                           804  *Unsupported OP codes to check with partial static bits
0000135E                           805  CHECK_OP_ANDI:
0000135E  3038 4000                806      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001362  0240 FF00                807      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001366  B07C 0200                808      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
0000136A  6700 0150                809      BEQ GROUP0_INVALID              ;INVALID OP code found
0000136E  6600 0002                810      BNE CHECK_OP_SUBI               Check next routine
00001372                           811      
00001372                           812  CHECK_OP_SUBI:
00001372  3038 4000                813      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001376  0240 FF00                814      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000137A  B07C 0400                815      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
0000137E  6700 013C                816      BEQ GROUP0_INVALID              ;INVALID OP code found
00001382  6600 0002                817      BNE CHECK_OP_ADDI               ;Check next routine
00001386                           818  
00001386                           819  CHECK_OP_ADDI:
00001386  3038 4000                820      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000138A  0240 FF00                821      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000138E  B07C 0600                822      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00001392  6700 0128                823      BEQ GROUP0_INVALID              ;INVALID OP code found
00001396  6600 0002                824      BNE CHECK_OP_EORI               ;Check next routine 
0000139A                           825  
0000139A                           826  CHECK_OP_EORI:
0000139A  3038 4000                827      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000139E  0240 FF00                828      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000013A2  B07C 0A00                829      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
000013A6  6700 0114                830      BEQ GROUP0_INVALID              ;INVALID OP code found
000013AA  6600 0002                831      BNE CHECK_OP_STATIC_BTST        ;Check next routine
000013AE                           832      
000013AE                           833  CHECK_OP_STATIC_BTST:
000013AE  3038 4000                834      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013B2  0240 FFC0                835      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013B6  B07C 0800                836      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
000013BA  6700 0100                837      BEQ GROUP0_INVALID              ;INVALID OP code found
000013BE  6600 0002                838      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
000013C2                           839      
000013C2                           840  CHECK_OP_STATIC_BCHG:
000013C2  3038 4000                841      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013C6  0240 FFC0                842      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013CA  B07C 0840                843      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
000013CE  6700 00EC                844      BEQ GROUP0_INVALID              ;INVALID OP code found
000013D2  6600 0002                845      BNE CHECK_OP_STATIC_BSET        ;Check next routine
000013D6                           846  
000013D6                           847  CHECK_OP_STATIC_BSET:
000013D6  3038 4000                848      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013DA  0240 FFC0                849      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013DE  B07C 08C0                850      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
000013E2  6700 00D8                851      BEQ GROUP0_INVALID              ;INVALID OP code found   
000013E6  6600 0002                852      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
000013EA                           853  
000013EA                           854  CHECK_OP_DYNAMIC_BTST:
000013EA  3038 4000                855      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013EE  0240 F1C0                856      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
000013F2  B07C 0100                857      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
000013F6  6700 00C4                858      BEQ GROUP0_INVALID              ;INVALID OP code found
000013FA  6600 0002                859      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
000013FE                           860  
000013FE                           861  CHECK_OP_DYNAMIC_BCHG:
000013FE  3038 4000                862      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001402  0240 F1C0                863      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001406  B07C 0140                864      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
0000140A  6700 00B0                865      BEQ GROUP0_INVALID              ;INVALID OP code found
0000140E  6600 0002                866      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001412                           867      
00001412                           868  CHECK_OP_DYNAMIC_BSET:
00001412                           869  
00001412  3038 4000                870      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001416  0240 F1C0                871      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
0000141A  B07C 01C0                872      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
0000141E  6700 0006                873      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001422  6600 001C                874      BNE     CHECK_OP_MOVEP          ;Check next routine
00001426                           875  
00001426                           876  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00001426  3038 4000                877      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000142A  323C 000A                878      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
0000142E  E368                     879      LSL.W   D1,D0                   ;Shift out 10 bits left 
00001430  E268                     880      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001432  E648                     881      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00001434  B07C 0001                882      CMP.W   #$1,D0                  ;Compare bits to D0
00001438  6700 0006                883      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
0000143C  6600 007E                884      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid                                                    
00001440                           885      
00001440                           886  CHECK_OP_MOVEP:
00001440  3038 4000                887      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001444  0240 F138                888      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00001448  B07C 0108                889      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
0000144C  6700 08A6                890      BEQ INVALID_OP                  ;INVALID OP code found
00001450  6600 0002                891      BNE CHECK_OP_ORI                ;Check next routine
00001454                           892  
00001454                           893  *Supported OP code checks
00001454                           894  CHECK_OP_ORI:
00001454  3038 4000                895      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001458  0240 FF00                896      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
0000145C  B07C 0000                897      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00001460  6600 000C                898      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00001464  4EB9 00001D22            899      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
0000146A  6000 0056                900      BRA     GROUP0_SUCCESS          ;Finish routine
0000146E                           901      
0000146E                           902  CHECK_OP_CMPI:
0000146E  3038 4000                903      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001472  0240 FF00                904      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001476  B07C 0C00                905      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
0000147A  6600 000C                906      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
0000147E  4EB9 00001D32            907      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00001484  6000 003C                908      BRA     GROUP0_SUCCESS          ;Finish routine
00001488                           909      
00001488                           910  CHECK_OP_STATIC_BCLR:
00001488  3038 4000                911      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000148C  0240 FF00                912      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001490  B07C 0800                913      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00001494  6600 000C                914      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00001498  4EB9 00001D42            915      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
0000149E  6000 0022                916      BRA     GROUP0_SUCCESS          ;Finish routine
000014A2                           917      
000014A2                           918  CHECK_OP_DYNAMIC_BCLR:
000014A2  3038 4000                919      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000014A6  0240 0180                920      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
000014AA  B07C 0180                921      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
000014AE  6600 000C                922      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
000014B2  4EB9 00001D52            923      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
000014B8  6000 0008                924      BRA     GROUP0_SUCCESS          ;Finish routine
000014BC                           925  
000014BC                           926  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
000014BC  4EB9 00001CF4            927      JSR INVALID_OP                  ;INVALID OP code found
000014C2                           928      
000014C2                           929  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
000014C2  4CDF 0003                930      MOVEM.L (SP)+,D0-D1             ;Restore registers
000014C6  4E75                     931      RTS                             ;Return to stack
000014C8                           932      
000014C8                           933  * GROUP_1                      
000014C8                           934  ********************************************************************************
000014C8                           935  * Supported OP code:
000014C8                           936  * MOVE.B: $1, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
000014C8                           937  ********************************************************************************
000014C8                           938  C_GROUP_1:
000014C8  48E7 C000                939      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
000014CC                           940  
000014CC                           941  CHECK_OP_MOVE_B:
000014CC  3038 4000                942      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
000014D0  0240 F000                943      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
000014D4  B07C 1000                944      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
000014D8  6600 000C                945      BNE     GROUP1_INVALID          ;Invalid OP code has been found
000014DC  4EB9 00001D62            946      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
000014E2  6000 0008                947      BRA     GROUP1_SUCCESS          ;Finish routine
000014E6                           948      
000014E6                           949  GROUP1_INVALID:
000014E6  4EB9 00001CF4            950      JSR INVALID_OP                  ;Invalid OP code found
000014EC                           951      
000014EC                           952  GROUP1_SUCCESS:
000014EC  4CDF 0003                953      MOVEM.L (SP)+,D0-D1             ;Restore register
000014F0  4E75                     954      RTS                             ;Return to stack
000014F2                           955  * GROUP_2
000014F2                           956  ********************************************************************************
000014F2                           957  * Supported OP codes:
000014F2                           958  * MOVEA.L: $2, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
000014F2                           959  * MOVE.L: $2, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
000014F2                           960  ********************************************************************************
000014F2                           961  C_GROUP_2:
000014F2  48E7 E000                962      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
000014F6                           963  
000014F6                           964  CHECK_OP_MOVEA_L:
000014F6  3038 4000                965      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
000014FA  0240 F000                966      ANDI.W #$F000,D0                ;Mask relevant bits to D0
000014FE  B07C 2000                967      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001502  4EF9 00001508            968      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00001508                           969      
00001508                           970  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00001508  3038 4000                971      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
0000150C  323C 0007                972      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00001510  E368                     973      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001512  E268                     974      LSR.W    D1,D0                  ;Reposition the bits
00001514  323C 0006                975      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00001518  E268                     976      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
0000151A  3400                     977      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
0000151C  B47C 0001                978      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00001520  6600 000C                979      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00001524  4EB9 00001D72            980      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
0000152A  6000 0022                981      BRA     GROUP2_SUCCESS          ;Finish routine
0000152E                           982      
0000152E                           983      
0000152E                           984  CHECK_OP_MOVE_L:
0000152E  3038 4000                985      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001532  0240 F000                986      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001536  B07C 2000                987      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
0000153A  6600 000C                988      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
0000153E  4EB9 00001D82            989      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00001544  6000 0008                990      BRA GROUP2_SUCCESS              ;Finish routine
00001548                           991      
00001548                           992  GROUP2_INVALID:    
00001548  4EB9 00001CF4            993      JSR INVALID_OP                  ;Invalid OP code found
0000154E                           994      
0000154E                           995  GROUP2_SUCCESS:
0000154E  4CDF 0007                996      MOVEM.L (SP)+,D0-D2             ;Restore register
00001552  4E75                     997      RTS                             ;Return to stack
00001554                           998  * GROUP_3
00001554                           999  ********************************************************************************
00001554                          1000  * Supported OP codes:
00001554                          1001  * MOVEA.W: $3, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
00001554                          1002  * MOVE.W: $3, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00001554                          1003  ********************************************************************************
00001554                          1004  C_GROUP_3:
00001554  48E7 E000               1005      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001558                          1006      
00001558                          1007  CHECK_OP_MOVEA_W:
00001558  3038 4000               1008      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
0000155C  0240 F000               1009      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001560  B07C 3000               1010      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001564  4EF9 0000156A           1011      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
0000156A                          1012  
0000156A                          1013      
0000156A                          1014  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
0000156A  3038 4000               1015      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
0000156E  323C 0007               1016      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00001572  E368                    1017      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00001574  E268                    1018      LSR.W    D1,D0                 ;Reposition the bits
00001576  323C 0006               1019      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
0000157A  E268                    1020      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
0000157C  3400                    1021      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
0000157E  B47C 0001               1022      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00001582  6600 000C               1023      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00001586  4EB9 00001D92           1024      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
0000158C  6000 0022               1025      BRA      GROUP3_SUCCESS        ;Finish routine
00001590                          1026      
00001590                          1027  CHECK_OP_MOVE_W:
00001590  3038 4000               1028      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001594  0240 F000               1029      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001598  B07C 3000               1030      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
0000159C  6600 000C               1031      BNE      GROUP3_INVALID        ;INVALID OP code found
000015A0  4EB9 00001DA2           1032      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
000015A6  6000 0008               1033      BRA      GROUP3_SUCCESS        ;Finish routine
000015AA                          1034      
000015AA                          1035  GROUP3_INVALID:
000015AA  4EB9 00001CF4           1036      JSR INVALID_OP                 ;INVALID OP code found
000015B0                          1037  
000015B0                          1038  GROUP3_SUCCESS:
000015B0  4CDF 0007               1039      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
000015B4  4E75                    1040      RTS                            ;Return to stack
000015B6                          1041  
000015B6                          1042  * GROUP_4
000015B6                          1043  ********************************************************************************
000015B6                          1044  * Supported OP codes:
000015B6                          1045  * LEA: $4, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
000015B6                          1046  * JSR: $4E, 7-6 %10, 5-3 EA Mode, 2-0 EA Reg 
000015B6                          1047  * RTS: $4E75
000015B6                          1048  * NEG: $44, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000015B6                          1049  * MOVEM: $4, 11 %1, 10 %D, 9-7 %001, 6 S, 5-3 EA Mode, 2-0 EA Reg
000015B6                          1050  * %D = 0 , Register to Memory, 1 Memory to Register
000015B6                          1051  * Unsupported OP codes: MOVE_FROM_SR, MOVE_TO_CCR, MOVE_TO_SR, NEGX, CLR, NOT
000015B6                          1052  * EXT, NBCD, SWAP, PEA, ILLEGAL, TAS, TST, TRAP, LINK, UNLK, MOVE_USP, RESET,
000015B6                          1053  * NOP, STOP, RTE, TRAPV, RTR, JMP, CHK
000015B6                          1054  ********************************************************************************
000015B6                          1055  C_GROUP_4:
000015B6  2F00                    1056      MOVE.L  D0,-(SP)            ;Save registers
000015B8                          1057      
000015B8                          1058  *Unsupported OP codes to check that are full static bits
000015B8                          1059  CHECK_OP_STOP:
000015B8  3038 4000               1060      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015BC  B07C 4E72               1061      CMP.W  #$4E72,D0                ;Compare the appropriate bits
000015C0  6700 0266               1062      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015C4  6600 0002               1063      BNE    CHECK_OP_RESET           ;Check next OP code
000015C8                          1064      
000015C8                          1065  CHECK_OP_RESET:
000015C8  3038 4000               1066      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015CC  B07C 4E70               1067      CMP.W  #$4E70,D0                ;Compare the appropriate bits
000015D0  6700 0256               1068      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015D4  6600 0002               1069      BNE    CHECK_OP_NOP             ;Check next OP code
000015D8                          1070      
000015D8                          1071  CHECK_OP_NOP:
000015D8  3038 4000               1072      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015DC  B07C 4E71               1073      CMP.W  #$4E71,D0                ;Compare the appropriate bits
000015E0  6700 0246               1074      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015E4  6600 0002               1075      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
000015E8                          1076      
000015E8                          1077  CHECK_OP_ILLEGAL:
000015E8  3038 4000               1078      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015EC  B07C 4AFC               1079      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
000015F0  6700 0236               1080      BEQ    GROUP4_INVALID           ;INVALID OP code found
000015F4  6600 0002               1081      BNE    CHECK_OP_RTE             ;Check next OP code
000015F8                          1082      
000015F8                          1083  CHECK_OP_RTE:    
000015F8  3038 4000               1084      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000015FC  B07C 4E73               1085      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00001600  6700 0226               1086      BEQ   GROUP4_INVALID            ;INVALID OP code found
00001604  6600 0002               1087      BNE   CHECK_OP_TRAPV            ;Check next OP code
00001608                          1088      
00001608                          1089  CHECK_OP_TRAPV:
00001608  3038 4000               1090      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000160C  B07C 4E76               1091      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00001610  6700 0216               1092      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001614  6600 0002               1093      BNE    CHECK_OP_RTR             ;Check next OP code
00001618                          1094      
00001618                          1095  CHECK_OP_RTR:
00001618  3038 4000               1096      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000161C  B07C 4E77               1097      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00001620  6700 0206               1098      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001624  6600 0002               1099      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00001628                          1100  
00001628                          1101  
00001628                          1102  *Unsupported OP codes to check that have partial static bits
00001628                          1103  CHECK_OP_MOVE_FROM_SR:
00001628  3038 4000               1104      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000162C  0240 FFC0               1105      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001630  B07C 40C0               1106      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00001634  6700 01F2               1107      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00001638  6600 0002               1108      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
0000163C                          1109      
0000163C                          1110  CHECK_OP_MOVE_TO_CCR:
0000163C  3038 4000               1111      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001640  0240 FFC0               1112      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001644  B07C 44C0               1113      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00001648  6700 01DE               1114      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000164C  6600 0002               1115      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00001650                          1116      
00001650                          1117  CHECK_OP_MOVE_TO_SR:
00001650  3038 4000               1118      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001654  0240 FFC0               1119      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001658  B07C 46C0               1120      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
0000165C  6700 01CA               1121      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001660  6600 0002               1122      BNE    CHECK_OP_NEGX            ;Check next OP code
00001664                          1123      
00001664                          1124  CHECK_OP_NEGX:
00001664  3038 4000               1125      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
00001668  0240 FF00               1126      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000166C  B07C 4000               1127      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
00001670  6700 01B6               1128      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001674  6600 0002               1129      BNE    CHECK_OP_CLR             ;Check next OP code
00001678                          1130      
00001678                          1131  CHECK_OP_CLR:
00001678  3038 4000               1132      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000167C  0240 FF00               1133      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001680  B07C 4200               1134      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00001684  6700 01A2               1135      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001688  6600 0002               1136      BNE    CHECK_OP_NOT             ;Check next OP code
0000168C                          1137      
0000168C                          1138  CHECK_OP_NOT:
0000168C  3038 4000               1139      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001690  0240 FF00               1140      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001694  B07C 4600               1141      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00001698  6700 018E               1142      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000169C  6600 0002               1143      BNE    CHECK_OP_EXT             ;Check next OP code
000016A0                          1144      
000016A0                          1145  CHECK_OP_EXT:
000016A0  3038 4000               1146      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016A4  0240 FF80               1147      ANDI.W #$FF80,D0                ;Mask relevant bits to D0
000016A8  B07C 4880               1148      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
000016AC  6700 017A               1149      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
000016B0  6600 001C               1150      BNE    CHECK_OP_NBCD            ;Check next OP code
000016B4                          1151  
000016B4                          1152  BIT_CHECK_EXT:    
000016B4  3038 4000               1153      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
000016B8  323C 000A               1154      MOVE.W #10,D1
000016BC  E368                    1155      LSL.W  D1,D0
000016BE  E068                    1156      LSR.W  D0,D0
000016C0  E648                    1157      LSR.W  #3,D0
000016C2  B078 0000               1158      CMP.W  %000,D0
000016C6  6700 0160               1159      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
000016CA  6600 0142               1160      BNE    CHECK_OP_MOVEM           ;This is the only other possibility 
000016CE                          1161      
000016CE                          1162  CHECK_OP_NBCD:
000016CE  3038 4000               1163      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016D2  0240 FFC0               1164      ANDI.W #$FFC0,D0            
000016D6  B07C 4800               1165      CMP.W  #$4800,D0
000016DA  6700 014C               1166      BEQ    GROUP4_INVALID
000016DE  6600 0002               1167      BNE    CHECK_OP_SWAP
000016E2                          1168      
000016E2                          1169  CHECK_OP_SWAP:                  ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
000016E2  3038 4000               1170      MOVE.W CUR_OP_CODE,D0       ;Move current instruction set into D0
000016E6  0240 FF48               1171      ANDI.W #$FF48,D0
000016EA  B07C 4840               1172      CMP.W  #$4840,D0
000016EE  6700 0138               1173      BEQ    GROUP4_INVALID
000016F2  6600 0002               1174      BNE    CHECK_OP_PEA
000016F6                          1175   
000016F6                          1176  CHECK_OP_PEA:               ; This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
000016F6  3038 4000               1177      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000016FA  0240 FF40               1178      ANDI.W #$FF40,D0
000016FE  B07C 4840               1179      CMP.W  #$4840,D0
00001702  6700 0124               1180      BEQ    GROUP4_INVALID
00001706  6600 0002               1181      BNE    CHECK_OP_TAS
0000170A                          1182      
0000170A                          1183  CHECK_OP_TAS:
0000170A  3038 4000               1184      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000170E  0240 FFC0               1185      ANDI.W #$FFC0,D0
00001712  B07C 4AC0               1186      CMP.W  #$4AC0,D0
00001716  6700 0110               1187      BEQ    GROUP4_INVALID
0000171A  6600 0002               1188      BNE    CHECK_OP_TST
0000171E                          1189  
0000171E                          1190  CHECK_OP_TST:               ; This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
0000171E  3038 4000               1191      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001722  0240 FF00               1192      ANDI.W #$FF00,D0
00001726  B07C 4A00               1193      CMP.W  #$4A00,D0
0000172A  6700 00FC               1194      BEQ    GROUP4_INVALID
0000172E  6600 0002               1195      BNE    CHECK_OP_TRAP
00001732                          1196      
00001732                          1197  CHECK_OP_TRAP:
00001732  3038 4000               1198      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001736  0240 FFF0               1199      ANDI.W #$FFF0,D0
0000173A  B07C 4E40               1200      CMP.W  #$4E40,D0
0000173E  6700 00E8               1201      BEQ    GROUP4_INVALID
00001742  6600 0002               1202      BNE    CHECK_OP_LINK
00001746                          1203      
00001746                          1204  CHECK_OP_LINK:
00001746  3038 4000               1205      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000174A  0240 FFF8               1206      ANDI.W #$FFF8,D0
0000174E  B07C 4E50               1207      CMP.W  #$4E50,D0
00001752  6700 00D4               1208      BEQ    GROUP4_INVALID
00001756  6600 0002               1209      BNE    CHECK_OP_UNLK
0000175A                          1210  
0000175A                          1211  CHECK_OP_UNLK:
0000175A  3038 4000               1212      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000175E  0240 FFF8               1213      ANDI.W #$FFF8,D0
00001762  B07C 4E58               1214      CMP.W  #$4E58,D0
00001766  6700 00C0               1215      BEQ    GROUP4_INVALID
0000176A  6600 0002               1216      BNE    CHECK_OP_MOVE_USP
0000176E                          1217      
0000176E                          1218  CHECK_OP_MOVE_USP:
0000176E  3038 4000               1219      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001772  0240 FFF0               1220      ANDI.W #$FFF0,D0
00001776  B07C 4E60               1221      CMP.W  #$4E60,D0
0000177A  6700 00AC               1222      BEQ    GROUP4_INVALID
0000177E  6600 0002               1223      BNE    CHECK_OP_JMP
00001782                          1224  
00001782                          1225  CHECK_OP_JMP:
00001782  3038 4000               1226       MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001786  0240 FFC0               1227       ANDI.W #$FFC0,D0
0000178A  B07C 4EC0               1228       CMP.W  #$4EC0,D0
0000178E  6700 0098               1229       BEQ    GROUP4_INVALID
00001792  6600 0002               1230       BNE    CHECK_OP_CHK
00001796                          1231       
00001796                          1232  CHECK_OP_CHK:
00001796  3038 4000               1233      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
0000179A  0240 F1C0               1234      ANDI.W  #$F1C0,D0
0000179E  B07C 4180               1235      CMP.W   #$4180,D0
000017A2  6700 0550               1236      BEQ     INVALID_OP
000017A6  6600 0002               1237      BNE     CHECK_OP_RTS
000017AA                          1238  
000017AA                          1239  *Supported OP codes to check
000017AA                          1240  CHECK_OP_RTS:
000017AA  3038 4000               1241      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017AE  B07C 4E75               1242      CMP.W  #$4E75,D0
000017B2  6600 000C               1243      BNE    CHECK_OP_LEA
000017B6  4EB9 00001DC2           1244      JSR    PRINT_OP_RTS
000017BC  6000 0070               1245      BRA    GROUP4_SUCCESS              ;Finish routine
000017C0                          1246   
000017C0                          1247  CHECK_OP_LEA:
000017C0  3038 4000               1248      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017C4  0240 F1C0               1249      ANDI.W #$F1C0,D0
000017C8  B07C 41C0               1250      CMP.W  #$41C0,D0
000017CC  6600 000C               1251      BNE    CHECK_OP_JSR
000017D0  4EB9 00001DD2           1252      JSR    PRINT_OP_LEA
000017D6  6000 0056               1253      BRA    GROUP4_SUCCESS              ;Finish routine
000017DA                          1254   
000017DA                          1255  CHECK_OP_JSR:
000017DA  3038 4000               1256      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017DE  0240 FFC0               1257      ANDI.W #$FFC0,D0
000017E2  B07C 4E80               1258      CMP.W  #$4E80,D0
000017E6  6600 000C               1259      BNE    CHECK_OP_NEG
000017EA  4EB9 00001DB2           1260      JSR    PRINT_OP_JSR
000017F0  6000 003C               1261      BRA    GROUP4_SUCCESS              ;Finish routine
000017F4                          1262      
000017F4                          1263  CHECK_OP_NEG:
000017F4  3038 4000               1264      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000017F8  0240 FF00               1265      ANDI.W #$FF00,D0
000017FC  B07C 4400               1266      CMP.W  #$4400,D0
00001800  6600 000C               1267      BNE    CHECK_OP_MOVEM
00001804  4EB9 00001DE2           1268      JSR    PRINT_OP_NEG
0000180A  6000 0022               1269      BRA    GROUP4_SUCCESS              ;Finish routine
0000180E                          1270  
0000180E                          1271      
0000180E                          1272  **************** COME BACK TO FINISH UP SIZE **********************************
0000180E                          1273  CHECK_OP_MOVEM:
0000180E  3038 4000               1274      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001812  0240 FB80               1275      ANDI.W #$FB80,D0
00001816  B07C 4880               1276      CMP.W  #$4880,D0
0000181A  6600 04D8               1277      BNE    INVALID_OP       ;If no code is found, it is invalid
0000181E  4EB9 00001DF2           1278      JSR    PRINT_OP_MOVEM_W
00001824  6000 0008               1279      BRA    GROUP4_SUCCESS
00001828                          1280      
00001828                          1281  GROUP4_INVALID:
00001828  4EB9 00001CF4           1282      JSR INVALID_OP
0000182E                          1283  
0000182E                          1284  GROUP4_SUCCESS:
0000182E  4CDF 0001               1285      MOVEM.L (SP)+,D0 
00001832  4E75                    1286      RTS
00001834                          1287  * GROUP_5
00001834                          1288  ********************************************************************************
00001834                          1289  * Supported OP code:
00001834                          1290  * SUBQ: $5, 11-9 DATA, 8 %1, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00001834                          1291  * Unsupported OP codes: ADDQ, Scc, DBcc
00001834                          1292  * Validation checking:
00001834                          1293  * Check against, ADDQ, Scc, DBcc
00001834                          1294  ********************************************************************************
00001834                          1295  C_GROUP_5:
00001834  48E7 8000               1296      MOVEM.L D0,-(SP)         ;Save registers to stack
00001838                          1297  *Unsupported OP codes
00001838                          1298  CHECK_OP_DBcc:               ;These are ordered first due to checking bits 7-6
00001838  3038 4000               1299      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000183C  0240 F0C8               1300      ANDI.W #$F0C8,D0
00001840  B07C 50C8               1301      CMP.W  #$50C8,D0
00001844  6700 0048               1302      BEQ    GROUP5_INVALID
00001848  6600 0002               1303      BNE    CHECK_OP_Scc 
0000184C                          1304  
0000184C                          1305  CHECK_OP_Scc:
0000184C  3038 4000               1306      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001850  0240 F0C0               1307      ANDI.W #$F0C0,D0 
00001854  B07C 50C0               1308      CMP.W  #$50C0,D0
00001858  6700 0034               1309      BEQ     GROUP5_INVALID
0000185C  6600 0002               1310      BNE     CHECK_OP_ADDQ
00001860                          1311  
00001860                          1312  CHECK_OP_ADDQ:
00001860  3038 4000               1313      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001864  0240 F100               1314      ANDI.W #$F100,D0
00001868  B07C 5000               1315      CMP.W  #$5000,D0
0000186C  6700 0020               1316      BEQ    GROUP5_INVALID
00001870  6600 0002               1317      BNE    CHECK_OP_SUBQ
00001874                          1318  
00001874                          1319  *Supported OP code   
00001874                          1320  CHECK_OP_SUBQ     
00001874  3038 4000               1321      MOVE.W  CUR_OP_CODE,D0  ;Actual check for SUBQ
00001878  0240 F100               1322      ANDI.W #$F100,D0        ;Bitmask check for SUBQ
0000187C  B07C 5100               1323      CMP.W  #$5100,D0        ;Compare the proper value
00001880  6600 000C               1324      BNE    GROUP5_INVALID       ;Else the operand is invalid
00001884  4EB9 00001E12           1325      JSR    PRINT_OP_SUBQ    ;If equal print it out
0000188A  6000 0008               1326      BRA    GROUP5_SUCCESS   ;Finish routine
0000188E                          1327      
0000188E                          1328  GROUP5_INVALID: 
0000188E  4EB9 00001CF4           1329      JSR INVALID_OP          ;INVALID OP has been found
00001894                          1330  
00001894                          1331  GROUP5_SUCCESS:
00001894  4CDF 0001               1332      MOVEM.L (SP)+,D0        ;Restore registers from stack
00001898  4E75                    1333      RTS                     ;Return to stack
0000189A                          1334      
0000189A                          1335  * GROUP_6
0000189A                          1336  ********************************************************************************
0000189A                          1337  * Supported OP codes
0000189A                          1338  * BRA: $60, 7-0 8-Bit Displacement
0000189A                          1339  * Bcc: $6, 11-8 Condition, 7-0 8-Bit Displacement
0000189A                          1340  *   Branch: <Condition>   
0000189A                          1341  *   BCS: %0101          
0000189A                          1342  *   BGE: %1100      
0000189A                          1343  *   BLT: %1101  
0000189A                          1344  *   BVC: %1000
0000189A                          1345  *   
0000189A                          1346  *   MOVE.W #%0110010100000000   ;BCS
0000189A                          1347  *   MOVE.W #%0110110001010101   ;BGE
0000189A                          1348  *   MVE.W #%0110110110101010    ;BLT
0000189A                          1349  *   MOVE.W #%0110100001010101   ;BVC
0000189A                          1350  * Unsupported OP code: BSR
0000189A                          1351  ********************************************************************************
0000189A                          1352  C_GROUP_6:
0000189A  48E7 8000               1353      MOVEM.L D0,-(SP)        ;Save register to stack
0000189E                          1354  *Unsupported OP code
0000189E                          1355  CHECK_OP_BSR:
0000189E  3038 4000               1356      MOVE.W  CUR_OP_CODE,D0
000018A2  0240 FF00               1357      ANDI.W  #$FF00,D0
000018A6  B07C 6100               1358      CMP.W   #$6100,D0
000018AA  6700 0088               1359      BEQ     GROUP6_INVALID
000018AE  6600 0002               1360      BNE     CHECK_OP_BRA
000018B2                          1361      
000018B2                          1362  *Supported OP codes
000018B2                          1363  CHECK_OP_BRA:
000018B2  3038 4000               1364      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0       
000018B6  0240 FF00               1365      ANDI.W  #$FF00,D0
000018BA  B07C 6000               1366      CMP.W   #$6000,D0
000018BE  6600 000C               1367      BNE     CHECK_OP_BCS
000018C2  4EB9 00001E62           1368      JSR     PRINT_OP_BRA
000018C8  6000 0070               1369      BRA     GROUP6_SUCCESS
000018CC                          1370      
000018CC                          1371  CHECK_OP_BCS:
000018CC  3038 4000               1372      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000018D0  0240 FF00               1373      ANDI.W #$FF00,D0
000018D4  B07C 6500               1374      CMP.W  #$6500,D0 
000018D8  6600 000C               1375      BNE    CHECK_OP_BGE
000018DC  4EB9 00001E22           1376      JSR    PRINT_OP_BCS
000018E2  6000 0056               1377      BRA    GROUP6_SUCCESS
000018E6                          1378  
000018E6                          1379      
000018E6                          1380  CHECK_OP_BGE:
000018E6  3038 4000               1381      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
000018EA  0240 FF00               1382      ANDI.W #$FF00,D0
000018EE  B07C 6C00               1383      CMP.W  #$6C00,D0 
000018F2  6600 000C               1384      BNE    CHECK_OP_BLT
000018F6  4EB9 00001E32           1385      JSR    PRINT_OP_BGE
000018FC  6000 003C               1386      BRA    GROUP6_SUCCESS
00001900                          1387      
00001900                          1388      
00001900                          1389  CHECK_OP_BLT:
00001900  3038 4000               1390      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001904  0240 FF00               1391      ANDI.W #$FF00,D0
00001908  B07C 6D00               1392      CMP.W  #$6D00,D0 
0000190C  6600 000C               1393      BNE    CHECK_OP_BVC
00001910  4EB9 00001E42           1394      JSR    PRINT_OP_BLT
00001916  6000 0022               1395      BRA    GROUP6_SUCCESS
0000191A                          1396      
0000191A                          1397  CHECK_OP_BVC:
0000191A  3038 4000               1398      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000191E  0240 FF00               1399      ANDI.W #$FF00,D0
00001922  B07C 6800               1400      CMP.W  #$6800,D0 
00001926  6600 000C               1401      BNE    GROUP6_INVALID
0000192A  4EB9 00001E52           1402      JSR    PRINT_OP_BVC
00001930  6000 0008               1403      BRA    GROUP6_SUCCESS
00001934                          1404      
00001934                          1405  GROUP6_INVALID:
00001934  4EB9 00001CF4           1406      JSR    INVALID_OP    
0000193A                          1407          
0000193A                          1408  GROUP6_SUCCESS:
0000193A  4CDF 0001               1409      MOVEM.L (SP)+,D0
0000193E  4E75                    1410      RTS
00001940                          1411      
00001940                          1412  *GROUP_7
00001940                          1413  ********************************************************************************
00001940                          1414  * Currently no OP codes here are supported. MOVEQ is the only code in this group
00001940                          1415  * Unsupported OP code: MOVEQ
00001940                          1416  ********************************************************************************
00001940                          1417  C_GROUP_7:
00001940  48E7 8000               1418      MOVEM.L D0,-(SP)        ;Save register to stack
00001944                          1419      
00001944                          1420  CHECK_OP_MOVEQ
00001944  3038 4000               1421      MOVE.W CUR_OP_CODE,D0
00001948  0240 F100               1422      ANDI.W #$F100,D0
0000194C  B07C 7000               1423      CMP.W  #$7000,D0
00001950  6600 0006               1424      BNE    GROUP7_INVALID
00001954  6700 0008               1425      BEQ    GROUP7_SUCCESS
00001958                          1426      
00001958                          1427  GROUP7_INVALID:
00001958  4EB9 00001CF4           1428      JSR INVALID_OP
0000195E                          1429      
0000195E                          1430  GROUP7_SUCCESS:    
0000195E  4CDF 0001               1431      MOVEM.L (SP)+,D0
00001962  4E75                    1432      RTS
00001964                          1433  * GROUP_8
00001964                          1434  ********************************************************************************
00001964                          1435  * Supported OP code:
00001964                          1436  * DIVS: $8, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00001964                          1437  * OR: $80, 7-6 Size, 5-3 EA Mode, 2-0 EA Register
00001964                          1438  * Unsupported OP codes: DIVU, SBCD
00001964                          1439  ********************************************************************************
00001964                          1440  C_GROUP_8:
00001964  48E7 8000               1441      MOVEM.L D0,-(SP)
00001968                          1442  *Unsupported OP codes
00001968                          1443  CHECK_OP_DIVU:
00001968  3038 4000               1444      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
0000196C  0240 F1C0               1445      ANDI.W  #$F1C0,D0
00001970  B07C 80C0               1446      CMP.W   #$80C0,D0
00001974  6700 0038               1447      BEQ     GROUP8_INVALID
00001978  6600 0002               1448      BNE     CHECK_OP_SBCD 
0000197C                          1449  
0000197C                          1450  CHECK_OP_SBCD:
0000197C  3038 4000               1451      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
00001980  0240 F1F0               1452      ANDI.W  #$F1F0,D0
00001984  B07C 8100               1453      CMP.W   #$8100,D0
00001988  6700 0024               1454      BEQ     GROUP8_INVALID
0000198C  6600 0002               1455      BNE     CHECK_OP_DIVS
00001990                          1456      
00001990                          1457  *Supported OP codes
00001990                          1458  CHECK_OP_DIVS:
00001990  3038 4000               1459      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
00001994  0240 F1C0               1460      ANDI.W  #$F1C0,D0
00001998  B07C 81C0               1461      CMP.W   #$81C0,D0
0000199C  6700 04D4               1462      BEQ     PRINT_OP_DIVS
000019A0  6600 0002               1463      BNE     CHECK_OP_OR
000019A4                          1464      
000019A4                          1465  CHECK_OP_OR:              ;At this point only remaining $8 code is OR
000019A4  4EB9 00001E82           1466      JSR     PRINT_OP_OR
000019AA  6000 0008               1467      BRA     GROUP8_SUCCESS
000019AE                          1468  GROUP8_INVALID:
000019AE  4EB9 00001CF4           1469       JSR    INVALID_OP
000019B4                          1470       
000019B4                          1471  GROUP8_SUCCESS:
000019B4  4CDF 0001               1472       MOVEM.L (SP)+,D0
000019B8  4E75                    1473       RTS
000019BA                          1474       
000019BA                          1475  * GROUP_9                      
000019BA                          1476  ********************************************************************************
000019BA                          1477  * Supported OP code:
000019BA                          1478  * SUB: $9, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
000019BA                          1479  * Unsupported OP codes: SUBX, SUBA
000019BA                          1480  ********************************************************************************
000019BA                          1481  C_GROUP_9:
000019BA  48E7 C000               1482      MOVEM.L D0-D1,-(SP)     ;Save the registers
000019BE                          1483  CHECK_OP_SUBA:             ;Check SUBA first as it has static bits
000019BE  3038 4000               1484      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
000019C2  0240 F0C0               1485      ANDI.W  #$F0C0,D0
000019C6  B07C 90C0               1486      CMP.W   #$90C0,D0
000019CA  6700 0328               1487      BEQ     INVALID_OP
000019CE  6600 0002               1488      BNE     CHECK_OP_SUBX
000019D2                          1489  
000019D2                          1490  CHECK_OP_SUBX:
000019D2  3038 4000               1491      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
000019D6  0240 F130               1492      ANDI.W  #$F130,D0
000019DA  B07C 9100               1493      CMP.W   #$9100,D0
000019DE  6700 0006               1494      BEQ     BIT_CHECK_SUBX
000019E2  6600 0026               1495      BNE     GROUP9_INVALID     ;Cannot be a valid OP code here
000019E6                          1496      
000019E6                          1497  BIT_CHECK_SUBX:    
000019E6  3038 4000               1498      MOVE.W  CUR_OP_CODE,D0      ;Move current instruction set into D0
000019EA  323C 0007               1499      MOVE.W  #7,D1               ;Prepare a shift of 7 bits into D1
000019EE  E368                    1500      LSL.W   D1,D0               ;Shift left 7 bits truncate 15-9 bits
000019F0  E268                    1501      LSR.W   D1,D0               ;Reposition D0
000019F2  E848                    1502      LSR.W   #4,D0               ;Truncate 4 right most bits to
000019F4  0240 FF18               1503      ANDI.W  #$FF18,D0           ;Compare remaining static bits
000019F8  B07C 0018               1504      CMP.W   #$0018,D0           ;If equal to this value it's SUBX
000019FC  6700 000C               1505      BEQ     GROUP9_INVALID      ;INVALID OP code found
00001A00  6600 0002               1506      BNE     CHECK_OP_SUB        ;Not can only be SUB here
00001A04                          1507      
00001A04                          1508  CHECK_OP_SUB:                   ;At this point only remaining $9 is SUB
00001A04  4EF9 00001E92           1509      JMP     PRINT_OP_SUB
00001A0A                          1510  
00001A0A                          1511  GROUP9_INVALID:
00001A0A  6000 02E8               1512      BRA     INVALID_OP
00001A0E                          1513      
00001A0E                          1514  GROUP9_SUCCESS:
00001A0E  4CDF 0003               1515      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001A12  4E75                    1516      RTS                         ;Return to stack
00001A14                          1517  
00001A14                          1518  *GROUP_A
00001A14                          1519  ********************************************************************************
00001A14                          1520  * Currently no OP codes here are supported. There are no current OP codes here.
00001A14                          1521  ********************************************************************************
00001A14                          1522  C_GROUP_A:
00001A14  4EB9 00001CF4           1523      JSR INVALID_OP
00001A1A  4E75                    1524      RTS
00001A1C                          1525      
00001A1C                          1526  * GROUP_B                     
00001A1C                          1527  ********************************************************************************
00001A1C                          1528  * Supported OP codes:
00001A1C                          1529  * EOR: $B, 11-9 Reg, 8 %1, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A1C                          1530  * CMP: $B, 11-9 Reg, 8 %0, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A1C                          1531  * The specific bit difference is listed 
00001A1C                          1532  * Unsupported OP codes: CMPM, CMPA
00001A1C                          1533  ********************************************************************************
00001A1C                          1534  C_GROUP_B:
00001A1C  48E7 8000               1535      MOVEM.L D0,-(SP)         ;Save current registers to stack
00001A20                          1536      
00001A20                          1537  CHECK_OP_CMPM
00001A20  3038 4000               1538      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A24  0240 F138               1539      ANDI.W  #$F138,D0
00001A28  B07C B108               1540      CMP.W   #$B108,D0
00001A2C  6700 0042               1541      BEQ     GROUPB_INVALID
00001A30  6600 0002               1542      BNE     CHECK_OP_CMPA
00001A34                          1543      
00001A34                          1544  CHECK_OP_CMPA:
00001A34  3038 4000               1545      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A38  0240 F0C0               1546      ANDI.W  #$F0C0,D0
00001A3C  B07C B0C0               1547      CMP.W   #$B0C0,D0
00001A40  6700 002E               1548      BEQ     GROUPB_INVALID
00001A44  6600 0002               1549      BNE     CHECK_OP_EOR
00001A48                          1550      
00001A48                          1551  CHECK_OP_EOR:
00001A48  3038 4000               1552      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A4C  0240 F100               1553      ANDI.W  #$F100,D0
00001A50  B07C B100               1554      CMP.W   #$B100,D0
00001A54  6700 044C               1555      BEQ     PRINT_OP_EOR
00001A58  6600 0002               1556      BNE     CHECK_OP_CMP
00001A5C                          1557      
00001A5C                          1558  CHECK_OP_CMP:
00001A5C  3038 4000               1559      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A60  0240 F100               1560      ANDI.W  #$F100,D0
00001A64  B07C B000               1561      CMP.W   #$B000,D0
00001A68  6700 0448               1562      BEQ     PRINT_OP_CMP
00001A6C  6600 0002               1563      BNE     GROUPB_INVALID
00001A70                          1564  
00001A70                          1565  GROUPB_INVALID:
00001A70  4EB9 00001CF4           1566      JSR     INVALID_OP           ;INVALID OP has been found 
00001A76                          1567   
00001A76                          1568  GROUPB_SUCCESS:
00001A76  4CDF 0001               1569      MOVEM.L (SP)+,D0         ;Restore registers from stack
00001A7A  4E75                    1570      RTS                      ;Return to stack
00001A7C                          1571  * GROUP_C                     
00001A7C                          1572  ********************************************************************************
00001A7C                          1573  * Supported OP code:
00001A7C                          1574  * MULS: $C, 11-8 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00001A7C                          1575  * Note: EXG OP mode has to be 01000, 01001, 10001, as such can never be 11 for
00001A7C                          1576  * bits 7-6
00001A7C                          1577  * Unsupported OP codes: MULU, ABCD, EXG, AND
00001A7C                          1578  ********************************************************************************
00001A7C                          1579  C_GROUP_C:
00001A7C                          1580  *Unsupported OP codes
00001A7C  48E7 C000               1581      MOVEM.L D0-D1,-(SP)
00001A80                          1582      
00001A80                          1583  CHECK_OP_MULU:
00001A80  3038 4000               1584      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A84  0240 F1C0               1585      ANDI.W  #$F1C0,D0
00001A88  B07C C0C0               1586      CMP.W   #$C0C0,D0
00001A8C  6700 0078               1587      BEQ     GROUPC_INVALID
00001A90  6600 0002               1588      BNE     CHECK_OP_ABCD
00001A94                          1589   
00001A94                          1590  CHECK_OP_ABCD:
00001A94  3038 4000               1591      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A98  0240 F1F0               1592      ANDI.W  #$F1F0,D0
00001A9C  B07C C100               1593      CMP.W   #$C100,D0
00001AA0  6700 0064               1594      BEQ     GROUPC_INVALID
00001AA4  6600 0002               1595      BNE     CHECK_OP_EXG
00001AA8                          1596   
00001AA8                          1597  CHECK_OP_EXG:
00001AA8  3038 4000               1598      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AAC  0240 F130               1599      ANDI.W  #$F130,D0
00001AB0  B07C C100               1600      CMP.W   #$C100,D0
00001AB4  6700 0006               1601      BEQ     BIT_CHECK_EXG
00001AB8  6600 003C               1602      BNE     CHECK_OP_AND
00001ABC                          1603                          
00001ABC                          1604  BIT_CHECK_EXG:                 ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
00001ABC  3038 4000               1605      MOVE.W  CUR_OP_CODE,D0
00001AC0  323C 0008               1606      MOVE.W  #8,D1
00001AC4  E368                    1607      LSL.W   D1,D0
00001AC6  E268                    1608      LSR.W   D1,D0
00001AC8  EC48                    1609      LSR.W   #6,D0
00001ACA  0240 FFF3               1610      ANDI.W  #$FFF3,D0
00001ACE  B07C 0003               1611      CMP.W   #$0003,D0          ;This bit then equals MULS
00001AD2  6700 000E               1612      BEQ     CHECK_OP_MULS
00001AD6  B07C 0000               1613      CMP.W   #$0000,D0          ;Second comparison to check if OP mode bit is valid
00001ADA  6700 001A               1614      BEQ     CHECK_OP_AND       ;If it's 0 it could be OP_AND
00001ADE  6600 0026               1615      BNE     GROUPC_INVALID         ;Otherwise it's EXG (01,10 op bits)
00001AE2                          1616  *Supported OP code
00001AE2                          1617  CHECK_OP_MULS:
00001AE2  3038 4000               1618      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AE6  0240 F1C0               1619      ANDI.W #$F1C0,D0
00001AEA  B07C C1C0               1620      CMP.W  #$C1C0,D0
00001AEE  6700 03D2               1621      BEQ    PRINT_OP_MULS
00001AF2  6600 0002               1622      BNE    CHECK_OP_AND          ; OP_AND is completely dynamic outside of first nibble
00001AF6                          1623  
00001AF6                          1624  *Odd completely dynamic unsupported OP code    
00001AF6                          1625  CHECK_OP_AND:                 ;This would be the only possible OP code left after CHECK_OP_MULS
00001AF6  3038 4000               1626      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AFA  0240 F000               1627      ANDI.W  #$F000,D0
00001AFE  B07C C000               1628      CMP.W   #$C000,D0
00001B02  6700 0002               1629      BEQ     GROUPC_INVALID
00001B06                          1630      
00001B06                          1631  GROUPC_INVALID:
00001B06  4EB9 00001CF4           1632      JSR     INVALID_OP
00001B0C                          1633      
00001B0C                          1634  GROUPC_SUCCESS:
00001B0C  4CDF 0003               1635      MOVEM.L (SP)+,D0-D1
00001B10  4E75                    1636      RTS
00001B12                          1637      
00001B12                          1638  * GROUP_D                     
00001B12                          1639  ********************************************************************************
00001B12                          1640  * Supported OP codes:
00001B12                          1641  * ADD: $D, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001B12                          1642  * ADDA: $D, 11- 9 Reg, 8-6 OPMODE, 7-6 %11, 5-3 EA Mode, 2-0 EA Reg
00001B12                          1643  * The specific bit difference is listed out in the OPMODE field.
00001B12                          1644  * Unsupported: ADDX
00001B12                          1645  ********************************************************************************
00001B12                          1646  C_GROUP_D:
00001B12  48E7 8000               1647      MOVEM.L D0,-(SP)        ;Save registers to stack
00001B16                          1648      
00001B16                          1649  CHECK_OP_ADDX:
00001B16  3038 4000               1650      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B1A  0240 F130               1651      ANDI.W #$F130,D0
00001B1E  B07C D100               1652      CMP.W  #$D100,D0
00001B22  6700 0024               1653      BEQ    GROUPD_INVALID
00001B26  6600 0002               1654      BNE    CHECK_OP_ADDA
00001B2A                          1655  
00001B2A                          1656  CHECK_OP_ADDA:
00001B2A  3038 4000               1657      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B2E  0240 F0C0               1658      ANDI.W #$F0C0,D0
00001B32  B07C D0C0               1659      CMP.W  #$D0C0,D0
00001B36  6700 03AA               1660      BEQ    PRINT_OP_ADDA
00001B3A  6600 0002               1661      BNE    CHECK_OP_ADD
00001B3E                          1662  
00001B3E                          1663  CHECK_OP_ADD:
00001B3E  4EB9 00001ED2           1664      JSR PRINT_OP_ADD        ;Only remaining OP in $D is ADD
00001B44  6000 0008               1665      BRA GROUPD_SUCCESS
00001B48                          1666      
00001B48                          1667  GROUPD_INVALID:
00001B48  4EB9 00001CF4           1668      JSR INVALID_OP
00001B4E                          1669      
00001B4E                          1670  GROUPD_SUCCESS:
00001B4E  4CDF 0001               1671      MOVEM.L (SP)+,D0        ;Restore registers from stack
00001B52  4E75                    1672      RTS                     ;Return to stack
00001B54                          1673      
00001B54                          1674  * GROUP_E                     
00001B54                          1675  ********************************************************************************
00001B54                          1676  * Supported:
00001B54                          1677  * LSR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001B54                          1678  * LSL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001B54                          1679  * ASR: $E, $0, 8 %0, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001B54                          1680  * ASL: $E, $0, 8 %1, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001B54                          1681  * ROR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001B54                          1682  * ROL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001B54                          1683  * Count/Reg for LSR/LSL refers to shift count, where 0 = shift count of 8, 1-7 
00001B54                          1684  * refers to the respective value when i/r = 0. If i/r = 1, data register in the 
00001B54                          1685  * Count/Reg field specifies the shift count.  
00001B54                          1686  * For directional bit at 8, R = 0, L = 1
00001B54                          1687  * Count/Reg for ROR/ROL specifies rotate count instead of shift count.
00001B54                          1688  *
00001B54                          1689  * Split into ROT and NO_ROT groups first to make identifying easier.
00001B54                          1690  * Unsupported: ROXL, ROXR
00001B54                          1691  ********************************************************************************
00001B54                          1692  C_GROUP_E:
00001B54  48E7 8000               1693      MOVEM.L D0,-(SP)
00001B58                          1694  *Unsupported OP codes
00001B58                          1695  CHECK_OP_ROXR_NO_ROT:
00001B58  3038 4000               1696      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B5C  0240 FFC0               1697      ANDI.W #$FFC0,D0
00001B60  B07C E4C0               1698      CMP.W  #$E4C0,D0
00001B64  6700 017A               1699      BEQ    GROUPE_INVALID
00001B68  6600 0002               1700      BNE    CHECK_OP_ROXL_NO_ROT
00001B6C                          1701  
00001B6C                          1702  CHECK_OP_ROXL_NO_ROT:
00001B6C  3038 4000               1703      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B70  0240 FFC0               1704      ANDI.W #$FFC0,D0
00001B74  B07C E5C0               1705      CMP.W  #$E5C0,D0
00001B78  6700 0166               1706      BEQ    GROUPE_INVALID
00001B7C  6600 0002               1707      BNE    CHECK_OP_ROR_NO_ROT
00001B80                          1708  
00001B80                          1709  *Supported OP codes
00001B80                          1710  CHECK_OP_ROR_NO_ROT:
00001B80  3038 4000               1711      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B84  0240 FFC0               1712      ANDI.W #$FFC0,D0
00001B88  B07C E6C0               1713      CMP.W  #$E6C0,D0
00001B8C  6600 000C               1714      BNE    CHECK_OP_ROL_NO_ROT
00001B90  4EB9 00001F42           1715      JSR    PRINT_OP_ROR
00001B96  6000 014E               1716      BRA    GROUPE_SUCCESS
00001B9A                          1717      
00001B9A                          1718  CHECK_OP_ROL_NO_ROT:
00001B9A  3038 4000               1719      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B9E  0240 FFC0               1720      ANDI.W #$FFC0,D0
00001BA2  B07C E7C0               1721      CMP.W  #$E7C0,D0
00001BA6  6600 000C               1722      BNE    CHECK_OP_LSR_NO_ROT
00001BAA  4EB9 00001F32           1723      JSR    PRINT_OP_ROL
00001BB0  6000 0134               1724      BRA    GROUPE_SUCCESS
00001BB4                          1725   
00001BB4                          1726  CHECK_OP_LSR_NO_ROT:
00001BB4  3038 4000               1727      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BB8  0240 FFC0               1728      ANDI.W #$FFC0,D0
00001BBC  B07C E2C0               1729      CMP.W  #$E2C0,D0
00001BC0  6600 000C               1730      BNE    CHECK_OP_LSL_NO_ROT
00001BC4  4EB9 00001F02           1731      JSR    PRINT_OP_LSR
00001BCA  6000 011A               1732      BRA    GROUPE_SUCCESS
00001BCE                          1733  
00001BCE                          1734  CHECK_OP_LSL_NO_ROT:
00001BCE  3038 4000               1735      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BD2  0240 FFC0               1736      ANDI.W #$FFC0,D0
00001BD6  B07C E3C0               1737      CMP.W  #$E3C0,D0
00001BDA  6600 000C               1738      BNE    CHECK_OP_ASR_NO_ROT
00001BDE  4EB9 00001EF2           1739      JSR    PRINT_OP_LSL
00001BE4  6000 0100               1740      BRA    GROUPE_SUCCESS
00001BE8                          1741  
00001BE8                          1742  CHECK_OP_ASR_NO_ROT:
00001BE8  3038 4000               1743      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BEC  0240 FFC0               1744      ANDI.W #$FFC0,D0
00001BF0  B07C E0C0               1745      CMP.W  #$E0C0,D0
00001BF4  6600 000C               1746      BNE    CHECK_OP_ASL_NO_ROT
00001BF8  4EB9 00001F12           1747      JSR    PRINT_OP_ASR
00001BFE  6000 00E6               1748      BRA    GROUPE_SUCCESS
00001C02                          1749              
00001C02                          1750  CHECK_OP_ASL_NO_ROT:
00001C02  3038 4000               1751      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C06  0240 FFC0               1752      ANDI.W #$FFC0,D0
00001C0A  B07C E1C0               1753      CMP.W  #$E1C0,D0
00001C0E  6600 000C               1754      BNE    CHECK_OP_ROXR
00001C12  4EB9 00001F22           1755      JSR    PRINT_OP_ASL
00001C18  6000 00CC               1756      BRA    GROUPE_SUCCESS
00001C1C                          1757  
00001C1C                          1758  *Unsupported OP codes
00001C1C                          1759  CHECK_OP_ROXR:
00001C1C  3038 4000               1760      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C20  0240 F118               1761      ANDI.W #$F118,D0
00001C24  B07C E010               1762      CMP.W  #$E010,D0
00001C28  6700 00B6               1763      BEQ    GROUPE_INVALID
00001C2C  6600 0002               1764      BNE    CHECK_OP_ROXL
00001C30                          1765      
00001C30                          1766  CHECK_OP_ROXL:
00001C30  3038 4000               1767      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C34  0240 F118               1768      ANDI.W #$F118,D0
00001C38  B07C E110               1769      CMP.W  #$E110,D0
00001C3C  6700 00A2               1770      BEQ    GROUPE_INVALID
00001C40  6600 0002               1771      BNE    CHECK_OP_ROR
00001C44                          1772      
00001C44                          1773  *Supported OP codes
00001C44                          1774  CHECK_OP_ROR:
00001C44  3038 4000               1775      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C48  0240 F118               1776      ANDI.W #$F118,D0
00001C4C  B07C E018               1777      CMP.W  #$E018,D0
00001C50  6600 000C               1778      BNE    CHECK_OP_ROL
00001C54  4EB9 00001F42           1779      JSR    PRINT_OP_ROR
00001C5A  6000 008A               1780      BRA    GROUPE_SUCCESS
00001C5E                          1781  
00001C5E                          1782  CHECK_OP_ROL:
00001C5E  3038 4000               1783      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C62  0240 F118               1784      ANDI.W #$F118,D0
00001C66  B07C E118               1785      CMP.W  #$E118,D0
00001C6A  6600 000C               1786      BNE    CHECK_OP_LSR
00001C6E  4EB9 00001F32           1787      JSR    PRINT_OP_ROL
00001C74  6000 0070               1788      BRA    GROUPE_SUCCESS
00001C78                          1789      
00001C78                          1790  CHECK_OP_LSR:
00001C78  3038 4000               1791      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C7C  0240 F118               1792      ANDI.W #$F118,D0
00001C80  B07C E008               1793      CMP.W  #$E008,D0
00001C84  6600 000C               1794      BNE    CHECK_OP_LSL
00001C88  4EB9 00001F02           1795      JSR    PRINT_OP_LSR
00001C8E  6000 0056               1796      BRA    GROUPE_SUCCESS
00001C92                          1797  
00001C92                          1798  CHECK_OP_LSL:
00001C92  3038 4000               1799      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C96  0240 F118               1800      ANDI.W #$F118,D0
00001C9A  B07C E108               1801      CMP.W  #$E108,D0
00001C9E  6600 000C               1802      BNE    CHECK_OP_ASR
00001CA2  4EB9 00001EF2           1803      JSR    PRINT_OP_LSL
00001CA8  6000 003C               1804      BRA    GROUPE_SUCCESS
00001CAC                          1805  
00001CAC                          1806  CHECK_OP_ASR:
00001CAC  3038 4000               1807      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CB0  0240 F118               1808      ANDI.W #$F118,D0
00001CB4  B07C E000               1809      CMP.W  #$E000,D0
00001CB8  6600 000C               1810      BNE    CHECK_OP_ASL
00001CBC  4EB9 00001F12           1811      JSR    PRINT_OP_ASR
00001CC2  6000 0022               1812      BRA    GROUPE_SUCCESS
00001CC6                          1813  
00001CC6                          1814  CHECK_OP_ASL:
00001CC6  3038 4000               1815      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CCA  0240 F118               1816      ANDI.W #$F118,D0
00001CCE  B07C E100               1817      CMP.W  #$E100,D0
00001CD2  6600 000C               1818      BNE    GROUPE_INVALID      ;Last possible OP code
00001CD6  4EB9 00001F22           1819      JSR    PRINT_OP_ASL
00001CDC  6000 0008               1820      BRA    GROUPE_SUCCESS
00001CE0                          1821  
00001CE0                          1822  GROUPE_INVALID:
00001CE0  4EB9 00001CF4           1823      JSR     INVALID_OP
00001CE6                          1824      
00001CE6                          1825  GROUPE_SUCCESS:
00001CE6  4CDF 0001               1826      MOVEM.L (SP)+,D0
00001CEA  4E75                    1827      RTS
00001CEC                          1828  * GROUP_F
00001CEC                          1829  ********************************************************************************
00001CEC                          1830  * Currently no OP codes here are supported. There are no OP codes here
00001CEC                          1831  ********************************************************************************
00001CEC                          1832  C_GROUP_F:
00001CEC  4EB9 00001CF4           1833      JSR INVALID_OP
00001CF2  4E75                    1834      RTS
00001CF4                          1835      
00001CF4                          1836  * INVALID_OP                     
00001CF4                          1837  ********************************************************************************
00001CF4                          1838  * Any value that is not covered in the above groups would be considered invalid. 
00001CF4                          1839  * The following values in the first nibble would also indicate that the 
00001CF4                          1840  * operand codes is already invalid: $7, $A, $F.
00001CF4                          1841  * For unsupported OP codes, display DATA $WXYZ   
00001CF4                          1842  * THIS WILL NEED TO BE CHANGED TO DISPLAY: 1000 DATA $WXYZ IN THE FUTURE
00001CF4                          1843  ********************************************************************************
00001CF4                          1844  INVALID_OP:  ; Prints DATA for invalid op, THIS SHOULD BE SETTING THE IS_VALID BIT TO 0
00001CF4  23FC 00001F5A 0000203A  1845      MOVE.L #P_INVALID_OP, Arg_AddStrToBuffer_String
00001CFE  4EB9 00001D10           1846      JSR PRINT_TO_BUFFER
00001D04  11FC 0000 10B5          1847      MOVE.B #0,IS_VALID
00001D0A  4E75                    1848      RTS
00001D0C                          1849      
00001D0C                          1850  READ_NEXT_INSTRUCTION: ; Needs to read next instruction set {PLACEHOLDER}
00001D0C  FFFF FFFF               1851      SIMHALT
00001D10                          1852  
00001D10                          1853  ********************** PRINTING ROUTINES **************************************
00001D10                          1854  * Description: These routines are to print the associated op codes, by placing
00001D10                          1855  * them in the appropriate area to the buffer
00001D10                          1856  *
00001D10                          1857  * Registers used: A1 for loading, A6 for EA parsing.
00001D10                          1858  *
00001D10                          1859  * Precondition: The relevant opcode has been identified correctly.
00001D10                          1860  *
00001D10                          1861  * Postcondition: Prints out the associated opcode to the buffer.
00001D10                          1862  
00001D10                          1863  * THIS NEEDS TO BE RETOOLED TO PRINT TO BUFFER NOT TO CONSOLE
00001D10                          1864  *******************************************************************************
00001D10                          1865  
00001D10                          1866  * Prints the loaded item into G_BUFFER
00001D10                          1867  PRINT_TO_BUFFER:
00001D10  23FC 00004100 0000203E  1868      MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer
00001D1A  4EB9 00002048           1869      JSR AddStrToBuffer
00001D20  4E75                    1870      RTS
00001D22                          1871      
00001D22                          1872  
00001D22                          1873  ****************************** GROUP 0 **************************************** 
00001D22                          1874  PRINT_OP_ORI:
00001D22  23FC 00001F77 0000203A  1875      MOVE.L #P_OP_ORI, Arg_AddStrToBuffer_String
00001D2C  4EB8 1D10               1876      JSR PRINT_TO_BUFFER
00001D30  4E75                    1877      RTS
00001D32                          1878  PRINT_OP_CMPI:
00001D32  23FC 00001F7B 0000203A  1879      MOVE.L #P_OP_CMPI, Arg_AddStrToBuffer_String
00001D3C  4EB8 1D10               1880      JSR PRINT_TO_BUFFER
00001D40  4E75                    1881      RTS
00001D42                          1882  PRINT_OP_STATIC_BCLR:
00001D42  23FC 00001F80 0000203A  1883      MOVE.L #P_OP_STATIC_BCLR, Arg_AddStrToBuffer_String
00001D4C  4EB8 1D10               1884      JSR PRINT_TO_BUFFER
00001D50  4E75                    1885      RTS
00001D52                          1886  PRINT_OP_DYNAMIC_BCLR:
00001D52  23FC 00001F85 0000203A  1887      MOVE.L #P_OP_DYNAMIC_BCLR, Arg_AddStrToBuffer_String
00001D5C  4EB8 1D10               1888      JSR PRINT_TO_BUFFER
00001D60  4E75                    1889      RTS
00001D62                          1890  ******************************* END OF GROUP 0 ********************************
00001D62                          1891  
00001D62                          1892  ****************************** GROUP 1 ****************************************    
00001D62                          1893  PRINT_OP_MOVEB:
00001D62  23FC 00001F8A 0000203A  1894      MOVE.L #P_OP_MOVEB, Arg_AddStrToBuffer_String
00001D6C  4EB8 1D10               1895      JSR PRINT_TO_BUFFER
00001D70  4E75                    1896      RTS
00001D72                          1897  ******************************* END OF GROUP 1 ********************************
00001D72                          1898      
00001D72                          1899  ****************************** GROUP 2 **************************************** 
00001D72                          1900  PRINT_OP_MOVEA_L:
00001D72  23FC 00001F92 0000203A  1901      MOVE.L #P_OP_MOVEA_L, Arg_AddStrToBuffer_String
00001D7C  4EB8 1D10               1902      JSR PRINT_TO_BUFFER
00001D80  4E75                    1903      RTS
00001D82                          1904  PRINT_OP_MOVE_L:
00001D82  23FC 00001F9E 0000203A  1905      MOVE.L #P_OP_MOVE_L, Arg_AddStrToBuffer_String
00001D8C  4EB8 1D10               1906      JSR PRINT_TO_BUFFER
00001D90  4E75                    1907      RTS
00001D92                          1908  ******************************* END OF GROUP 2 ********************************
00001D92                          1909      
00001D92                          1910  ****************************** GROUP 3 ****************************************    
00001D92                          1911  PRINT_OP_MOVEA_W:
00001D92  23FC 00001FA6 0000203A  1912      MOVE.L #P_OP_MOVEA_W, Arg_AddStrToBuffer_String
00001D9C  4EB8 1D10               1913      JSR PRINT_TO_BUFFER
00001DA0  4E75                    1914      RTS
00001DA2                          1915  PRINT_OP_MOVE_W:
00001DA2  23FC 00001FB2 0000203A  1916      MOVE.L #P_OP_MOVE_W, Arg_AddStrToBuffer_String
00001DAC  4EB8 1D10               1917      JSR PRINT_TO_BUFFER
00001DB0  4E75                    1918      RTS
00001DB2                          1919  ******************************* END OF GROUP 3 ********************************
00001DB2                          1920  
00001DB2                          1921  ****************************** GROUP 4 ****************************************
00001DB2                          1922  PRINT_OP_JSR:
00001DB2  23FC 00001FD6 0000203A  1923      MOVE.L #P_OP_JSR, Arg_AddStrToBuffer_String
00001DBC  4EB8 1D10               1924      JSR PRINT_TO_BUFFER
00001DC0  4E75                    1925      RTS
00001DC2                          1926  PRINT_OP_RTS:
00001DC2  23FC 00001FDE 0000203A  1927      MOVE.L #P_OP_RTS, Arg_AddStrToBuffer_String
00001DCC  4EB8 1D10               1928      JSR PRINT_TO_BUFFER
00001DD0  4E75                    1929      RTS
00001DD2                          1930  PRINT_OP_LEA:
00001DD2  23FC 00001FD2 0000203A  1931      MOVE.L #P_OP_LEA, Arg_AddStrToBuffer_String
00001DDC  4EB8 1D10               1932      JSR PRINT_TO_BUFFER
00001DE0  4E75                    1933      RTS
00001DE2                          1934  PRINT_OP_NEG:
00001DE2  23FC 00001FE2 0000203A  1935      MOVE.L #P_OP_NEG, Arg_AddStrToBuffer_String
00001DEC  4EB8 1D10               1936      JSR PRINT_TO_BUFFER
00001DF0  4E75                    1937      RTS
00001DF2                          1938  PRINT_OP_MOVEM_W:
00001DF2  23FC 00001FBA 0000203A  1939      MOVE.L #P_OP_MOVEM_W, Arg_AddStrToBuffer_String
00001DFC  4EB8 1D10               1940      JSR PRINT_TO_BUFFER
00001E00  4E75                    1941      RTS
00001E02                          1942  PRINT_OP_MOVEM_L:
00001E02  23FC 00001FC6 0000203A  1943      MOVE.L #P_OP_MOVEM_L, Arg_AddStrToBuffer_String
00001E0C  4EB8 1D10               1944      JSR PRINT_TO_BUFFER
00001E10  4E75                    1945      RTS
00001E12                          1946  ******************************* END OF GROUP 4 ********************************
00001E12                          1947      
00001E12                          1948  ****************************** GROUP 5 ****************************************
00001E12                          1949  PRINT_OP_SUBQ:
00001E12  23FC 00001FE6 0000203A  1950      MOVE.L #P_OP_SUBQ, Arg_AddStrToBuffer_String
00001E1C  4EB8 1D10               1951      JSR PRINT_TO_BUFFER
00001E20  4E75                    1952      RTS
00001E22                          1953  ******************************* END OF GROUP 5 ********************************
00001E22                          1954  
00001E22                          1955  ****************************** GROUP 6 ****************************************
00001E22                          1956  PRINT_OP_BCS:
00001E22  23FC 00001FEF 0000203A  1957      MOVE.L #P_OP_BCS, Arg_AddStrToBuffer_String
00001E2C  4EB8 1D10               1958      JSR PRINT_TO_BUFFER
00001E30  4E75                    1959      RTS
00001E32                          1960  PRINT_OP_BGE:
00001E32  23FC 00001FF3 0000203A  1961      MOVE.L #P_OP_BGE, Arg_AddStrToBuffer_String
00001E3C  4EB8 1D10               1962      JSR PRINT_TO_BUFFER
00001E40  4E75                    1963      RTS
00001E42                          1964  PRINT_OP_BLT:
00001E42  23FC 00001FF7 0000203A  1965      MOVE.L #P_OP_BLT, Arg_AddStrToBuffer_String
00001E4C  4EB8 1D10               1966      JSR PRINT_TO_BUFFER
00001E50  4E75                    1967      RTS
00001E52                          1968  PRINT_OP_BVC:
00001E52  23FC 00001FFB 0000203A  1969      MOVE.L #P_OP_BVC, Arg_AddStrToBuffer_String
00001E5C  4EB8 1D10               1970      JSR PRINT_TO_BUFFER
00001E60  4E75                    1971      RTS
00001E62                          1972  PRINT_OP_BRA:
00001E62  23FC 00001FEB 0000203A  1973      MOVE.L #P_OP_BRA, Arg_AddStrToBuffer_String
00001E6C  4EB8 1D10               1974      JSR PRINT_TO_BUFFER
00001E70  4E75                    1975      RTS
00001E72                          1976  ******************************* END OF GROUP 6 ********************************
00001E72                          1977  
00001E72                          1978  ****************************** GROUP 7 ****************************************
00001E72                          1979  * No currently supported OP codes to print here.
00001E72                          1980  ******************************* END OF GROUP 7 ********************************
00001E72                          1981  
00001E72                          1982  ****************************** GROUP 8 ****************************************
00001E72                          1983  PRINT_OP_DIVS:
00001E72  23FC 00001FFF 0000203A  1984      MOVE.L #P_OP_DIVS, Arg_AddStrToBuffer_String
00001E7C  4EB8 1D10               1985      JSR PRINT_TO_BUFFER
00001E80  4E75                    1986      RTS
00001E82                          1987  PRINT_OP_OR:
00001E82  23FC 00002004 0000203A  1988      MOVE.L #P_OP_OR, Arg_AddStrToBuffer_String
00001E8C  4EB8 1D10               1989      JSR PRINT_TO_BUFFER
00001E90  4E75                    1990      RTS
00001E92                          1991  ******************************* END OF GROUP 8 ********************************
00001E92                          1992  
00001E92                          1993  ****************************** GROUP 9 ****************************************
00001E92                          1994  PRINT_OP_SUB:
00001E92  23FC 00002007 0000203A  1995      MOVE.L #P_OP_SUB, Arg_AddStrToBuffer_String
00001E9C  4EB8 1D10               1996      JSR PRINT_TO_BUFFER
00001EA0  4E75                    1997      RTS
00001EA2                          1998  ******************************* END OF GROUP 9 ********************************
00001EA2                          1999  
00001EA2                          2000  ****************************** GROUP A ****************************************
00001EA2                          2001  * No currently supported OP codes to print here.
00001EA2                          2002  ******************************* END OF GROUP A ********************************
00001EA2                          2003  
00001EA2                          2004  ****************************** GROUP B ****************************************
00001EA2                          2005  PRINT_OP_EOR:
00001EA2  23FC 0000200B 0000203A  2006      MOVE.L #P_OP_EOR, Arg_AddStrToBuffer_String
00001EAC  4EB8 1D10               2007      JSR PRINT_TO_BUFFER
00001EB0  4E75                    2008      RTS
00001EB2                          2009  PRINT_OP_CMP:
00001EB2  23FC 0000200F 0000203A  2010      MOVE.L #P_OP_CMP, Arg_AddStrToBuffer_String
00001EBC  4EB8 1D10               2011      JSR PRINT_TO_BUFFER
00001EC0  4E75                    2012      RTS
00001EC2                          2013  ******************************* END OF GROUP B ********************************
00001EC2                          2014  
00001EC2                          2015  ****************************** GROUP C ****************************************
00001EC2                          2016  PRINT_OP_MULS:
00001EC2  23FC 00002013 0000203A  2017      MOVE.L #P_OP_MULS, Arg_AddStrToBuffer_String
00001ECC  4EB8 1D10               2018      JSR PRINT_TO_BUFFER
00001ED0  4E75                    2019      RTS
00001ED2                          2020  ******************************* END OF GROUP C ********************************
00001ED2                          2021  
00001ED2                          2022  ****************************** GROUP D ****************************************
00001ED2                          2023  PRINT_OP_ADD:
00001ED2  23FC 0000201D 0000203A  2024      MOVE.L #P_OP_ADD, Arg_AddStrToBuffer_String
00001EDC  4EB8 1D10               2025      JSR PRINT_TO_BUFFER
00001EE0  4E75                    2026      RTS
00001EE2                          2027  PRINT_OP_ADDA:
00001EE2  23FC 00002018 0000203A  2028      MOVE.L #P_OP_ADDA, Arg_AddStrToBuffer_String
00001EEC  4EB8 1D10               2029      JSR PRINT_TO_BUFFER
00001EF0  4E75                    2030      RTS
00001EF2                          2031  
00001EF2                          2032  ******************************* END OF GROUP D ********************************
00001EF2                          2033  
00001EF2                          2034  ****************************** GROUP E ****************************************
00001EF2                          2035  PRINT_OP_LSL:
00001EF2  23FC 00002025 0000203A  2036      MOVE.L #P_OP_LSL, Arg_AddStrToBuffer_String
00001EFC  4EB8 1D10               2037      JSR PRINT_TO_BUFFER
00001F00  4E75                    2038      RTS
00001F02                          2039  PRINT_OP_LSR:
00001F02  23FC 00002021 0000203A  2040      MOVE.L #P_OP_LSR, Arg_AddStrToBuffer_String
00001F0C  4EB8 1D10               2041      JSR PRINT_TO_BUFFER
00001F10  4E75                    2042      RTS
00001F12                          2043  PRINT_OP_ASR:
00001F12  23FC 00002029 0000203A  2044      MOVE.L #P_OP_ASR, Arg_AddStrToBuffer_String
00001F1C  4EB8 1D10               2045      JSR PRINT_TO_BUFFER
00001F20  4E75                    2046      RTS
00001F22                          2047  PRINT_OP_ASL:
00001F22  23FC 0000202D 0000203A  2048      MOVE.L #P_OP_ASL, Arg_AddStrToBuffer_String
00001F2C  4EB8 1D10               2049      JSR PRINT_TO_BUFFER
00001F30  4E75                    2050      RTS
00001F32                          2051  PRINT_OP_ROL:
00001F32  23FC 00002035 0000203A  2052      MOVE.L #P_OP_ROL, Arg_AddStrToBuffer_String
00001F3C  4EB8 1D10               2053      JSR PRINT_TO_BUFFER
00001F40  4E75                    2054      RTS
00001F42                          2055  PRINT_OP_ROR:
00001F42  23FC 00002031 0000203A  2056      MOVE.L #P_OP_ROR, Arg_AddStrToBuffer_String
00001F4C  4EB8 1D10               2057      JSR PRINT_TO_BUFFER
00001F50  4E75                    2058      RTS
00001F52                          2059  ******************************* END OF GROUP E ********************************
00001F52                          2060  
00001F52                          2061  ****************************** GROUP F ****************************************
00001F52                          2062  * No currently supported OP codes to print here.
00001F52                          2063  ******************************* END OF GROUP F ********************************
00001F52                          2064  
00001F52                          2065  
00001F52                          2066  
00001F52                          2067  PRINT_OP:   ;Prints current op code byte
00001F52                          2068      ;MOVE.W (A4),(A1)       ; NEEDS TO USE G_BUFFER LATER
00001F52  103C 000D               2069      MOVE.B #13,D0
00001F56  4E4F                    2070      TRAP #15
00001F58  4E75                    2071      RTS
00001F5A                          2072  ******************* END OF PRINTING ROUTINES **********************************
00001F5A                          2073  
00001F5A                          2074  ******************* END OF JMP LABELS *****************************************
00001F5A                          2075  
00001F5A                          2076  ******************* DATA CONSTANT PRINTS **************************************
00001F5A                          2077  * Formatting is as follows: P_OP_<OPCODE>, where P = Print, OP = Operation,
00001F5A                          2078  * <OPCODE> is any valid operand
00001F5A                          2079  
00001F5A= 44 41 54 41 20 20 ...   2080  P_INVALID_OP    DC.B    'DATA   ',0
00001F62= 46 6F 75 6E 64 20 ...   2081  OP_FOUND        DC.B    'Found OP',0 ; this should be taken out later
00001F6B= 2E 42 20 00             2082  P_SIZE_B        DC.B    '.B ',0
00001F6F= 2E 57 20 00             2083  P_SIZE_W        DC.B    '.W ',0
00001F73= 2E 4C 20 00             2084  P_SIZE_L        DC.B    '.L ',0
00001F77= 4F 52 49 00             2085  P_OP_ORI        DC.B    'ORI',0
00001F7B= 43 4D 50 49 00          2086  P_OP_CMPI       DC.B    'CMPI',0
00001F80= 42 43 4C 52 00          2087  P_OP_STATIC_BCLR     DC.B    'BCLR',0
00001F85= 42 43 4C 52 00          2088  P_OP_DYNAMIC_BCLR     DC.B    'BCLR',0
00001F8A= 4D 4F 56 45 2E 42 ...   2089  P_OP_MOVEB      DC.B    'MOVE.B ',0
00001F92= 4D 4F 56 45 41 2E ...   2090  P_OP_MOVEA_L    DC.B    'MOVEA.L    ',0 
00001F9E= 4D 4F 56 45 2E 4C ...   2091  P_OP_MOVE_L     DC.B    'MOVE.L ',0
00001FA6= 4D 4F 56 45 41 2E ...   2092  P_OP_MOVEA_W    DC.B    'MOVEA.W    ',0
00001FB2= 4D 4F 56 45 2E 57 ...   2093  P_OP_MOVE_W     DC.B    'MOVE.W ',0
00001FBA= 4D 4F 56 45 4D 2E ...   2094  P_OP_MOVEM_W    DC.B    'MOVEM.W    ',0
00001FC6= 4D 4F 56 45 4D 2E ...   2095  P_OP_MOVEM_L    DC.B    'MOVEM.L    ',0
00001FD2= 4C 45 41 00             2096  P_OP_LEA        DC.B    'LEA',0
00001FD6= 4A 53 52 00             2097  P_OP_JSR        DC.B    'JSR',0
00001FDA= 4E 4F 50 00             2098  P_OP_NOP        DC.B    'NOP',0
00001FDE= 52 54 53 00             2099  P_OP_RTS        DC.B    'RTS',0
00001FE2= 4E 45 47 00             2100  P_OP_NEG        DC.B    'NEG',0
00001FE6= 53 55 42 51 00          2101  P_OP_SUBQ       DC.B    'SUBQ',0
00001FEB= 42 52 41 00             2102  P_OP_BRA        DC.B    'BRA',0
00001FEF= 42 43 53 00             2103  P_OP_BCS        DC.B    'BCS',0
00001FF3= 42 47 45 00             2104  P_OP_BGE        DC.B    'BGE',0
00001FF7= 42 4C 54 00             2105  P_OP_BLT        DC.B    'BLT',0
00001FFB= 42 56 43 00             2106  P_OP_BVC        DC.B    'BVC',0
00001FFF= 44 49 56 53 00          2107  P_OP_DIVS       DC.B    'DIVS',0
00002004= 4F 52 00                2108  P_OP_OR         DC.B    'OR',0
00002007= 53 55 42 00             2109  P_OP_SUB        DC.B    'SUB',0
0000200B= 45 4F 52 00             2110  P_OP_EOR        DC.B    'EOR',0
0000200F= 43 4D 50 00             2111  P_OP_CMP        DC.B    'CMP',0
00002013= 4D 55 4C 53 00          2112  P_OP_MULS       DC.B    'MULS',0
00002018= 41 44 44 41 00          2113  P_OP_ADDA       DC.B    'ADDA',0
0000201D= 41 44 44 00             2114  P_OP_ADD        DC.B    'ADD',0
00002021= 4C 53 52 00             2115  P_OP_LSR        DC.B    'LSR',0
00002025= 4C 53 4C 00             2116  P_OP_LSL        DC.B    'LSL',0
00002029= 41 53 52 00             2117  P_OP_ASR        DC.B    'ASR',0
0000202D= 41 53 4C 00             2118  P_OP_ASL        DC.B    'ASL',0
00002031= 52 4F 52 00             2119  P_OP_ROR        DC.B    'ROR',0
00002035= 52 4F 4C 00             2120  P_OP_ROL        DC.B    'ROL',0
00002039                          2121  ***************** END OF DATA CONSTANT PRINTS ***********************************
00002039                          2122   
00002039                          2123  
00002039                          2124  **
00002039                          2125  * AddStrToBuffer
00002039                          2126  **
00002039                          2127  * Adds the given NULL-terminated string to the specified buffer.
00002039                          2128  *
00002039                          2129  * Default buffer length is 80 characters, but can be modified in the argument
00002039                          2130  * variables.
00002039                          2131  *
00002039                          2132  * If the buffer length is exceeded, either due to lack of a NULL character or
00002039                          2133  * an incorrectly specified length, 1 is returned. Otherwise, 0 is returned to
00002039                          2134  * indicate success.
00002039                          2135  *
00002039                          2136  **
00002039                          2137  * @param Arg_AddStrToBuffer_String              Pointer to string
00002039                          2138  * @param Arg_AddStrToBuffer_Buffer              Pointer to buffer
00002039                          2139  * @param Arg_AddStrToBuffer_BufferLength        Length of buffer (default 80 chars)
00002039                          2140  * @return Ret_AddStrToBuffer_Success            0 if successful, 1 otherwise.
00002039                          2141  * @branch _AddStrToBuffer_FindBufferNullLoop    Loop to find NULL in buffer
00002039                          2142  * @branch _AddStrToBuffer_AddLoop               Loop to add string to buffer
00002039                          2143  * @branch _AddStrToBuffer_Success               Branch when string successfully added
00002039                          2144  * @branch _AddStrToBuffer_StringLengthExceeded  Branch when length exceeded (either string or buffer)
00002039                          2145  * @branch _AddStrToBuffer_End                   End of subroutine
00002039                          2146  **
0000203A                          2147  Arg_AddStrToBuffer_String           DS.L    1
0000203E                          2148  Arg_AddStrToBuffer_Buffer           DS.L    1
00002042= 00000050                2149  Arg_AddStrToBuffer_BufferLength     DC.L    80
00002046                          2150  Ret_AddStrToBuffer_Success          DS.B    1
00002047                          2151  
00002048                          2152  AddStrToBuffer:                     DS.W    0
00002048  48E7 C0C0               2153      MOVEM.L     D0-D1/A0-A1, -(SP)                  * Backup registers to stack
0000204C                          2154  
0000204C  2078 203A               2155      MOVE.L      Arg_AddStrToBuffer_String, A0       * Load string pointer
00002050  2278 203E               2156      MOVE.L      Arg_AddStrToBuffer_Buffer, A1       * Load buffer pointer
00002054  2038 2042               2157      MOVE.L      Arg_AddStrToBuffer_BufferLength, D0 * Load buffer length
00002058  4278 2046               2158      CLR.W       Ret_AddStrToBuffer_Success          * Clear success bit
0000205C  4281                    2159      CLR.L       D1                                  * Clear loop counter
0000205E                          2160  
0000205E                          2161  _AddStrToBuffer_BufferLoop
0000205E  0C11 0000               2162      CMPI.B      #0, (A1)                            * If buffer char is NULL
00002062  6700 000E               2163      BEQ         _AddStrToBuffer_AddLoop             * Start adding string to bufer
00002066                          2164      
00002066  B280                    2165      CMP.L       D0, D1                              * If counter >= max length
00002068  6C00 0026               2166      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
0000206C                          2167      
0000206C  5289                    2168      ADDQ.L      #1, A1                              * Go to next character
0000206E  5201                    2169      ADDQ.B      #1, D1                              * Increment counter
00002070  60EC                    2170      BRA         _AddStrToBuffer_BufferLoop          * Loop back
00002072                          2171      
00002072                          2172  _AddStrToBuffer_AddLoop
00002072  0C10 0000               2173      CMPI.B      #0, (A0)                            * If string char is NULL
00002076  6700 0010               2174      BEQ         _AddStrToBuffer_Success             * String successfully added
0000207A                          2175      
0000207A  B200                    2176      CMP.B       D0, D1                              * If counter >= max length
0000207C  6C00 0012               2177      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
00002080                          2178      
00002080  12D8                    2179      MOVE.B      (A0)+, (A1)+                        * Move string char to buffer char
00002082  528C                    2180      ADDQ.L      #1, A4
00002084  5201                    2181      ADDQ.B      #1, D1                              * Increment counter
00002086  60EA                    2182      BRA         _AddStrToBuffer_AddLoop             * Loop back
00002088                          2183  
00002088                          2184  _AddStrToBuffer_Success
00002088  12BC 0000               2185      MOVE.B      #0, (A1)                            * Add NULL to end of string
0000208C  6000 0008               2186      BRA         _AddStrToBuffer_End                 * Finish subroutine
00002090                          2187  
00002090                          2188  _AddStrToBuffer_LengthExceeded
00002090  31FC 0001 2046          2189      MOVE.W      #1, Ret_AddStrToBuffer_Success      * Invalidate success bit
00002096                          2190  
00002096                          2191  _AddStrToBuffer_End
00002096  4CDF 0303               2192      MOVEM.L     (SP)+, D0-D1/A0-A1                  * Restore registers from stack
0000209A  4E75                    2193      RTS                  
0000209C                          2194     
0000209C                          2195     
0000209C                          2196  ;DENNY_EA_SHIT:
0000209C                          2197  
0000209C                          2198  ;    MOVEA.L #0, A5
0000209C                          2199   ;   MOVEA.L #START_ADDRESS, A5
0000209C                          2200    ;  JSR     PARSE_EA_CONSTANT_BITS
0000209C                          2201     ; JSR     CHECK_XXXX
0000209C                          2202  
0000209C                          2203  
0000209C                          2204  **************************************************
0000209C                          2205  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000209C                          2206   
0000209C                          2207  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000209C                          2208  * EXECUTION **************************************
0000209C                          2209   * TEST FOR MOVE.L
0000209C                          2210      *MOVE.B  #%0100, MNEMONIC
0000209C                          2211      *MOVE.B  #%001, FIRST_3
0000209C                          2212      ;MOVE.B  #%111, SECOND_3
0000209C                          2213      ;MOVE.B  #%111, THIRD_3
0000209C                          2214      ;MOVE.B  #%000, FOURTH_3
0000209C                          2215      ;MOVEA.L #START_ADDRESS, A5
0000209C                          2216  
0000209C                          2217      ;CHECK IF IS_VALID = 0
0000209C                          2218      ;IF SO SKIP TO RUN_FAHAD_CODE
0000209C                          2219  
0000209C                          2220  DENNY_EA_SHIT:
0000209C                          2221  
0000209C  2A7C 00000000           2222      MOVEA.L #0, A5
000020A2  2A7C 00004000           2223      MOVEA.L #START_ADDRESS, A5
000020A8  4EB8 12AC               2224      JSR     PARSE_EA_CONSTANT_BITS
000020AC  4EB9 000020BC           2225      JSR     CHECK_XXXX              ;When it returns here, Denny's routines have finished
000020B2                          2226      ;CHECK IF IS_VALID = 0
000020B2                          2227  
000020B2  4EF9 000020B8           2228  EXT JMP RUN_FAHAD_CODE
000020B8                          2229  
000020B8  FFFF FFFF               2230  RUN_FAHAD_CODE SIMHALT * This EXT alias is critical for NOT loading error
000020BC                          2231  
000020BC                          2232  ;RUN_FAHAD_CODE here would do something like
000020BC                          2233  ;
000020BC                          2234  **************************************************
000020BC                          2235  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000020BC                          2236  
000020BC                          2237  
000020BC                          2238  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000020BC                          2239  * CHECK_MNEMONIC FUNCTIONS ***************
000020BC                          2240  
000020BC                          2241  * <EA>
000020BC                          2242  **********************************************************************************
000020BC                          2243  * Description: Checks the mnemonic starting from XXXX
000020BC                          2244  *
000020BC                          2245  * Registers used: X
000020BC                          2246  *
000020BC                          2247  * Precondition: X
000020BC                          2248  *
000020BC                          2249  * Postcondition: X
000020BC                          2250  **********************************************************************************
000020BC                          2251  CHECK_XXXX:
000020BC  0C38 0008 1000          2252      CMPI.B  #$8, MNEMONIC
000020C2  6D00 0008               2253      BLT     CHECK_0XXX
000020C6  4EF9 000020DC           2254      JMP     CHECK_1XXX
000020CC                          2255  
000020CC                          2256  * <EA>
000020CC                          2257  **********************************************************************************
000020CC                          2258  * Description: Checks the mnemonic starting from 0XXX
000020CC                          2259  *
000020CC                          2260  * Registers used: X
000020CC                          2261  *
000020CC                          2262  * Precondition: X
000020CC                          2263  *
000020CC                          2264  * Postcondition: X
000020CC                          2265  **********************************************************************************
000020CC                          2266  CHECK_0XXX:
000020CC  0C38 0004 1000          2267      CMPI.B  #$4, MNEMONIC
000020D2  6D00 003C               2268      BLT     CHECK_00XX
000020D6  4EF9 0000211E           2269      JMP     CHECK_01XX
000020DC                          2270  
000020DC                          2271  * <EA>
000020DC                          2272  **********************************************************************************
000020DC                          2273  * Description: Checks the mnemonic starting from 1XXX
000020DC                          2274  *
000020DC                          2275  * Registers used: X
000020DC                          2276  *
000020DC                          2277  * Precondition: X
000020DC                          2278  *
000020DC                          2279  * Postcondition: X
000020DC                          2280  **********************************************************************************
000020DC                          2281  CHECK_1XXX:
000020DC  0C38 0008 1000          2282      CMPI.B  #$8, MNEMONIC
000020E2  6700 00BE               2283      BEQ     LOAD_1000
000020E6  0C38 0009 1000          2284      CMPI.B  #$9, MNEMONIC
000020EC  6700 00AE               2285      BEQ     LOAD_1001
000020F0  0C38 0011 1000          2286      CMPI.B  #$11, MNEMONIC
000020F6  6700 009E               2287      BEQ     LOAD_1011
000020FA  0C38 0012 1000          2288      CMPI.B  #$12, MNEMONIC
00002100  6700 008E               2289      BEQ     LOAD_1100
00002104  0C38 0013 1000          2290      CMPI.B  #$13, MNEMONIC
0000210A  6700 0028               2291      BEQ     LOAD_1101
0000210E                          2292      
0000210E  4E75                    2293      RTS
00002110                          2294  
00002110                          2295  * <EA>
00002110                          2296  **********************************************************************************
00002110                          2297  * Description: Checks the mnemonic starting from 00XX
00002110                          2298  *
00002110                          2299  * Registers used: X
00002110                          2300  *
00002110                          2301  * Precondition: X
00002110                          2302  *
00002110                          2303  * Postcondition: X
00002110                          2304  **********************************************************************************
00002110                          2305  CHECK_00XX:
00002110  0C38 0001 1000          2306      CMPI.B  #$1, MNEMONIC
00002116  6D00 035E               2307      BLT     LOAD_0000
0000211A  6C00 04C4               2308      BGE     LOAD_00XX
0000211E                          2309  
0000211E                          2310  * <EA>
0000211E                          2311  **********************************************************************************
0000211E                          2312  * Description: Checks the mnemonic starting from 01XX
0000211E                          2313  *
0000211E                          2314  * Registers used: X
0000211E                          2315  *
0000211E                          2316  * Precondition: X
0000211E                          2317  *
0000211E                          2318  * Postcondition: X
0000211E                          2319  **********************************************************************************
0000211E                          2320  CHECK_01XX:
0000211E  0C38 0004 1000          2321      CMPI.B  #%0100, MNEMONIC
00002124  6700 01F8               2322      BEQ     LOAD_0100
00002128  0C38 0005 1000          2323      CMPI.B  #%0101, MNEMONIC
0000212E  6700 0164               2324      BEQ     LOAD_0101
00002132  4E75                    2325      RTS
00002134                          2326  
00002134                          2327  **************************************************
00002134                          2328  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002134                          2329  
00002134                          2330  
00002134                          2331  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002134                          2332  * LOAD_THIS FUNCTIONS (HIGHEST LEVEL) ************
00002134                          2333  * <EA>
00002134                          2334  **********************************************************************************
00002134                          2335  * Description: Once the mnemonic is 1001, it is either ADD or ADDA.
00002134                          2336  *
00002134                          2337  * Registers used: If ADDA, D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch.
00002134                          2338  *                 If ADD, basically recycling the algorithm for DIVS/OR
00002134                          2339  *
00002134                          2340  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
00002134                          2341  *
00002134                          2342  * Postcondition: X
00002134                          2343  **********************************************************************************
00002134                          2344  LOAD_1101:
00002134  0C38 0003 1005          2345              CMPI.B  #%011, SECOND_3
0000213A  6700 0012               2346              BEQ     ADDA
0000213E  0C38 0007 1005          2347              CMPI.B  #%111, SECOND_3
00002144  6700 0008               2348              BEQ     ADDA
00002148                          2349              
00002148  4EF9 000021A2           2350              JMP     LOAD_1000
0000214E                          2351              
0000214E  367C 2166               2352  ADDA        MOVEA.W #ADDA_BACK, A3
00002152  0C38 0000 1007          2353              CMPI.B  #%000, FOURTH_3
00002158  6700 059C               2354              BEQ     SIZE_W
0000215C  0C38 0001 1007          2355              CMPI.B  #%001, FOURTH_3
00002162  6700 059A               2356              BEQ     SIZE_L
00002166                          2357              
00002166  1638 1006               2358  ADDA_BACK   MOVE.B  THIRD_3, D3
0000216A  1438 1007               2359              MOVE.B  FOURTH_3, D2
0000216E                          2360  
0000216E  4EB9 00002644           2361              JSR     LOAD_EA
00002174  4EB9 000027C4           2362              JSR     LOAD_COMMA_SPACE
0000217A                          2363              
0000217A  163C 0001               2364              MOVE.B  #%001, D3
0000217E  1438 1004               2365              MOVE.B  FIRST_3, D2
00002182                          2366              
00002182  4EB9 00002644           2367              JSR     LOAD_EA
00002188  4EB9 000027AC           2368              JSR     LOAD_NEW_LINE
0000218E  4E75                    2369              RTS
00002190                          2370  
00002190                          2371  * <EA>
00002190                          2372  **********************************************************************************
00002190                          2373  * Description: Once the mnemonic is 1001, it is MULS.
00002190                          2374  *
00002190                          2375  * Registers used: X. Basically recycling the algorithm for DIVS/OR
00002190                          2376  *
00002190                          2377  * Precondition: X
00002190                          2378  *
00002190                          2379  * Postcondition: X
00002190                          2380  **********************************************************************************
00002190                          2381  LOAD_1100:
00002190  4EF9 000021A2           2382      JMP     LOAD_1000
00002196                          2383      
00002196                          2384  * <EA>
00002196                          2385  **********************************************************************************
00002196                          2386  * Description: Once the mnemonic is 1001, it is either EOR or CMP.
00002196                          2387  *
00002196                          2388  * Registers used: X. Basically recycling the algorithm for DIVS/OR
00002196                          2389  *
00002196                          2390  * Precondition: X
00002196                          2391  *
00002196                          2392  * Postcondition: X
00002196                          2393  **********************************************************************************
00002196                          2394  LOAD_1011:
00002196  4EF9 000021A2           2395      JMP     LOAD_1000
0000219C                          2396  
0000219C                          2397  
0000219C                          2398  * <EA>
0000219C                          2399  **********************************************************************************
0000219C                          2400  * Description: Once the mnemonic is 1001, it is SUB.
0000219C                          2401  *
0000219C                          2402  * Registers used: X. Basically recycling the algorithm for DIVS/OR
0000219C                          2403  *
0000219C                          2404  * Precondition: X
0000219C                          2405  *
0000219C                          2406  * Postcondition: X
0000219C                          2407  **********************************************************************************
0000219C                          2408  LOAD_1001:
0000219C  4EF9 000021A2           2409      JMP     LOAD_1000
000021A2                          2410  
000021A2                          2411  
000021A2                          2412  * <EA>
000021A2                          2413  **********************************************************************************
000021A2                          2414  * Description: Once the mnemonic is 1000, it is either DIVS or OR.
000021A2                          2415  *
000021A2                          2416  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch.
000021A2                          2417  *
000021A2                          2418  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
000021A2                          2419  *
000021A2                          2420  * Postcondition: X
000021A2                          2421  **********************************************************************************
000021A2                          2422  LOAD_1000:
000021A2  4283                    2423              CLR.L   D3
000021A4  4282                    2424              CLR.L   D2
000021A6  267C 00000000           2425              MOVEA.L #0, A3
000021AC                          2426              
000021AC  0C38 0007 1005          2427              CMPI.B  #%111, SECOND_3
000021B2  6700 009E               2428              BEQ     DIVS
000021B6                          2429              
000021B6  0C38 0003 1005          2430              CMPI.B  #%011, SECOND_3
000021BC  6700 06B6               2431              BEQ     INVALID
000021C0                          2432              
000021C0                          2433  ***vvvvvvvvvvvvvvvvvvv***
000021C0  0C38 0004 1005          2434              CMPI.B  #%100, SECOND_3
000021C6  6D00 0006               2435              BLT     DIR_0 * direction bit 0
000021CA  6C00 0044               2436              BGE     DIR_1 * direction bit 1
000021CE                          2437              
000021CE  367C 21E6               2438  DIR_0       MOVEA.W #OR_BACK, A3
000021D2  0C38 0000 1007          2439              CMPI.B  #%000, FOURTH_3
000021D8  6700 051C               2440              BEQ     SIZE_W
000021DC  0C38 0001 1007          2441              CMPI.B  #%001, FOURTH_3
000021E2  6700 051A               2442              BEQ     SIZE_L
000021E6                          2443              
000021E6  1638 1006               2444  OR_BACK     MOVE.B  THIRD_3, D3
000021EA  1438 1007               2445              MOVE.B  FOURTH_3, D2
000021EE                          2446  
000021EE  4EB9 00002644           2447              JSR     LOAD_EA
000021F4  4EB9 000027C4           2448              JSR     LOAD_COMMA_SPACE
000021FA                          2449              
000021FA  163C 0000               2450              MOVE.B  #%000, D3
000021FE  1438 1004               2451              MOVE.B  FIRST_3, D2
00002202                          2452              
00002202  4EB9 00002644           2453              JSR     LOAD_EA
00002208  4EB9 000027AC           2454              JSR     LOAD_NEW_LINE
0000220E  4E75                    2455              RTS
00002210                          2456              
00002210  163C 0000               2457  DIR_1       MOVE.B  #%000, D3
00002214  1438 1004               2458              MOVE.B  FIRST_3, D2
00002218                          2459              
00002218  4EB9 00002644           2460              JSR     LOAD_EA
0000221E  4EB9 000027C4           2461              JSR     LOAD_COMMA_SPACE
00002224                          2462              
00002224  367C 223C               2463              MOVEA.W #OR_BACK2, A3
00002228  0C38 0000 1007          2464              CMPI.B  #%000, FOURTH_3
0000222E  6700 04C6               2465              BEQ     SIZE_W
00002232  0C38 0001 1007          2466              CMPI.B  #%001, FOURTH_3
00002238  6700 04C4               2467              BEQ     SIZE_L
0000223C                          2468              
0000223C  1638 1006               2469  OR_BACK2    MOVE.B  THIRD_3, D3
00002240  1438 1007               2470              MOVE.B  FOURTH_3, D2
00002244                          2471  
00002244  4EB9 00002644           2472              JSR     LOAD_EA
0000224A  4EB9 000027AC           2473              JSR     LOAD_NEW_LINE
00002250  4E75                    2474              RTS    
00002252                          2475  ***^^^^^^^^^^^^^^^^^^^***
00002252                          2476              
00002252                          2477  ***vvvvvvvvvvvvvvvvvvv***
00002252  163C 0000               2478  DIVS        MOVE.B  #%000, D3
00002256  1438 1004               2479              MOVE.B  FIRST_3, D2
0000225A                          2480  
0000225A  4EB9 00002644           2481              JSR     LOAD_EA
00002260  4EB9 000027C4           2482              JSR     LOAD_COMMA_SPACE
00002266                          2483              
00002266  367C 227E               2484              MOVEA.W #DIVS_BACK, A3
0000226A  0C38 0000 1007          2485              CMPI.B  #%000, FOURTH_3
00002270  6700 0484               2486              BEQ     SIZE_W
00002274  0C38 0001 1007          2487              CMPI.B  #%001, FOURTH_3
0000227A  6700 0482               2488              BEQ     SIZE_L
0000227E                          2489              
0000227E  1638 1006               2490  DIVS_BACK   MOVE.B  THIRD_3, D3
00002282  1438 1007               2491              MOVE.B  FOURTH_3, D2
00002286                          2492              
00002286  4EB9 00002644           2493              JSR     LOAD_EA
0000228C  4EB9 000027AC           2494              JSR     LOAD_NEW_LINE
00002292  4E75                    2495              RTS
00002294                          2496  ***^^^^^^^^^^^^^^^^^^^***
00002294                          2497  
00002294                          2498  
00002294                          2499  * <EA>
00002294                          2500  **********************************************************************************
00002294                          2501  * Description: Once the mnemonic is 0101, it is SUBQ
00002294                          2502  *
00002294                          2503  * Registers used: D4 to load the data within the EA bits, and A2 to come back
00002294                          2504  *
00002294                          2505  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
00002294                          2506  *
00002294                          2507  * Postcondition: X
00002294                          2508  **********************************************************************************
00002294                          2509  LOAD_0101:
00002294  4283                    2510              CLR.L   D3
00002296  4282                    2511              CLR.L   D2
00002298  267C 00000000           2512              MOVEA.L #0, A3
0000229E                          2513  
0000229E  0C38 0007 1004          2514              CMPI.B  #%111, FIRST_3
000022A4  6F00 0008               2515              BLE     MYBE_SUBQ1
000022A8  4EF9 00002874           2516              JMP     INVALID
000022AE                          2517              
000022AE  0C38 0003 1005          2518  MYBE_SUBQ1  CMPI.B  #%011, SECOND_3
000022B4  6E00 0008               2519              BGT     MYBE_SUBQ2
000022B8  4EF9 00002874           2520              JMP     INVALID
000022BE                          2521  
000022BE  0C38 0007 1005          2522  MYBE_SUBQ2  CMPI.B  #%111, SECOND_3
000022C4  6D00 0008               2523              BLT     SUBQ
000022C8  4EF9 00002874           2524              JMP     INVALID
000022CE                          2525  
000022CE  5238 1004               2526  SUBQ        ADDI.B  #%1, FIRST_3
000022D2  1838 1004               2527              MOVE.B  FIRST_3, D4
000022D6                          2528              
000022D6  347C 22E0               2529              MOVEA.W #SUBQ_SAVED, A2
000022DA  4EF9 00002778           2530              JMP     LOAD_IMMDTE
000022E0                          2531              
000022E0  4EB9 000027C4           2532  SUBQ_SAVED  JSR     LOAD_COMMA_SPACE
000022E6                          2533  
000022E6  367C 2308               2534              MOVEA.W #SUBQ_BACK, A3
000022EA  0C38 0004 1005          2535              CMPI.B  #%100, SECOND_3
000022F0  6700 03FC               2536              BEQ     SIZE_B
000022F4  0C38 0005 1005          2537              CMPI.B  #%101, SECOND_3
000022FA  6700 03FA               2538              BEQ     SIZE_W
000022FE  0C38 0006 1005          2539              CMPI.B  #%110, SECOND_3
00002304  6700 03F8               2540              BEQ     SIZE_L
00002308                          2541              
00002308  1638 1006               2542  SUBQ_BACK   MOVE.B  THIRD_3, D3
0000230C  1438 1007               2543              MOVE.B  FOURTH_3, D2
00002310                          2544  
00002310  4EB9 00002644           2545              JSR     LOAD_EA
00002316  4EB9 000027AC           2546              JSR     LOAD_NEW_LINE
0000231C  4E75                    2547              RTS
0000231E                          2548  
0000231E                          2549  * <EA>
0000231E                          2550  **********************************************************************************
0000231E                          2551  * Description: Once the mnemonic is 0100, it is either NEG, RTS, JSR, MOVEM, or LEA.
0000231E                          2552  *
0000231E                          2553  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch,
0000231E                          2554  *                 D5, D4 for BCLR, D6 for recognizing MOVEM
0000231E                          2555  *
0000231E                          2556  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000231E                          2557  *
0000231E                          2558  * Postcondition: X
0000231E                          2559  **********************************************************************************
0000231E                          2560  LOAD_0100:
0000231E  4283                    2561              CLR.L   D3
00002320  4282                    2562              CLR.L   D2
00002322  267C 00000000           2563              MOVEA.L #0, A3
00002328                          2564  
00002328  0C38 0002 1004          2565              CMPI.B  #%010, FIRST_3
0000232E  6700 0006               2566              BEQ     MYBE_NEG
00002332  6600 000C               2567              BNE     NOT_NEG
00002336  0C38 0003 1005          2568  MYBE_NEG    CMPI.B  #%011, SECOND_3
0000233C  6D00 0084               2569              BLT     NEG
00002340                          2570  
00002340  0C38 0007 1004          2571  NOT_NEG     CMPI.B  #%111, FIRST_3
00002346  6700 0006               2572              BEQ     MYBE_RTS1
0000234A  6600 0028               2573              BNE     NOT_RTS
0000234E  0C38 0001 1005          2574  MYBE_RTS1   CMPI.B  #%001, SECOND_3
00002354  6700 0006               2575              BEQ     MYBE_RTS2
00002358  6600 001A               2576              BNE     NOT_RTS
0000235C  0C38 0006 1006          2577  MYBE_RTS2   CMPI.B  #%110, THIRD_3
00002362  6700 0006               2578              BEQ     MYBE_RTS3
00002366  6600 000C               2579              BNE     NOT_RTS
0000236A  0C38 0005 1007          2580  MYBE_RTS3   CMPI.B  #%101, FOURTH_3
00002370  6700 0088               2581              BEQ     RTS
00002374                          2582              
00002374  0C38 0007 1004          2583  NOT_RTS     CMPI.B  #%111, FIRST_3
0000237A  6700 0006               2584              BEQ     MYBE_JSR
0000237E  6600 000C               2585              BNE     NOT_JSR
00002382  0C38 0002 1005          2586  MYBE_JSR    CMPI.B  #%010, SECOND_3
00002388  6700 0078               2587              BEQ     JSR
0000238C                          2588  
0000238C  4286                    2589  NOT_JSR     CLR.L   D6
0000238E  1C38 1004               2590              MOVE.B  FIRST_3, D6
00002392  0206 0005               2591              ANDI.B  #%101, D6 * Making %1X0 -> %100
00002396  0C06 0004               2592              CMPI.B  #%100, D6
0000239A  6700 0006               2593              BEQ     MYBE_MOVEM
0000239E  6600 0012               2594              BNE     NOT_MOVEM
000023A2                          2595              
000023A2  1C38 1005               2596  MYBE_MOVEM  MOVE.B  SECOND_3, D6
000023A6  0206 0006               2597              ANDI.B  #%110, D6
000023AA  0C06 0002               2598              CMPI.B  #%010, D6
000023AE  6700 0080               2599              BEQ     MOVEM
000023B2                          2600              
000023B2  0C38 0007 1005          2601  NOT_MOVEM   CMPI.B  #%111, SECOND_3
000023B8  6700 007A               2602              BEQ     LEA
000023BC                          2603              
000023BC  4EF9 00002874           2604              JMP     INVALID
000023C2                          2605  
000023C2                          2606  NEG:
000023C2  367C 23E4               2607              MOVEA.W #NEG_BACK, A3
000023C6  0C38 0000 1005          2608              CMPI.B  #%000, SECOND_3
000023CC  6700 0320               2609              BEQ     SIZE_B
000023D0  0C38 0001 1005          2610              CMPI.B  #%001, SECOND_3
000023D6  6700 031E               2611              BEQ     SIZE_W
000023DA  0C38 0002 1005          2612              CMPI.B  #%010, SECOND_3
000023E0  6700 031C               2613              BEQ     SIZE_L
000023E4                          2614              
000023E4  1638 1006               2615  NEG_BACK    MOVE.B  THIRD_3, D3
000023E8  1438 1007               2616              MOVE.B  FOURTH_3, D2
000023EC                          2617  
000023EC  4EB9 00002644           2618              JSR     LOAD_EA
000023F2  4EB9 000027AC           2619              JSR     LOAD_NEW_LINE
000023F8  4E75                    2620              RTS
000023FA                          2621              
000023FA                          2622  RTS:
000023FA  4EB9 000027AC           2623              JSR     LOAD_NEW_LINE
00002400  4E75                    2624              RTS
00002402                          2625  
00002402                          2626  JSR:
00002402  367C 241A               2627              MOVEA.W #JSR_BACK, A3
00002406  0C38 0000 1007          2628              CMPI.B  #%000, FOURTH_3
0000240C  6700 02E8               2629              BEQ     SIZE_W
00002410  0C38 0001 1007          2630              CMPI.B  #%001, FOURTH_3
00002416  6700 02E6               2631              BEQ     SIZE_L
0000241A                          2632              
0000241A  1638 1006               2633  JSR_BACK    MOVE.B  THIRD_3, D3
0000241E  1438 1007               2634              MOVE.B  FOURTH_3, D2
00002422                          2635              
00002422  4EB9 00002644           2636              JSR     LOAD_EA
00002428  4EB9 000027AC           2637              JSR     LOAD_NEW_LINE
0000242E  4E75                    2638              RTS
00002430                          2639  
00002430                          2640  MOVEM:
00002430  FFFF FFFF               2641      SIMHALT
00002434                          2642      
00002434                          2643  LEA:
00002434  367C 244C               2644              MOVEA.W #LEA_BACK, A3
00002438  0C38 0000 1007          2645              CMPI.B  #%000, FOURTH_3
0000243E  6700 02B6               2646              BEQ     SIZE_W
00002442  0C38 0001 1007          2647              CMPI.B  #%001, FOURTH_3
00002448  6700 02B4               2648              BEQ     SIZE_L
0000244C                          2649              
0000244C  1638 1006               2650  LEA_BACK    MOVE.B  THIRD_3, D3
00002450  1438 1007               2651              MOVE.B  FOURTH_3, D2
00002454                          2652              
00002454  4EB9 00002644           2653              JSR     LOAD_EA
0000245A  4EB9 000027C4           2654              JSR     LOAD_COMMA_SPACE
00002460                          2655              
00002460  163C 0001               2656              MOVE.B  #%001, D3
00002464  1438 1004               2657              MOVE.B  FIRST_3, D2
00002468                          2658              
00002468  4EB9 00002644           2659              JSR     LOAD_EA
0000246E  4EB9 000027AC           2660              JSR     LOAD_NEW_LINE
00002474  4E75                    2661              RTS
00002476                          2662  
00002476                          2663  * <EA>
00002476                          2664  **********************************************************************************
00002476                          2665  * Description: Once the mnemonic is 0000, it is either BCLR, CMPI, ORI, or Dynamic BCLR.
00002476                          2666  *
00002476                          2667  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch,
00002476                          2668  *                 D5, D4 for BCLR
00002476                          2669  *
00002476                          2670  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
00002476                          2671  *
00002476                          2672  * Postcondition: X
00002476                          2673  **********************************************************************************
00002476                          2674  LOAD_0000:
00002476  4283                    2675              CLR.L   D3
00002478  4282                    2676              CLR.L   D2
0000247A  267C 00000000           2677              MOVEA.L #0, A3
00002480                          2678  
00002480  0C38 0000 1004          2679              CMPI.B  #%000, FIRST_3
00002486  6700 0006               2680              BEQ     MYBE_ORI
0000248A  6600 000C               2681              BNE     NOT_ORI
0000248E  0C38 0003 1005          2682  MYBE_ORI    CMPI.B  #%011, SECOND_3
00002494  6D00 0042               2683              BLT     ORI_CMPI            
00002498                          2684  
00002498  0C38 0006 1004          2685  NOT_ORI     CMPI.B  #%110, FIRST_3
0000249E  6700 0006               2686              BEQ     MYBE_CMPI
000024A2  6600 000C               2687              BNE     NOT_CMPI
000024A6  0C38 0003 1005          2688  MYBE_CMPI   CMPI.B  #%011, SECOND_3
000024AC  6D00 002A               2689              BLT     ORI_CMPI
000024B0                          2690              
000024B0  0C38 0004 1004          2691  NOT_CMPI    CMPI.B  #%100, FIRST_3
000024B6  6700 0006               2692              BEQ     MYBE_BCLR
000024BA  6600 000C               2693              BNE     NOT_BCLR
000024BE  0C38 0002 1005          2694  MYBE_BCLR   CMPI.B  #%010, SECOND_3
000024C4  6700 0076               2695              BEQ     BCLR
000024C8                          2696  
000024C8  0C38 0006 1005          2697  NOT_BCLR    CMPI.B  #%110, SECOND_3
000024CE  6700 00CE               2698              BEQ     DYNMC_BCLR
000024D2                          2699              
000024D2  4EF9 00002874           2700              JMP     INVALID
000024D8                          2701              
000024D8                          2702  ***vvvvvvvvvvvvvvvvvvv***
000024D8  367C 24FA               2703  ORI_CMPI    MOVEA.W #BACK, A3
000024DC  0C38 0000 1005          2704              CMPI.B  #%000, SECOND_3
000024E2  6700 020A               2705              BEQ     SIZE_B
000024E6  0C38 0001 1005          2706              CMPI.B  #%001, SECOND_3
000024EC  6700 0208               2707              BEQ     SIZE_W
000024F0  0C38 0002 1005          2708              CMPI.B  #%010, SECOND_3
000024F6  6700 0206               2709              BEQ     SIZE_L
000024FA                          2710  
000024FA  163C 0007               2711  BACK        MOVE.B  #%111, D3
000024FE  143C 0004               2712              MOVE.B  #%100, D2
00002502                          2713              
00002502  4EB9 00002644           2714              JSR     LOAD_EA
00002508  4EB9 000027C4           2715              JSR     LOAD_COMMA_SPACE
0000250E                          2716              
0000250E  367C 2526               2717              MOVEA.W #BACK2, A3   
00002512  0C38 0000 1007          2718              CMPI.B  #%000, FOURTH_3
00002518  6700 01DC               2719              BEQ     SIZE_W
0000251C  0C38 0001 1007          2720              CMPI.B  #%001, FOURTH_3
00002522  6700 01DA               2721              BEQ     SIZE_L
00002526                          2722  
00002526  1638 1006               2723  BACK2       MOVE.B  THIRD_3, D3
0000252A  1438 1007               2724              MOVE.B  FOURTH_3, D2
0000252E                          2725          
0000252E  4EB9 00002644           2726              JSR     LOAD_EA
00002534  4EB9 000027AC           2727              JSR     LOAD_NEW_LINE
0000253A  4E75                    2728              RTS
0000253C                          2729  ***^^^^^^^^^^^^^^^^^^^***
0000253C                          2730  
0000253C                          2731  ***vvvvvvvvvvvvvvvvvvv***
0000253C  4285                    2732  BCLR        CLR.L   D5
0000253E  4284                    2733              CLR.L   D4
00002540  247C 00000000           2734              MOVEA.L #0, A2
00002546                          2735  
00002546  3A3C 5000               2736              MOVE.W  #END_ADDRESS, D5
0000254A  9A4D                    2737              SUB.W   A5, D5
0000254C  0C45 0002               2738              CMPI.W  #$2, D5
00002550  6D00 0322               2739              BLT     INVALID
00002554                          2740  
00002554  381D                    2741              MOVE.W  (A5)+, D4
00002556  4284                    2742              CLR.L   D4
00002558  381D                    2743              MOVE.W  (A5)+, D4
0000255A  0244 00FF               2744              ANDI.W  #$00FF, D4
0000255E  247C 0000256A           2745              MOVEA.L #BACK4, A2
00002564  4EF9 00002778           2746              JMP     LOAD_IMMDTE
0000256A                          2747              
0000256A  4EB9 000027C4           2748  BACK4       JSR     LOAD_COMMA_SPACE
00002570                          2749              
00002570  367C 2588               2750              MOVEA.W #BACK3, A3
00002574  0C38 0000 1007          2751              CMPI.B  #%000, FOURTH_3
0000257A  6700 017A               2752              BEQ     SIZE_W
0000257E  0C38 0001 1007          2753              CMPI.B  #%001, FOURTH_3
00002584  6700 0178               2754              BEQ     SIZE_L
00002588                          2755  
00002588  1638 1006               2756  BACK3       MOVE.B  THIRD_3, D3
0000258C  1438 1007               2757              MOVE.B  FOURTH_3, D2
00002590                          2758  
00002590  4EB9 00002644           2759              JSR     LOAD_EA
00002596  4EB9 000027AC           2760              JSR     LOAD_NEW_LINE
0000259C                          2761  
0000259C  4E75                    2762              RTS
0000259E                          2763  ***^^^^^^^^^^^^^^^^^^^***
0000259E                          2764  
0000259E                          2765  ***vvvvvvvvvvvvvvvvvvv***
0000259E  163C 0000               2766  DYNMC_BCLR  MOVE.B  #%000, D3
000025A2  1438 1004               2767              MOVE.B  FIRST_3, D2
000025A6                          2768              
000025A6  4EB9 00002644           2769              JSR     LOAD_EA
000025AC  4EB9 000027C4           2770              JSR     LOAD_COMMA_SPACE
000025B2                          2771  
000025B2  367C 25CA               2772              MOVEA.W #BACK5, A3
000025B6  0C38 0000 1007          2773              CMPI.B  #%000, FOURTH_3
000025BC  6700 0138               2774              BEQ     SIZE_W
000025C0  0C38 0001 1007          2775              CMPI.B  #%001, FOURTH_3
000025C6  6700 0136               2776              BEQ     SIZE_L
000025CA                          2777              
000025CA  1638 1006               2778  BACK5       MOVE.B  THIRD_3, D3
000025CE  1438 1007               2779              MOVE.B  FOURTH_3, D2
000025D2                          2780              
000025D2  4EB9 00002644           2781              JSR     LOAD_EA
000025D8  4EB9 000027AC           2782              JSR     LOAD_NEW_LINE
000025DE                          2783              
000025DE  4E75                    2784              RTS
000025E0                          2785  ***^^^^^^^^^^^^^^^^^^^***
000025E0                          2786  
000025E0                          2787  * <EA>
000025E0                          2788  **********************************************************************************
000025E0                          2789  * Description: Once the mnemonic is 00XX, it is either MOVE or MOVEA. Checks the 3-bit bundles and
000025E0                          2790  *              the size of immediate/address values if necessary.
000025E0                          2791  *
000025E0                          2792  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch
000025E0                          2793  *
000025E0                          2794  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
000025E0                          2795  *
000025E0                          2796  * Postcondition: X
000025E0                          2797  **********************************************************************************
000025E0                          2798  LOAD_00XX:
000025E0  4283                    2799          CLR.L   D3
000025E2  4282                    2800          CLR.L   D2
000025E4  267C 00000000           2801          MOVEA.L #0, A3
000025EA                          2802          
000025EA  367C 2602               2803          MOVEA.W #GOO, A3
000025EE  0C38 0003 1000          2804          CMPI.B  #%0011, MNEMONIC
000025F4  6700 0100               2805          BEQ     SIZE_W
000025F8  0C38 0002 1000          2806          CMPI.B  #%0010, MNEMONIC
000025FE  6700 00FE               2807          BEQ     SIZE_L
00002602                          2808  
00002602  1638 1006               2809  GOO     MOVE.B  THIRD_3, D3
00002606  1438 1007               2810          MOVE.B  FOURTH_3, D2
0000260A                          2811      
0000260A  4EB9 00002644           2812          JSR     LOAD_EA
00002610  4EB9 000027C4           2813          JSR     LOAD_COMMA_SPACE
00002616                          2814      
00002616  367C 262E               2815          MOVEA.W #GOO2, A3
0000261A  0C38 0000 1004          2816          CMPI.B  #%000, FIRST_3
00002620  6700 00D4               2817          BEQ     SIZE_W
00002624  0C38 0001 1004          2818          CMPI.B  #%001, FIRST_3
0000262A  6700 00D2               2819          BEQ     SIZE_L
0000262E                          2820      
0000262E  1638 1005               2821  GOO2    MOVE.B  SECOND_3, D3
00002632  1438 1004               2822          MOVE.B  FIRST_3, D2
00002636                          2823              
00002636  4EB9 00002644           2824          JSR     LOAD_EA
0000263C  4EB9 000027AC           2825          JSR     LOAD_NEW_LINE
00002642                          2826      
00002642  4E75                    2827          RTS
00002644                          2828  **************************************************
00002644                          2829  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002644                          2830  
00002644                          2831  
00002644                          2832  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002644                          2833  * LOAD_THIS FUNCTIONS (HIGH LEVEL) ***************
00002644                          2834  
00002644                          2835  * <EA>
00002644                          2836  **********************************************************************************
00002644                          2837  * Description: Checks the SRC/DST mod
00002644                          2838  *
00002644                          2839  * Registers used: A2 for branching back from subbranches
00002644                          2840  *
00002644                          2841  * Precondition: D3 for SRC/DST mod
00002644                          2842  *
00002644                          2843  * Postcondition: X
00002644                          2844  **********************************************************************************
00002644                          2845  LOAD_EA:
00002644  347C 2654               2846          MOVEA.W #SAVED, A2 * remember to come back!
00002648                          2847  
00002648  0C43 0007               2848          CMPI    #%111, D3
0000264C  6D00 0008               2849          BLT     LOAD_LT_111
00002650  6C00 0032               2850          BGE     LOAD_GE_111
00002654                          2851      
00002654  4E75                    2852  SAVED   RTS
00002656                          2853  
00002656                          2854  * <EA>
00002656                          2855  **********************************************************************************
00002656                          2856  * Description: Checks the SRC/DST mod where it is not immediate/address value
00002656                          2857  *
00002656                          2858  * Registers used: X
00002656                          2859  *
00002656                          2860  * Precondition: D3 for SRC/DST mod
00002656                          2861  *
00002656                          2862  * Postcondition: X
00002656                          2863  **********************************************************************************
00002656                          2864  LOAD_LT_111:
00002656  0C43 0000               2865      CMPI    #%000, D3 * e.g. D3
0000265A  6700 00AA               2866      BEQ     LOAD_DATA_REGISTER
0000265E  0C43 0001               2867      CMPI    #%001, D3 * e.g. A3
00002662  6700 00B4               2868      BEQ     LOAD_ADDR_REGISTER
00002666  0C43 0002               2869      CMPI    #%010, D3 * e.g. (A3)
0000266A  6700 00BE               2870      BEQ     LOAD_ADDRESS
0000266E  0C43 0003               2871      CMPI    #%011, D3 * e.g. (A3)+
00002672  6700 00C8               2872      BEQ     LOAD_ADDRESS_W_POST_INC
00002676  0C43 0004               2873      CMPI    #%100, D3 * e.g. -(A3)
0000267A  6700 00CC               2874      BEQ     LOAD_ADDRESS_W_PRE_DEC
0000267E                          2875      
0000267E  4EF9 00002874           2876      JMP     INVALID
00002684                          2877      
00002684                          2878  * <EA>
00002684                          2879  **********************************************************************************
00002684                          2880  * Description: Checks the SRC/DST mod where it is immediate/address value
00002684                          2881  *
00002684                          2882  * Registers used: D5 for SUB.W, D4 for immediate/address value extraction
00002684                          2883  *
00002684                          2884  * Precondition: A5 for START_ADDRESS iteration, TRAILING_SIZE for size of the immediate/address value
00002684                          2885  *
00002684                          2886  * Postcondition: IS_INVALID flag set if EA bit not valid
00002684                          2887  **********************************************************************************
00002684                          2888  LOAD_GE_111:
00002684  4285                    2889              CLR.L   D5
00002686  4284                    2890              CLR.L   D4
00002688                          2891  
00002688  3A3C 5000               2892              MOVE.W  #END_ADDRESS, D5
0000268C  9A4D                    2893              SUB.W   A5, D5
0000268E  BA78 1002               2894              CMP.W   TRAILING_SIZE, D5
00002692  6D00 01E0               2895              BLT     INVALID
00002696                          2896  
00002696  381D                    2897              MOVE.W  (A5)+, D4
00002698  4284                    2898              CLR.L   D4
0000269A                          2899              
0000269A  0C78 0001 1002          2900              CMPI.W  #$1, TRAILING_SIZE
000026A0  6700 0016               2901              BEQ     CHUMP_BYTE
000026A4  0C78 0002 1002          2902              CMPI.W  #$2, TRAILING_SIZE
000026AA  6700 0014               2903              BEQ     CHUMP_WORD
000026AE  0C78 0004 1002          2904              CMPI.W  #$4, TRAILING_SIZE
000026B4  6700 0012               2905              BEQ     CHUMP_LONG
000026B8                          2906  
000026B8  381D                    2907  CHUMP_BYTE  MOVE.W  (A5)+, D4 * Minimum 4 hex (e.g. MOVE.B #1, $2 = XXXX 0001 0002)
000026BA  4EF9 000026D0           2908              JMP     GO
000026C0                          2909  
000026C0  381D                    2910  CHUMP_WORD  MOVE.W  (A5)+, D4
000026C2  4EF9 000026D0           2911              JMP     GO
000026C8                          2912              
000026C8  281D                    2913  CHUMP_LONG  MOVE.L  (A5)+, D4
000026CA  4EF9 000026D0           2914              JMP     GO
000026D0                          2915  
000026D0  0C42 0000               2916  GO          CMPI    #%000, D2
000026D4  6700 007E               2917              BEQ     LOAD_ABS_SHORT
000026D8  0C42 0001               2918              CMPI    #%001, D2
000026DC  6700 0088               2919              BEQ     LOAD_ABS_LONG
000026E0  0C42 0004               2920              CMPI    #%100, D2
000026E4  6700 0092               2921              BEQ     LOAD_IMMDTE
000026E8                          2922      
000026E8  4EF9 00002874           2923              JMP     INVALID
000026EE                          2924  * <EA>
000026EE                          2925  **********************************************************************************
000026EE                          2926  * Description: Puts in the proper value in TRAILING_SIZE based on the immediate/address value size
000026EE                          2927  *
000026EE                          2928  * Registers used: X
000026EE                          2929  *
000026EE                          2930  * Precondition: X
000026EE                          2931  *
000026EE                          2932  * Postcondition: Set up TRAILING_SIZE
000026EE                          2933  **********************************************************************************
000026EE                          2934  TRAILING_HELPER:            
000026EE  31FC 0002 1002          2935  SIZE_B  MOVE.W  #$2, TRAILING_SIZE
000026F4  4ED3                    2936          JMP     (A3)
000026F6                          2937  
000026F6  31FC 0002 1002          2938  SIZE_W  MOVE.W  #$2, TRAILING_SIZE
000026FC  4ED3                    2939          JMP     (A3)
000026FE                          2940          
000026FE  31FC 0004 1002          2941  SIZE_L  MOVE.W  #$4, TRAILING_SIZE
00002704  4ED3                    2942          JMP     (A3)
00002706                          2943  **************************************************
00002706                          2944  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002706                          2945  
00002706                          2946  
00002706                          2947  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002706                          2948  * LOAD_THIS FUNCTIONS (INTERMEDIATE LEVEL) *******
00002706                          2949  
00002706                          2950  * <EA>
00002706                          2951  **********************************************************************************
00002706                          2952  * Description: Loads ASCII for e.g. D3 in EA_BUFFER
00002706                          2953  *
00002706                          2954  * Registers used: D0 for actually loading
00002706                          2955  *
00002706                          2956  * Precondition: D2 for SRC/DST reg
00002706                          2957  *
00002706                          2958  * Postcondition: X
00002706                          2959  **********************************************************************************
00002706                          2960  LOAD_DATA_REGISTER:
00002706  4280                    2961      CLR.L   D0
00002708                          2962      
00002708  4EB9 000027DC           2963      JSR     LOAD_D
0000270E  1002                    2964      MOVE.B  D2, D0
00002710  4EB9 00002850           2965      JSR     LOAD_NUM
00002716  4ED2                    2966      JMP     (A2)
00002718                          2967  
00002718                          2968  * <EA>
00002718                          2969  **********************************************************************************
00002718                          2970  * Description: Loads ASCII for e.g. A3 in EA_BUFFER
00002718                          2971  *
00002718                          2972  * Registers used: D0 for actually loading
00002718                          2973  *
00002718                          2974  * Precondition: D2 for SRC/DST reg
00002718                          2975  *
00002718                          2976  * Postcondition: X
00002718                          2977  **********************************************************************************
00002718                          2978  LOAD_ADDR_REGISTER:
00002718  4280                    2979      CLR.L   D0
0000271A                          2980  
0000271A  4EB9 000027EA           2981      JSR     LOAD_A
00002720  1002                    2982      MOVE.B  D2, D0
00002722  4EB9 00002850           2983      JSR     LOAD_NUM
00002728  4ED2                    2984      JMP     (A2)
0000272A                          2985  
0000272A                          2986  * <EA>
0000272A                          2987  **********************************************************************************
0000272A                          2988  * Description: Loads ASCII for e.g. (A3) in EA_BUFFER
0000272A                          2989  *
0000272A                          2990  * Registers used: X
0000272A                          2991  *
0000272A                          2992  * Precondition: X
0000272A                          2993  *
0000272A                          2994  * Postcondition: X
0000272A                          2995  **********************************************************************************
0000272A                          2996  LOAD_ADDRESS:
0000272A  4EB9 000027F8           2997      JSR     LOAD_PTHSIS_OPEN
00002730  4EB8 2718               2998      JSR     LOAD_ADDR_REGISTER
00002734  4EB9 00002806           2999      JSR     LOAD_PTHSIS_CLSD
0000273A  4ED2                    3000      JMP     (A2)
0000273C                          3001  
0000273C                          3002  * <EA>
0000273C                          3003  **********************************************************************************
0000273C                          3004  * Description: Loads ASCII for e.g. (A3)+ in EA_BUFFER
0000273C                          3005  *
0000273C                          3006  * Registers used: X
0000273C                          3007  *
0000273C                          3008  * Precondition: X
0000273C                          3009  *
0000273C                          3010  * Postcondition: X
0000273C                          3011  **********************************************************************************
0000273C                          3012  LOAD_ADDRESS_W_POST_INC:
0000273C  4EB8 272A               3013      JSR     LOAD_ADDRESS
00002740  4EB9 00002830           3014      JSR     LOAD_PLUS_SIGN
00002746  4ED2                    3015      JMP     (A2)
00002748                          3016  
00002748                          3017  * <EA>
00002748                          3018  **********************************************************************************
00002748                          3019  * Description: Loads ASCII for e.g. -(A3) in EA_BUFFER
00002748                          3020  *
00002748                          3021  * Registers used: X
00002748                          3022  *
00002748                          3023  * Precondition: X
00002748                          3024  *
00002748                          3025  * Postcondition: X
00002748                          3026  **********************************************************************************
00002748                          3027  LOAD_ADDRESS_W_PRE_DEC:
00002748  4EB9 0000283E           3028      JSR     LOAD_MINUS_SIGN
0000274E  4EB8 272A               3029      JSR     LOAD_ADDRESS
00002752  4ED2                    3030      JMP     (A2)
00002754                          3031  
00002754                          3032  * <EA>
00002754                          3033  **********************************************************************************
00002754                          3034  * Description: Loads ASCII for e.g. $1234 in EA_BUFFER
00002754                          3035  *
00002754                          3036  * Registers used: D0 for actually loading
00002754                          3037  *
00002754                          3038  * Precondition: D4 for immediate/address value  
00002754                          3039  *
00002754                          3040  * Postcondition: X
00002754                          3041  **********************************************************************************
00002754                          3042  LOAD_ABS_SHORT:
00002754  4280                    3043      CLR.L   D0
00002756                          3044  
00002756  4EB9 00002814           3045      JSR     LOAD_HEX_SIGN
0000275C  3004                    3046      MOVE.W  D4, D0
0000275E  4EB9 00002782           3047      JSR     LOAD_BYTES
00002764  4ED2                    3048      JMP     (A2)
00002766                          3049  
00002766                          3050  * <EA>
00002766                          3051  **********************************************************************************
00002766                          3052  * Description: Loads ASCII for e.g. $12345678 in EA_BUFFER
00002766                          3053  *
00002766                          3054  * Registers used: D0 for actually loading
00002766                          3055  *
00002766                          3056  * Precondition: D4 for immediate/address value  
00002766                          3057  *
00002766                          3058  * Postcondition: X
00002766                          3059  **********************************************************************************
00002766                          3060  LOAD_ABS_LONG:
00002766  4280                    3061      CLR.L   D0
00002768                          3062  
00002768  4EB9 00002814           3063      JSR     LOAD_HEX_SIGN
0000276E  2004                    3064      MOVE.L  D4, D0
00002770  4EB9 00002782           3065      JSR     LOAD_BYTES
00002776  4ED2                    3066      JMP     (A2)
00002778                          3067  
00002778                          3068  * <EA>
00002778                          3069  **********************************************************************************
00002778                          3070  * Description: Loads ASCII for e.g. #$1234 in EA_BUFFER
00002778                          3071  *
00002778                          3072  * Registers used: X
00002778                          3073  *
00002778                          3074  * Precondition: X 
00002778                          3075  *
00002778                          3076  * Postcondition: X
00002778                          3077  **********************************************************************************
00002778                          3078  LOAD_IMMDTE:
00002778  4EB9 00002822           3079      JSR     LOAD_IMMDTE_VALU
0000277E  4EF8 2766               3080      JMP     LOAD_ABS_LONG
00002782                          3081  
00002782                          3082  **************************************************
00002782                          3083  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002782                          3084  
00002782                          3085  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002782                          3086  * LOAD_THIS FUNCTIONS (LOW LEVEL) ****************
00002782                          3087  
00002782                          3088  * <EA>
00002782                          3089  **********************************************************************************
00002782                          3090  * Description: Shifts the hex to the left and loads from the left-most hex to EA_BUFFER in ASCII
00002782                          3091  *
00002782                          3092  * Registers used: D5 for the loop counter, D1 for loop assist
00002782                          3093  *
00002782                          3094  * Precondition: D0 for the immediate/address value  
00002782                          3095  *
00002782                          3096  * Postcondition: X
00002782                          3097  **********************************************************************************
00002782                          3098  LOAD_BYTES:
00002782  4285                    3099          CLR.L   D5
00002784  4281                    3100          CLR.L   D1
00002786                          3101  
00002786  2200                    3102          MOVE.L  D0, D1
00002788  1A3C 0008               3103          MOVE.B  #8, D5
0000278C  0C45 0000               3104  LOOP    CMPI    #0, D5
00002790  6E00 0004               3105          BGT     ROTATE
00002794  4E75                    3106          RTS
00002796                          3107      
00002796  E999                    3108  ROTATE  ROL.L   #$04, D1
00002798  1001                    3109          MOVE.B  D1, D0
0000279A  0280 0000000F           3110          ANDI.L  #$0000000F, D0
000027A0  4EB9 00002850           3111          JSR     LOAD_NUM
000027A6  5345                    3112          SUBI    #1, D5
000027A8  4EF8 278C               3113          JMP     LOOP        
000027AC                          3114  
000027AC                          3115  * <EA>
000027AC                          3116  **********************************************************************************
000027AC                          3117  * Description: Loads ASCII for CR, LF 
000027AC                          3118  *
000027AC                          3119  * Registers used: D0 for actually loading
000027AC                          3120  *
000027AC                          3121  * Precondition: CR, LF 
000027AC                          3122  *
000027AC                          3123  * Postcondition: X
000027AC                          3124  **********************************************************************************
000027AC                          3125  LOAD_NEW_LINE:
000027AC  4280                    3126      CLR.L   D0
000027AE                          3127  
000027AE  1038 1063               3128      MOVE.B  CR, D0
000027B2  4EB9 0000284C           3129      JSR     LOAD_THIS_SHIT
000027B8  1038 1064               3130      MOVE.B  LF, D0
000027BC  4EB9 0000284C           3131      JSR     LOAD_THIS_SHIT
000027C2  4E75                    3132      RTS
000027C4                          3133  
000027C4                          3134  * <EA>
000027C4                          3135  **********************************************************************************
000027C4                          3136  * Description: Loads ASCII for ', ' 
000027C4                          3137  *
000027C4                          3138  * Registers used: D0 for actually loading
000027C4                          3139  *
000027C4                          3140  * Precondition: COMMA, SPACE
000027C4                          3141  *
000027C4                          3142  * Postcondition: X
000027C4                          3143  **********************************************************************************
000027C4                          3144  LOAD_COMMA_SPACE:
000027C4  4280                    3145      CLR.L   D0
000027C6                          3146  
000027C6  1038 1061               3147      MOVE.B  COMMA, D0
000027CA  4EB9 0000284C           3148      JSR     LOAD_THIS_SHIT
000027D0  1038 1062               3149      MOVE.B  SPACE, D0
000027D4  4EB9 0000284C           3150      JSR     LOAD_THIS_SHIT
000027DA                          3151      
000027DA  4E75                    3152      RTS
000027DC                          3153  
000027DC                          3154  * <EA>
000027DC                          3155  **********************************************************************************
000027DC                          3156  * Description: Loads ASCII for D 
000027DC                          3157  *
000027DC                          3158  * Registers used: D0 for actually loading
000027DC                          3159  *
000027DC                          3160  * Precondition: DATA
000027DC                          3161  *
000027DC                          3162  * Postcondition: X
000027DC                          3163  **********************************************************************************
000027DC                          3164  LOAD_D:
000027DC  4280                    3165      CLR.L   D0
000027DE                          3166  
000027DE  1038 105A               3167      MOVE.B  DATA, D0
000027E2  4EB9 0000284C           3168      JSR     LOAD_THIS_SHIT
000027E8  4E75                    3169      RTS
000027EA                          3170  
000027EA                          3171  * <EA>
000027EA                          3172  **********************************************************************************
000027EA                          3173  * Description: Loads ASCII for A
000027EA                          3174  *
000027EA                          3175  * Registers used: D0 for actually loading
000027EA                          3176  *
000027EA                          3177  * Precondition: ADDRESS
000027EA                          3178  *
000027EA                          3179  * Postcondition: X
000027EA                          3180  **********************************************************************************
000027EA                          3181  LOAD_A:
000027EA  4280                    3182      CLR.L   D0
000027EC                          3183  
000027EC  1038 1059               3184      MOVE.B  ADDRESS, D0
000027F0  4EB9 0000284C           3185      JSR     LOAD_THIS_SHIT
000027F6  4E75                    3186      RTS
000027F8                          3187  
000027F8                          3188  * <EA>
000027F8                          3189  **********************************************************************************
000027F8                          3190  * Description: Loads ASCII for (
000027F8                          3191  *
000027F8                          3192  * Registers used: D0 for actually loading
000027F8                          3193  *
000027F8                          3194  * Precondition: PTHSIS_OPEN
000027F8                          3195  *
000027F8                          3196  * Postcondition: X
000027F8                          3197  **********************************************************************************
000027F8                          3198  LOAD_PTHSIS_OPEN:
000027F8  4280                    3199      CLR.L   D0
000027FA                          3200  
000027FA  1038 105B               3201      MOVE.B  PTHSIS_OPEN, D0
000027FE  4EB9 0000284C           3202      JSR     LOAD_THIS_SHIT
00002804  4E75                    3203      RTS
00002806                          3204  
00002806                          3205  * <EA>
00002806                          3206  **********************************************************************************
00002806                          3207  * Description: Loads ASCII for )
00002806                          3208  *
00002806                          3209  * Registers used: D0 for actually loading
00002806                          3210  *
00002806                          3211  * Precondition: PTHSIS_CLSD
00002806                          3212  *
00002806                          3213  * Postcondition: X
00002806                          3214  **********************************************************************************
00002806                          3215  LOAD_PTHSIS_CLSD:
00002806  4280                    3216      CLR.L   D0
00002808                          3217  
00002808  1038 105C               3218      MOVE.B  PTHSIS_CLSD, D0
0000280C  4EB9 0000284C           3219      JSR     LOAD_THIS_SHIT
00002812  4E75                    3220      RTS
00002814                          3221  
00002814                          3222  * <EA>
00002814                          3223  **********************************************************************************
00002814                          3224  * Description: Loads ASCII for $
00002814                          3225  *
00002814                          3226  * Registers used: D0 for actually loading
00002814                          3227  *
00002814                          3228  * Precondition: HEX_SIGN
00002814                          3229  *
00002814                          3230  * Postcondition: X
00002814                          3231  **********************************************************************************
00002814                          3232  LOAD_HEX_SIGN:
00002814  4280                    3233      CLR.L   D0
00002816                          3234  
00002816  1038 105D               3235      MOVE.B  HEX_SIGN, D0
0000281A  4EB9 0000284C           3236      JSR     LOAD_THIS_SHIT
00002820  4E75                    3237      RTS
00002822                          3238  
00002822                          3239  * <EA>
00002822                          3240  **********************************************************************************
00002822                          3241  * Description: Loads ASCII for #
00002822                          3242  *
00002822                          3243  * Registers used: D0 for actually loading
00002822                          3244  *
00002822                          3245  * Precondition: IMMDTE_VALU
00002822                          3246  *
00002822                          3247  * Postcondition: X
00002822                          3248  **********************************************************************************
00002822                          3249  LOAD_IMMDTE_VALU:
00002822  4280                    3250      CLR.L   D0
00002824                          3251  
00002824  1038 105E               3252      MOVE.B  IMMDTE_VALU, D0
00002828  4EB9 0000284C           3253      JSR     LOAD_THIS_SHIT
0000282E  4E75                    3254      RTS
00002830                          3255  
00002830                          3256  * <EA>
00002830                          3257  **********************************************************************************
00002830                          3258  * Description: Loads ASCII for +
00002830                          3259  *
00002830                          3260  * Registers used: D0 for actually loading
00002830                          3261  *
00002830                          3262  * Precondition: PLUS_SIGN
00002830                          3263  *
00002830                          3264  * Postcondition: X
00002830                          3265  **********************************************************************************
00002830                          3266  LOAD_PLUS_SIGN:
00002830  4280                    3267      CLR.L   D0
00002832                          3268  
00002832  1038 105F               3269      MOVE.B  PLUS_SIGN, D0
00002836  4EB9 0000284C           3270      JSR     LOAD_THIS_SHIT
0000283C  4E75                    3271      RTS
0000283E                          3272  
0000283E                          3273  * <EA>
0000283E                          3274  **********************************************************************************
0000283E                          3275  * Description: Loads ASCII for -
0000283E                          3276  *
0000283E                          3277  * Registers used: D0 for actually loading
0000283E                          3278  *
0000283E                          3279  * Precondition: MINUS_SIGN
0000283E                          3280  *
0000283E                          3281  * Postcondition: X
0000283E                          3282  **********************************************************************************
0000283E                          3283  LOAD_MINUS_SIGN:
0000283E  4280                    3284      CLR.L   D0
00002840                          3285  
00002840  1038 1060               3286      MOVE.B  MINUS_SIGN, D0
00002844  4EB9 0000284C           3287      JSR     LOAD_THIS_SHIT
0000284A  4E75                    3288      RTS
0000284C                          3289  **************************************************
0000284C                          3290  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000284C                          3291  
0000284C                          3292  
0000284C                          3293  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000284C                          3294  * LOAD_THIS FUNCTIONS (LOWEST LEVEL) *************
0000284C                          3295  * <EA>
0000284C                          3296  **********************************************************************************
0000284C                          3297  * Description: Loads the hex value from D0 to EA_BUFFER in ASCII
0000284C                          3298  *
0000284C                          3299  * Registers used: X
0000284C                          3300  *
0000284C                          3301  * Precondition: X
0000284C                          3302  *
0000284C                          3303  * Postcondition: X
0000284C                          3304  **********************************************************************************
0000284C                          3305  LOAD_THIS_SHIT:
0000284C  18C0                    3306      MOVE.B  D0, (A4)+
0000284E  4E75                    3307      RTS
00002850                          3308  
00002850                          3309  * <EA>
00002850                          3310  **********************************************************************************
00002850                          3311  * Description: Adds $30 to a number in D0 to make it a hex. If the number is greater
00002850                          3312  *              than 9 (A~F), then adds $37. Then moves the hex value from D0 to EA_BUFFER in ASCII
00002850                          3313  *
00002850                          3314  * Registers used: X
00002850                          3315  *
00002850                          3316  * Precondition: X
00002850                          3317  *
00002850                          3318  * Postcondition: X
00002850                          3319  **********************************************************************************
00002850                          3320  LOAD_NUM:
00002850  0C00 0009               3321      CMPI.B  #$9, D0
00002854  6E00 0006               3322      BGT     GT
00002858  6F00 000C               3323      BLE     LE
0000285C                          3324      
0000285C  0600 0037               3325  GT  ADDI.B  #$37, D0 * A~F
00002860  4EF9 00002870           3326      JMP     END
00002866  0600 0030               3327  LE  ADDI.B  #$30, D0 * 0~9
0000286A  4EF9 00002870           3328      JMP     END
00002870                          3329  
00002870  18C0                    3330  END MOVE.B  D0, (A4)+
00002872  4E75                    3331      RTS
00002874                          3332  
00002874                          3333  * <EA>
00002874                          3334  **********************************************************************************
00002874                          3335  * Description: Execution goes here if even one of the EA bit is invalid. Flags the invalid-bit and
00002874                          3336  *              entirely exits the EA process.
00002874                          3337  *
00002874                          3338  * Registers used: X
00002874                          3339  *
00002874                          3340  * Precondition: X
00002874                          3341  *
00002874                          3342  * Postcondition: X
00002874                          3343  **********************************************************************************
00002874                          3344  INVALID:
00002874  11FC 0000 10B5          3345              MOVE.B  #%0, IS_VALID
0000287A  4EF8 20B2               3346              JMP     EXT
0000287E                          3347  **************************************************
0000287E                          3348  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           
0000287E                          3349              *you call the opcode subroutine 
0000287E                          3350              
0000287E                          3351              *if the opcode is valid, you print the G.BUFFER
0000287E                          3352              *if not, you print  DATA $XXXX $ADDRESS 
0000287E                          3353              
0000287E                          3354              
0000287E                          3355              
0000287E  6000 E80C               3356              BRA mainLoop
00002882                          3357  
00002882                          3358  
00002882                          3359  DONE
00002882                          3360  
00002882                          3361  **
00002882                          3362  * AddStrToBuffer
00002882                          3363  **
00002882                          3364  * Adds the given NULL-terminated string to the specified buffer.
00002882                          3365  *
00002882                          3366  * Default buffer length is 80 characters, but can be modified in the argument
00002882                          3367  * variables.
00002882                          3368  *
00002882                          3369  * If the buffer length is exceeded, either due to lack of a NULL character or
00002882                          3370  * an incorrectly specified length, 1 is returned. Otherwise, 0 is returned to
00002882                          3371  * indicate success.
00002882                          3372  *
00002882                          3373  **
00002882                          3374  * @param Arg_AddStrToBuffer_String              Pointer to string
00002882                          3375  * @param Arg_AddStrToBuffer_Buffer              Pointer to buffer
00002882                          3376  * @param Arg_AddStrToBuffer_BufferLength        Length of buffer (default 80 chars)
00002882                          3377  * @return Ret_AddStrToBuffer_Success            0 if successful, 1 otherwise.
00002882                          3378  * @branch _AddStrToBuffer_FindBufferNullLoop    Loop to find NULL in buffer
00002882                          3379  * @branch _AddStrToBuffer_AddLoop               Loop to add string to buffer
00002882                          3380  * @branch _AddStrToBuffer_Success               Branch when string successfully added
00002882                          3381  * @branch _AddStrToBuffer_StringLengthExceeded  Branch when length exceeded (either string or buffer)
00002882                          3382  * @branch _AddStrToBuffer_End                   End of subroutine
00002882                          3383  **
Line 3384 ERROR: Symbol defined more than once
00002882                          3384  Arg_AddStrToBuffer_String           DS.L    1
Line 3385 ERROR: Symbol defined more than once
00002886                          3385  Arg_AddStrToBuffer_Buffer           DS.L    1
Line 3386 ERROR: Symbol defined more than once
0000288A= 00000050                3386  Arg_AddStrToBuffer_BufferLength     DC.L    80
Line 3387 ERROR: Symbol defined more than once
0000288E                          3387  Ret_AddStrToBuffer_Success          DS.B    1
0000288F                          3388  
Line 3389 ERROR: Symbol defined more than once
00002890                          3389  AddStrToBuffer:                     DS.W    0
00002890  48E7 C0C0               3390      MOVEM.L     D0-D1/A0-A1, -(SP)                  * Backup registers to stack
00002894                          3391  
00002894  2078 203A               3392      MOVE.L      Arg_AddStrToBuffer_String, A0       * Load string pointer
00002898  2278 203E               3393      MOVE.L      Arg_AddStrToBuffer_Buffer, A1       * Load buffer pointer
0000289C  2038 2042               3394      MOVE.L      Arg_AddStrToBuffer_BufferLength, D0 * Load buffer length
000028A0  4278 2046               3395      CLR.W       Ret_AddStrToBuffer_Success          * Clear success bit
000028A4  4281                    3396      CLR.L       D1                                  * Clear loop counter
000028A6                          3397  
Line 3398 ERROR: Symbol defined more than once
000028A6                          3398  _AddStrToBuffer_BufferLoop
000028A6  0C11 0000               3399      CMPI.B      #0, (A1)                            * If buffer char is NULL
000028AA  6700 F7C6               3400      BEQ         _AddStrToBuffer_AddLoop             * Start adding string to bufer
000028AE                          3401      
000028AE  B280                    3402      CMP.L       D0, D1                              * If counter >= max length
000028B0  6C00 F7DE               3403      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
000028B4                          3404      
000028B4  5289                    3405      ADDQ.L      #1, A1                              * Go to next character
000028B6  5201                    3406      ADDQ.B      #1, D1                              * Increment counter
000028B8  6000 F7A4               3407      BRA         _AddStrToBuffer_BufferLoop          * Loop back
000028BC                          3408      
Line 3409 ERROR: Symbol defined more than once
000028BC                          3409  _AddStrToBuffer_AddLoop
000028BC  0C10 0000               3410      CMPI.B      #0, (A0)                            * If string char is NULL
000028C0  6700 F7C6               3411      BEQ         _AddStrToBuffer_Success             * String successfully added
000028C4                          3412      
000028C4  B200                    3413      CMP.B       D0, D1                              * If counter >= max length
000028C6  6C00 F7C8               3414      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
000028CA                          3415      
000028CA  12D8                    3416      MOVE.B      (A0)+, (A1)+                        * Move string char to buffer char
000028CC  5201                    3417      ADDQ.B      #1, D1                              * Increment counter
000028CE  6000 F7A2               3418      BRA         _AddStrToBuffer_AddLoop             * Loop back
000028D2                          3419  
Line 3420 ERROR: Symbol defined more than once
000028D2                          3420  _AddStrToBuffer_Success
000028D2  12BC 0000               3421      MOVE.B      #0, (A1)                            * Add NULL to end of string
000028D6  6000 F7BE               3422      BRA         _AddStrToBuffer_End                 * Finish subroutine
000028DA                          3423  
Line 3424 ERROR: Symbol defined more than once
000028DA                          3424  _AddStrToBuffer_LengthExceeded
000028DA  31FC 0001 2046          3425      MOVE.W      #1, Ret_AddStrToBuffer_Success      * Invalidate success bit
000028E0                          3426  
Line 3427 ERROR: Symbol defined more than once
000028E0                          3427  _AddStrToBuffer_End
000028E0  4CDF 0303               3428      MOVEM.L     (SP)+, D0-D1/A0-A1                  * Restore registers from stack
000028E4  4E75                    3429      RTS                                             * Exit subroutine
000028E6                          3430  
000028E6                          3431  
000028E6                          3432  **************************************************************************
000028E6                          3433  * ClearBuffer
000028E6                          3434  ***********************************************************************
000028E6                          3435  * Clears the given buffer by filling it with NULL. By default it will fill 80
000028E6                          3436  * bytes from the buffer pointer with NULL, so make sure the buffer reserves
000028E6                          3437  * that many bytes. The default can be changed.
000028E6                          3438  *
000028E6                          3439  **
000028E6                          3440  * @param Arg_ClearBuffer_Buffer     Pointer to buffer
000028E6                          3441  * @param Arg_ClearBuffer_Length     Byte length of buffer, default 80
000028E6                          3442  * @branch _ClearBuffer_Loop         Buffer loop
000028E6                          3443  * @branch _ClearBuffer_End          Subroutine end
000028E6                          3444  *****************************************************************************
000028E6                          3445  Arg_ClearBuffer_Buffer  DS.L    1
000028EA= 00000050                3446  Arg_ClearBuffer_Length  DC.L    80
000028EE                          3447  
000028EE                          3448  ClearBuffer:            DS.W    0
000028EE  48E7 C080               3449      MOVEM.L     D0-D1/A0, -(SP)             * Backup registers to stack
000028F2  2078 28E6               3450      MOVEA.L     Arg_ClearBuffer_Buffer, A0  * Load buffer address
000028F6  2038 28EA               3451      MOVE.L      Arg_ClearBuffer_Length, D0  * Load buffer length
000028FA  4281                    3452      CLR.L       D1                          * Clear counter
000028FC                          3453      
000028FC                          3454  _ClearBuffer_Loop
000028FC  B280                    3455      CMP.L       D0, D1                      * If counter >= length
000028FE  6C00 0008               3456      BGE         _ClearBuffer_End            * Finish subroutine
00002902                          3457      
00002902  4218                    3458      CLR.B       (A0)+                       * Clear current character in buffer
00002904  5241                    3459      ADDQ        #1, D1                      * Increment counter
00002906  60F4                    3460      BRA         _ClearBuffer_Loop           * Loop back
00002908                          3461      
00002908                          3462  _ClearBuffer_End
00002908  4CDF 0103               3463      MOVEM.L     (SP)+, D0-D1/A0             * Restore registers from stack
0000290C  4E75                    3464      RTS                                     * Exit subroutine
0000290E                          3465  
0000290E                          3466  
0000290E  FFFF FFFF               3467      SIMHALT
00002912                          3468  
00002912                          3469  
Line 3470 ERROR: Symbol defined more than once
00002912                          3470  CUR_OP_CODE DS.W 1    
00002914                          3471  
00002914                          3472  
00002914                          3473  *********************************************************************************
00002914                          3474  * Method Name: TrapTask13
00002914                          3475  * Description: Creates a file if none exists, and appends bytes to that file
00002914                          3476  *   while also echoing the written bytes to the screen.  You shouldn't need to
00002914                          3477  *   change this code.
00002914                          3478  *
00002914                          3479  * Calling Convention: Callee-Saved 
00002914                          3480  *
00002914                          3481  * Preconditions & Method Input:
00002914                          3482  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00002914                          3483  *
00002914                          3484  * Postconditions & Output:
00002914                          3485  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00002914                          3486  *   See 'Output.txt' in directory for the results, also piped to the console
00002914                          3487  *
00002914                          3488  *
00002914                          3489  *  A2 holds a pointer to null terminated string to write (input)
00002914                          3490  *  A3 points to the null-terminated file name
00002914                          3491  *  D3 holds the number of bytes already in the file to write
00002914                          3492  *
00002914                          3493  *  D5 holds number of bytes to write
00002914                          3494  ********************************************************************************
00002914                          3495  toSave REG D0-D5/A2-A3
00002914                          3496  TrapTask13:
00002914                          3497      *******************************************************************
00002914                          3498      * Method initialization, regsiter spilling, parameter saving, etc.
00002914                          3499      *******************************************************************
00002914  48E7 FC30               3500      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00002918                          3501        
00002918  2449                    3502      MOVEA.L A1, A2 ; save this buffer to write
0000291A  47F9 00002CA0           3503      LEA outFilename, A3  ; save this for later, too
00002920                          3504        
00002920  303C 0032               3505      move #50,d0   
00002924  4E4F                    3506      trap #15 ; close all files, suggested to begin any IO 
00002926                          3507      *******************************************************************
00002926                          3508      * End Method Init
00002926                          3509      *******************************************************************
00002926                          3510  
00002926                          3511      ******************************************************************************************
00002926                          3512      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00002926                          3513      ******************************************************************************************
00002926  4285                    3514      CLR.L D5 *D5 is now the number of bytes to write
00002928                          3515  nullLoop:
00002928  1019                    3516      MOVE.B (A1)+, D0
0000292A  0C00 0000               3517      CMPI.B #0,D0  * compare to null
0000292E  6700 0006               3518      BEQ findNullLoopDone
00002932  5245                    3519      ADDI.W #1, D5
00002934  60F2                    3520      BRA nullLoop
00002936                          3521      
00002936                          3522  findNullLoopDone:
00002936  224B                    3523      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00002938                          3524      
00002938                          3525      ;check if file exists, and open with task 51 if so, otherwise 52
00002938                          3526      ;(precondition here is A1 points to the null-terminated filename )
00002938  103C 0033               3527      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
0000293C  4E4F                    3528      trap #15
0000293E                          3529        
0000293E                          3530      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00002944  103C 0034               3531          MOVE.B #52, D0             ; open new file (52 is new)
00002948  4E4F                    3532          trap #15
0000294A                          3533      endi
0000294A                          3534      
0000294A                          3535      ********************************************************************************************************* 
0000294A                          3536      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
0000294A                          3537      *    (first, count number of bytes already in the file to obtain seek position)
0000294A                          3538      *********************************************************************************************************
0000294A  4283                    3539      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
0000294C  7401                    3540      MOVE.L #1, D2 ; read one byte at a time
0000294E  43F9 00002CAB           3541      LEA byteRead, A1
00002954                          3542      
00002954                          3543  countLoop:
00002954  103C 0035               3544      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00002958  4E4F                    3545      trap #15
0000295A                          3546      
0000295A  0C40 0001               3547      CMPI.W #1,D0  ;1 == EOF
0000295E  6700 0006               3548      BEQ countDone
00002962  5243                    3549      ADDI #1, D3
00002964  60EE                    3550      BRA countLoop
00002966                          3551      
00002966                          3552  countDone:    
00002966                          3553      * close this file
00002966  303C 0038               3554       move #56,d0  
0000296A  4E4F                    3555       trap #15 
0000296C                          3556       
0000296C                          3557       * reopen the target file
0000296C  224B                    3558       MOVE.L A3,A1
0000296E  303C 0033               3559       MOVE #51, D0
00002972  4E4F                    3560       trap #15
00002974                          3561       
00002974                          3562      * seek to right position, then continue with writing
00002974  2403                    3563      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
00002976  303C 0037               3564      MOVE #55, D0  ; position file task
0000297A  4E4F                    3565      trap #15
0000297C                          3566  
0000297C                          3567      ******************************************************************************
0000297C                          3568      * Actually write the buffer to the file, after caculating the number of bytes 
0000297C                          3569      *  to write and after seeking to the right location in the file for append
0000297C                          3570      ******************************************************************************
0000297C                          3571  
0000297C  2405                    3572      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
0000297E                          3573      ; assumes A0 hasnt changed since handed to this method      
0000297E  224A                    3574      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
00002980                          3575      ; assumes file ID is still stored in D1.L  
00002980  103C 0036               3576      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
00002984  4E4F                    3577      trap #15
00002986                          3578  
00002986                          3579      ; add a newline to the file output
00002986  43F9 00002C9D           3580      LEA NEWLINE, A1
0000298C  103C 0036               3581      MOVE.B #54, D0 
00002990  143C 0002               3582      MOVE.B #2,D2  ; kills # of bytes to write from input param
00002994  4E4F                    3583      trap #15
00002996                          3584      
00002996                          3585      ; finally, close only this file
00002996  103C 0038               3586      MOVE.B #56, D0 ; close file task
0000299A  4E4F                    3587      trap #15
0000299C                          3588    
0000299C                          3589      ; report to screen
0000299C  224A                    3590      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
0000299E  103C 000D               3591      MOVE.B #13, D0
000029A2  4E4F                    3592      trap #15
000029A4                          3593        
000029A4                          3594      ; restore context
000029A4  4CDF 0C3F               3595      MOVEM.L (SP)+, toSave
000029A8                          3596      
000029A8  4E75                    3597      RTS
000029AA                          3598      
000029AA                          3599      
000029AA                          3600  *----------------------------------------------------------------------------------
000029AA                          3601  * Method Name: AsciiToHex
000029AA                          3602  * Written by : Berger, Modified by Nash
000029AA                          3603  * Date       : 3/1/2019
000029AA                          3604  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000029AA                          3605  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000029AA                          3606  *              its (4b each) equivalent hex value 
000029AA                          3607  *  
000029AA                          3608  *  Preconditions & Input
000029AA                          3609  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000029AA                          3610  *       This function calls another function (strip_ascii)
000029AA                          3611  *
000029AA                          3612  *  Postconditions & Output
000029AA                          3613  *       D7 (output) holds the converted value 
000029AA                          3614  *       Caller-Saved : D0 is temp, D6 is a loop var
000029AA                          3615  *----------------------------------------------------------------------------------
000029AA                          3616  AsciiToHexRegList REG D0,D6
000029AA                          3617  AsciiToHex     
000029AA  48E7 8000               3618      MOVEM.L asciiToHexRegList, -(SP)  *save context
000029AE  4287                    3619      CLR.L D7 * clear our return value
000029B0  7C08                    3620      MOVE.L #8, D6 ; and set up our loop counter
000029B2                          3621  
000029B2                          3622  chrLoop
000029B2  1019                    3623      MOVE.B (A1)+,D0 * Get the first byte
000029B4  4EB9 000029CC           3624      jsr strip_ascii * Get rid of the ascii code    
000029BA  8E40                    3625      OR.W D0,D7 * Load the bits into D7
000029BC                          3626      
000029BC  5306                    3627      subI.B #1,D6  *decrement our loop variable
000029BE  6700 0006               3628      BEQ chrDone   *skip shifting if we are done
000029C2                          3629      
000029C2  E987                    3630      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
000029C4  60EC                    3631      BRA chrLoop
000029C6                          3632  
000029C6                          3633  chrDone
000029C6  4CDF 0001               3634      MOVEM.L (SP)+,asciiToHexRegList 
000029CA  4E75                    3635      RTS
000029CC                          3636  
000029CC                          3637  
000029CC                          3638  **********************************************************************
000029CC                          3639  * SUBROUTINE: strip_ascii
000029CC                          3640  * remove the ascii code from the digits 0-9,a-f, or A-F
000029CC                          3641  * Input Parameters: <D0> = ascii code
000029CC                          3642  *
000029CC                          3643  * Return parameters: D0.B = number 0...F, returned as 00...0F
000029CC                          3644  * Registers used internally: D0
000029CC                          3645  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
000029CC                          3646  *
000029CC                          3647  ***********************************************************************
000029CC                          3648  strip_ascii
000029CC  B03C 0039               3649        CMP.B #$39,D0 * Is it in range of 0-9?
000029D0  6F00 001A               3650        BLE sub30 * Its a number
000029D4  B03C 0046               3651        CMP.B #$46,D0 * Is is A...F?
000029D8  6F00 000A               3652        BLE sub37 * Its A...F
000029DC  0400 0057               3653        SUB.B #$57,D0 * Its a...f
000029E0  6000 000E               3654        BRA ret_sa * Go back
000029E4  0400 0037               3655  sub37 SUB.B #$37,D0 * Strip 37
000029E8  6000 0006               3656        BRA ret_sa * Go back
000029EC  0400 0030               3657  sub30 SUB.B #$30,D0 * Strip 30
000029F0  4E75                    3658  ret_sa RTS * Go back
000029F2                          3659  
000029F2                          3660  
000029F2                          3661  MAIN_CONSOLE:
000029F2                          3662     
Line 3663 ERROR: Immediate data exceeds 8 bits
000029F2= 3D 3D 3D 3D 3D 3D ...   3663        DC.B '============================================================',CR,LF
Line 3664 ERROR: Immediate data exceeds 8 bits
00002A30= 7C 7C 20 20 20 20 ...   3664        DC.B '||                                                        ||',CR,LF
Line 3665 ERROR: Immediate data exceeds 8 bits
00002A6E= 7C 7C 20 20 20 23 ...   3665        DC.B '||   #####      ###    ##   ##                            ||',CR,LF
Line 3666 ERROR: Immediate data exceeds 8 bits
00002AAC= 7C 7C 20 20 23 23 ...   3666        DC.B '||  ##        ##   ##  ## ##                              ||',CR,LF
Line 3667 ERROR: Immediate data exceeds 8 bits
00002AEA= 7C 7C 20 23 23 20 ...   3667        DC.B '|| ## ####     #####   ####                               ||',CR,LF
Line 3668 ERROR: Immediate data exceeds 8 bits
00002B28= 7C 7C 20 23 23 20 ...   3668        DC.B '|| ##    ##  ##    ##  ####                               ||',CR,LF
Line 3669 ERROR: Immediate data exceeds 8 bits
00002B66= 7C 7C 20 23 23 20 ...   3669        DC.B '|| ##    ##  ##    ##  ## ##                              ||',CR,LF
Line 3670 ERROR: Immediate data exceeds 8 bits
00002BA4= 7C 7C 20 20 23 23 ...   3670        DC.B '||  #####     ######   ##  ##                             ||',CR,LF
Line 3671 ERROR: Immediate data exceeds 8 bits
00002BE2= 7C 7C 20 20 20 20 ...   3671        DC.B '||                                                        ||',CR,LF
Line 3672 ERROR: Immediate data exceeds 8 bits
00002C20= 7C 7C 20 20 20 44 ...   3672        DC.B '||   Daniel Yan, Fahad Alshehri, Denny Park               ||',CR,LF
Line 3673 ERROR: Immediate data exceeds 8 bits
00002C5E= 3D 3D 3D 3D 3D 3D ...   3673        DC.B '============================================================',CR,LF,0
00002C9D                          3674      
00002C9D                          3675  * Required variables and constants go here for your Disassembler
Line 3676 ERROR: Symbol defined more than once
00002C9D                          3676  CR                  EQU $0D
Line 3677 ERROR: Symbol defined more than once
00002C9D                          3677  LF                  EQU $0A
Line 3678 ERROR: Immediate data exceeds 8 bits
00002C9D= 63 64 00                3678  NEWLINE             DC.B CR,LF,0  
00002CA0= 4F 75 74 70 75 74 ...   3679  outFilename         DC.B 'Output.txt',0
00002CAB                          3680  byteRead            DS.B 1
00002CAC= 31 41 30 30 31 41 ...   3681  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00002CB4                          3682  
00002CB4                          3683  * Variables and constants
Line 3684 ERROR: Symbol defined more than once
00002CB4                          3684  CR              EQU     $D              ; ASCII code for carriage return
Line 3685 ERROR: Symbol defined more than once
00002CB4                          3685  LF              EQU     $A              ; ASCII code for line feed
00002CB4  =00000014               3686  SIZE            EQU     20             ; Max string size
Line 3687 ERROR: Immediate data exceeds 8 bits
00002CB4= 44 65 6D 6F 6E 73 ...   3687  description     DC.B    'Demonstrates reading a string from a file. ',CR,LF,CR,LF,0
Line 3688 ERROR: Immediate data exceeds 8 bits
00002CE4= 54 68 65 20 73 74 ...   3688  result          DC.B    'The string read from the file is:',CR,LF,0
00002D08= 43 6F 6E 66 69 67 ...   3689  fileName        DC.B    'Config.cfg',0   ; name of text file
Line 3690 ERROR: Immediate data exceeds 8 bits
00002D13= 41 20 66 69 6C 65 ...   3690  errorFile       DC.B    'A file error occurred.',CR,LF,0
Line 3691 ERROR: Immediate data exceeds 8 bits
00002D2C= 46 69 6C 65 20 72 ...   3691  success         DC.B    'File read complete.',CR,LF,0
00002D42                          3692  string          DS.B    SIZE            ; I/O buffer
00002D56                          3693  strSize         DS.W    1               ; Size if input string
00002D58                          3694  fileID          DS.L    1               ; File ID
00002D5C                          3695  
00002D5C                          3696  
00002D5C                          3697  
00002D5C                          3698     END    START        ; last line of source

31 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA                214E
ADDA_BACK           2166
ADDRESS             1059
ADDSTRTOBUFFER      2048
ARG_ADDSTRTOBUFFER_BUFFER  203E
ARG_ADDSTRTOBUFFER_BUFFERLENGTH  2042
ARG_ADDSTRTOBUFFER_STRING  203A
ARG_CLEARBUFFER_BUFFER  28E6
ARG_CLEARBUFFER_LENGTH  28EA
ASCIITOHEX          29AA
ASCIITOHEXREGLIST   1
ASCII_VAL           2CAC
BACK                24FA
BACK2               2526
BACK3               2588
BACK4               256A
BACK5               25CA
BCLR                253C
BIT_CHECK_EXG       1ABC
BIT_CHECK_EXT       16B4
BIT_CHECK_MOVEP     1426
BIT_CHECK_SUBX      19E6
BYTEREAD            2CAB
B_BUFFER            1009
CHECK_00XX          2110
CHECK_01XX          211E
CHECK_0XXX          20CC
CHECK_1XXX          20DC
CHECK_OP_ABCD       1A94
CHECK_OP_ADD        1B3E
CHECK_OP_ADDA       1B2A
CHECK_OP_ADDI       1386
CHECK_OP_ADDQ       1860
CHECK_OP_ADDX       1B16
CHECK_OP_AND        1AF6
CHECK_OP_ANDI       135E
CHECK_OP_ANDI_TO_CCR  131E
CHECK_OP_ANDI_TO_SR  132E
CHECK_OP_ASL        1CC6
CHECK_OP_ASL_NO_ROT  1C02
CHECK_OP_ASR        1CAC
CHECK_OP_ASR_NO_ROT  1BE8
CHECK_OP_BCS        18CC
CHECK_OP_BGE        18E6
CHECK_OP_BLT        1900
CHECK_OP_BRA        18B2
CHECK_OP_BSR        189E
CHECK_OP_BVC        191A
CHECK_OP_CHK        1796
CHECK_OP_CLR        1678
CHECK_OP_CMP        1A5C
CHECK_OP_CMPA       1A34
CHECK_OP_CMPI       146E
CHECK_OP_CMPM       1A20
CHECK_OP_DBCC       1838
CHECK_OP_DIVS       1990
CHECK_OP_DIVU       1968
CHECK_OP_DYNAMIC_BCHG  13FE
CHECK_OP_DYNAMIC_BCLR  14A2
CHECK_OP_DYNAMIC_BSET  1412
CHECK_OP_DYNAMIC_BTST  13EA
CHECK_OP_EOR        1A48
CHECK_OP_EORI       139A
CHECK_OP_EORI_TO_CCR  133E
CHECK_OP_EORI_TO_SR  134E
CHECK_OP_EXG        1AA8
CHECK_OP_EXT        16A0
CHECK_OP_ILLEGAL    15E8
CHECK_OP_JMP        1782
CHECK_OP_JSR        17DA
CHECK_OP_LEA        17C0
CHECK_OP_LINK       1746
CHECK_OP_LSL        1C92
CHECK_OP_LSL_NO_ROT  1BCE
CHECK_OP_LSR        1C78
CHECK_OP_LSR_NO_ROT  1BB4
CHECK_OP_MOVEA_L    14F6
CHECK_OP_MOVEA_W    1558
CHECK_OP_MOVEM      180E
CHECK_OP_MOVEP      1440
CHECK_OP_MOVEQ      1944
CHECK_OP_MOVE_B     14CC
CHECK_OP_MOVE_FROM_SR  1628
CHECK_OP_MOVE_L     152E
CHECK_OP_MOVE_TO_CCR  163C
CHECK_OP_MOVE_TO_SR  1650
CHECK_OP_MOVE_USP   176E
CHECK_OP_MOVE_W     1590
CHECK_OP_MULS       1AE2
CHECK_OP_MULU       1A80
CHECK_OP_NBCD       16CE
CHECK_OP_NEG        17F4
CHECK_OP_NEGX       1664
CHECK_OP_NOP        15D8
CHECK_OP_NOT        168C
CHECK_OP_OR         19A4
CHECK_OP_ORI        1454
CHECK_OP_ORI_TO_CCR  12FE
CHECK_OP_ORI_TO_SR  130E
CHECK_OP_PEA        16F6
CHECK_OP_RESET      15C8
CHECK_OP_ROL        1C5E
CHECK_OP_ROL_NO_ROT  1B9A
CHECK_OP_ROR        1C44
CHECK_OP_ROR_NO_ROT  1B80
CHECK_OP_ROXL       1C30
CHECK_OP_ROXL_NO_ROT  1B6C
CHECK_OP_ROXR       1C1C
CHECK_OP_ROXR_NO_ROT  1B58
CHECK_OP_RTE        15F8
CHECK_OP_RTR        1618
CHECK_OP_RTS        17AA
CHECK_OP_SBCD       197C
CHECK_OP_SCC        184C
CHECK_OP_STATIC_BCHG  13C2
CHECK_OP_STATIC_BCLR  1488
CHECK_OP_STATIC_BSET  13D6
CHECK_OP_STATIC_BTST  13AE
CHECK_OP_STOP       15B8
CHECK_OP_SUB        1A04
CHECK_OP_SUBA       19BE
CHECK_OP_SUBI       1372
CHECK_OP_SUBQ       1874
CHECK_OP_SUBX       19D2
CHECK_OP_SWAP       16E2
CHECK_OP_TAS        170A
CHECK_OP_TRAP       1732
CHECK_OP_TRAPV      1608
CHECK_OP_TST        171E
CHECK_OP_UNLK       175A
CHECK_XXXX          20BC
CHRDONE             29C6
CHRLOOP             29B2
CHUMP_BYTE          26B8
CHUMP_LONG          26C8
CHUMP_WORD          26C0
CLEARBUFFER         28EE
COMMA               1061
COUNTDONE           2966
COUNTLOOP           2954
CR                  1063
CURRENTADDR         1000
CUR_OP_CODE         4000
C_GROUP_0           12FA
C_GROUP_1           14C8
C_GROUP_2           14F2
C_GROUP_3           1554
C_GROUP_4           15B6
C_GROUP_5           1834
C_GROUP_6           189A
C_GROUP_7           1940
C_GROUP_8           1964
C_GROUP_9           19BA
C_GROUP_A           1A14
C_GROUP_B           1A1C
C_GROUP_C           1A7C
C_GROUP_D           1B12
C_GROUP_E           1B54
C_GROUP_F           1CEC
DATA                105A
DENNY_EA_SHIT       209C
DESCRIPTION         2CB4
DIR_0               21CE
DIR_1               2210
DIVS                2252
DIVS_BACK           227E
DONE                2882
DYNMC_BCLR          259E
EA_BUFFER           1065
EA_SIZE             1008
END                 2870
END_ADDRESS         5000
ERRORFILE           2D13
EXT                 20B2
FILEID              2D58
FILENAME            2D08
FINDNULLLOOPDONE    2936
FIND_2_BIT_SIZE_TO_EA  1224
FIND_3_BIT_REG_TO_EA  123A
FIND_MOVEA_L_DIFFERENCE  1508
FIND_MOVEA_W_DIFF   156A
FIND_TRAILING_BITS_TO_EA  1296
FIRST_3             1004
FOURTH_3            1007
GO                  26D0
GOO                 2602
GOO2                262E
GROUP0_INVALID      14BC
GROUP0_SUCCESS      14C2
GROUP1_INVALID      14E6
GROUP1_SUCCESS      14EC
GROUP2_INVALID      1548
GROUP2_SUCCESS      154E
GROUP3_INVALID      15AA
GROUP3_SUCCESS      15B0
GROUP4_INVALID      1828
GROUP4_SUCCESS      182E
GROUP5_INVALID      188E
GROUP5_SUCCESS      1894
GROUP6_INVALID      1934
GROUP6_SUCCESS      193A
GROUP7_INVALID      1958
GROUP7_SUCCESS      195E
GROUP8_INVALID      19AE
GROUP8_SUCCESS      19B4
GROUP9_INVALID      1A0A
GROUP9_SUCCESS      1A0E
GROUPB_INVALID      1A70
GROUPB_SUCCESS      1A76
GROUPC_INVALID      1B06
GROUPC_SUCCESS      1B0C
GROUPD_INVALID      1B48
GROUPD_SUCCESS      1B4E
GROUPE_INVALID      1CE0
GROUPE_SUCCESS      1CE6
GROUP_0             10DC
GROUP_1             10EE
GROUP_2             1100
GROUP_3             1112
GROUP_4             1124
GROUP_5             1136
GROUP_6             1148
GROUP_7             115A
GROUP_8             116C
GROUP_9             117E
GROUP_A             1190
GROUP_B             11A2
GROUP_C             11B4
GROUP_D             11C6
GROUP_E             11D8
GROUP_F             11EA
GT                  285C
G_BUFFER            4100
HEX_SIGN            105D
IMMDTE_VALU         105E
INVALID             2874
INVALID_OP          1CF4
IS_VALID            10B5
JSR                 2402
JSR_BACK            241A
LE                  2866
LEA                 2434
LEA_BACK            244C
LF                  1064
LOAD_0000           2476
LOAD_00XX           25E0
LOAD_0100           231E
LOAD_0101           2294
LOAD_1000           21A2
LOAD_1001           219C
LOAD_1011           2196
LOAD_1100           2190
LOAD_1101           2134
LOAD_A              27EA
LOAD_ABS_LONG       2766
LOAD_ABS_SHORT      2754
LOAD_ADDRESS        272A
LOAD_ADDRESS_W_POST_INC  273C
LOAD_ADDRESS_W_PRE_DEC  2748
LOAD_ADDR_REGISTER  2718
LOAD_BYTES          2782
LOAD_COMMA_SPACE    27C4
LOAD_D              27DC
LOAD_DATA_REGISTER  2706
LOAD_EA             2644
LOAD_GE_111         2684
LOAD_HEX_SIGN       2814
LOAD_IMMDTE         2778
LOAD_IMMDTE_VALU    2822
LOAD_LT_111         2656
LOAD_MINUS_SIGN     283E
LOAD_NEW_LINE       27AC
LOAD_NUM            2850
LOAD_OP_CODE        10C4
LOAD_PLUS_SIGN      2830
LOAD_PTHSIS_CLSD    2806
LOAD_PTHSIS_OPEN    27F8
LOAD_THIS_SHIT      284C
LOOP                278C
MAINLOOP            108C
MAIN_CONSOLE        29F2
MINUS_SIGN          1060
MNEMONIC            1000
MOVEM               2430
MOVE_AND_MOVEA_PARSE_EA  1250
MOVE_LAST_6_BITS_TO_EA  1202
MYBE_BCLR           24BE
MYBE_CMPI           24A6
MYBE_JSR            2382
MYBE_MOVEM          23A2
MYBE_NEG            2336
MYBE_ORI            248E
MYBE_RTS1           234E
MYBE_RTS2           235C
MYBE_RTS3           236A
MYBE_SUBQ1          22AE
MYBE_SUBQ2          22BE
NEG                 23C2
NEG_BACK            23E4
NEWLINE             2C9D
NOT_BCLR            24C8
NOT_CMPI            24B0
NOT_JSR             238C
NOT_MOVEM           23B2
NOT_NEG             2340
NOT_ORI             2498
NOT_RTS             2374
NULLLOOP            2928
OP_FOUND            1F62
OP_JSR_DONE         11F8
OP_JSR_ROUTINE      10D4
ORI_CMPI            24D8
OR_BACK             21E6
OR_BACK2            223C
OUTFILENAME         2CA0
PARSE_EA_CONSTANT_BITS  12AC
PLUS_SIGN           105F
PRINT_OP            1F52
PRINT_OP_ADD        1ED2
PRINT_OP_ADDA       1EE2
PRINT_OP_ASL        1F22
PRINT_OP_ASR        1F12
PRINT_OP_BCS        1E22
PRINT_OP_BGE        1E32
PRINT_OP_BLT        1E42
PRINT_OP_BRA        1E62
PRINT_OP_BVC        1E52
PRINT_OP_CMP        1EB2
PRINT_OP_CMPI       1D32
PRINT_OP_DIVS       1E72
PRINT_OP_DYNAMIC_BCLR  1D52
PRINT_OP_EOR        1EA2
PRINT_OP_JSR        1DB2
PRINT_OP_LEA        1DD2
PRINT_OP_LSL        1EF2
PRINT_OP_LSR        1F02
PRINT_OP_MOVEA_L    1D72
PRINT_OP_MOVEA_W    1D92
PRINT_OP_MOVEB      1D62
PRINT_OP_MOVEM_L    1E02
PRINT_OP_MOVEM_W    1DF2
PRINT_OP_MOVE_L     1D82
PRINT_OP_MOVE_W     1DA2
PRINT_OP_MULS       1EC2
PRINT_OP_NEG        1DE2
PRINT_OP_OR         1E82
PRINT_OP_ORI        1D22
PRINT_OP_ROL        1F32
PRINT_OP_ROR        1F42
PRINT_OP_RTS        1DC2
PRINT_OP_STATIC_BCLR  1D42
PRINT_OP_SUB        1E92
PRINT_OP_SUBQ       1E12
PRINT_TO_BUFFER     1D10
PTHSIS_CLSD         105C
PTHSIS_OPEN         105B
P_INVALID_OP        1F5A
P_OP_ADD            201D
P_OP_ADDA           2018
P_OP_ASL            202D
P_OP_ASR            2029
P_OP_BCS            1FEF
P_OP_BGE            1FF3
P_OP_BLT            1FF7
P_OP_BRA            1FEB
P_OP_BVC            1FFB
P_OP_CMP            200F
P_OP_CMPI           1F7B
P_OP_DIVS           1FFF
P_OP_DYNAMIC_BCLR   1F85
P_OP_EOR            200B
P_OP_JSR            1FD6
P_OP_LEA            1FD2
P_OP_LSL            2025
P_OP_LSR            2021
P_OP_MOVEA_L        1F92
P_OP_MOVEA_W        1FA6
P_OP_MOVEB          1F8A
P_OP_MOVEM_L        1FC6
P_OP_MOVEM_W        1FBA
P_OP_MOVE_L         1F9E
P_OP_MOVE_W         1FB2
P_OP_MULS           2013
P_OP_NEG            1FE2
P_OP_NOP            1FDA
P_OP_OR             2004
P_OP_ORI            1F77
P_OP_ROL            2035
P_OP_ROR            2031
P_OP_RTS            1FDE
P_OP_STATIC_BCLR    1F80
P_OP_SUB            2007
P_OP_SUBQ           1FE6
P_SIZE_B            1F6B
P_SIZE_L            1F73
P_SIZE_W            1F6F
READ_NEXT_INSTRUCTION  1D0C
RESULT              2CE4
RET_ADDSTRTOBUFFER_SUCCESS  2046
RET_SA              29F0
ROTATE              2796
RTS                 23FA
RUN_FAHAD_CODE      20B8
SAVED               2654
SECOND_3            1005
SIZE                14
SIZE_B              26EE
SIZE_L              26FE
SIZE_W              26F6
SPACE               1062
START               1004
START_ADDRESS       4000
STRING              2D42
STRIP_ASCII         29CC
STRSIZE             2D56
SUB30               29EC
SUB37               29E4
SUBQ                22CE
SUBQ_BACK           2308
SUBQ_SAVED          22E0
SUCCESS             2D2C
THIRD_3             1006
TOSAVE              C3F
TRAILING_HELPER     26EE
TRAILING_SIZE       1002
TRAPTASK13          2914
_00000000           294A
_ADDSTRTOBUFFER_ADDLOOP  2072
_ADDSTRTOBUFFER_BUFFERLOOP  205E
_ADDSTRTOBUFFER_END  2096
_ADDSTRTOBUFFER_LENGTHEXCEEDED  2090
_ADDSTRTOBUFFER_SUCCESS  2088
_CLEARBUFFER_END    2908
_CLEARBUFFER_LOOP   28FC
