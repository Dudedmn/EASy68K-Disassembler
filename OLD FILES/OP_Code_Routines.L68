000010AA Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/14/2019 10:38:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : OP Code routines for Disassembler
00000000                             3  * Written by : Daniel Yan
00000000                             4  * Date       : 2/28/2019, Updated 3/12/2019
00000000                             5  
00000000                             6  * Description: Disassembler routines to identify any valid
00000000                             7  * OP code dependent on current supported list.
00000000                             8  *------------------------------------------------------------
00001000                             9       ORG $1000              ;Start at address $1000
00001000                            10  CUR_OP_CODE     DS.W    1   ;Used to determine the current 4 hex OP code
00001002                            11  OP_SIZE         DS.B    1   ;This constant refers to the size of the current OP code 
00001003                            12  G_BUFFER        DS.B    80  ;Used to print out the needed letters to the buffer
00001053                            13  MNEMONIC        DS.B    1   ;Constant for EA, first 4 bits (15-12) of a 4 hex OP code
00001054                            14  FIRST_3         DS.B    1   ;Constant for EA, 3 bits (11-9) of a 4 hex OP code
00001055                            15  SECOND_3        DS.B    1   ;Constant for EA, 3 bits (8-6) of a 4 hex OP code
00001056                            16  THIRD_3         DS.B    1   ;Constant for EA, 3 bits (5-3) of a 4 hex OP code
00001057                            17  FOURTH_3        DS.B    1   ;Constant for EA, 3 bits (2-0) of a 4 hex OP code
00001058                            18  B_BUFFER        DS.B    81  ;Bad buffer used to load bad data
000010A9                            19  IS_VALID        DS.B    1   ;Global-bit validity flag
000010AA                            20                              ;$0 = invalid, $1 = valid
000010AA                            21  
000010AA                            22  START:
000010AA                            23      
000010AA  49F8 1003                 24      LEA G_BUFFER,A4         ;Load G_BUFFER into A4, put a pointer to it as A4
000010AE  18BC 0000                 25      MOVE.B #0, (A4)         ;Move 0 to indicate where to put the loaded buffer word
000010B2                            26  
000010B2                            27      ;MOVE.L (A5)+, D0
000010B2                            28  ************** BUFFER PRINTING/LOADING EXAMPLES *************************************
000010B2                            29      ; Load the message onto A4
000010B2                            30      ;MOVE.L #P_OP_MOVEA_L_T, Arg_AddStrToBuffer_String
000010B2                            31      ;MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer 
000010B2                            32      ;JSR AddStrToBuffer
000010B2                            33      ;LEA G_BUFFER, A4   ; Load the value of the message onto the G_BUFFER
000010B2                            34      ;MOVE.L P_OP_MOVEA_L_T,(A4)+
000010B2                            35      ;MOVE.L P_OP_MOVEA_L_A_L,(A4)+
000010B2                            36      
000010B2                            37  ***************************** Input Tests ********************************************
000010B2                            38      ; indicates a test has been finished
000010B2                            39      * indicates a test hasn't been finished
000010B2                            40      
000010B2                            41      ****SIZE PARSING TESTS********************************************************** 
000010B2                            42      *SIZE CHECKING OP CODES EXCEPTIONS:
000010B2                            43      *$0   BLCR (B,L)
000010B2                            44      *$2-3 MOVEA (W,L), 
000010B2                            45      *$4   RTS (NONE), JSR(NONE), MOVEM (W,L), LEA (L only),
000010B2                            46      *$8   DIVS (W only)
000010B2                            47      *$C   MULS (W only)
000010B2                            48      ;MOVE.W #%00000000010000101,CUR_OP_CODE     ;ORI.L D5                SHOULD BE 2
000010B2                            49      ;MOVE.W #%00000000000000101,CUR_OP_CODE     ;ORI.B D5                SHOULD BE 0
000010B2                            50      ;MOVE.W #%00000000001000101,CUR_OP_CODE     ;ORI.W D5                SHOULD BE 1
000010B2                            51      ;JSR FIND_2_BIT_SIZE_7_TO_6                 ;Testing Routine
000010B2                            52      ;MOVE.W #%00000000001000101,CUR_OP_CODE     ;Testing bit 6           SHOULD BE 1
000010B2                            53      ;MOVE.W #%00000000000000101,CUR_OP_CODE     ;Testing bit 6           SHOULD BE 0
000010B2                            54      ;JSR   FIND_1_BIT_SIZE_6
000010B2                            55      ;MOVE.W #$F1FF,CUR_OP_CODE                  ;Testing bit 8           SHOULD BE 1
000010B2                            56      ;MOVE.W #$FEFF,CUR_OP_CODE                  ;Testing bit 8           SHOULD BE 0
000010B2                            57      ;JSR    FIND_1_BIT_SIZE_8
000010B2                            58      ****END OF SIZE PARSING TESTS***************************************************
000010B2                            59      
000010B2                            60      ***GROUP 0 tests**** SUPPORTED: ORI, BCLR (static, dynamic), CMPI
000010B2                            61      ;MOVE.W #%0000000000111100,CUR_OP_CODE      ;ORI TO CCR              SHOULD FAIL
000010B2                            62      ;MOVE.W #%0000000001111100,CUR_OP_CODE      ;ORI TO SR               SHOULD FAIL
000010B2                            63      ;MOVE.W #%0000000010000101,CUR_OP_CODE      ;ORI.L D5                SHOULD PASS
000010B2                            64      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO CCR             SHOULD FAIL
000010B2                            65      ;MOVE.W #%0000001001111100,CUR_OP_CODE      ;ANDI TO SR              SHOULD FAIL
000010B2                            66      ;MOVE.W #%0000001010000101,CUR_OP_CODE      ;ANDI.W D5               SHOULD FAIL
000010B2                            67      ;MOVE.W #%0000010010000101,CUR_OP_CODE      ;SUBI.W D5               SHOULD FAIL
000010B2                            68      ;MOVE.W #%0000011010000101,CUR_OP_CODE      ;ADDI.W D5               SHOULD FAIL
000010B2                            69      ;MOVE.W #%0000101000111100,CUR_OP_CODE      ;EORI TO CCR             SHOULD FAIL
000010B2                            70      ;MOVE.W #%0000101001111100,CUR_OP_CODE      ;EORI TO SR              SHOULD FAIL
000010B2                            71      ;MOVE.W #%0000101010000101,CUR_OP_CODE      ;EORI.W D5               SHOULD FAIL
000010B2                            72      ;MOVE.W #%0000110010000101,CUR_OP_CODE      ;CMPI.L D5               SHOULD PASS
000010B2                            73      ;MOVE.W #%0000100000000101,CUR_OP_CODE      ;STATIC BTST. B D5       SHOULD FAIL
000010B2                            74      ;MOVE.W #%0000100001000101,CUR_OP_CODE      ;STATIC BCHG .B D5       SHOULD FAIL
000010B2                            75      ;MOVE.W #%0000100010000101,CUR_OP_CODE      ;STATIC BCLR D5          SHOULD PASS
000010B2                            76      ;MOVE.W #%0000100011000101,CUR_OP_CODE      ;STATIC BSET.B D5        SHOULD FAIL
000010B2                            77      ;MOVE.W #%0000111100000101,CUR_OP_CODE      ;DYNAMIC BTST.B D7,D5    SHOULD FAIL
000010B2                            78      ;MOVE.W #%0000111101000101,CUR_OP_CODE      ;DYNAMIC BCHG.B,D7,D5    SHOULD FAIL
000010B2                            79      ;MOVE.W #%0000101110000111,CUR_OP_CODE      ;DYNAMIC BCLR.L D7,D5    SHOULD PASS
000010B2                            80      ;MOVE.W #%0000111111000101,CUR_OP_CODE      ;DYNAMIC BSET.B D7,D5    SHOULD FAIL
000010B2                            81      ;MOVE.W #%0000111111001101,CUR_OP_CODE      ;MOVEP.L MEM TO REG, A5  SHOULD FAIL, MADE A SPECIAL CASE FOR DYNAMIC BSET BIT SHIFTING
000010B2                            82          
000010B2                            83      ***GROUP 1 tests**** SUPPORTED: MOVE.B
000010B2                            84      ;MOVE.W #%0001101000000111,CUR_OP_CODE       ;MOVE.B D5,D7           SHOULD PASS
000010B2                            85      ***GROUP 2 tests**** SUPPORTED: MOVEA.L, MOVE.L
000010B2                            86      ;MOVE.W #%0010101000000111,CUR_OP_CODE       ;MOVE.L D5,D7           SHOULD PASS
000010B2                            87      ;MOVE.W #%0010101001000111,CUR_OP_CODE       ;MOVEA.L D5,D7          SHOULD PASS
000010B2                            88         
000010B2                            89      ***GROUP 3 tests**** SUPPORTED: MOVEA.W, MOVE.W
000010B2                            90      ;MOVE.W #%0011101000000111,CUR_OP_CODE       ;MOVE.W D5,D7           SHOULD PASS
000010B2                            91      ;MOVE.W #%0011101001000111,CUR_OP_CODE       ;MOVEA.W D5,D7          SHOULD PASS
000010B2                            92      
000010B2                            93      ****GROUP 4 tests**** SUPPORTED: LEA, JSR, RTS, NEG, MOVEM  
000010B2                            94      ;MOVE.W #%0100000011000101,CUR_OP_CODE       ;MOVE_FROM_SR           SHOULD FAIL
000010B2                            95      ;MOVE.W #%0100010011000101,CUR_OP_CODE       ;MOVE_TO_CCR            SHOULD FAIL
000010B2                            96      ;MOVE.W #%0100011011000101,CUR_OP_CODE       ;MOVE_TO_SR             SHOULD FAIL
000010B2                            97      ;MOVE.W #%0100000010000101,CUR_OP_CODE       ;NEGX                   SHOULD FAIL
000010B2                            98      ;MOVE.W #%0100001010000101,CUR_OP_CODE       ;CLR                    SHOULD FAIL
000010B2                            99      ;MOVE.W #%0100010001000101,CUR_OP_CODE       ;NEG                    SHOULD PASS
000010B2                           100      ;MOVE.W #%0100011010000101,CUR_OP_CODE       ;NOT                    SHOULD FAIL
000010B2                           101      ;MOVE.W #%0100100011000101,CUR_OP_CODE       ;EXT                    SHOULD FAIL
000010B2                           102      ;MOVE.W #%0100100000000101,CUR_OP_CODE       ;NBCD                   SHOULD FAIL
000010B2                           103      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;SWAP                   SHOULD FAIL
000010B2                           104      ;MOVE.W #%0100100001000101,CUR_OP_CODE       ;PEA                    SHOULD FAIL
000010B2                           105      ;MOVE.W #%0100101011111100,CUR_OP_CODE       ;ILLEGAL                SHOULD FAIL
000010B2                           106      ;MOVE.W #%0100101011000101,CUR_OP_CODE       ;TAS                    SHOULD FAIL
000010B2                           107      ;MOVE.W #%0100101010000101,CUR_OP_CODE       ;TST                    SHOULD FAIL
000010B2                           108      ;MOVE.W #%0100111001000111,CUR_OP_CODE       ;TRAP                   SHOULD FAIL
000010B2                           109      ;MOVE.W #%0100111001010101,CUR_OP_CODE       ;LINK                   SHOULD FAIL
000010B2                           110      ;MOVE.W #%0100111001011101,CUR_OP_CODE       ;UNLK                   SHOULD FAIL
000010B2                           111      ;MOVE.W #%0100111001101101,CUR_OP_CODE       ;MOVE_USP               SHOULD FAIL
000010B2                           112      ;MOVE.W #%0100111001110000,CUR_OP_CODE       ;RESET                  SHOULD FAIL
000010B2                           113      ;MOVE.W #%0100111001110001,CUR_OP_CODE       ;NOP                    SHOULD FAIL
000010B2                           114      ;MOVE.W #%0100111001110010,CUR_OP_CODE       ;STOP                   SHOULD FAIL
000010B2                           115      ;MOVE.W #%0100111001110011,CUR_OP_CODE       ;RTE                    SHOULD FAIL
000010B2                           116      ;MOVE.W #%0100111001110101,CUR_OP_CODE       ;RTS                    SHOULD PASS
000010B2                           117      ;MOVE.W #%0100111001110110,CUR_OP_CODE       ;TRAPV                  SHOULD FAIL
000010B2                           118      ;MOVE.W #%0100111001110111,CUR_OP_CODE       ;RTR                    SHOULD FAIL
000010B2                           119      ;MOVE.W #%0100111010000101,CUR_OP_CODE       ;JSR                    SHOULD PASS
000010B2                           120      ;MOVE.W #%0100111011000101,CUR_OP_CODE       ;JMP                    SHOULD FAIL
000010B2                           121      ;MOVE.W #$488E,CUR_OP_CODE                   ;MOVEM.W Reg to Mem,A6  SHOULD PASS
000010B2                           122      ;MOVE.W #$4C8E,CUR_OP_CODE                   ;MOVEM.W Mem to Reg,A6  SHOULD PASS
000010B2                           123      ;MOVE.W #$43CC,CUR_OP_CODE                   ;LEA A1,A6              SHOULD PASS
000010B2                           124      ;MOVE.W #%0100000110000101,CUR_OP_CODE       ;CHK                    SHOULD FAIL
000010B2                           125      ;MOVE.W #$4E75,CUR_OP_CODE                   ;RTS                    SHOULD PASS
000010B2                           126      ;MOVE.W #$4E71,CUR_OP_CODE                   ;NOP                    SHOULD FAIL
000010B2                           127      ;MOVE.W #$4415,CUR_OP_CODE                   ;NEG.B D5               SHOULD PASS
000010B2                           128      ;MOVE.W #$4485,CUR_OP_CODE                   ;NEG.L D5               SHOULD PASS
000010B2                           129     
000010B2                           130      *****GROUP 5 TESTS**** SUPPORTED: SUBQ
000010B2                           131      ;MOVE.W #%0101110010000101,CUR_OP_CODE        ;ADDQ                  SHOULD FAIL
000010B2                           132      ;MOVE.W #%0101110110000101,CUR_OP_CODE        ;SUBQ                  SHOULD PASS
000010B2                           133      ;MOVE.W #%0101101011000101,CUR_OP_CODE        ;Scc (SPL)             SHOULD FAIL
000010B2                           134      ;MOVE.W #%0101101011001101,CUR_OP_CODE        ;DBcc (DCPL)          SHOULD FAIL
000010B2                           135         
000010B2                           136      *****GROUP 6 TESTS********* SUPPORTED: BCS,BGE,BLT,BVC               ;Check if Branch size here should be printed
000010B2                           137      ; DISPLACEMENT, $00 is 16 bits, $FF is 32 bits
000010B2                           138      ; DISPLACEMENT = Last 8 bits
000010B2                           139      ;MOVE.W #%0110000001010101,CUR_OP_CODE   ;BRA                        SHOULD PASS
000010B2                           140      ;MOVE.W #%0110000110101010,CUR_OP_CODE   ;BSR                        SHOULD FAIL
000010B2                           141      ;MOVE.W #%0110010100000001,CUR_OP_CODE   ;BCS                        SHOULD PASS
000010B2                           142      ;MOVE.W #%0110110001010100,CUR_OP_CODE   ;BGE                        SHOULD PASS
000010B2                           143      ;MOVE.W #%0110110110101010,CUR_OP_CODE   ;BLT                        SHOULD PASS
000010B2                           144      ;MOVE.W #%0110100001010100,CUR_OP_CODE   ;BVC                        SHOULD PASS
000010B2                           145      
000010B2                           146      *****GROUP 7 TESTS********** NONE SUPPORTED
000010B2                           147      ;MOVE.W #%0111101011110000,CUR_OP_CODE   ;MOVEQ                      SHOULD FAIL
000010B2                           148      
000010B2                           149      *****GROUP 8 TESTS********** SUPPORTED: DIVS, OR
000010B2                           150      ;MOVE.W #%1000101011000101,CUR_OP_CODE    ;DIVU                      SHOULD FAIL
000010B2                           151      ;MOVE.W #%1000101111000110,CUR_OP_CODE    ;DIVS                      SHOULD PASS
000010B2                           152      ;MOVE.W #%1000101100001111,CUR_OP_CODE    ;SBCD                      SHOULD FAIL
000010B2                           153      ;MOVE.W #%1000110101000101,CUR_OP_CODE    ;OR                        SHOULD PASS
000010B2                           154              
000010B2                           155      *****GROUP 9 TESTS********** SUPPORTED: SUB
000010B2                           156      ;MOVE.W #%1001101100000101,CUR_OP_CODE    ;SUB                       SHOULD PASS
000010B2                           157      ;MOVE.W #%1001000110001101,CUR_OP_CODE    ;SUBX                      SHOULD FAIL
000010B2                           158      ;MOVE.W #%1001101011001101,CUR_OP_CODE    ;SUBA                      SHOULD FAIL
000010B2                           159      
000010B2                           160      *****GROUP A TESTS********** NONE SUPPORTED
000010B2                           161      ;MOVE.W #%1010110101010011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010B2                           162      
000010B2                           163      *****GROUP B TESTS********** SUPPORTED: EOR, CMP
000010B2                           164      ;MOVE.W #%1011101101000110,CUR_OP_CODE    ;EOR                       SHOULD PASS
000010B2                           165      ;MOVE.W #%1011110101001101,CUR_OP_CODE    ;CMPM                      SHOULD FAIL
000010B2                           166      ;MOVE.W #%1011010001000101,CUR_OP_CODE    ;CMP                       SHOULD PASS
000010B2                           167      *MOVE.W #%1011110011000101,CUR_OP_CODE    ;CMPA                      SHOULD FAIL
000010B2                           168      
000010B2                           169      *****GROUP C TESTS********** SUPPORTED: MULS
000010B2                           170      ;MOVE.W #%1100101011000110,CUR_OP_CODE    ;MULU                      SHOULD FAIL
000010B2                           171      ;MOVE.W #%1100101111000101,CUR_OP_CODE    ;MULS                      SHOULD PASS
000010B2                           172      ;MOVE.W #%1100101100000101,CUR_OP_CODE    ;ABCD                      SHOULD FAIL
000010B2                           173      ;MOVE.W #%1100101110001110,CUR_OP_CODE    ;EXG                       SHOULD FAIL
000010B2                           174      ;MOVE.W #%1100101001000101,CUR_OP_CODE    ;AND                       SHOULD FAIL   
000010B2                           175       
000010B2                           176      *****GROUP D TESTS********** SUPPORTED: ADD, ADDA
000010B2                           177      ;MOVE.W #%1101101101000101,CUR_OP_CODE    ;ADDX                      SHOULD FAIL
000010B2                           178      ;MOVE.W #%1101101011001101,CUR_OP_CODE    ;ADDA                      SHOULD FAIL
000010B2                           179      ;MOVE.W #%1101101001001101,CUR_OP_CODE    ;ADD                       SHOULD PASS
000010B2                           180      
000010B2                           181      *****GROUP E TESTS********** SUPPORTED: LSX, ASX, ROX
000010B2                           182      ;MOVE.W #%1110000011000101,CUR_OP_CODE    ;ASR NO_ROT                SHOULD PASS
000010B2                           183      ;MOVE.W #%1110000111000101,CUR_OP_CODE    ;ASL NO_ROT                SHOULD PASS
000010B2                           184      ;MOVE.W #%1110001011000101,CUR_OP_CODE    ;LSR NO_ROT                SHOULD PASS
000010B2                           185      ;MOVE.W #%1110001111000101,CUR_OP_CODE    ;LSL NO_ROT                SHOULD PASS
000010B2                           186      ;MOVE.W #%1110010011000101,CUR_OP_CODE    ;ROXR NO_ROT               SHOULD FAIL
000010B2                           187      ;MOVE.W #%1110010111000101,CUR_OP_CODE    ;ROXL NO_ROT               SHOULD FAIL
000010B2                           188      ;MOVE.W #%1110011011000101,CUR_OP_CODE    ;ROR NO_ROT                SHOULD PASS
000010B2                           189      ;MOVE.W #%1110011111000101,CUR_OP_CODE    ;ROL NO_ROT                SHOULD PASS    
000010B2                           190      
000010B2                           191      ;MOVE.W #%1110000001000101,CUR_OP_CODE    ;ASR                       SHOULD PASS
000010B2                           192      ;MOVE.W #%1110000101000101,CUR_OP_CODE    ;ASL                       SHOULD PASS
000010B2                           193      ;MOVE.W #%1110001001001101,CUR_OP_CODE    ;LSR                       SHOULD PASS
000010B2                           194      ;MOVE.W #%1110001101001101,CUR_OP_CODE    ;LSL                       SHOULD PASS
000010B2                           195      ;MOVE.W #%1110010001010101,CUR_OP_CODE    ;ROXR                      SHOULD FAIL
000010B2                           196      ;MOVE.W #%1110010101010101,CUR_OP_CODE    ;ROXL                      SHOULD FAIL
000010B2                           197      ;MOVE.W #%1110011001011101,CUR_OP_CODE    ;ROR                       SHOULD PASS
000010B2  31FC E75D 1000           198      MOVE.W #%1110011101011101,CUR_OP_CODE    ;ROL                       SHOULD PASS    
000010B8                           199          
000010B8                           200      *****GROUP F TESTS********** NONE SUPPORTED
000010B8                           201      ;MOVE.W #%1111010110101011,CUR_OP_CODE    ;INVALID_OP                SHOULD FAIL
000010B8                           202      
000010B8                           203      
000010B8                           204  ************************************************************************************
000010B8                           205  * PRINTING BUFFER FUNCTION HAS BEEN FINISHED
000010B8                           206  * STATUS: 
000010B8                           207  * IDENTIFICATION FOR ALL OP CODES:      DONE
000010B8                           208  * VALIDATION TESTING FOR ALL OP CODES:  DONE
000010B8                           209  * PRINTING ALL OP CODES TO BUFFER:      DONE
000010B8                           210  * PRINTING SIZE BITS OF ALL OP CODES:   NOT DONE
000010B8                           211  *-----------------------------------------------------------
000010B8                           212  *First Nibble Values (15-12)
000010B8                           213  *Value                  Operations
000010B8                           214  *$0                     GROUP_0: ORI,BCLR (static and dynamic),CMPI --- DONE
000010B8                           215  *$1                     GROUP_1: MOVE.B                             --- DONE
000010B8                           216  *$2                     GROUP_2: MOVE.L, MOVEA.L                    --- DONE
000010B8                           217  *$3                     GROUP_3: MOVE.W, MOVEA.W                    --- DONE
000010B8                           218  *$4                     GROUP_4: LEA,JSR,RTS,NEG,MOVEM              --- DONE
000010B8                           219  *$5                     GROUP_5: SUBQ                               --- DONE
000010B8                           220  *$6                     GROUP_6: Bcc(BCS,BGE,BLT,BVC), BRA          --- DONE
000010B8                           221  *$7                     GROUP_7: INVALID_OP                         --- DONE
000010B8                           222  *$8                     GROUP_8: DIVS, OR                           --- DONE
000010B8                           223  *$9                     GROUP_9: SUB                                --- DONE
000010B8                           224  *$A                     GROUP_A: INVALID_OP                         --- DONE
000010B8                           225  *$B                     GROUP_B: EOR, CMP                           --- DONE
000010B8                           226  *$C                     GROUP_C: MULS                               --- DONE
000010B8                           227  *$D                     GROUP_D: ADD, ADDA                          --- DONE
000010B8                           228  *$E                     GROUP_E: LSR, LSL, ASR, ASL, ROL, ROR       --- DONE
000010B8                           229  *$F                     GROUP_F: INVALID_OP                         --- DONE
000010B8                           230  
000010B8                           231  
000010B8                           232  * OP_JSR_Routine
000010B8                           233  **********************************************************************************
000010B8                           234  * Description: Catalog all supported OP codes into groupings based on their hex
000010B8                           235  * values. Sort the supported OP codes by looking at the first nibble for their
000010B8                           236  * grouping value. Call underlying subroutines for further identification of the
000010B8                           237  * op code.
000010B8                           238  *
000010B8                           239  * Registers used: A6,D0,D1 
000010B8                           240  *
000010B8                           241  * Precondition: Instruction set (size Word) has been loaded in the appropriate
000010B8                           242  * address to be parsed and read.
000010B8                           243  
000010B8                           244  * Postcondition: OP code has been identified as either valid or invalid. If it is
000010B8                           245  * valid, it is stored into A6 and EA parsing methods are called to pass needed
000010B8                           246  * information to EA. If invalid, DATA output will be utilized to indicate so.
000010B8                           247  **********************************************************************************
000010B8                           248  * These valid operand codes refer to the basic supported operand codes
000010B8                           249  * Groups refer to the first nibble value that is supported by the operand
000010B8                           250  
000010B8                           251  OP_JSR_Routine:
000010B8  48E7 C000                252      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
000010BC  3038 1000                253      MOVE.W CUR_OP_CODE,D0
000010C0  11FC 0001 10A9           254      MOVE.B #1,IS_VALID
000010C6  720C                     255      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
000010C8  E2A8                     256      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
000010CA                           257  
000010CA                           258  GROUP_0:                ;$0| ORI, BCLR (static and dynamic), CMPI                  
000010CA  B03C 0000                259      CMP.B   #$0,D0                 ;Compare first nibble
000010CE  6600 000C                260      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
000010D2  4EB9 00001330            261      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
000010D8  6000 010C                262      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000010DC                           263      
000010DC                           264  GROUP_1:                ;$1| MOVE.B
000010DC  B03C 0001                265      CMP.B   #$1,D0                 ;Compare first nibble
000010E0  6600 000C                266      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
000010E4  4EB9 0000150E            267      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
000010EA  6000 00FA                268      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000010EE                           269  
000010EE                           270  GROUP_2:                ;$2| MOVE.L, MOVEA.L
000010EE  B03C 0002                271      CMP.B   #$2,D0                 ;Compare first nibble
000010F2  6600 000C                272      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
000010F6  4EB9 00001538            273      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
000010FC  6000 00E8                274      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001100                           275  
00001100                           276  GROUP_3:                ;$3| MOVE.W, MOVEA.W
00001100  B03C 0003                277      CMP.B   #$3,D0                 ;Compare first nibble
00001104  6600 000C                278      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
00001108  4EB9 0000159A            279      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
0000110E  6000 00D6                280      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001112                           281  
00001112                           282  GROUP_4:                ;$4| LEA, JSR, RTS, NEG, MOVEM
00001112  B03C 0004                283      CMP.B   #$4,D0                 ;Compare first nibble
00001116  6600 000C                284      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
0000111A  4EB9 000015FC            285      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
00001120  6000 00C4                286      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001124                           287  
00001124                           288  
00001124                           289  GROUP_5:                ;$5| SUBQ
00001124  B03C 0005                290      CMP.B   #$5,D0                 ;Compare first nibble
00001128  6600 000C                291      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
0000112C  4EB9 0000187E            292      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
00001132  6000 00B2                293      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001136                           294  
00001136                           295  
00001136                           296  GROUP_6:                ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
00001136  B03C 0006                297      CMP.B   #$6,D0                 ;Compare first nibble
0000113A  6600 000C                298      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
0000113E  4EB9 000018E8            299      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
00001144  6000 00A0                300      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001148                           301  
00001148                           302  
00001148                           303  GROUP_7:                ;$7| Display: DATA, $WXYZ (Unsupported)
00001148  B03C 0007                304      CMP.B   #$7,D0                 ;Compare first nibble
0000114C  6600 000C                305      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
00001150  4EB9 0000198E            306      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
00001156  6000 008E                307      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000115A                           308  
0000115A                           309  
0000115A                           310  GROUP_8:                ;$8| DIVS, OR
0000115A  B03C 0008                311      CMP.B   #$8,D0                 ;Compare first nibble
0000115E  6600 000C                312      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
00001162  4EB9 000019B2            313      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
00001168  6000 007C                314      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000116C                           315  
0000116C                           316  
0000116C                           317  GROUP_9:                ;$9| SUB
0000116C  B03C 0009                318      CMP.B   #$9,D0                 ;Compare first nibble
00001170  6600 000C                319      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
00001174  4EB9 00001A0C            320      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
0000117A  6000 006A                321      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000117E                           322  
0000117E                           323  
0000117E                           324  GROUP_A:                ;$A| Display: DATA, $WXYZ (Unsupported)
0000117E  B03C 000A                325      CMP.B   #$A,D0                 ;Compare first nibble
00001182  6600 000C                326      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
00001186  4EB9 00001A6E            327      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
0000118C  6000 0058                328      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001190                           329  
00001190                           330  
00001190                           331  GROUP_B:                ;$B| EOR, CMP
00001190  B03C 000B                332      CMP.B   #$B,D0                 ;Compare first nibble
00001194  6600 000C                333      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
00001198  4EB9 00001A76            334      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
0000119E  6000 0046                335      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011A2                           336  
000011A2                           337  
000011A2                           338  GROUP_C:                ;$C| MULS
000011A2  B03C 000C                339      CMP.B   #$C,D0                 ;Compare first nibble
000011A6  6600 000C                340      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
000011AA  4EB9 00001AEA            341      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
000011B0  6000 0034                342      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011B4                           343  
000011B4                           344  
000011B4                           345  GROUP_D:                 ;$D| ADD, ADDA
000011B4  B03C 000D                346      CMP.B   #$D,D0                 ;Compare first nibble
000011B8  6600 000C                347      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
000011BC  4EB9 00001B80            348      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
000011C2  6000 0022                349      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011C6                           350  
000011C6                           351  
000011C6                           352  GROUP_E:                ;$E| LSR, LSL, ASR, ASL, ROL, ROR
000011C6  B03C 000E                353      CMP.B   #$E,D0                 ;Compare first nibble
000011CA  6600 000C                354      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
000011CE  4EB9 00001BD0            355      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
000011D4  6000 0010                356      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011D8                           357  
000011D8                           358  
000011D8                           359  GROUP_F:                ;$F| Display: DATA, $WXYZ (Unsupported)
000011D8  B03C 000F                360      CMP.B   #$F,D0                 ;Compare first nibble
000011DC  4EB9 00001D80            361      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
000011E2  6000 0002                362      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000011E6                           363  
000011E6                           364  
000011E6                           365  OP_JSR_DONE:
000011E6  4CDF 0003                366           MOVEM.L (SP)+,D0-D1       ;Recover register D0
000011EA  FFFF FFFF                367           SIMHALT
000011EE                           368           ;JMP EA_ROUTINE        ;This runs EA's routines after OP code portion is finished
000011EE                           369  **********************************************************************************
000011EE                           370  
000011EE                           371  ********** EA Parsing ************************************************************
000011EE                           372  
000011EE                           373  * MOVE_LAST_6_BITS_TO_EA
000011EE                           374  **********************************************************************************
000011EE                           375  * Description: For OP codes with the last 6 bits specified as EA Mode and EA Reg,
000011EE                           376  * the last 6 bits will be parsed and moved into the appropriate registers.
000011EE                           377  *
000011EE                           378  * Registers used: A6,D0,D1,D6,D7 
000011EE                           379  
000011EE                           380  * Precondition: OP code has been identified with only the last 6 bits for EA,
000011EE                           381  * current instruction set is stored into A6.
000011EE                           382  
000011EE                           383  * Postcondition: Last 6 bits of instruction bit has been isolated and stored. Bits
000011EE                           384  * for EA Mode have been stored in D7, Bits for EA Reg been stored in D6.
000011EE                           385  **********************************************************************************
000011EE                           386  MOVE_LAST_6_BITS_TO_EA:      ;Move last 6 bits from EA field to relevant registers
000011EE                           387     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
000011EE  3038 1000                388      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
000011F2  323C 000A                389      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
000011F6  E368                     390      LSL.W   D1,D0            ;Truncate to find the last 6 bits
000011F8  E268                     391      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
000011FA  3E00                     392      MOVE.W  D0,D7            ;Move last 6 bits into D7
000011FC  323C 0003                393      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001200  E26F                     394      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00001202  3C07                     395      MOVE.W  D7,D6            ;Move the 'upper' 3 bits into D6
00001204  323C 000D                396      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
00001208  E368                     397      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
0000120A  E268                     398      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
0000120C  3E00                     399      MOVE.W  D0,D7            ;Move the 'lower' 3 bits into D7
0000120E                           400     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
0000120E  4E75                     401      RTS                      ;Return to stack
00001210                           402      
00001210                           403  * FIND_2_BIT_SIZE_7_TO_6
00001210                           404  **********************************************************************************
00001210                           405  * Description: For OP codes with 2 bit size fields, the 2 relevant bits (7-6) will 
00001210                           406  * be parsed and moved to the appropriate registers.
00001210                           407  *
00001210                           408  * Registers used: D0,D1
00001210                           409  *
00001210                           410  * Precondition: OP code has been identified with 2 size bit field for CUR_OP_CODE.
00001210                           411  *
00001210                           412  * Postcondition: 2 bit size field has been isolated and stored into OP_SIZE.
00001210                           413  **********************************************************************************
00001210                           414  FIND_2_BIT_SIZE_7_TO_6:         ;Move the 2 bit size field relevant register
00001210  48E7 C000                415      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
00001214  3038 1000                416      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
00001218  323C 0008                417      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
0000121C  E368                     418      LSL.W    D1,D0              ;Truncate to find the 2 size bits
0000121E  E268                     419      LSR.W    D1,D0              ;Reposition the bits
00001220  323C 0006                420      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
00001224  E268                     421      LSR.W    D1,D0              ;Truncate to shift 2 bits to a byte
00001226  11C0 1002                422      MOVE.B   D0,OP_SIZE         ;Move 2 size bits into OP_SIZE
0000122A  4CDF 0003                423      MOVEM.L (SP)+,D0-D1         ;Restore registers
0000122E  4E75                     424      RTS                         ;Return to stack
00001230                           425  **********************************************************************************
00001230                           426  
00001230                           427  * FIND_1_BIT_SIZE_6
00001230                           428  **********************************************************************************
00001230                           429  * Description: For OP codes with 1 bit size fields, the 1 relevant bit 6 will 
00001230                           430  * be parsed and moved to the appropriate registers.
00001230                           431  * This particular size parsing is used for MOVEM
00001230                           432  *
00001230                           433  * Registers used: D0,D1
00001230                           434  *
00001230                           435  * Precondition: OP code has been identified with 1 size bit field for CUR_OP_CODE.
00001230                           436  *
00001230                           437  * Postcondition: 1 bit size field has been isolated and stored into OP_SIZE.
00001230                           438  **********************************************************************************
00001230                           439  FIND_1_BIT_SIZE_6:              ;Move the 1 bit size field relevant register
00001230  48E7 C000                440      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
00001234  3038 1000                441      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
00001238  323C 0009                442      MOVE.W   #9,D1              ;Prepare 9 bit shift to D1
0000123C  E368                     443      LSL.W    D1,D0              ;Truncate to find the size bit
0000123E  E268                     444      LSR.W    D1,D0              ;Reposition the bits
00001240  323C 0006                445      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
00001244  E268                     446      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
00001246  11C0 1002                447      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
0000124A  4CDF 0003                448      MOVEM.L (SP)+,D0-D1         ;Restore registers
0000124E  4E75                     449      RTS                         ;Return to stack
00001250                           450  **********************************************************************************
00001250                           451  
00001250                           452  * FIND_1_BIT_SIZE_8
00001250                           453  **********************************************************************************
00001250                           454  * Description: For OP codes with 1 bit size fields, the 1 relevant bit 8 will 
00001250                           455  * be parsed and moved to the appropriate registers.
00001250                           456  * This particular size parsing is used for ADDA
00001250                           457  *
00001250                           458  * Registers used: D0,D1
00001250                           459  *
00001250                           460  * Precondition: OP code has been identified with 1 size bit field for CUR_OP_CODE.
00001250                           461  *
00001250                           462  * Postcondition: 1 bit size field has been isolated and stored into OP_SIZE.
00001250                           463  *
00001250                           464  **********************************************************************************
00001250                           465  FIND_1_BIT_SIZE_8:         ;Move the 1 bit size field relevant register
00001250  48E7 C000                466      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
00001254  3038 1000                467      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
00001258  323C 0007                468      MOVE.W   #7,D1              ;Prepare 7 bit shift to D1
0000125C  E368                     469      LSL.W    D1,D0              ;Truncate to find the 1 size bit
0000125E  E268                     470      LSR.W    D1,D0              ;Reposition the bits
00001260  323C 0008                471      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
00001264  E268                     472      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
00001266  11C0 1002                473      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
0000126A  4CDF 0003                474      MOVEM.L (SP)+,D0-D1         ;Restore registers
0000126E  4E75                     475      RTS                         ;Return to stack
00001270                           476  **********************************************************************************
00001270                           477  
00001270                           478  
00001270                           479  
00001270                           480  * FIND_3_BIT_REG_TO_EA
00001270                           481  **********************************************************************************
00001270                           482  * Description: OP codes with a dynamic 3 bit register in bits 11-9 will be parsed
00001270                           483  * and have those 3 bits isolated and moved to the appropriate registers.
00001270                           484  *
00001270                           485  * Registers used: A6,D0,D1,D5
00001270                           486  *
00001270                           487  * Precondition: OP code has been identified with a dynamic 3 bit register in bits
00001270                           488  * 11-9.
00001270                           489  *
00001270                           490  * Postcondition: 3 bit dynamic register has been isolated and stored into D4.
00001270                           491  **********************************************************************************
00001270                           492  FIND_3_BIT_REG_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
00001270                           493     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
00001270  3038 1000                494      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
00001274  323C 0004                495      MOVE.W   #4,D1          ;Prepare 4 bit shift to D1
00001278  E368                     496      LSL.W    D1,D0          ;Truncate to find the 2 size bits
0000127A  E268                     497      LSR.W    D1,D0          ;Reposition the bits
0000127C  323C 0009                498      MOVE.W   #9,D1          ;Prepare 9 bit shift to D1
00001280  E268                     499      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
00001282  3A00                     500      MOVE.W   D0,D5          ;Move 3 register bits into D4
00001284                           501     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
00001284  4E75                     502      RTS                     ;Return to stack
00001286                           503  **********************************************************************************
00001286                           504  
00001286                           505  * MOVE_AND_MOVEA_PARSE_EA
00001286                           506  **********************************************************************************
00001286                           507  * Description: Special parsing for the SRC and DST Mode/Reg for MOVE/MOVE
00001286                           508  *
00001286                           509  * Registers used: A6,D0,D1,D7,D6,D5,D4
00001286                           510  *
00001286                           511  * Precondition: OP code has been identified with either MOVE or MOVEA
00001286                           512  *
00001286                           513  * Postcondition: Store all relevant EA bits into associated register.
00001286                           514  **********************************************************************************
00001286                           515  MOVE_AND_MOVEA_PARSE_EA:       ;Move the 3 bit dynamic register bits to proper register
00001286                           516     ; MOVEM.L D0-D7/A6, -(SP)  ;Save all changed registers
00001286  3038 1000                517      MOVE.W CUR_OP_CODE,D0           ;Move current OP code into D0
0000128A  323C 000A                518      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
0000128E  E368                     519      LSL.W   D1,D0            ;Truncate to find the last 6 bits
00001290  E268                     520      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
00001292  3E00                     521      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
00001294  323C 0003                522      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001298  E26F                     523      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
0000129A  3A07                     524      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
0000129C  323C 000D                525      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
000012A0  E368                     526      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
000012A2  E268                     527      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
000012A4  3800                     528      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
000012A6                           529      **************MOVING SOURCE*********** TO BE DONE LATER
000012A6                           530      ; MOVE.W #%0011 011 001 001 101,(A6)              ;MOVEA.W A5,A3
000012A6                           531      ; MOVE.W #%0010 011 001 001 101,D0                ;MOVEA.L A5,A3
000012A6                           532       ;Expected values:
000012A6                           533      ;D7, DST REG:   011
000012A6                           534      ;D6, DST MODE:  001
000012A6                           535      ;D5, SRC MODE:  001
000012A6                           536      ;D4, SRC REG:   101
000012A6                           537      ;00011001
000012A6  3038 1000                538      MOVE.W CUR_OP_CODE,D0     ;Move current OP code into D0     
000012AA  323C 0004                539      MOVE.W  #4,D1             ;Prepare 4 bit shift to D1
000012AE  E368                     540      LSL.W   D1,D0             ;Truncate to find bits 11-6
000012B0  E268                     541      LSR.W   D1,D0             ;Reposition bits
000012B2  323C 0006                542      MOVE.W  #6,D1             ;Prepare 6 bit shift to D1
000012B6  E268                     543      LSR.W   D1,D0             ;Truncate the SRC Reg/Mode bits
000012B8  323C 0003                544      MOVE.W  #3,D1             ;Prepare a 3 bit shift to D1 for DST Reg/Mode
000012BC  3C00                     545      MOVE.W  D0,D6             ;Copy over the current 6 bits to D6
000012BE  E268                     546      LSR.W   D1,D0             ;Truncate DST Mode  
000012C0  3E00                     547      MOVE.W  D0,D7             ;Move DST Reg to D7
000012C2  323C 000D                548      MOVE.W  #13,D1             
000012C6  E36E                     549      LSL.W   D1,D6             ;Truncate 13 bits in D6
000012C8  E26E                     550      LSR.W   D1,D6             ;Reposition D6
000012CA                           551                                ;D6 now contains the DST Reg
000012CA                           552     ; MOVEM.L (SP)+,D0-D7/A6   ;Restore registers
000012CA  4E75                     553      RTS                     ;Return to stack
000012CC                           554  **********************************************************************************
000012CC                           555  
000012CC                           556  *FIND_TRAILING_BITS_TO_EA
000012CC                           557  **********************************************************************************
000012CC                           558  FIND_TRAILING_BITS_TO_EA:       ;Move the 3 bit dynamic register bits to proper register
000012CC                           559     ; MOVEM.L  D0-D5/A6,-(SP) ;Save all changed registers
000012CC  3038 1000                560      MOVE.W   CUR_OP_CODE,D0        ;Move current OP code into D0
000012D0  323C 0007                561      MOVE.W   #7,D1          ;Prepare 4 bit shift to D1
000012D4  E368                     562      LSL.W    D1,D0          ;Truncate to find the 2 size bits
000012D6  E268                     563      LSR.W    D1,D0          ;Reposition the bits
000012D8  323C 0006                564      MOVE.W   #6,D1          ;Prepare 9 bit shift to D1
000012DC  E268                     565      LSR.W    D1,D0          ;Truncate to shift 3 bits to a byte
000012DE  3680                     566      MOVE.W   D0,(A3)          ;Move 3 register bits into D4
000012E0                           567     ; MOVEM.L (SP)+,D0-D5/A6  ;Restore registers
000012E0  4E75                     568      RTS                    ;Return to stack
000012E2                           569  **********************************************************************************
000012E2                           570  
000012E2                           571  *PARSE_EA_CONSTANT_BITS
000012E2                           572  **********************************************************************************
000012E2                           573  * Definition: Uses CUR_OP_CODE to shift the proper bits into the global constants
000012E2                           574  * used for EA (MNEMONIC,FIRST_3,SECOND_3,THIRD_3,FOURTH_3. Where MNEMONIC refers
000012E2                           575  * to the first 4 bits of CUR_OP_CODE (15-12), FIRST_3 refers to the first group
000012E2                           576  * of 3 bits (11-9), SECOND_3 refers to the second group of 3 bits (8-6), THIRD_3
000012E2                           577  * refers to the third group of 3 bits (5-3), and FOURTH_3 refers to the fourth
000012E2                           578  * group of 3 bits (2-0). Shifts CUR_OP_CODE bits to initialize constants.
000012E2                           579  *
000012E2                           580  * Registers used: D0,D1
000012E2                           581  *
000012E2                           582  * Precondition: CUR_OP_CODE has been set with an 4 hex instruction set
000012E2                           583  * 
000012E2                           584  * Postcondition: MNEMONIC, FIRST_3, SECOND_3, THIRD_3, FOURTH_3 have been set
000012E2                           585  * to the corresponding values.
000012E2                           586  **********************************************************************************
000012E2                           587  PARSE_EA_CONSTANT_BITS:
000012E2                           588      *MNEMONIC SHIFT
000012E2  3038 1000                589      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
000012E6  323C 000C                590      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
000012EA  E268                     591      LSR.W D1,D0                 ;Shift 12 bits from D0 right
000012EC  11C0 1053                592      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
000012F0                           593      *FIRST_3 SHIFT
000012F0  323C 0009                594      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
000012F4  3038 1000                595      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000012F8  E948                     596      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
000012FA  E848                     597      LSR.W #4,D0                 ;Reposition D0
000012FC  E268                     598      LSR.W  D1,D0                ;Shift D0 9 bits right
000012FE  11C0 1054                599      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
00001302                           600      *SECOND_3 SHIFT
00001302  3038 1000                601      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001306  EF48                     602      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
00001308  EE48                     603      LSR.W #7,D0                 ;Reposition D0
0000130A  EC48                     604      LSR.W #6,D0                 ;Shift D0 6 bits right
0000130C  11C0 1055                605      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
00001310                           606      *THIRD_3 SHIFT
00001310  3038 1000                607      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001314  E648                     608      LSR.W #3,D0                 ;Shift D0 3 bits right
00001316  323C 000D                609      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
0000131A  E368                     610      LSL.W D1,D0                 ;Truncate first 13 bits of D0
0000131C  E268                     611      LSR.W D1,D0                 ;Reposition D0
0000131E  11C0 1056                612      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
00001322                           613      *FOURTH_3 SHIFT
00001322  3038 1000                614      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001326  E368                     615      LSL.W D1,D0                 ;Grab the fourth 3-bit group
00001328  E268                     616      LSR.W D1,D0                 ;Shift D0 back into position
0000132A  11C0 1057                617      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
0000132E  4E75                     618      RTS                         ;Return to stack
00001330                           619  **********************************************************************************
00001330                           620  ********** End of EA Parsing *****************************************************
00001330                           621  
00001330                           622  *******************JMP LABELS ****************************************************
00001330                           623  * Labelling for group codes will be in the following format
00001330                           624  
00001330                           625  * <JMP Labelname>
00001330                           626  ********************************************************************************
00001330                           627  * Checking List Order (If more than one value)
00001330                           628  * Operand1 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
00001330                           629  * Operand2 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
00001330                           630  
00001330                           631  * Where a-b will refer to the bit corresponding bit value in the instruction
00001330                           632  * format, and a specifier will be attached such as Size, EA Mode, SRC Reg, etc
00001330                           633  * to clarify what a specific bit range means.
00001330                           634  * Checking order refers to what order the checks will be performed in. 
00001330                           635  * Any other code outside of the listed ones will be INVALID_OP.
00001330                           636  ********************************************************************************
00001330                           637  
00001330                           638  ********************************************************************************
00001330                           639  * Global Field Descriptions
00001330                           640  * Size Field: Byte = 00 Word = 01 Long = 10
00001330                           641  * EA Mode: Refer to EA Address Modes
00001330                           642  * EA Reg: 3-bit input that is mapped to the respective binary value
00001330                           643  ********************************************************************************
00001330                           644  
00001330                           645  * GROUP_0                      
00001330                           646  ********************************************************************************
00001330                           647  * Description: Checks for the following listed OP codes to be present or not
00001330                           648  * Supported OP codes:
00001330                           649  * ORI: $00, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00001330                           650  * CMPI: $0C, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00001330                           651  * Dynamic BCLR: $0, 11-9 Register, 8-6 %110, 5-3 EA Mode, 2-0 EA Reg
00001330                           652  * Static BCLR: $01, 7-6 10, 5-3 EA Mode, 2-0 EA Reg
00001330                           653  *
00001330                           654  * Registers used: D0
00001330                           655  *
00001330                           656  * Precondition: First nibble has been identified as $0
00001330                           657  *
00001330                           658  * Postcondition: Parses proper OP code with a nibble value of $0 or finds an
00001330                           659  * invalid OP code. After a successful parse loading for EA values will be done
00001330                           660  * through a subroutine.
00001330                           661  * 
00001330                           662  * Unsupported OP codes:
00001330                           663  * ORI_TO_CCR, ORI_TO_SR, ANDI_TO_CCR, ANDI_TO_SR, ANDI, SUBI, ADDI, EORI_TO_CCR
00001330                           664  * EORI_TO_SR, EORI, STATIC_BTST, STATIC_BCHG, STATIC_BSET, DYNAMIC_BTST,
00001330                           665  * DYNAMIC_BCHG, DYNAMIC_BSET, MOVEP 
00001330                           666  ********************************************************************************
00001330                           667  C_GROUP_0:
00001330  48E7 C000                668      MOVEM.L D0-D1, -(SP)            ;Backup registers
00001334                           669      
00001334                           670  *Unsupported OP codes that are fully static in bits
00001334                           671  CHECK_OP_ORI_TO_CCR:
00001334  3038 1000                672      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001338  B07C 003C                673      CMP.W #$003C,D0                 ;Compare the direct full bits
0000133C  6700 01C4                674      BEQ GROUP0_INVALID              ;INVALID OP code found
00001340  6600 0002                675      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
00001344                           676      
00001344                           677  CHECK_OP_ORI_TO_SR:
00001344  3038 1000                678      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001348  B07C 007C                679      CMP.W #$007C,D0                 ;Compare the direct full bits
0000134C  6700 01B4                680      BEQ GROUP0_INVALID              ;INVALID OP code found
00001350  6600 0002                681      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
00001354                           682      
00001354                           683  CHECK_OP_ANDI_TO_CCR:
00001354  3038 1000                684      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001358  B07C 023C                685      CMP.W #$023C,D0                 ;Compare the direct full bits
0000135C  6700 01A4                686      BEQ GROUP0_INVALID              ;INVALID OP code found
00001360  6600 0002                687      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
00001364                           688      
00001364                           689  CHECK_OP_ANDI_TO_SR:
00001364  3038 1000                690      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001368  B07C 027C                691      CMP.W #$027C,D0                 ;Compare the direct full bits
0000136C  6700 0194                692      BEQ GROUP0_INVALID              ;INVALID OP code found
00001370  6600 0002                693      BNE CHECK_OP_EORI_TO_CCR                ;Check next routine
00001374                           694  
00001374                           695  CHECK_OP_EORI_TO_CCR:
00001374  3038 1000                696      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001378  B07C 0A3C                697      CMP.W #$0A3C,D0                 ;Compare the direct full bits
0000137C  6700 0184                698      BEQ GROUP0_INVALID              ;INVALID OP code found
00001380  6600 0002                699      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
00001384                           700      
00001384                           701  CHECK_OP_EORI_TO_SR:
00001384  3038 1000                702      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001388  B07C 0A7C                703      CMP.W #$0A7C,D0                 ;Compare the direct full bits
0000138C  6700 0174                704      BEQ GROUP0_INVALID              ;INVALID OP code found
00001390  6600 0002                705      BNE CHECK_OP_ANDI               ;Check next routine
00001394                           706      
00001394                           707  *Unsupported OP codes to check with partial static bits
00001394                           708  CHECK_OP_ANDI:
00001394  3038 1000                709      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001398  0240 FF00                710      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
0000139C  B07C 0200                711      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
000013A0  6700 0160                712      BEQ GROUP0_INVALID              ;INVALID OP code found
000013A4  6600 0002                713      BNE CHECK_OP_SUBI               Check next routine
000013A8                           714      
000013A8                           715  CHECK_OP_SUBI:
000013A8  3038 1000                716      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013AC  0240 FF00                717      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000013B0  B07C 0400                718      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
000013B4  6700 014C                719      BEQ GROUP0_INVALID              ;INVALID OP code found
000013B8  6600 0002                720      BNE CHECK_OP_ADDI               ;Check next routine
000013BC                           721  
000013BC                           722  CHECK_OP_ADDI:
000013BC  3038 1000                723      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013C0  0240 FF00                724      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000013C4  B07C 0600                725      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
000013C8  6700 0138                726      BEQ GROUP0_INVALID              ;INVALID OP code found
000013CC  6600 0002                727      BNE CHECK_OP_EORI               ;Check next routine 
000013D0                           728  
000013D0                           729  CHECK_OP_EORI:
000013D0  3038 1000                730      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013D4  0240 FF00                731      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000013D8  B07C 0A00                732      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
000013DC  6700 0124                733      BEQ GROUP0_INVALID              ;INVALID OP code found
000013E0  6600 0002                734      BNE CHECK_OP_STATIC_BTST        ;Check next routine
000013E4                           735      
000013E4                           736  CHECK_OP_STATIC_BTST:
000013E4  3038 1000                737      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013E8  0240 FFC0                738      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
000013EC  B07C 0800                739      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
000013F0  6700 0110                740      BEQ GROUP0_INVALID              ;INVALID OP code found
000013F4  6600 0002                741      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
000013F8                           742      
000013F8                           743  CHECK_OP_STATIC_BCHG:
000013F8  3038 1000                744      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000013FC  0240 FFC0                745      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001400  B07C 0840                746      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
00001404  6700 00FC                747      BEQ GROUP0_INVALID              ;INVALID OP code found
00001408  6600 0002                748      BNE CHECK_OP_STATIC_BSET        ;Check next routine
0000140C                           749  
0000140C                           750  CHECK_OP_STATIC_BSET:
0000140C  3038 1000                751      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001410  0240 FFC0                752      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001414  B07C 08C0                753      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
00001418  6700 00E8                754      BEQ GROUP0_INVALID              ;INVALID OP code found   
0000141C  6600 0002                755      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
00001420                           756  
00001420                           757  CHECK_OP_DYNAMIC_BTST:
00001420  3038 1000                758      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001424  0240 F1C0                759      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001428  B07C 0100                760      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
0000142C  6700 00D4                761      BEQ GROUP0_INVALID              ;INVALID OP code found
00001430  6600 0002                762      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
00001434                           763  
00001434                           764  CHECK_OP_DYNAMIC_BCHG:
00001434  3038 1000                765      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001438  0240 F1C0                766      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
0000143C  B07C 0140                767      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00001440  6700 00C0                768      BEQ GROUP0_INVALID              ;INVALID OP code found
00001444  6600 0002                769      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001448                           770      
00001448                           771  CHECK_OP_DYNAMIC_BSET:
00001448                           772  
00001448  3038 1000                773      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000144C  0240 F1C0                774      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001450  B07C 01C0                775      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
00001454  6700 0006                776      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001458  6600 001C                777      BNE     CHECK_OP_MOVEP          ;Check next routine
0000145C                           778  
0000145C                           779  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
0000145C  3038 1000                780      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001460  323C 000A                781      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
00001464  E368                     782      LSL.W   D1,D0                   ;Shift out 10 bits left 
00001466  E268                     783      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001468  E648                     784      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
0000146A  B07C 0001                785      CMP.W   #$1,D0                  ;Compare bits to D0
0000146E  6700 0006                786      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
00001472  6600 008E                787      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid                                                    
00001476                           788      
00001476                           789  CHECK_OP_MOVEP:
00001476  3038 1000                790      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000147A  0240 F138                791      ANDI.W #$F138,D0                ;Mask relevant bits to D0
0000147E  B07C 0108                792      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
00001482  6700 0904                793      BEQ INVALID_OP                  ;INVALID OP code found
00001486  6600 0002                794      BNE CHECK_OP_ORI                ;Check next routine
0000148A                           795  
0000148A                           796  *Supported OP code checks
0000148A                           797  CHECK_OP_ORI:
0000148A  3038 1000                798      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000148E  0240 FF00                799      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001492  B07C 0000                800      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00001496  6600 0010                801      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
0000149A  4EB8 1210                802      JSR     FIND_2_BIT_SIZE_7_TO_6
0000149E  4EB9 00001DB2            803      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
000014A4  6000 0062                804      BRA     GROUP0_SUCCESS          ;Finish routine
000014A8                           805      
000014A8                           806  CHECK_OP_CMPI:
000014A8  3038 1000                807      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000014AC  0240 FF00                808      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
000014B0  B07C 0C00                809      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
000014B4  6600 0010                810      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
000014B8  4EB8 1210                811      JSR     FIND_2_BIT_SIZE_7_TO_6
000014BC  4EB9 00001DC8            812      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
000014C2  6000 0044                813      BRA     GROUP0_SUCCESS          ;Finish routine
000014C6                           814      
000014C6                           815  CHECK_OP_STATIC_BCLR:
000014C6  3038 1000                816      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000014CA  0240 FF00                817      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
000014CE  B07C 0800                818      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
000014D2  6600 0010                819      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
000014D6  4EB8 1210                820      JSR     FIND_2_BIT_SIZE_7_TO_6
000014DA  4EB9 00001DDE            821      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
000014E0  6000 0026                822      BRA     GROUP0_SUCCESS          ;Finish routine
000014E4                           823      
000014E4                           824  CHECK_OP_DYNAMIC_BCLR:
000014E4  3038 1000                825      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000014E8  0240 0180                826      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
000014EC  B07C 0180                827      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
000014F0  6600 0010                828      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
000014F4  4EB8 1210                829      JSR     FIND_2_BIT_SIZE_7_TO_6
000014F8  4EB9 00001DF4            830      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
000014FE  6000 0008                831      BRA     GROUP0_SUCCESS          ;Finish routine
00001502                           832  
00001502                           833  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
00001502  4EB9 00001D88            834      JSR INVALID_OP                  ;INVALID OP code found
00001508                           835      
00001508                           836  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
00001508  4CDF 0003                837      MOVEM.L (SP)+,D0-D1             ;Restore registers
0000150C  4E75                     838      RTS                             ;Return to stack
0000150E                           839      
0000150E                           840  * GROUP_1                      
0000150E                           841  ********************************************************************************
0000150E                           842  * Supported OP code:
0000150E                           843  * MOVE.B: $1, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
0000150E                           844  ********************************************************************************
0000150E                           845  C_GROUP_1:
0000150E  48E7 C000                846      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
00001512                           847  
00001512                           848  CHECK_OP_MOVE_B:
00001512  3038 1000                849      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
00001516  0240 F000                850      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
0000151A  B07C 1000                851      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
0000151E  6600 000C                852      BNE     GROUP1_INVALID          ;Invalid OP code has been found
00001522  4EB9 00001E0A            853      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
00001528  6000 0008                854      BRA     GROUP1_SUCCESS          ;Finish routine
0000152C                           855      
0000152C                           856  GROUP1_INVALID:
0000152C  4EB9 00001D88            857      JSR INVALID_OP                  ;Invalid OP code found
00001532                           858      
00001532                           859  GROUP1_SUCCESS:
00001532  4CDF 0003                860      MOVEM.L (SP)+,D0-D1             ;Restore register
00001536  4E75                     861      RTS                             ;Return to stack
00001538                           862  * GROUP_2
00001538                           863  ********************************************************************************
00001538                           864  * Supported OP codes:
00001538                           865  * MOVEA.L: $2, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
00001538                           866  * MOVE.L: $2, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00001538                           867  ********************************************************************************
00001538                           868  C_GROUP_2:
00001538  48E7 E000                869      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
0000153C                           870  
0000153C                           871  CHECK_OP_MOVEA_L:
0000153C  3038 1000                872      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
00001540  0240 F000                873      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001544  B07C 2000                874      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001548  4EF9 0000154E            875      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
0000154E                           876      
0000154E                           877  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
0000154E  3038 1000                878      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
00001552  323C 0007                879      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00001556  E368                     880      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001558  E268                     881      LSR.W    D1,D0                  ;Reposition the bits
0000155A  323C 0006                882      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
0000155E  E268                     883      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00001560  3400                     884      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
00001562  B47C 0001                885      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00001566  6600 000C                886      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
0000156A  4EB9 00001E20            887      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00001570  6000 0022                888      BRA     GROUP2_SUCCESS          ;Finish routine
00001574                           889      
00001574                           890      
00001574                           891  CHECK_OP_MOVE_L:
00001574  3038 1000                892      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001578  0240 F000                893      ANDI.W #$F000,D0                ;Mask relevant bits to D0
0000157C  B07C 2000                894      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001580  6600 000C                895      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
00001584  4EB9 00001E36            896      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
0000158A  6000 0008                897      BRA GROUP2_SUCCESS              ;Finish routine
0000158E                           898      
0000158E                           899  GROUP2_INVALID:    
0000158E  4EB9 00001D88            900      JSR INVALID_OP                  ;Invalid OP code found
00001594                           901      
00001594                           902  GROUP2_SUCCESS:
00001594  4CDF 0007                903      MOVEM.L (SP)+,D0-D2             ;Restore register
00001598  4E75                     904      RTS                             ;Return to stack
0000159A                           905  * GROUP_3
0000159A                           906  ********************************************************************************
0000159A                           907  * Supported OP codes:
0000159A                           908  * MOVEA.W: $3, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
0000159A                           909  * MOVE.W: $3, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
0000159A                           910  ********************************************************************************
0000159A                           911  C_GROUP_3:
0000159A  48E7 E000                912      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
0000159E                           913      
0000159E                           914  CHECK_OP_MOVEA_W:
0000159E  3038 1000                915      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
000015A2  0240 F000                916      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
000015A6  B07C 3000                917      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
000015AA  4EF9 000015B0            918      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
000015B0                           919  
000015B0                           920      
000015B0                           921  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
000015B0  3038 1000                922      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
000015B4  323C 0007                923      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
000015B8  E368                     924      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
000015BA  E268                     925      LSR.W    D1,D0                 ;Reposition the bits
000015BC  323C 0006                926      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
000015C0  E268                     927      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
000015C2  3400                     928      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
000015C4  B47C 0001                929      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
000015C8  6600 000C                930      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
000015CC  4EB9 00001E4C            931      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
000015D2  6000 0022                932      BRA      GROUP3_SUCCESS        ;Finish routine
000015D6                           933      
000015D6                           934  CHECK_OP_MOVE_W:
000015D6  3038 1000                935      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
000015DA  0240 F000                936      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
000015DE  B07C 3000                937      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
000015E2  6600 000C                938      BNE      GROUP3_INVALID        ;INVALID OP code found
000015E6  4EB9 00001E5C            939      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
000015EC  6000 0008                940      BRA      GROUP3_SUCCESS        ;Finish routine
000015F0                           941      
000015F0                           942  GROUP3_INVALID:
000015F0  4EB9 00001D88            943      JSR INVALID_OP                 ;INVALID OP code found
000015F6                           944  
000015F6                           945  GROUP3_SUCCESS:
000015F6  4CDF 0007                946      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
000015FA  4E75                     947      RTS                            ;Return to stack
000015FC                           948  
000015FC                           949  * GROUP_4
000015FC                           950  ********************************************************************************
000015FC                           951  * Supported OP codes:
000015FC                           952  * LEA: $4, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
000015FC                           953  * JSR: $4E, 7-6 %10, 5-3 EA Mode, 2-0 EA Reg 
000015FC                           954  * RTS: $4E75
000015FC                           955  * NEG: $44, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000015FC                           956  * MOVEM: $4, 11 %1, 10 %D, 9-7 %001, 6 S, 5-3 EA Mode, 2-0 EA Reg
000015FC                           957  * %D = 0 , Register to Memory, 1 Memory to Register
000015FC                           958  * Unsupported OP codes: MOVE_FROM_SR, MOVE_TO_CCR, MOVE_TO_SR, NEGX, CLR, NOT
000015FC                           959  * EXT, NBCD, SWAP, PEA, ILLEGAL, TAS, TST, TRAP, LINK, UNLK, MOVE_USP, RESET,
000015FC                           960  * NOP, STOP, RTE, TRAPV, RTR, JMP, CHK
000015FC                           961  ********************************************************************************
000015FC                           962  C_GROUP_4:
000015FC  2F00                     963      MOVE.L  D0,-(SP)            ;Save registers
000015FE                           964      
000015FE                           965  *Unsupported OP codes to check that are full static bits
000015FE                           966  CHECK_OP_STOP:
000015FE  3038 1000                967      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001602  B07C 4E72                968      CMP.W  #$4E72,D0                ;Compare the appropriate bits
00001606  6700 026A                969      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000160A  6600 0002                970      BNE    CHECK_OP_RESET           ;Check next OP code
0000160E                           971      
0000160E                           972  CHECK_OP_RESET:
0000160E  3038 1000                973      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001612  B07C 4E70                974      CMP.W  #$4E70,D0                ;Compare the appropriate bits
00001616  6700 025A                975      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000161A  6600 0002                976      BNE    CHECK_OP_NOP             ;Check next OP code
0000161E                           977      
0000161E                           978  CHECK_OP_NOP:
0000161E  3038 1000                979      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001622  B07C 4E71                980      CMP.W  #$4E71,D0                ;Compare the appropriate bits
00001626  6700 024A                981      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000162A  6600 0002                982      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
0000162E                           983      
0000162E                           984  CHECK_OP_ILLEGAL:
0000162E  3038 1000                985      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001632  B07C 4AFC                986      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
00001636  6700 023A                987      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000163A  6600 0002                988      BNE    CHECK_OP_RTE             ;Check next OP code
0000163E                           989      
0000163E                           990  CHECK_OP_RTE:    
0000163E  3038 1000                991      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001642  B07C 4E73                992      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00001646  6700 022A                993      BEQ   GROUP4_INVALID            ;INVALID OP code found
0000164A  6600 0002                994      BNE   CHECK_OP_TRAPV            ;Check next OP code
0000164E                           995      
0000164E                           996  CHECK_OP_TRAPV:
0000164E  3038 1000                997      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001652  B07C 4E76                998      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00001656  6700 021A                999      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000165A  6600 0002               1000      BNE    CHECK_OP_RTR             ;Check next OP code
0000165E                          1001      
0000165E                          1002  CHECK_OP_RTR:
0000165E  3038 1000               1003      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001662  B07C 4E77               1004      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00001666  6700 020A               1005      BEQ    GROUP4_INVALID           ;INVALID OP code found
0000166A  6600 0002               1006      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
0000166E                          1007  
0000166E                          1008  
0000166E                          1009  *Unsupported OP codes to check that have partial static bits
0000166E                          1010  CHECK_OP_MOVE_FROM_SR:
0000166E  3038 1000               1011      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001672  0240 FFC0               1012      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001676  B07C 40C0               1013      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
0000167A  6700 01F6               1014      BEQ    GROUP4_INVALID           ;INVALID OP code found  
0000167E  6600 0002               1015      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
00001682                          1016      
00001682                          1017  CHECK_OP_MOVE_TO_CCR:
00001682  3038 1000               1018      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001686  0240 FFC0               1019      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
0000168A  B07C 44C0               1020      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
0000168E  6700 01E2               1021      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001692  6600 0002               1022      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00001696                          1023      
00001696                          1024  CHECK_OP_MOVE_TO_SR:
00001696  3038 1000               1025      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000169A  0240 FFC0               1026      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
0000169E  B07C 46C0               1027      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
000016A2  6700 01CE               1028      BEQ    GROUP4_INVALID           ;INVALID OP code found
000016A6  6600 0002               1029      BNE    CHECK_OP_NEGX            ;Check next OP code
000016AA                          1030      
000016AA                          1031  CHECK_OP_NEGX:
000016AA  3038 1000               1032      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
000016AE  0240 FF00               1033      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000016B2  B07C 4000               1034      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
000016B6  6700 01BA               1035      BEQ    GROUP4_INVALID           ;INVALID OP code found
000016BA  6600 0002               1036      BNE    CHECK_OP_CLR             ;Check next OP code
000016BE                          1037      
000016BE                          1038  CHECK_OP_CLR:
000016BE  3038 1000               1039      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016C2  0240 FF00               1040      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000016C6  B07C 4200               1041      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
000016CA  6700 01A6               1042      BEQ    GROUP4_INVALID           ;INVALID OP code found
000016CE  6600 0002               1043      BNE    CHECK_OP_NOT             ;Check next OP code
000016D2                          1044      
000016D2                          1045  CHECK_OP_NOT:
000016D2  3038 1000               1046      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016D6  0240 FF00               1047      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
000016DA  B07C 4600               1048      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
000016DE  6700 0192               1049      BEQ    GROUP4_INVALID           ;INVALID OP code found
000016E2  6600 0002               1050      BNE    CHECK_OP_EXT             ;Check next OP code
000016E6                          1051      
000016E6                          1052  CHECK_OP_EXT:
000016E6  3038 1000               1053      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000016EA  0240 FF88               1054      ANDI.W #$FF88,D0                ;Mask relevant bits to D0
000016EE  B07C 4880               1055      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
000016F2  6700 017E               1056      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
000016F6  6600 001C               1057      BNE    CHECK_OP_NBCD            ;Check next OP code
000016FA                          1058  
000016FA                          1059  BIT_CHECK_EXT:    
000016FA  3038 1000               1060      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
000016FE  323C 000A               1061      MOVE.W #10,D1
00001702  E368                    1062      LSL.W  D1,D0
00001704  E068                    1063      LSR.W  D0,D0
00001706  E648                    1064      LSR.W  #3,D0
00001708  B078 0000               1065      CMP.W  %000,D0
0000170C  6700 0164               1066      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
00001710  6600 0146               1067      BNE    CHECK_OP_MOVEM           ;This is the only other possibility 
00001714                          1068      
00001714                          1069  CHECK_OP_NBCD:
00001714  3038 1000               1070      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001718  0240 FFC0               1071      ANDI.W #$FFC0,D0            
0000171C  B07C 4800               1072      CMP.W  #$4800,D0
00001720  6700 0150               1073      BEQ    GROUP4_INVALID
00001724  6600 0002               1074      BNE    CHECK_OP_SWAP
00001728                          1075      
00001728                          1076  CHECK_OP_SWAP:                  ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
00001728  3038 1000               1077      MOVE.W CUR_OP_CODE,D0       ;Move current instruction set into D0
0000172C  0240 FF48               1078      ANDI.W #$FF48,D0
00001730  B07C 4840               1079      CMP.W  #$4840,D0
00001734  6700 013C               1080      BEQ    GROUP4_INVALID
00001738  6600 0002               1081      BNE    CHECK_OP_PEA
0000173C                          1082   
0000173C                          1083  CHECK_OP_PEA:               ; This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
0000173C  3038 1000               1084      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001740  0240 FF40               1085      ANDI.W #$FF40,D0
00001744  B07C 4840               1086      CMP.W  #$4840,D0
00001748  6700 0128               1087      BEQ    GROUP4_INVALID
0000174C  6600 0002               1088      BNE    CHECK_OP_TAS
00001750                          1089      
00001750                          1090  CHECK_OP_TAS:
00001750  3038 1000               1091      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001754  0240 FFC0               1092      ANDI.W #$FFC0,D0
00001758  B07C 4AC0               1093      CMP.W  #$4AC0,D0
0000175C  6700 0114               1094      BEQ    GROUP4_INVALID
00001760  6600 0002               1095      BNE    CHECK_OP_TST
00001764                          1096  
00001764                          1097  CHECK_OP_TST:               ; This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
00001764  3038 1000               1098      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001768  0240 FF00               1099      ANDI.W #$FF00,D0
0000176C  B07C 4A00               1100      CMP.W  #$4A00,D0
00001770  6700 0100               1101      BEQ    GROUP4_INVALID
00001774  6600 0002               1102      BNE    CHECK_OP_TRAP
00001778                          1103      
00001778                          1104  CHECK_OP_TRAP:
00001778  3038 1000               1105      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000177C  0240 FFF0               1106      ANDI.W #$FFF0,D0
00001780  B07C 4E40               1107      CMP.W  #$4E40,D0
00001784  6700 00EC               1108      BEQ    GROUP4_INVALID
00001788  6600 0002               1109      BNE    CHECK_OP_LINK
0000178C                          1110      
0000178C                          1111  CHECK_OP_LINK:
0000178C  3038 1000               1112      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001790  0240 FFF8               1113      ANDI.W #$FFF8,D0
00001794  B07C 4E50               1114      CMP.W  #$4E50,D0
00001798  6700 00D8               1115      BEQ    GROUP4_INVALID
0000179C  6600 0002               1116      BNE    CHECK_OP_UNLK
000017A0                          1117  
000017A0                          1118  CHECK_OP_UNLK:
000017A0  3038 1000               1119      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017A4  0240 FFF8               1120      ANDI.W #$FFF8,D0
000017A8  B07C 4E58               1121      CMP.W  #$4E58,D0
000017AC  6700 00C4               1122      BEQ    GROUP4_INVALID
000017B0  6600 0002               1123      BNE    CHECK_OP_MOVE_USP
000017B4                          1124      
000017B4                          1125  CHECK_OP_MOVE_USP:
000017B4  3038 1000               1126      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017B8  0240 FFF0               1127      ANDI.W #$FFF0,D0
000017BC  B07C 4E60               1128      CMP.W  #$4E60,D0
000017C0  6700 00B0               1129      BEQ    GROUP4_INVALID
000017C4  6600 0002               1130      BNE    CHECK_OP_JMP
000017C8                          1131  
000017C8                          1132  CHECK_OP_JMP:
000017C8  3038 1000               1133       MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017CC  0240 FFC0               1134       ANDI.W #$FFC0,D0
000017D0  B07C 4EC0               1135       CMP.W  #$4EC0,D0
000017D4  6700 009C               1136       BEQ    GROUP4_INVALID
000017D8  6600 0002               1137       BNE    CHECK_OP_CHK
000017DC                          1138       
000017DC                          1139  CHECK_OP_CHK:
000017DC  3038 1000               1140      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
000017E0  0240 F1C0               1141      ANDI.W  #$F1C0,D0
000017E4  B07C 4180               1142      CMP.W   #$4180,D0
000017E8  6700 059E               1143      BEQ     INVALID_OP
000017EC  6600 0002               1144      BNE     CHECK_OP_RTS
000017F0                          1145  
000017F0                          1146  *Supported OP codes to check
000017F0                          1147  CHECK_OP_RTS:
000017F0  3038 1000               1148      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000017F4  B07C 4E75               1149      CMP.W  #$4E75,D0
000017F8  6600 000C               1150      BNE    CHECK_OP_LEA
000017FC  4EB9 00001E88           1151      JSR    PRINT_OP_RTS
00001802  6000 0074               1152      BRA    GROUP4_SUCCESS              ;Finish routine
00001806                          1153   
00001806                          1154  CHECK_OP_LEA:
00001806  3038 1000               1155      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000180A  0240 F1C0               1156      ANDI.W #$F1C0,D0
0000180E  B07C 41C0               1157      CMP.W  #$41C0,D0
00001812  6600 000C               1158      BNE    CHECK_OP_JSR
00001816  4EB9 00001E9E           1159      JSR    PRINT_OP_LEA
0000181C  6000 005A               1160      BRA    GROUP4_SUCCESS              ;Finish routine
00001820                          1161   
00001820                          1162  CHECK_OP_JSR:
00001820  3038 1000               1163      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001824  0240 FFC0               1164      ANDI.W #$FFC0,D0
00001828  B07C 4E80               1165      CMP.W  #$4E80,D0
0000182C  6600 000C               1166      BNE    CHECK_OP_NEG
00001830  4EB9 00001E72           1167      JSR    PRINT_OP_JSR
00001836  6000 0040               1168      BRA    GROUP4_SUCCESS              ;Finish routine
0000183A                          1169      
0000183A                          1170  CHECK_OP_NEG:
0000183A  3038 1000               1171      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000183E  0240 FF00               1172      ANDI.W #$FF00,D0
00001842  B07C 4400               1173      CMP.W  #$4400,D0
00001846  6600 0010               1174      BNE    CHECK_OP_MOVEM
0000184A  4EB8 1210               1175      JSR     FIND_2_BIT_SIZE_7_TO_6
0000184E  4EB9 00001EB4           1176      JSR    PRINT_OP_NEG
00001854  6000 0022               1177      BRA    GROUP4_SUCCESS              ;Finish routine
00001858                          1178  
00001858                          1179      
00001858                          1180  **************** COME BACK TO FINISH UP SIZE **********************************
00001858                          1181  CHECK_OP_MOVEM:
00001858  3038 1000               1182      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000185C  0240 FB80               1183      ANDI.W #$FB80,D0
00001860  B07C 4880               1184      CMP.W  #$4880,D0
00001864  6600 0522               1185      BNE    INVALID_OP       ;If no code is found, it is invalid
00001868  4EB9 00001ECA           1186      JSR    PRINT_OP_MOVEM_W
0000186E  6000 0008               1187      BRA    GROUP4_SUCCESS
00001872                          1188      
00001872                          1189  GROUP4_INVALID:
00001872  4EB9 00001D88           1190      JSR INVALID_OP
00001878                          1191  
00001878                          1192  GROUP4_SUCCESS:
00001878  4CDF 0001               1193      MOVEM.L (SP)+,D0 
0000187C  4E75                    1194      RTS
0000187E                          1195  * GROUP_5
0000187E                          1196  ********************************************************************************
0000187E                          1197  * Supported OP code:
0000187E                          1198  * SUBQ: $5, 11-9 DATA, 8 %1, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
0000187E                          1199  * Unsupported OP codes: ADDQ, Scc, DBcc
0000187E                          1200  * Validation checking:
0000187E                          1201  * Check against, ADDQ, Scc, DBcc
0000187E                          1202  ********************************************************************************
0000187E                          1203  C_GROUP_5:
0000187E  48E7 8000               1204      MOVEM.L D0,-(SP)         ;Save registers to stack
00001882                          1205  *Unsupported OP codes
00001882                          1206  CHECK_OP_DBcc:               ;These are ordered first due to checking bits 7-6
00001882  3038 1000               1207      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001886  0240 F0C8               1208      ANDI.W #$F0C8,D0
0000188A  B07C 50C8               1209      CMP.W  #$50C8,D0
0000188E  6700 004C               1210      BEQ    GROUP5_INVALID
00001892  6600 0002               1211      BNE    CHECK_OP_Scc 
00001896                          1212  
00001896                          1213  CHECK_OP_Scc:
00001896  3038 1000               1214      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
0000189A  0240 F0C0               1215      ANDI.W #$F0C0,D0 
0000189E  B07C 50C0               1216      CMP.W  #$50C0,D0
000018A2  6700 0038               1217      BEQ     GROUP5_INVALID
000018A6  6600 0002               1218      BNE     CHECK_OP_ADDQ
000018AA                          1219  
000018AA                          1220  CHECK_OP_ADDQ:
000018AA  3038 1000               1221      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
000018AE  0240 F100               1222      ANDI.W #$F100,D0
000018B2  B07C 5000               1223      CMP.W  #$5000,D0
000018B6  6700 0024               1224      BEQ    GROUP5_INVALID
000018BA  6600 0002               1225      BNE    CHECK_OP_SUBQ
000018BE                          1226  
000018BE                          1227  *Supported OP code   
000018BE                          1228  CHECK_OP_SUBQ     
000018BE  3038 1000               1229      MOVE.W  CUR_OP_CODE,D0  ;Actual check for SUBQ
000018C2  0240 F100               1230      ANDI.W #$F100,D0        ;Bitmask check for SUBQ
000018C6  B07C 5100               1231      CMP.W  #$5100,D0        ;Compare the proper value
000018CA  6600 0010               1232      BNE    GROUP5_INVALID       ;Else the operand is invalid
000018CE  4EB8 1210               1233      JSR     FIND_2_BIT_SIZE_7_TO_6
000018D2  4EB9 00001EEA           1234      JSR    PRINT_OP_SUBQ    ;If equal print it out
000018D8  6000 0008               1235      BRA    GROUP5_SUCCESS   ;Finish routine
000018DC                          1236      
000018DC                          1237  GROUP5_INVALID: 
000018DC  4EB9 00001D88           1238      JSR INVALID_OP          ;INVALID OP has been found
000018E2                          1239  
000018E2                          1240  GROUP5_SUCCESS:
000018E2  4CDF 0001               1241      MOVEM.L (SP)+,D0        ;Restore registers from stack
000018E6  4E75                    1242      RTS                     ;Return to stack
000018E8                          1243      
000018E8                          1244  * GROUP_6
000018E8                          1245  ********************************************************************************
000018E8                          1246  * Supported OP codes
000018E8                          1247  * BRA: $60, 7-0 8-Bit Displacement
000018E8                          1248  * Bcc: $6, 11-8 Condition, 7-0 8-Bit Displacement
000018E8                          1249  *   Branch: <Condition>   
000018E8                          1250  *   BCS: %0101          
000018E8                          1251  *   BGE: %1100      
000018E8                          1252  *   BLT: %1101  
000018E8                          1253  *   BVC: %1000
000018E8                          1254  *   
000018E8                          1255  *   MOVE.W #%0110010100000000   ;BCS
000018E8                          1256  *   MOVE.W #%0110110001010101   ;BGE
000018E8                          1257  *   MVE.W #%0110110110101010    ;BLT
000018E8                          1258  *   MOVE.W #%0110100001010101   ;BVC
000018E8                          1259  * Unsupported OP code: BSR
000018E8                          1260  ********************************************************************************
000018E8                          1261  C_GROUP_6:
000018E8  48E7 8000               1262      MOVEM.L D0,-(SP)        ;Save register to stack
000018EC                          1263  *Unsupported OP code
000018EC                          1264  CHECK_OP_BSR:
000018EC  3038 1000               1265      MOVE.W  CUR_OP_CODE,D0
000018F0  0240 FF00               1266      ANDI.W  #$FF00,D0
000018F4  B07C 6100               1267      CMP.W   #$6100,D0
000018F8  6700 0088               1268      BEQ     GROUP6_INVALID
000018FC  6600 0002               1269      BNE     CHECK_OP_BRA
00001900                          1270      
00001900                          1271  *Supported OP codes
00001900                          1272  CHECK_OP_BRA:
00001900  3038 1000               1273      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0       
00001904  0240 FF00               1274      ANDI.W  #$FF00,D0
00001908  B07C 6000               1275      CMP.W   #$6000,D0
0000190C  6600 000C               1276      BNE     CHECK_OP_BCS
00001910  4EB9 00001F58           1277      JSR     PRINT_OP_BRA
00001916  6000 0070               1278      BRA     GROUP6_SUCCESS
0000191A                          1279      
0000191A                          1280  CHECK_OP_BCS:
0000191A  3038 1000               1281      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000191E  0240 FF00               1282      ANDI.W #$FF00,D0
00001922  B07C 6500               1283      CMP.W  #$6500,D0 
00001926  6600 000C               1284      BNE    CHECK_OP_BGE
0000192A  4EB9 00001F00           1285      JSR    PRINT_OP_BCS
00001930  6000 0056               1286      BRA    GROUP6_SUCCESS
00001934                          1287  
00001934                          1288      
00001934                          1289  CHECK_OP_BGE:
00001934  3038 1000               1290      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001938  0240 FF00               1291      ANDI.W #$FF00,D0
0000193C  B07C 6C00               1292      CMP.W  #$6C00,D0 
00001940  6600 000C               1293      BNE    CHECK_OP_BLT
00001944  4EB9 00001F16           1294      JSR    PRINT_OP_BGE
0000194A  6000 003C               1295      BRA    GROUP6_SUCCESS
0000194E                          1296      
0000194E                          1297      
0000194E                          1298  CHECK_OP_BLT:
0000194E  3038 1000               1299      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
00001952  0240 FF00               1300      ANDI.W #$FF00,D0
00001956  B07C 6D00               1301      CMP.W  #$6D00,D0 
0000195A  6600 000C               1302      BNE    CHECK_OP_BVC
0000195E  4EB9 00001F2C           1303      JSR    PRINT_OP_BLT
00001964  6000 0022               1304      BRA    GROUP6_SUCCESS
00001968                          1305      
00001968                          1306  CHECK_OP_BVC:
00001968  3038 1000               1307      MOVE.W CUR_OP_CODE,D0   ;Move current instruction set into D0
0000196C  0240 FF00               1308      ANDI.W #$FF00,D0
00001970  B07C 6800               1309      CMP.W  #$6800,D0 
00001974  6600 000C               1310      BNE    GROUP6_INVALID
00001978  4EB9 00001F42           1311      JSR    PRINT_OP_BVC
0000197E  6000 0008               1312      BRA    GROUP6_SUCCESS
00001982                          1313      
00001982                          1314  GROUP6_INVALID:
00001982  4EB9 00001D88           1315      JSR    INVALID_OP    
00001988                          1316          
00001988                          1317  GROUP6_SUCCESS:
00001988  4CDF 0001               1318      MOVEM.L (SP)+,D0
0000198C  4E75                    1319      RTS
0000198E                          1320      
0000198E                          1321  *GROUP_7
0000198E                          1322  ********************************************************************************
0000198E                          1323  * Currently no OP codes here are supported. MOVEQ is the only code in this group
0000198E                          1324  * Unsupported OP code: MOVEQ
0000198E                          1325  ********************************************************************************
0000198E                          1326  C_GROUP_7:
0000198E  48E7 8000               1327      MOVEM.L D0,-(SP)        ;Save register to stack
00001992                          1328      
00001992                          1329  CHECK_OP_MOVEQ
00001992  3038 1000               1330      MOVE.W CUR_OP_CODE,D0
00001996  0240 F100               1331      ANDI.W #$F100,D0
0000199A  B07C 7000               1332      CMP.W  #$7000,D0
0000199E  6600 0006               1333      BNE    GROUP7_INVALID
000019A2  6700 0008               1334      BEQ    GROUP7_SUCCESS
000019A6                          1335      
000019A6                          1336  GROUP7_INVALID:
000019A6  4EB9 00001D88           1337      JSR INVALID_OP
000019AC                          1338      
000019AC                          1339  GROUP7_SUCCESS:    
000019AC  4CDF 0001               1340      MOVEM.L (SP)+,D0
000019B0  4E75                    1341      RTS
000019B2                          1342  * GROUP_8
000019B2                          1343  ********************************************************************************
000019B2                          1344  * Supported OP code:
000019B2                          1345  * DIVS: $8, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
000019B2                          1346  * OR: $80, 7-6 Size, 5-3 EA Mode, 2-0 EA Register
000019B2                          1347  * Unsupported OP codes: DIVU, SBCD
000019B2                          1348  ********************************************************************************
000019B2                          1349  C_GROUP_8:
000019B2  48E7 8000               1350      MOVEM.L D0,-(SP)
000019B6                          1351  *Unsupported OP codes
000019B6                          1352  CHECK_OP_DIVU:
000019B6  3038 1000               1353      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
000019BA  0240 F1C0               1354      ANDI.W  #$F1C0,D0
000019BE  B07C 80C0               1355      CMP.W   #$80C0,D0
000019C2  6700 003C               1356      BEQ     GROUP8_INVALID
000019C6  6600 0002               1357      BNE     CHECK_OP_SBCD 
000019CA                          1358  
000019CA                          1359  CHECK_OP_SBCD:
000019CA  3038 1000               1360      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
000019CE  0240 F1F0               1361      ANDI.W  #$F1F0,D0
000019D2  B07C 8100               1362      CMP.W   #$8100,D0
000019D6  6700 0028               1363      BEQ     GROUP8_INVALID
000019DA  6600 0002               1364      BNE     CHECK_OP_DIVS
000019DE                          1365      
000019DE                          1366  *Supported OP codes
000019DE                          1367  CHECK_OP_DIVS:
000019DE  3038 1000               1368      MOVE.W  CUR_OP_CODE,D0   ;Move current instruction set into D0
000019E2  0240 F1C0               1369      ANDI.W  #$F1C0,D0
000019E6  B07C 81C0               1370      CMP.W   #$81C0,D0
000019EA  6700 0582               1371      BEQ     PRINT_OP_DIVS
000019EE  6600 0002               1372      BNE     CHECK_OP_OR
000019F2                          1373      
000019F2                          1374  CHECK_OP_OR:              ;At this point only remaining $8 code is OR
000019F2  4EB8 1210               1375      JSR     FIND_2_BIT_SIZE_7_TO_6
000019F6  4EB9 00001F84           1376      JSR     PRINT_OP_OR
000019FC  6000 0008               1377      BRA     GROUP8_SUCCESS
00001A00                          1378  GROUP8_INVALID:
00001A00  4EB9 00001D88           1379       JSR    INVALID_OP
00001A06                          1380       
00001A06                          1381  GROUP8_SUCCESS:
00001A06  4CDF 0001               1382       MOVEM.L (SP)+,D0
00001A0A  4E75                    1383       RTS
00001A0C                          1384       
00001A0C                          1385  * GROUP_9                      
00001A0C                          1386  ********************************************************************************
00001A0C                          1387  * Supported OP code:
00001A0C                          1388  * SUB: $9, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A0C                          1389  * Unsupported OP codes: SUBX, SUBA
00001A0C                          1390  ********************************************************************************
00001A0C                          1391  C_GROUP_9:
00001A0C  48E7 C000               1392      MOVEM.L D0-D1,-(SP)     ;Save the registers
00001A10                          1393  *Unsupported OP codes
00001A10                          1394  CHECK_OP_SUBA:             ;Check SUBA first as it has static bits
00001A10  3038 1000               1395      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A14  0240 F0C0               1396      ANDI.W  #$F0C0,D0
00001A18  B07C 90C0               1397      CMP.W   #$90C0,D0
00001A1C  6700 036A               1398      BEQ     INVALID_OP
00001A20  6600 0002               1399      BNE     CHECK_OP_SUBX
00001A24                          1400  
00001A24                          1401  CHECK_OP_SUBX:
00001A24  3038 1000               1402      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A28  0240 F130               1403      ANDI.W  #$F130,D0
00001A2C  B07C 9100               1404      CMP.W   #$9100,D0
00001A30  6700 0006               1405      BEQ     BIT_CHECK_SUBX
00001A34  6600 002E               1406      BNE     GROUP9_INVALID     ;Cannot be a valid OP code here
00001A38                          1407      
00001A38                          1408  BIT_CHECK_SUBX:    
00001A38  3038 1000               1409      MOVE.W  CUR_OP_CODE,D0      ;Move current instruction set into D0
00001A3C  323C 0007               1410      MOVE.W  #7,D1               ;Prepare a shift of 7 bits into D1
00001A40  E368                    1411      LSL.W   D1,D0               ;Shift left 7 bits truncate 15-9 bits
00001A42  E268                    1412      LSR.W   D1,D0               ;Reposition D0
00001A44  E848                    1413      LSR.W   #4,D0               ;Truncate 4 right most bits to
00001A46  0240 FF18               1414      ANDI.W  #$FF18,D0           ;Compare remaining static bits
00001A4A  B07C 0018               1415      CMP.W   #$0018,D0           ;If equal to this value it's SUBX
00001A4E  6700 0014               1416      BEQ     GROUP9_INVALID      ;INVALID OP code found
00001A52  6600 0002               1417      BNE     CHECK_OP_SUB        ;Not can only be SUB here
00001A56                          1418      
00001A56                          1419  *Supported OP code 
00001A56                          1420  CHECK_OP_SUB:                   ;At this point only remaining $9 is SUB
00001A56  4EB8 1210               1421      JSR     FIND_2_BIT_SIZE_7_TO_6
00001A5A  4EB9 00001F9A           1422      JSR     PRINT_OP_SUB
00001A60  6000 0006               1423      BRA     GROUP9_SUCCESS
00001A64                          1424      
00001A64                          1425  GROUP9_INVALID:
00001A64  6000 0322               1426      BRA     INVALID_OP
00001A68                          1427      
00001A68                          1428  GROUP9_SUCCESS:
00001A68  4CDF 0003               1429      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001A6C  4E75                    1430      RTS                         ;Return to stack
00001A6E                          1431  
00001A6E                          1432  *GROUP_A
00001A6E                          1433  ********************************************************************************
00001A6E                          1434  * Currently no OP codes here are supported. There are no current OP codes here.
00001A6E                          1435  ********************************************************************************
00001A6E                          1436  C_GROUP_A:
00001A6E  4EB9 00001D88           1437      JSR INVALID_OP
00001A74  4E75                    1438      RTS
00001A76                          1439      
00001A76                          1440  * GROUP_B                     
00001A76                          1441  ********************************************************************************
00001A76                          1442  * Supported OP codes:
00001A76                          1443  * EOR: $B, 11-9 Reg, 8 %1, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A76                          1444  * CMP: $B, 11-9 Reg, 8 %0, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001A76                          1445  * The specific bit difference is listed 
00001A76                          1446  * Unsupported OP codes: CMPM, CMPA
00001A76                          1447  ********************************************************************************
00001A76                          1448  C_GROUP_B:
00001A76  48E7 8000               1449      MOVEM.L D0,-(SP)         ;Save current registers to stack
00001A7A                          1450  *Unsupported OP codes    
00001A7A                          1451  CHECK_OP_CMPM
00001A7A  3038 1000               1452      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A7E  0240 F138               1453      ANDI.W  #$F138,D0
00001A82  B07C B108               1454      CMP.W   #$B108,D0
00001A86  6700 0056               1455      BEQ     GROUPB_INVALID
00001A8A  6600 0002               1456      BNE     CHECK_OP_CMPA
00001A8E                          1457      
00001A8E                          1458  CHECK_OP_CMPA:
00001A8E  3038 1000               1459      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001A92  0240 F0C0               1460      ANDI.W  #$F0C0,D0
00001A96  B07C B0C0               1461      CMP.W   #$B0C0,D0
00001A9A  6700 0042               1462      BEQ     GROUPB_INVALID
00001A9E  6600 0002               1463      BNE     CHECK_OP_EOR
00001AA2                          1464  
00001AA2                          1465  *Supported OP codes    
00001AA2                          1466  CHECK_OP_EOR:
00001AA2  3038 1000               1467      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AA6  0240 F100               1468      ANDI.W  #$F100,D0
00001AAA  B07C B100               1469      CMP.W   #$B100,D0
00001AAE  6600 0010               1470      BNE     CHECK_OP_CMP
00001AB2  4EB8 1210               1471      JSR     FIND_2_BIT_SIZE_7_TO_6
00001AB6  4EB9 00001FB0           1472      JSR     PRINT_OP_EOR
00001ABC  6000 0026               1473      BRA     GROUPB_SUCCESS
00001AC0                          1474      
00001AC0                          1475  CHECK_OP_CMP:
00001AC0  3038 1000               1476      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AC4  0240 F100               1477      ANDI.W  #$F100,D0
00001AC8  B07C B000               1478      CMP.W   #$B000,D0
00001ACC  6600 0010               1479      BNE     GROUPB_INVALID
00001AD0  4EB8 1210               1480      JSR     FIND_2_BIT_SIZE_7_TO_6
00001AD4  4EB9 00001FC6           1481      JSR     PRINT_OP_CMP
00001ADA  6000 0008               1482      BRA     GROUPB_SUCCESS
00001ADE                          1483      
00001ADE                          1484  GROUPB_INVALID:
00001ADE  4EB9 00001D88           1485      JSR     INVALID_OP           ;INVALID OP has been found 
00001AE4                          1486   
00001AE4                          1487  GROUPB_SUCCESS:
00001AE4  4CDF 0001               1488      MOVEM.L (SP)+,D0         ;Restore registers from stack
00001AE8  4E75                    1489      RTS                      ;Return to stack
00001AEA                          1490  * GROUP_C                     
00001AEA                          1491  ********************************************************************************
00001AEA                          1492  * Supported OP code:
00001AEA                          1493  * MULS: $C, 11-8 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00001AEA                          1494  * Note: EXG OP mode has to be 01000, 01001, 10001, as such can never be 11 for
00001AEA                          1495  * bits 7-6
00001AEA                          1496  * Unsupported OP codes: MULU, ABCD, EXG, AND
00001AEA                          1497  ********************************************************************************
00001AEA                          1498  C_GROUP_C:
00001AEA                          1499  *Unsupported OP codes
00001AEA  48E7 C000               1500      MOVEM.L D0-D1,-(SP)
00001AEE                          1501      
00001AEE                          1502  CHECK_OP_MULU:
00001AEE  3038 1000               1503      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001AF2  0240 F1C0               1504      ANDI.W  #$F1C0,D0
00001AF6  B07C C0C0               1505      CMP.W   #$C0C0,D0
00001AFA  6700 0078               1506      BEQ     GROUPC_INVALID
00001AFE  6600 0002               1507      BNE     CHECK_OP_ABCD
00001B02                          1508   
00001B02                          1509  CHECK_OP_ABCD:
00001B02  3038 1000               1510      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B06  0240 F1F0               1511      ANDI.W  #$F1F0,D0
00001B0A  B07C C100               1512      CMP.W   #$C100,D0
00001B0E  6700 0064               1513      BEQ     GROUPC_INVALID
00001B12  6600 0002               1514      BNE     CHECK_OP_EXG
00001B16                          1515   
00001B16                          1516  CHECK_OP_EXG:
00001B16  3038 1000               1517      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B1A  0240 F130               1518      ANDI.W  #$F130,D0
00001B1E  B07C C100               1519      CMP.W   #$C100,D0
00001B22  6700 0006               1520      BEQ     BIT_CHECK_EXG
00001B26  6600 003C               1521      BNE     CHECK_OP_AND
00001B2A                          1522                          
00001B2A                          1523  BIT_CHECK_EXG:                 ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
00001B2A  3038 1000               1524      MOVE.W  CUR_OP_CODE,D0
00001B2E  323C 0008               1525      MOVE.W  #8,D1
00001B32  E368                    1526      LSL.W   D1,D0
00001B34  E268                    1527      LSR.W   D1,D0
00001B36  EC48                    1528      LSR.W   #6,D0
00001B38  0240 FFF3               1529      ANDI.W  #$FFF3,D0
00001B3C  B07C 0003               1530      CMP.W   #$0003,D0          ;This bit then equals MULS
00001B40  6700 000E               1531      BEQ     CHECK_OP_MULS
00001B44  B07C 0000               1532      CMP.W   #$0000,D0          ;Second comparison to check if OP mode bit is valid
00001B48  6700 001A               1533      BEQ     CHECK_OP_AND       ;If it's 0 it could be OP_AND
00001B4C  6600 0026               1534      BNE     GROUPC_INVALID         ;Otherwise it's EXG (01,10 op bits)
00001B50                          1535  *Supported OP code
00001B50                          1536  CHECK_OP_MULS:
00001B50  3038 1000               1537      MOVE.W CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B54  0240 F1C0               1538      ANDI.W #$F1C0,D0
00001B58  B07C C1C0               1539      CMP.W  #$C1C0,D0
00001B5C  6700 047E               1540      BEQ    PRINT_OP_MULS
00001B60  6600 0002               1541      BNE    CHECK_OP_AND          ; OP_AND is completely dynamic outside of first nibble
00001B64                          1542  
00001B64                          1543  *Odd completely dynamic unsupported OP code    
00001B64                          1544  CHECK_OP_AND:                 ;This would be the only possible OP code left after CHECK_OP_MULS
00001B64  3038 1000               1545      MOVE.W  CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B68  0240 F000               1546      ANDI.W  #$F000,D0
00001B6C  B07C C000               1547      CMP.W   #$C000,D0
00001B70  6700 0002               1548      BEQ     GROUPC_INVALID
00001B74                          1549      
00001B74                          1550  GROUPC_INVALID:
00001B74  4EB9 00001D88           1551      JSR     INVALID_OP
00001B7A                          1552      
00001B7A                          1553  GROUPC_SUCCESS:
00001B7A  4CDF 0003               1554      MOVEM.L (SP)+,D0-D1
00001B7E  4E75                    1555      RTS
00001B80                          1556      
00001B80                          1557  * GROUP_D                     
00001B80                          1558  ********************************************************************************
00001B80                          1559  * Supported OP codes:
00001B80                          1560  * ADD: $D, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
00001B80                          1561  * ADDA: $D, 11- 9 Reg, 8-6 OPMODE, 7-6 %11, 5-3 EA Mode, 2-0 EA Reg
00001B80                          1562  * The specific bit difference is listed out in the OPMODE field.
00001B80                          1563  * Unsupported: ADDX
00001B80                          1564  ********************************************************************************
00001B80                          1565  C_GROUP_D:
00001B80  48E7 8000               1566      MOVEM.L D0,-(SP)        ;Save registers to stack
00001B84                          1567      
00001B84                          1568  CHECK_OP_ADDX:
00001B84  3038 1000               1569      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B88  0240 F130               1570      ANDI.W #$F130,D0
00001B8C  B07C D100               1571      CMP.W  #$D100,D0
00001B90  6700 0032               1572      BEQ    GROUPD_INVALID
00001B94  6600 0002               1573      BNE    CHECK_OP_ADDA
00001B98                          1574  
00001B98                          1575  CHECK_OP_ADDA:
00001B98  3038 1000               1576      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001B9C  0240 F0C0               1577      ANDI.W #$F0C0,D0
00001BA0  B07C D0C0               1578      CMP.W  #$D0C0,D0
00001BA4  6600 0010               1579      BNE    CHECK_OP_ADD
00001BA8  4EB8 1250               1580      JSR    FIND_1_BIT_SIZE_8
00001BAC  4EB9 00002008           1581      JSR    PRINT_OP_ADDA
00001BB2  6000 0016               1582      BRA    GROUPD_SUCCESS
00001BB6                          1583  
00001BB6                          1584  CHECK_OP_ADD:
00001BB6  4EB8 1210               1585      JSR FIND_2_BIT_SIZE_7_TO_6
00001BBA  4EB9 00001FF2           1586      JSR PRINT_OP_ADD        ;Only remaining OP in $D is ADD
00001BC0  6000 0008               1587      BRA GROUPD_SUCCESS
00001BC4                          1588      
00001BC4                          1589  GROUPD_INVALID:
00001BC4  4EB9 00001D88           1590      JSR INVALID_OP
00001BCA                          1591      
00001BCA                          1592  GROUPD_SUCCESS:
00001BCA  4CDF 0001               1593      MOVEM.L (SP)+,D0        ;Restore registers from stack
00001BCE  4E75                    1594      RTS                     ;Return to stack
00001BD0                          1595      
00001BD0                          1596  * GROUP_E                     
00001BD0                          1597  ********************************************************************************
00001BD0                          1598  * Supported:
00001BD0                          1599  * LSR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001BD0                          1600  * LSL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
00001BD0                          1601  * ASR: $E, $0, 8 %0, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001BD0                          1602  * ASL: $E, $0, 8 %1, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
00001BD0                          1603  * ROR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001BD0                          1604  * ROL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
00001BD0                          1605  * Count/Reg for LSR/LSL refers to shift count, where 0 = shift count of 8, 1-7 
00001BD0                          1606  * refers to the respective value when i/r = 0. If i/r = 1, data register in the 
00001BD0                          1607  * Count/Reg field specifies the shift count.  
00001BD0                          1608  * For directional bit at 8, R = 0, L = 1
00001BD0                          1609  * Count/Reg for ROR/ROL specifies rotate count instead of shift count.
00001BD0                          1610  *
00001BD0                          1611  * Split into ROT and NO_ROT groups first to make identifying easier.
00001BD0                          1612  * Unsupported: ROXL, ROXR
00001BD0                          1613  ********************************************************************************
00001BD0                          1614  C_GROUP_E:
00001BD0  48E7 8000               1615      MOVEM.L D0,-(SP)
00001BD4                          1616  *Unsupported OP codes
00001BD4                          1617  CHECK_OP_ROXR_NO_ROT:
00001BD4  3038 1000               1618      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BD8  0240 FFC0               1619      ANDI.W #$FFC0,D0
00001BDC  B07C E4C0               1620      CMP.W  #$E4C0,D0
00001BE0  6700 0192               1621      BEQ    GROUPE_INVALID
00001BE4  6600 0002               1622      BNE    CHECK_OP_ROXL_NO_ROT
00001BE8                          1623  
00001BE8                          1624  CHECK_OP_ROXL_NO_ROT:
00001BE8  3038 1000               1625      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001BEC  0240 FFC0               1626      ANDI.W #$FFC0,D0
00001BF0  B07C E5C0               1627      CMP.W  #$E5C0,D0
00001BF4  6700 017E               1628      BEQ    GROUPE_INVALID
00001BF8  6600 0002               1629      BNE    CHECK_OP_ROR_NO_ROT
00001BFC                          1630  
00001BFC                          1631  *Supported OP codes
00001BFC                          1632  CHECK_OP_ROR_NO_ROT:
00001BFC  3038 1000               1633      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C00  0240 FFC0               1634      ANDI.W #$FFC0,D0
00001C04  B07C E6C0               1635      CMP.W  #$E6C0,D0
00001C08  6600 000C               1636      BNE    CHECK_OP_ROL_NO_ROT
00001C0C  4EB9 0000208C           1637      JSR    PRINT_OP_ROR
00001C12  6000 0166               1638      BRA    GROUPE_SUCCESS
00001C16                          1639      
00001C16                          1640  CHECK_OP_ROL_NO_ROT:
00001C16  3038 1000               1641      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C1A  0240 FFC0               1642      ANDI.W #$FFC0,D0
00001C1E  B07C E7C0               1643      CMP.W  #$E7C0,D0
00001C22  6600 000C               1644      BNE    CHECK_OP_LSR_NO_ROT
00001C26  4EB9 00002076           1645      JSR    PRINT_OP_ROL
00001C2C  6000 014C               1646      BRA    GROUPE_SUCCESS
00001C30                          1647   
00001C30                          1648  CHECK_OP_LSR_NO_ROT:
00001C30  3038 1000               1649      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C34  0240 FFC0               1650      ANDI.W #$FFC0,D0
00001C38  B07C E2C0               1651      CMP.W  #$E2C0,D0
00001C3C  6600 000C               1652      BNE    CHECK_OP_LSL_NO_ROT
00001C40  4EB9 00002034           1653      JSR    PRINT_OP_LSR
00001C46  6000 0132               1654      BRA    GROUPE_SUCCESS
00001C4A                          1655  
00001C4A                          1656  CHECK_OP_LSL_NO_ROT:
00001C4A  3038 1000               1657      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C4E  0240 FFC0               1658      ANDI.W #$FFC0,D0
00001C52  B07C E3C0               1659      CMP.W  #$E3C0,D0
00001C56  6600 000C               1660      BNE    CHECK_OP_ASR_NO_ROT
00001C5A  4EB9 0000201E           1661      JSR    PRINT_OP_LSL
00001C60  6000 0118               1662      BRA    GROUPE_SUCCESS
00001C64                          1663  
00001C64                          1664  CHECK_OP_ASR_NO_ROT:
00001C64  3038 1000               1665      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C68  0240 FFC0               1666      ANDI.W #$FFC0,D0
00001C6C  B07C E0C0               1667      CMP.W  #$E0C0,D0
00001C70  6600 000C               1668      BNE    CHECK_OP_ASL_NO_ROT
00001C74  4EB9 0000204A           1669      JSR    PRINT_OP_ASR
00001C7A  6000 00FE               1670      BRA    GROUPE_SUCCESS
00001C7E                          1671              
00001C7E                          1672  CHECK_OP_ASL_NO_ROT:
00001C7E  3038 1000               1673      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C82  0240 FFC0               1674      ANDI.W #$FFC0,D0
00001C86  B07C E1C0               1675      CMP.W  #$E1C0,D0
00001C8A  6600 000C               1676      BNE    CHECK_OP_ROXR
00001C8E  4EB9 00002060           1677      JSR    PRINT_OP_ASL
00001C94  6000 00E4               1678      BRA    GROUPE_SUCCESS
00001C98                          1679  
00001C98                          1680  *Unsupported OP codes
00001C98                          1681  CHECK_OP_ROXR:
00001C98  3038 1000               1682      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001C9C  0240 F118               1683      ANDI.W #$F118,D0
00001CA0  B07C E010               1684      CMP.W  #$E010,D0
00001CA4  6700 00CE               1685      BEQ    GROUPE_INVALID
00001CA8  6600 0002               1686      BNE    CHECK_OP_ROXL
00001CAC                          1687      
00001CAC                          1688  CHECK_OP_ROXL:
00001CAC  3038 1000               1689      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CB0  0240 F118               1690      ANDI.W #$F118,D0
00001CB4  B07C E110               1691      CMP.W  #$E110,D0
00001CB8  6700 00BA               1692      BEQ    GROUPE_INVALID
00001CBC  6600 0002               1693      BNE    CHECK_OP_ROR
00001CC0                          1694      
00001CC0                          1695  *Supported OP codes
00001CC0                          1696  CHECK_OP_ROR:
00001CC0  3038 1000               1697      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CC4  0240 F118               1698      ANDI.W #$F118,D0
00001CC8  B07C E018               1699      CMP.W  #$E018,D0
00001CCC  6600 0010               1700      BNE    CHECK_OP_ROL
00001CD0  4EB8 1210               1701      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001CD4  4EB9 0000208C           1702      JSR    PRINT_OP_ROR
00001CDA  6000 009E               1703      BRA    GROUPE_SUCCESS
00001CDE                          1704  
00001CDE                          1705  CHECK_OP_ROL:
00001CDE  3038 1000               1706      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001CE2  0240 F118               1707      ANDI.W #$F118,D0
00001CE6  B07C E118               1708      CMP.W  #$E118,D0
00001CEA  6600 0010               1709      BNE    CHECK_OP_LSR
00001CEE  4EB8 1210               1710      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001CF2  4EB9 00002076           1711      JSR    PRINT_OP_ROL
00001CF8  6000 0080               1712      BRA    GROUPE_SUCCESS
00001CFC                          1713      
00001CFC                          1714  CHECK_OP_LSR:
00001CFC  3038 1000               1715      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001D00  0240 F118               1716      ANDI.W #$F118,D0
00001D04  B07C E008               1717      CMP.W  #$E008,D0
00001D08  6600 0010               1718      BNE    CHECK_OP_LSL
00001D0C  4EB8 1210               1719      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001D10  4EB9 00002034           1720      JSR    PRINT_OP_LSR
00001D16  6000 0062               1721      BRA    GROUPE_SUCCESS
00001D1A                          1722  
00001D1A                          1723  CHECK_OP_LSL:
00001D1A  3038 1000               1724      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001D1E  0240 F118               1725      ANDI.W #$F118,D0
00001D22  B07C E108               1726      CMP.W  #$E108,D0
00001D26  6600 0010               1727      BNE    CHECK_OP_ASR
00001D2A  4EB8 1210               1728      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001D2E  4EB9 0000201E           1729      JSR    PRINT_OP_LSL
00001D34  6000 0044               1730      BRA    GROUPE_SUCCESS
00001D38                          1731  
00001D38                          1732  CHECK_OP_ASR:
00001D38  3038 1000               1733      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001D3C  0240 F118               1734      ANDI.W #$F118,D0
00001D40  B07C E000               1735      CMP.W  #$E000,D0
00001D44  6600 0010               1736      BNE    CHECK_OP_ASL
00001D48  4EB8 1210               1737      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001D4C  4EB9 0000204A           1738      JSR    PRINT_OP_ASR
00001D52  6000 0026               1739      BRA    GROUPE_SUCCESS
00001D56                          1740  
00001D56                          1741  CHECK_OP_ASL:
00001D56  3038 1000               1742      MOVE CUR_OP_CODE,D0    ;Move current instruction set into D0
00001D5A  0240 F118               1743      ANDI.W #$F118,D0
00001D5E  B07C E100               1744      CMP.W  #$E100,D0
00001D62  6600 0010               1745      BNE    GROUPE_INVALID      ;Last possible OP code
00001D66  4EB8 1210               1746      JSR    FIND_2_BIT_SIZE_7_TO_6     
00001D6A  4EB9 00002060           1747      JSR    PRINT_OP_ASL
00001D70  6000 0008               1748      BRA    GROUPE_SUCCESS
00001D74                          1749  
00001D74                          1750  GROUPE_INVALID:
00001D74  4EB9 00001D88           1751      JSR     INVALID_OP
00001D7A                          1752      
00001D7A                          1753  GROUPE_SUCCESS:
00001D7A  4CDF 0001               1754      MOVEM.L (SP)+,D0
00001D7E  4E75                    1755      RTS
00001D80                          1756  * GROUP_F
00001D80                          1757  ********************************************************************************
00001D80                          1758  * Currently no OP codes here are supported. There are no OP codes here
00001D80                          1759  ********************************************************************************
00001D80                          1760  C_GROUP_F:
00001D80  4EB9 00001D88           1761      JSR INVALID_OP
00001D86  4E75                    1762      RTS
00001D88                          1763      
00001D88                          1764  * INVALID_OP                     
00001D88                          1765  ********************************************************************************
00001D88                          1766  * Any value that is not covered in the above groups would be considered invalid. 
00001D88                          1767  * The following values in the first nibble would also indicate that the 
00001D88                          1768  * operand codes is already invalid: $7, $A, $F.
00001D88                          1769  * For unsupported OP codes, display DATA $WXYZ   
00001D88                          1770  * THIS WILL NEED TO BE CHANGED TO DISPLAY: 1000 DATA $WXYZ IN THE FUTURE
00001D88                          1771  ********************************************************************************
00001D88                          1772  INVALID_OP:  ; Prints DATA for invalid op, THIS SHOULD BE SETTING THE IS_VALID BIT TO 0
00001D88  23FC 000020EC 000021CC  1773      MOVE.L #P_INVALID_OP, Arg_AddStrToBuffer_String
00001D92  4EB9 00001DA0           1774      JSR PRINT_TO_BUFFER
00001D98  11FC 0000 10A9          1775      MOVE.B #0,IS_VALID
00001D9E  4E75                    1776      RTS
00001DA0                          1777  
00001DA0                          1778  ********************** PRINTING ROUTINES **************************************
00001DA0                          1779  * Description: These routines are to print the associated op codes, by placing
00001DA0                          1780  * them in the appropriate area to the buffer
00001DA0                          1781  *
00001DA0                          1782  * Registers used: A1 for loading, A6 for EA parsing.
00001DA0                          1783  *
00001DA0                          1784  * Precondition: The relevant opcode has been identified correctly.
00001DA0                          1785  *
00001DA0                          1786  * Postcondition: Prints out the associated opcode to the buffer.
00001DA0                          1787  
00001DA0                          1788  * THIS NEEDS TO BE RETOOLED TO PRINT TO BUFFER NOT TO CONSOLE
00001DA0                          1789  *******************************************************************************
00001DA0                          1790  
00001DA0                          1791  * Prints the loaded item into G_BUFFER
00001DA0                          1792  PRINT_TO_BUFFER:
00001DA0  23FC 00001003 000021D0  1793      MOVE.L #G_BUFFER, Arg_AddStrToBuffer_Buffer
00001DAA  4EB9 000021DA           1794      JSR AddStrToBuffer
00001DB0  4E75                    1795      RTS
00001DB2                          1796      
00001DB2                          1797  ****************************** GROUP 0 **************************************** 
00001DB2                          1798  PRINT_OP_ORI:
00001DB2  23FC 00002109 000021CC  1799      MOVE.L #P_OP_ORI, Arg_AddStrToBuffer_String
00001DBC  4EB8 1DA0               1800      JSR PRINT_TO_BUFFER
00001DC0  4EB9 000020D2           1801      JSR PRINT_OP_SIZE
00001DC6  4E75                    1802      RTS
00001DC8                          1803  PRINT_OP_CMPI:
00001DC8  23FC 0000210D 000021CC  1804      MOVE.L #P_OP_CMPI, Arg_AddStrToBuffer_String
00001DD2  4EB8 1DA0               1805      JSR PRINT_TO_BUFFER
00001DD6  4EB9 000020D2           1806      JSR PRINT_OP_SIZE
00001DDC  4E75                    1807      RTS
00001DDE                          1808  PRINT_OP_STATIC_BCLR:
00001DDE  23FC 00002112 000021CC  1809      MOVE.L #P_OP_STATIC_BCLR, Arg_AddStrToBuffer_String
00001DE8  4EB8 1DA0               1810      JSR PRINT_TO_BUFFER
00001DEC  4EB9 000020D2           1811      JSR PRINT_OP_SIZE
00001DF2  4E75                    1812      RTS
00001DF4                          1813  PRINT_OP_DYNAMIC_BCLR:
00001DF4  23FC 00002117 000021CC  1814      MOVE.L #P_OP_DYNAMIC_BCLR, Arg_AddStrToBuffer_String
00001DFE  4EB8 1DA0               1815      JSR PRINT_TO_BUFFER
00001E02  4EB9 000020D2           1816      JSR PRINT_OP_SIZE
00001E08  4E75                    1817      RTS
00001E0A                          1818  ******************************* END OF GROUP 0 ********************************
00001E0A                          1819  
00001E0A                          1820  ****************************** GROUP 1 ****************************************    
00001E0A                          1821  PRINT_OP_MOVEB:
00001E0A  23FC 0000211C 000021CC  1822      MOVE.L #P_OP_MOVEB, Arg_AddStrToBuffer_String
00001E14  4EB8 1DA0               1823      JSR PRINT_TO_BUFFER
00001E18  4EB9 000020D2           1824      JSR PRINT_OP_SIZE
00001E1E  4E75                    1825      RTS
00001E20                          1826  ******************************* END OF GROUP 1 ********************************
00001E20                          1827      
00001E20                          1828  ****************************** GROUP 2 **************************************** 
00001E20                          1829  PRINT_OP_MOVEA_L:
00001E20  23FC 00002124 000021CC  1830      MOVE.L #P_OP_MOVEA_L, Arg_AddStrToBuffer_String
00001E2A  4EB8 1DA0               1831      JSR PRINT_TO_BUFFER
00001E2E  4EB9 000020D2           1832      JSR PRINT_OP_SIZE
00001E34  4E75                    1833      RTS
00001E36                          1834  PRINT_OP_MOVE_L:
00001E36  23FC 00002130 000021CC  1835      MOVE.L #P_OP_MOVE_L, Arg_AddStrToBuffer_String
00001E40  4EB8 1DA0               1836      JSR PRINT_TO_BUFFER
00001E44  4EB9 000020D2           1837      JSR PRINT_OP_SIZE
00001E4A  4E75                    1838      RTS
00001E4C                          1839  ******************************* END OF GROUP 2 ********************************
00001E4C                          1840      
00001E4C                          1841  ****************************** GROUP 3 ****************************************    
00001E4C                          1842  PRINT_OP_MOVEA_W:
00001E4C  23FC 00002138 000021CC  1843      MOVE.L #P_OP_MOVEA_W, Arg_AddStrToBuffer_String
00001E56  4EB8 1DA0               1844      JSR PRINT_TO_BUFFER
00001E5A  4E75                    1845      RTS
00001E5C                          1846  PRINT_OP_MOVE_W:
00001E5C  23FC 00002144 000021CC  1847      MOVE.L #P_OP_MOVE_W, Arg_AddStrToBuffer_String
00001E66  4EB8 1DA0               1848      JSR PRINT_TO_BUFFER
00001E6A  4EB9 000020D2           1849      JSR PRINT_OP_SIZE
00001E70  4E75                    1850      RTS
00001E72                          1851  ******************************* END OF GROUP 3 ********************************
00001E72                          1852  
00001E72                          1853  ****************************** GROUP 4 ****************************************
00001E72                          1854  PRINT_OP_JSR:
00001E72  23FC 00002168 000021CC  1855      MOVE.L #P_OP_JSR, Arg_AddStrToBuffer_String
00001E7C  4EB8 1DA0               1856      JSR PRINT_TO_BUFFER
00001E80  4EB9 000020D2           1857      JSR PRINT_OP_SIZE
00001E86  4E75                    1858      RTS
00001E88                          1859  PRINT_OP_RTS:
00001E88  23FC 00002170 000021CC  1860      MOVE.L #P_OP_RTS, Arg_AddStrToBuffer_String
00001E92  4EB8 1DA0               1861      JSR PRINT_TO_BUFFER
00001E96  4EB9 000020D2           1862      JSR PRINT_OP_SIZE
00001E9C  4E75                    1863      RTS
00001E9E                          1864  PRINT_OP_LEA:
00001E9E  23FC 00002164 000021CC  1865      MOVE.L #P_OP_LEA, Arg_AddStrToBuffer_String
00001EA8  4EB8 1DA0               1866      JSR PRINT_TO_BUFFER
00001EAC  4EB9 000020D2           1867      JSR PRINT_OP_SIZE
00001EB2  4E75                    1868      RTS
00001EB4                          1869  PRINT_OP_NEG:
00001EB4  23FC 00002174 000021CC  1870      MOVE.L #P_OP_NEG, Arg_AddStrToBuffer_String
00001EBE  4EB8 1DA0               1871      JSR PRINT_TO_BUFFER
00001EC2  4EB9 000020D2           1872      JSR PRINT_OP_SIZE
00001EC8  4E75                    1873      RTS
00001ECA                          1874  PRINT_OP_MOVEM_W:
00001ECA  23FC 0000214C 000021CC  1875      MOVE.L #P_OP_MOVEM_W, Arg_AddStrToBuffer_String
00001ED4  4EB8 1DA0               1876      JSR PRINT_TO_BUFFER
00001ED8  4E75                    1877      RTS
00001EDA                          1878  PRINT_OP_MOVEM_L:
00001EDA  23FC 00002158 000021CC  1879      MOVE.L #P_OP_MOVEM_L, Arg_AddStrToBuffer_String
00001EE4  4EB8 1DA0               1880      JSR PRINT_TO_BUFFER
00001EE8  4E75                    1881      RTS
00001EEA                          1882  ******************************* END OF GROUP 4 ********************************
00001EEA                          1883      
00001EEA                          1884  ****************************** GROUP 5 ****************************************
00001EEA                          1885  PRINT_OP_SUBQ:
00001EEA  23FC 00002178 000021CC  1886      MOVE.L #P_OP_SUBQ, Arg_AddStrToBuffer_String
00001EF4  4EB8 1DA0               1887      JSR PRINT_TO_BUFFER
00001EF8  4EB9 000020D2           1888      JSR PRINT_OP_SIZE
00001EFE  4E75                    1889      RTS
00001F00                          1890  ******************************* END OF GROUP 5 ********************************
00001F00                          1891  
00001F00                          1892  ****************************** GROUP 6 ****************************************
00001F00                          1893  PRINT_OP_BCS:
00001F00  23FC 00002181 000021CC  1894      MOVE.L #P_OP_BCS, Arg_AddStrToBuffer_String
00001F0A  4EB8 1DA0               1895      JSR PRINT_TO_BUFFER
00001F0E  4EB9 000020D2           1896      JSR PRINT_OP_SIZE
00001F14  4E75                    1897      RTS
00001F16                          1898  PRINT_OP_BGE:
00001F16  23FC 00002185 000021CC  1899      MOVE.L #P_OP_BGE, Arg_AddStrToBuffer_String
00001F20  4EB8 1DA0               1900      JSR PRINT_TO_BUFFER
00001F24  4EB9 000020D2           1901      JSR PRINT_OP_SIZE
00001F2A  4E75                    1902      RTS
00001F2C                          1903  PRINT_OP_BLT:
00001F2C  23FC 00002189 000021CC  1904      MOVE.L #P_OP_BLT, Arg_AddStrToBuffer_String
00001F36  4EB8 1DA0               1905      JSR PRINT_TO_BUFFER
00001F3A  4EB9 000020D2           1906      JSR PRINT_OP_SIZE
00001F40  4E75                    1907      RTS
00001F42                          1908  PRINT_OP_BVC:
00001F42  23FC 0000218D 000021CC  1909      MOVE.L #P_OP_BVC, Arg_AddStrToBuffer_String
00001F4C  4EB8 1DA0               1910      JSR PRINT_TO_BUFFER
00001F50  4EB9 000020D2           1911      JSR PRINT_OP_SIZE
00001F56  4E75                    1912      RTS
00001F58                          1913  PRINT_OP_BRA:
00001F58  23FC 0000217D 000021CC  1914      MOVE.L #P_OP_BRA, Arg_AddStrToBuffer_String
00001F62  4EB8 1DA0               1915      JSR PRINT_TO_BUFFER
00001F66  4EB9 000020D2           1916      JSR PRINT_OP_SIZE
00001F6C  4E75                    1917      RTS
00001F6E                          1918  ******************************* END OF GROUP 6 ********************************
00001F6E                          1919  
00001F6E                          1920  ****************************** GROUP 7 ****************************************
00001F6E                          1921  * No currently supported OP codes to print here.
00001F6E                          1922  ******************************* END OF GROUP 7 ********************************
00001F6E                          1923  
00001F6E                          1924  ****************************** GROUP 8 ****************************************
00001F6E                          1925  PRINT_OP_DIVS:
00001F6E  23FC 00002191 000021CC  1926      MOVE.L #P_OP_DIVS, Arg_AddStrToBuffer_String
00001F78  4EB8 1DA0               1927      JSR PRINT_TO_BUFFER
00001F7C  4EB9 000020D2           1928      JSR PRINT_OP_SIZE
00001F82  4E75                    1929      RTS
00001F84                          1930  PRINT_OP_OR:
00001F84  23FC 00002196 000021CC  1931      MOVE.L #P_OP_OR, Arg_AddStrToBuffer_String
00001F8E  4EB8 1DA0               1932      JSR PRINT_TO_BUFFER
00001F92  4EB9 000020D2           1933      JSR PRINT_OP_SIZE
00001F98  4E75                    1934      RTS
00001F9A                          1935  ******************************* END OF GROUP 8 ********************************
00001F9A                          1936  
00001F9A                          1937  ****************************** GROUP 9 ****************************************
00001F9A                          1938  PRINT_OP_SUB:
00001F9A  23FC 00002199 000021CC  1939      MOVE.L #P_OP_SUB, Arg_AddStrToBuffer_String
00001FA4  4EB8 1DA0               1940      JSR PRINT_TO_BUFFER
00001FA8  4EB9 000020D2           1941      JSR PRINT_OP_SIZE
00001FAE  4E75                    1942      RTS
00001FB0                          1943  ******************************* END OF GROUP 9 ********************************
00001FB0                          1944  
00001FB0                          1945  ****************************** GROUP A ****************************************
00001FB0                          1946  * No currently supported OP codes to print here.
00001FB0                          1947  ******************************* END OF GROUP A ********************************
00001FB0                          1948  
00001FB0                          1949  ****************************** GROUP B ****************************************
00001FB0                          1950  PRINT_OP_EOR:
00001FB0  23FC 0000219D 000021CC  1951      MOVE.L #P_OP_EOR, Arg_AddStrToBuffer_String
00001FBA  4EB8 1DA0               1952      JSR PRINT_TO_BUFFER
00001FBE  4EB9 000020D2           1953      JSR PRINT_OP_SIZE
00001FC4  4E75                    1954      RTS
00001FC6                          1955  PRINT_OP_CMP:
00001FC6  23FC 000021A1 000021CC  1956      MOVE.L #P_OP_CMP, Arg_AddStrToBuffer_String
00001FD0  4EB8 1DA0               1957      JSR PRINT_TO_BUFFER
00001FD4  4EB9 000020D2           1958      JSR PRINT_OP_SIZE
00001FDA  4E75                    1959      RTS
00001FDC                          1960  ******************************* END OF GROUP B ********************************
00001FDC                          1961  
00001FDC                          1962  ****************************** GROUP C ****************************************
00001FDC                          1963  PRINT_OP_MULS:
00001FDC  23FC 000021A5 000021CC  1964      MOVE.L #P_OP_MULS, Arg_AddStrToBuffer_String
00001FE6  4EB8 1DA0               1965      JSR PRINT_TO_BUFFER
00001FEA  4EB9 000020D2           1966      JSR PRINT_OP_SIZE
00001FF0  4E75                    1967      RTS
00001FF2                          1968  ******************************* END OF GROUP C ********************************
00001FF2                          1969  
00001FF2                          1970  ****************************** GROUP D ****************************************
00001FF2                          1971  PRINT_OP_ADD:
00001FF2  23FC 000021AF 000021CC  1972      MOVE.L #P_OP_ADD, Arg_AddStrToBuffer_String
00001FFC  4EB8 1DA0               1973      JSR PRINT_TO_BUFFER
00002000  4EB9 000020D2           1974      JSR PRINT_OP_SIZE
00002006  4E75                    1975      RTS
00002008                          1976  PRINT_OP_ADDA:
00002008  23FC 000021AA 000021CC  1977      MOVE.L #P_OP_ADDA, Arg_AddStrToBuffer_String
00002012  4EB8 1DA0               1978      JSR PRINT_TO_BUFFER
00002016  4EB9 000020D2           1979      JSR PRINT_OP_SIZE
0000201C  4E75                    1980      RTS
0000201E                          1981  
0000201E                          1982  ******************************* END OF GROUP D ********************************
0000201E                          1983  
0000201E                          1984  ****************************** GROUP E ****************************************
0000201E                          1985  PRINT_OP_LSL:
0000201E  23FC 000021B7 000021CC  1986      MOVE.L #P_OP_LSL, Arg_AddStrToBuffer_String
00002028  4EB8 1DA0               1987      JSR PRINT_TO_BUFFER
0000202C  4EB9 000020D2           1988      JSR PRINT_OP_SIZE
00002032  4E75                    1989      RTS
00002034                          1990  PRINT_OP_LSR:
00002034  23FC 000021B3 000021CC  1991      MOVE.L #P_OP_LSR, Arg_AddStrToBuffer_String
0000203E  4EB8 1DA0               1992      JSR PRINT_TO_BUFFER
00002042  4EB9 000020D2           1993      JSR PRINT_OP_SIZE
00002048  4E75                    1994      RTS
0000204A                          1995  PRINT_OP_ASR:
0000204A  23FC 000021BB 000021CC  1996      MOVE.L #P_OP_ASR, Arg_AddStrToBuffer_String
00002054  4EB8 1DA0               1997      JSR PRINT_TO_BUFFER
00002058  4EB9 000020D2           1998      JSR PRINT_OP_SIZE
0000205E  4E75                    1999      RTS
00002060                          2000  PRINT_OP_ASL:
00002060  23FC 000021BF 000021CC  2001      MOVE.L #P_OP_ASL, Arg_AddStrToBuffer_String
0000206A  4EB8 1DA0               2002      JSR PRINT_TO_BUFFER
0000206E  4EB9 000020D2           2003      JSR PRINT_OP_SIZE
00002074  4E75                    2004      RTS
00002076                          2005  PRINT_OP_ROL:
00002076  23FC 000021C7 000021CC  2006      MOVE.L #P_OP_ROL, Arg_AddStrToBuffer_String
00002080  4EB8 1DA0               2007      JSR PRINT_TO_BUFFER
00002084  4EB9 000020D2           2008      JSR PRINT_OP_SIZE
0000208A  4E75                    2009      RTS
0000208C                          2010  PRINT_OP_ROR:
0000208C  23FC 000021C3 000021CC  2011      MOVE.L #P_OP_ROR, Arg_AddStrToBuffer_String
00002096  4EB8 1DA0               2012      JSR PRINT_TO_BUFFER
0000209A  4EB9 000020D2           2013      JSR PRINT_OP_SIZE
000020A0  4E75                    2014      RTS
000020A2                          2015  ******************************* END OF GROUP E ********************************
000020A2                          2016  
000020A2                          2017  ****************************** GROUP F ****************************************
000020A2                          2018  * No currently supported OP codes to print here.
000020A2                          2019  ******************************* END OF GROUP F ********************************
000020A2                          2020  
000020A2                          2021  ****************************** SIZE PRINTS ************************************
000020A2                          2022  PRINT_SIZE_BYTE:
000020A2  23FC 000020FD 000021CC  2023      MOVE.L #P_SIZE_B, Arg_AddStrToBuffer_String
000020AC  4EB8 1DA0               2024      JSR PRINT_TO_BUFFER
000020B0  4E75                    2025      RTS    
000020B2                          2026  
000020B2                          2027  PRINT_SIZE_WORD:
000020B2  23FC 00002101 000021CC  2028      MOVE.L #P_SIZE_W, Arg_AddStrToBuffer_String
000020BC  4EB8 1DA0               2029      JSR PRINT_TO_BUFFER
000020C0  4E75                    2030      RTS
000020C2                          2031      
000020C2                          2032  PRINT_SIZE_LONG:
000020C2  23FC 00002105 000021CC  2033      MOVE.L #P_SIZE_L, Arg_AddStrToBuffer_String
000020CC  4EB8 1DA0               2034      JSR PRINT_TO_BUFFER
000020D0  4E75                    2035      RTS
000020D2                          2036  
000020D2                          2037  PRINT_OP_SIZE:                     ;Prints current OP code byte size if applicable
000020D2  0C38 0000 1002          2038      CMP.B  #%00,OP_SIZE         ;Checks for byte size
000020D8  67C8                    2039      BEQ    PRINT_SIZE_BYTE      ;Print .B to buffer
000020DA  0C38 0001 1002          2040      CMP.B  #%01,OP_SIZE         ;Check for word size
000020E0  67D0                    2041      BEQ    PRINT_SIZE_WORD      ;Print .W to buffer
000020E2  0C38 0002 1002          2042      CMP.B  #%10,OP_SIZE         ;Check for long size
000020E8  67D8                    2043      BEQ    PRINT_SIZE_LONG      ;Print .L to buffer
000020EA  4E75                    2044      RTS
000020EC                          2045  ******************* END OF SIZE PRINTS ****************************************
000020EC                          2046  
000020EC                          2047  ******************* END OF PRINTING ROUTINES **********************************
000020EC                          2048  
000020EC                          2049  ******************* END OF JMP LABELS *****************************************
000020EC                          2050  
000020EC                          2051  ******************* DATA CONSTANT PRINTS **************************************
000020EC                          2052  * Formatting is as follows: P_OP_<OPCODE>, where P = Print, OP = Operation,
000020EC                          2053  * <OPCODE> is any valid operand
000020EC                          2054  
000020EC= 44 41 54 41 20 20 ...   2055  P_INVALID_OP    DC.B    'DATA   ',0
000020F4= 46 6F 75 6E 64 20 ...   2056  OP_FOUND        DC.B    'Found OP',0 ; this should be taken out later
000020FD= 2E 42 20 00             2057  P_SIZE_B        DC.B    '.B ',0
00002101= 2E 57 20 00             2058  P_SIZE_W        DC.B    '.W ',0
00002105= 2E 4C 20 00             2059  P_SIZE_L        DC.B    '.L ',0
00002109= 4F 52 49 00             2060  P_OP_ORI        DC.B    'ORI',0
0000210D= 43 4D 50 49 00          2061  P_OP_CMPI       DC.B    'CMPI',0
00002112= 42 43 4C 52 00          2062  P_OP_STATIC_BCLR     DC.B    'BCLR',0
00002117= 42 43 4C 52 00          2063  P_OP_DYNAMIC_BCLR     DC.B    'BCLR',0
0000211C= 4D 4F 56 45 2E 42 ...   2064  P_OP_MOVEB      DC.B    'MOVE.B ',0
00002124= 4D 4F 56 45 41 2E ...   2065  P_OP_MOVEA_L    DC.B    'MOVEA.L    ',0 
00002130= 4D 4F 56 45 2E 4C ...   2066  P_OP_MOVE_L     DC.B    'MOVE.L ',0
00002138= 4D 4F 56 45 41 2E ...   2067  P_OP_MOVEA_W    DC.B    'MOVEA.W    ',0
00002144= 4D 4F 56 45 2E 57 ...   2068  P_OP_MOVE_W     DC.B    'MOVE.W ',0
0000214C= 4D 4F 56 45 4D 2E ...   2069  P_OP_MOVEM_W    DC.B    'MOVEM.W    ',0
00002158= 4D 4F 56 45 4D 2E ...   2070  P_OP_MOVEM_L    DC.B    'MOVEM.L    ',0
00002164= 4C 45 41 00             2071  P_OP_LEA        DC.B    'LEA',0
00002168= 4A 53 52 00             2072  P_OP_JSR        DC.B    'JSR',0
0000216C= 4E 4F 50 00             2073  P_OP_NOP        DC.B    'NOP',0
00002170= 52 54 53 00             2074  P_OP_RTS        DC.B    'RTS',0
00002174= 4E 45 47 00             2075  P_OP_NEG        DC.B    'NEG',0
00002178= 53 55 42 51 00          2076  P_OP_SUBQ       DC.B    'SUBQ',0
0000217D= 42 52 41 00             2077  P_OP_BRA        DC.B    'BRA',0
00002181= 42 43 53 00             2078  P_OP_BCS        DC.B    'BCS',0
00002185= 42 47 45 00             2079  P_OP_BGE        DC.B    'BGE',0
00002189= 42 4C 54 00             2080  P_OP_BLT        DC.B    'BLT',0
0000218D= 42 56 43 00             2081  P_OP_BVC        DC.B    'BVC',0
00002191= 44 49 56 53 00          2082  P_OP_DIVS       DC.B    'DIVS',0
00002196= 4F 52 00                2083  P_OP_OR         DC.B    'OR',0
00002199= 53 55 42 00             2084  P_OP_SUB        DC.B    'SUB',0
0000219D= 45 4F 52 00             2085  P_OP_EOR        DC.B    'EOR',0
000021A1= 43 4D 50 00             2086  P_OP_CMP        DC.B    'CMP',0
000021A5= 4D 55 4C 53 00          2087  P_OP_MULS       DC.B    'MULS',0
000021AA= 41 44 44 41 00          2088  P_OP_ADDA       DC.B    'ADDA',0
000021AF= 41 44 44 00             2089  P_OP_ADD        DC.B    'ADD',0
000021B3= 4C 53 52 00             2090  P_OP_LSR        DC.B    'LSR',0
000021B7= 4C 53 4C 00             2091  P_OP_LSL        DC.B    'LSL',0
000021BB= 41 53 52 00             2092  P_OP_ASR        DC.B    'ASR',0
000021BF= 41 53 4C 00             2093  P_OP_ASL        DC.B    'ASL',0
000021C3= 52 4F 52 00             2094  P_OP_ROR        DC.B    'ROR',0
000021C7= 52 4F 4C 00             2095  P_OP_ROL        DC.B    'ROL',0
000021CB                          2096  ***************** END OF DATA CONSTANT PRINTS ***********************************
000021CB                          2097   
000021CB                          2098  
000021CB                          2099  **
000021CB                          2100  * AddStrToBuffer
000021CB                          2101  **
000021CB                          2102  * Adds the given NULL-terminated string to the specified buffer.
000021CB                          2103  *
000021CB                          2104  * Default buffer length is 80 characters, but can be modified in the argument
000021CB                          2105  * variables.
000021CB                          2106  *
000021CB                          2107  * If the buffer length is exceeded, either due to lack of a NULL character or
000021CB                          2108  * an incorrectly specified length, 1 is returned. Otherwise, 0 is returned to
000021CB                          2109  * indicate success.
000021CB                          2110  *
000021CB                          2111  **
000021CB                          2112  * @param Arg_AddStrToBuffer_String              Pointer to string
000021CB                          2113  * @param Arg_AddStrToBuffer_Buffer              Pointer to buffer
000021CB                          2114  * @param Arg_AddStrToBuffer_BufferLength        Length of buffer (default 80 chars)
000021CB                          2115  * @return Ret_AddStrToBuffer_Success            0 if successful, 1 otherwise.
000021CB                          2116  * @branch _AddStrToBuffer_FindBufferNullLoop    Loop to find NULL in buffer
000021CB                          2117  * @branch _AddStrToBuffer_AddLoop               Loop to add string to buffer
000021CB                          2118  * @branch _AddStrToBuffer_Success               Branch when string successfully added
000021CB                          2119  * @branch _AddStrToBuffer_StringLengthExceeded  Branch when length exceeded (either string or buffer)
000021CB                          2120  * @branch _AddStrToBuffer_End                   End of subroutine
000021CB                          2121  **
000021CC                          2122  Arg_AddStrToBuffer_String           DS.L    1
000021D0                          2123  Arg_AddStrToBuffer_Buffer           DS.L    1
000021D4= 00000050                2124  Arg_AddStrToBuffer_BufferLength     DC.L    80
000021D8                          2125  Ret_AddStrToBuffer_Success          DS.B    1
000021D9                          2126  
000021DA                          2127  AddStrToBuffer:                     DS.W    0
000021DA  48E7 C0C0               2128      MOVEM.L     D0-D1/A0-A1, -(SP)                  * Backup registers to stack
000021DE                          2129  
000021DE  2078 21CC               2130      MOVE.L      Arg_AddStrToBuffer_String, A0       * Load string pointer
000021E2  2278 21D0               2131      MOVE.L      Arg_AddStrToBuffer_Buffer, A1       * Load buffer pointer
000021E6  2038 21D4               2132      MOVE.L      Arg_AddStrToBuffer_BufferLength, D0 * Load buffer length
000021EA  4278 21D8               2133      CLR.W       Ret_AddStrToBuffer_Success          * Clear success bit
000021EE  4281                    2134      CLR.L       D1                                  * Clear loop counter
000021F0                          2135  
000021F0                          2136  _AddStrToBuffer_BufferLoop
000021F0  0C11 0000               2137      CMPI.B      #0, (A1)                            * If buffer char is NULL
000021F4  6700 000E               2138      BEQ         _AddStrToBuffer_AddLoop             * Start adding string to bufer
000021F8                          2139      
000021F8  B280                    2140      CMP.L       D0, D1                              * If counter >= max length
000021FA  6C00 0026               2141      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
000021FE                          2142      
000021FE  5289                    2143      ADDQ.L      #1, A1                              * Go to next character
00002200  5201                    2144      ADDQ.B      #1, D1                              * Increment counter
00002202  60EC                    2145      BRA         _AddStrToBuffer_BufferLoop          * Loop back
00002204                          2146      
00002204                          2147  _AddStrToBuffer_AddLoop
00002204  0C10 0000               2148      CMPI.B      #0, (A0)                            * If string char is NULL
00002208  6700 0010               2149      BEQ         _AddStrToBuffer_Success             * String successfully added
0000220C                          2150      
0000220C  B200                    2151      CMP.B       D0, D1                              * If counter >= max length
0000220E  6C00 0012               2152      BGE         _AddStrToBuffer_LengthExceeded      * Error, return
00002212                          2153      
00002212  12D8                    2154      MOVE.B      (A0)+, (A1)+                        * Move string char to buffer char
00002214  528C                    2155      ADDQ.L      #1, A4
00002216  5201                    2156      ADDQ.B      #1, D1                              * Increment counter
00002218  60EA                    2157      BRA         _AddStrToBuffer_AddLoop             * Loop back
0000221A                          2158  
0000221A                          2159  _AddStrToBuffer_Success
0000221A  12BC 0000               2160      MOVE.B      #0, (A1)                            * Add NULL to end of string
0000221E  6000 0008               2161      BRA         _AddStrToBuffer_End                 * Finish subroutine
00002222                          2162  
00002222                          2163  _AddStrToBuffer_LengthExceeded
00002222  31FC 0001 21D8          2164      MOVE.W      #1, Ret_AddStrToBuffer_Success      * Invalidate success bit
00002228                          2165  
00002228                          2166  _AddStrToBuffer_End
00002228  4CDF 0303               2167      MOVEM.L     (SP)+, D0-D1/A0-A1                  * Restore registers from stack
0000222C  4E75                    2168      RTS                  
0000222E                          2169      END START                                   ; THIS SHOULD BE REMOVED FOR FULL INTEGRATION

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDSTRTOBUFFER      21DA
ARG_ADDSTRTOBUFFER_BUFFER  21D0
ARG_ADDSTRTOBUFFER_BUFFERLENGTH  21D4
ARG_ADDSTRTOBUFFER_STRING  21CC
BIT_CHECK_EXG       1B2A
BIT_CHECK_EXT       16FA
BIT_CHECK_MOVEP     145C
BIT_CHECK_SUBX      1A38
B_BUFFER            1058
CHECK_OP_ABCD       1B02
CHECK_OP_ADD        1BB6
CHECK_OP_ADDA       1B98
CHECK_OP_ADDI       13BC
CHECK_OP_ADDQ       18AA
CHECK_OP_ADDX       1B84
CHECK_OP_AND        1B64
CHECK_OP_ANDI       1394
CHECK_OP_ANDI_TO_CCR  1354
CHECK_OP_ANDI_TO_SR  1364
CHECK_OP_ASL        1D56
CHECK_OP_ASL_NO_ROT  1C7E
CHECK_OP_ASR        1D38
CHECK_OP_ASR_NO_ROT  1C64
CHECK_OP_BCS        191A
CHECK_OP_BGE        1934
CHECK_OP_BLT        194E
CHECK_OP_BRA        1900
CHECK_OP_BSR        18EC
CHECK_OP_BVC        1968
CHECK_OP_CHK        17DC
CHECK_OP_CLR        16BE
CHECK_OP_CMP        1AC0
CHECK_OP_CMPA       1A8E
CHECK_OP_CMPI       14A8
CHECK_OP_CMPM       1A7A
CHECK_OP_DBCC       1882
CHECK_OP_DIVS       19DE
CHECK_OP_DIVU       19B6
CHECK_OP_DYNAMIC_BCHG  1434
CHECK_OP_DYNAMIC_BCLR  14E4
CHECK_OP_DYNAMIC_BSET  1448
CHECK_OP_DYNAMIC_BTST  1420
CHECK_OP_EOR        1AA2
CHECK_OP_EORI       13D0
CHECK_OP_EORI_TO_CCR  1374
CHECK_OP_EORI_TO_SR  1384
CHECK_OP_EXG        1B16
CHECK_OP_EXT        16E6
CHECK_OP_ILLEGAL    162E
CHECK_OP_JMP        17C8
CHECK_OP_JSR        1820
CHECK_OP_LEA        1806
CHECK_OP_LINK       178C
CHECK_OP_LSL        1D1A
CHECK_OP_LSL_NO_ROT  1C4A
CHECK_OP_LSR        1CFC
CHECK_OP_LSR_NO_ROT  1C30
CHECK_OP_MOVEA_L    153C
CHECK_OP_MOVEA_W    159E
CHECK_OP_MOVEM      1858
CHECK_OP_MOVEP      1476
CHECK_OP_MOVEQ      1992
CHECK_OP_MOVE_B     1512
CHECK_OP_MOVE_FROM_SR  166E
CHECK_OP_MOVE_L     1574
CHECK_OP_MOVE_TO_CCR  1682
CHECK_OP_MOVE_TO_SR  1696
CHECK_OP_MOVE_USP   17B4
CHECK_OP_MOVE_W     15D6
CHECK_OP_MULS       1B50
CHECK_OP_MULU       1AEE
CHECK_OP_NBCD       1714
CHECK_OP_NEG        183A
CHECK_OP_NEGX       16AA
CHECK_OP_NOP        161E
CHECK_OP_NOT        16D2
CHECK_OP_OR         19F2
CHECK_OP_ORI        148A
CHECK_OP_ORI_TO_CCR  1334
CHECK_OP_ORI_TO_SR  1344
CHECK_OP_PEA        173C
CHECK_OP_RESET      160E
CHECK_OP_ROL        1CDE
CHECK_OP_ROL_NO_ROT  1C16
CHECK_OP_ROR        1CC0
CHECK_OP_ROR_NO_ROT  1BFC
CHECK_OP_ROXL       1CAC
CHECK_OP_ROXL_NO_ROT  1BE8
CHECK_OP_ROXR       1C98
CHECK_OP_ROXR_NO_ROT  1BD4
CHECK_OP_RTE        163E
CHECK_OP_RTR        165E
CHECK_OP_RTS        17F0
CHECK_OP_SBCD       19CA
CHECK_OP_SCC        1896
CHECK_OP_STATIC_BCHG  13F8
CHECK_OP_STATIC_BCLR  14C6
CHECK_OP_STATIC_BSET  140C
CHECK_OP_STATIC_BTST  13E4
CHECK_OP_STOP       15FE
CHECK_OP_SUB        1A56
CHECK_OP_SUBA       1A10
CHECK_OP_SUBI       13A8
CHECK_OP_SUBQ       18BE
CHECK_OP_SUBX       1A24
CHECK_OP_SWAP       1728
CHECK_OP_TAS        1750
CHECK_OP_TRAP       1778
CHECK_OP_TRAPV      164E
CHECK_OP_TST        1764
CHECK_OP_UNLK       17A0
CUR_OP_CODE         1000
C_GROUP_0           1330
C_GROUP_1           150E
C_GROUP_2           1538
C_GROUP_3           159A
C_GROUP_4           15FC
C_GROUP_5           187E
C_GROUP_6           18E8
C_GROUP_7           198E
C_GROUP_8           19B2
C_GROUP_9           1A0C
C_GROUP_A           1A6E
C_GROUP_B           1A76
C_GROUP_C           1AEA
C_GROUP_D           1B80
C_GROUP_E           1BD0
C_GROUP_F           1D80
FIND_1_BIT_SIZE_6   1230
FIND_1_BIT_SIZE_8   1250
FIND_2_BIT_SIZE_7_TO_6  1210
FIND_3_BIT_REG_TO_EA  1270
FIND_MOVEA_L_DIFFERENCE  154E
FIND_MOVEA_W_DIFF   15B0
FIND_TRAILING_BITS_TO_EA  12CC
FIRST_3             1054
FOURTH_3            1057
GROUP0_INVALID      1502
GROUP0_SUCCESS      1508
GROUP1_INVALID      152C
GROUP1_SUCCESS      1532
GROUP2_INVALID      158E
GROUP2_SUCCESS      1594
GROUP3_INVALID      15F0
GROUP3_SUCCESS      15F6
GROUP4_INVALID      1872
GROUP4_SUCCESS      1878
GROUP5_INVALID      18DC
GROUP5_SUCCESS      18E2
GROUP6_INVALID      1982
GROUP6_SUCCESS      1988
GROUP7_INVALID      19A6
GROUP7_SUCCESS      19AC
GROUP8_INVALID      1A00
GROUP8_SUCCESS      1A06
GROUP9_INVALID      1A64
GROUP9_SUCCESS      1A68
GROUPB_INVALID      1ADE
GROUPB_SUCCESS      1AE4
GROUPC_INVALID      1B74
GROUPC_SUCCESS      1B7A
GROUPD_INVALID      1BC4
GROUPD_SUCCESS      1BCA
GROUPE_INVALID      1D74
GROUPE_SUCCESS      1D7A
GROUP_0             10CA
GROUP_1             10DC
GROUP_2             10EE
GROUP_3             1100
GROUP_4             1112
GROUP_5             1124
GROUP_6             1136
GROUP_7             1148
GROUP_8             115A
GROUP_9             116C
GROUP_A             117E
GROUP_B             1190
GROUP_C             11A2
GROUP_D             11B4
GROUP_E             11C6
GROUP_F             11D8
G_BUFFER            1003
INVALID_OP          1D88
IS_VALID            10A9
MNEMONIC            1053
MOVE_AND_MOVEA_PARSE_EA  1286
MOVE_LAST_6_BITS_TO_EA  11EE
OP_FOUND            20F4
OP_JSR_DONE         11E6
OP_JSR_ROUTINE      10B8
OP_SIZE             1002
PARSE_EA_CONSTANT_BITS  12E2
PRINT_OP_ADD        1FF2
PRINT_OP_ADDA       2008
PRINT_OP_ASL        2060
PRINT_OP_ASR        204A
PRINT_OP_BCS        1F00
PRINT_OP_BGE        1F16
PRINT_OP_BLT        1F2C
PRINT_OP_BRA        1F58
PRINT_OP_BVC        1F42
PRINT_OP_CMP        1FC6
PRINT_OP_CMPI       1DC8
PRINT_OP_DIVS       1F6E
PRINT_OP_DYNAMIC_BCLR  1DF4
PRINT_OP_EOR        1FB0
PRINT_OP_JSR        1E72
PRINT_OP_LEA        1E9E
PRINT_OP_LSL        201E
PRINT_OP_LSR        2034
PRINT_OP_MOVEA_L    1E20
PRINT_OP_MOVEA_W    1E4C
PRINT_OP_MOVEB      1E0A
PRINT_OP_MOVEM_L    1EDA
PRINT_OP_MOVEM_W    1ECA
PRINT_OP_MOVE_L     1E36
PRINT_OP_MOVE_W     1E5C
PRINT_OP_MULS       1FDC
PRINT_OP_NEG        1EB4
PRINT_OP_OR         1F84
PRINT_OP_ORI        1DB2
PRINT_OP_ROL        2076
PRINT_OP_ROR        208C
PRINT_OP_RTS        1E88
PRINT_OP_SIZE       20D2
PRINT_OP_STATIC_BCLR  1DDE
PRINT_OP_SUB        1F9A
PRINT_OP_SUBQ       1EEA
PRINT_SIZE_BYTE     20A2
PRINT_SIZE_LONG     20C2
PRINT_SIZE_WORD     20B2
PRINT_TO_BUFFER     1DA0
P_INVALID_OP        20EC
P_OP_ADD            21AF
P_OP_ADDA           21AA
P_OP_ASL            21BF
P_OP_ASR            21BB
P_OP_BCS            2181
P_OP_BGE            2185
P_OP_BLT            2189
P_OP_BRA            217D
P_OP_BVC            218D
P_OP_CMP            21A1
P_OP_CMPI           210D
P_OP_DIVS           2191
P_OP_DYNAMIC_BCLR   2117
P_OP_EOR            219D
P_OP_JSR            2168
P_OP_LEA            2164
P_OP_LSL            21B7
P_OP_LSR            21B3
P_OP_MOVEA_L        2124
P_OP_MOVEA_W        2138
P_OP_MOVEB          211C
P_OP_MOVEM_L        2158
P_OP_MOVEM_W        214C
P_OP_MOVE_L         2130
P_OP_MOVE_W         2144
P_OP_MULS           21A5
P_OP_NEG            2174
P_OP_NOP            216C
P_OP_OR             2196
P_OP_ORI            2109
P_OP_ROL            21C7
P_OP_ROR            21C3
P_OP_RTS            2170
P_OP_STATIC_BCLR    2112
P_OP_SUB            2199
P_OP_SUBQ           2178
P_SIZE_B            20FD
P_SIZE_L            2105
P_SIZE_W            2101
RET_ADDSTRTOBUFFER_SUCCESS  21D8
SECOND_3            1055
START               10AA
THIRD_3             1056
_ADDSTRTOBUFFER_ADDLOOP  2204
_ADDSTRTOBUFFER_BUFFERLOOP  21F0
_ADDSTRTOBUFFER_END  2228
_ADDSTRTOBUFFER_LENGTHEXCEEDED  2222
_ADDSTRTOBUFFER_SUCCESS  221A
