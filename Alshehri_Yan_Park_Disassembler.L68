000010A4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/17/2019 10:30:24 PM

00000000                             1  **--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler in Motorola 68k
00000000                             3  * Written by : TEAM REEE Denny, Daniel, Fahad
00000000                             4  * Date       : 3/17/2019 
00000000                             5  * 
00000000                             6  * 
00000000                             7  * Description: This disassembler reverse assembles or decompiles a given
00000000                             8  * test program (with validity checking) from their machine code hex
00000000                             9  * equivalents to outputting them onto a console file and a log.
00000000                            10  *
00000000                            11  * This disassembler will print out <MEMORY ADDRESS> <OPERAND> <EA MODE/REG>
00000000                            12  * If the identified code is valid.
00000000                            13  *
00000000                            14  * This disassembler will print out <MEMORY ADDRESS> DATA $<INVALID HEX>
00000000                            15  * If the identified code is invalid.
00000000                            16  *---------------------------------------------------------------------------
00001000                            17      ORG    $1000    
00001000                            18  *---------------------------------------------------------------------------
00001000                            19  G_BUFFER        DS.B    80          ;Used to print out the needed letters to the buffer
00001050                            20  B_BUFFER        DS.B    80          ;Bad buffer used to load bad data
000010A0                            21  CUR_OP_CODE     DS.W    1           ;Used to determine the current 4 hex OP code
000010A2                            22  IS_VALID        DS.B    1           ;Validity bit to check if a code is valid or not
000010A3                            23                          ;1 = valid, 0 = invalid
000010A3                            24  
000010A3                            25  START:                      ;Start of the program
000010A3                            26  
000010A4  43F9 00001460             27      LEA MAIN_CONSOLE, A1            ;Loads the main message into A1
000010AA  4EB9 00001382             28      JSR TrapTask13                 ;Prints message out to console and log
000010B0                            29  
000010B0                            30      
000010B0                            31      
000010B0                            32      ******************************************
000010B0                            33      **
000010B0                            34      **     ___         ___        /  __  
000010B0                            35      **    |__  | |    |__     |  /  /  \  
000010B0                            36      **    |    | |___ |___    | /   \__/ 
000010B0                            37      **                           
000010B0                            38      **
000010B0                            39      ** This is the beginning of the code for reading from files
000010B0                            40      ******************************************
000010B0                            41  * Attempt to open file for input
000010B0  43F9 00001732             42          LEA     fileName,A1                    ;Name of file to open
000010B6  103C 0033                 43          MOVE.B  #51,D0                         ;Trap task #51, open existing file
000010BA  4E4F                      44          TRAP    #15                            ;Perform task
000010BC  23C1 00001752             45          MOVE.L  D1,fileID                      ;Save file ID
000010C2                            46  
000010C2                            47  * Read string from file
000010C2  43F9 0000173D             48          LEA     IO_BUFFER,A1                   ;Location of string buffer
000010C8  2239 00001752             49          MOVE.L  fileID,D1                      ;File ID of file to read from
000010CE  4282                      50          CLR.L   D2
000010D0  343C 0014                 51          MOVE.W  #SIZE,D2                       ;Number of bytes to read
000010D4  103C 0035                 52          MOVE.B  #53,D0                         ;Trap task #53, read from file
000010D8  4E4F                      53          TRAP    #15                            ;Perform task
000010DA                            54  * Close file when finished
000010DA  103C 0038                 55          MOVE.B  #56,D0                         ;Trap task #56, close file, D1 contains fileID
000010DE  4E4F                      56          TRAP    #15                            ;Perform task
000010E0                            57  
000010E0                            58  
000010E0                            59  *Load start and end address as longs
000010E0                            60  *Start Address is in A5     
000010E0  43F9 0000173D             61      LEA IO_BUFFER, A1               ;Load string or IO buffer to A1
000010E6  4EB9 00001418             62      JSR AsciiToHex                  ;Convert ASCII to Hex
000010EC  2A47                      63      MOVE.L D7, A5                   ;Loop counter prep
000010EE                            64      
000010EE                            65  *End Address is in A6
000010EE  5289                      66      ADDA.L #1, A1                   ;Add #2 to A1
000010F0  4EB9 00001418             67      JSR AsciiToHex                  ;Convert ASCII to Hex
000010F6  2C47                      68      MOVE.L D7, A6                   ;Loop counter prep
000010F8                            69      
000010F8                            70      
000010F8                            71               
000010F8                            72  VALIDATE_START_ADDRESS              ;Validates starting address
000010F8  200D                      73      MOVE.L A5, D0                   ;Move stating address to D0
000010FA                            74  *----------------------------------------------------------------------------------
000010FA                            75  * Method Name: VALIDATE_POSITIVE_ADDRESS
000010FA                            76  * Description: Checks if the start address is positive it then branches
000010FA                            77  *              to validate if the address in the Config.cfg file is even
000010FA                            78  *
000010FA                            79  *  Preconditions & Input of a start address that is even
000010FA                            80  *       A1 (input) points to a memory buffer holding 8 ASCII chars (not null-terminated) 
000010FA                            81  *       This function calls another function (strip_ascii)
000010FA                            82  *
000010FA                            83  *  Postconditions & Output
000010FA                            84  *   
000010FA                            85  *----------------------------------------------------------------------------------
000010FA                            86  VALIDATE_POSITIVE_ADDRESS
000010FA  200D                      87      MOVE.L A5, D0                   ;Move starting address to D0
000010FC  0280 80000000             88      ANDI.L #$80000000, D0           ;Checking if the start address address is positive
00001102  B0BC 00000000             89      CMP.L #0, D0                    ;Compare 0 to D0
00001108  6700 0012                 90      BEQ VALIDATE_END_POS                ;Check if the end address is positive
0000110C                            91      
0000110C  43F9 00001756             92      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001112  4EB9 00001382             93      JSR TrapTask13                             ;Use Nash's Console Output
00001118  6000 016C                 94      BRA DONE                        ;Finish routine
0000111C                            95  
0000111C                            96  VALIDATE_END_POS
0000111C  200E                      97      MOVE.L A6, D0                   ;Move ending address to D0
0000111E  0280 80000000             98      ANDI.L #$80000000, D0                  ;Checking if the end address address is positive
00001124  B0BC 00000000             99      CMP.L #0, D0                    ;Compare address to 0
0000112A  6700 0012                100      BEQ VALIDATE_START_EVEN            ;Check if the end address is even
0000112E                           101      
0000112E  43F9 00001756            102      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001134  4EB9 00001382            103      JSR TrapTask13                             ;Use Nash's Console Output      
0000113A  6000 014A                104      BRA DONE                        ;Finish routine
0000113E                           105      
0000113E                           106  VALIDATE_START_EVEN
0000113E  200D                     107      MOVE.L A5, D0                   ;MOVE STARTING ADDRESS TO D0
00001140  0280 00000001            108      ANDI.L #$00000001,D0                   ;Bitmask 1 a single bit to D0
00001146  B0BC 00000000            109      CMP.L #0, D0                    ;Check if even
0000114C  6700 0012                110      BEQ VALIDATE_END_EVEN                 ;Go to the VALIDATE_ADDRESS_RANGE if even
00001150                           111  *Handle odd addresses
00001150  43F9 00001756            112      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001156  4EB9 00001382            113      JSR TrapTask13                             ;Use Nash's Console Output
0000115C  6000 0128                114      BRA DONE                        ;Finish routine
00001160                           115  
00001160                           116  VALIDATE_END_EVEN
00001160  200E                     117      MOVE.L A6, D0                   ;MOVE STARTING ADDRESS TO D0
00001162  0280 00000001            118      ANDI.L #$00000001,D0                   ;Bitmask 1 a single bit to D0
00001168  B0BC 00000000            119      CMP.L #0, D0                    ;Check if even
0000116E  6700 0012                120      BEQ VALIDATE_ADDRESS_RANGE            ;Go to the VALIDATE_ADDRESS_RANGE if even
00001172                           121  *Handle odd addresses
00001172  43F9 00001756            122      LEA INVALID_ADDRES_MESSAGE, A1         ;Load INVALID message to A1
00001178  4EB9 00001382            123      JSR TrapTask13                             ;Use Nash's Console Output
0000117E  6000 0106                124      BRA DONE                        ;Finish routine
00001182                           125  
00001182                           126  VALIDATE_ADDRESS_RANGE
00001182  BBCE                     127     CMP.L A6,A5
00001184  6F00 0012                128     BLE MAIN_LOOP 
00001188  43F9 00001756            129     LEA INVALID_ADDRES_MESSAGE, A1                ;Load INVALID message to A1
0000118E  4EB9 00001382            130     JSR TrapTask13                              ;Use Nash's Console Output
00001194  6000 00F0                131     BRA DONE                     ;Finish routine
00001198                           132              
00001198                           133  
00001198                           134  
00001198                           135  *Comments are shifted if variable names get too long
00001198                           136  MAIN_LOOP                                   ;Main loop to run each instruction
00001198  49F8 1000                137           LEA G_BUFFER,A4                            ;Point G_BUFFER to A4
0000119C                           138              
0000119C  BDCD                     139              CMPA.L A5, A6                           ;Compare Starting to ending address
0000119E  6F00 00E6                140              BLE DONE                            ;If it's less then stop the loop
000011A2                           141              
000011A2                           142  *Clear both buffers 
000011A2  23FC 00001000 000012EC   143              MOVE.L #G_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to G_BUFFER
000011AC  4EB9 000012F4            144              JSR CLEAR_BUFFER                        ;Clear the buffer
000011B2                           145              
000011B2  23FC 00001050 000012EC   146              MOVE.L #B_BUFFER, CLEAR_BUFFER_POINTER              ;Point the clear pointer to B_BUFFER
000011BC  4EB9 000012F4            147              JSR CLEAR_BUFFER                        ;Clear the buffer
000011C2                           148              
000011C2                           149  *Add address to both buffers
000011C2                           150              
000011C2  23CD 00001314            151              MOVE.L A5, NUMBER_TO_CONVERT                ;The current address is stored to A5, we need to convert it to load it in the buffers.
000011C8  13FC 0008 00001318       152              MOVE.B #8, CHARNUM_TO_CONVERT               ;This specifies the number of characters that needs to be converted.
000011D0  4EB9 00001322            153              JSR CONVERT_HEX_TO_STRING                   ;Convert hex to string
000011D6                           154              
000011D6  23FC 00001319 0000128A   155              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER ;Prepare the string buffer with the converted hex string
000011E0  23FC 00001000 0000128E   156              MOVE.L #G_BUFFER, BUFFER_POINTER                   ;Point G_BUFFER to the print buffer
000011EA  4EB9 00001298            157              JSR AddStrToBuffer                      ;Add the string to the print buffer
000011F0                           158      
000011F0  31DD 10A0                159              MOVE.W (A5)+, CUR_OP_CODE                   ;Read the current opcode
000011F4  4EF9 00001776            160              JMP OP_JSR_Routine                      ;Run main OP code routine
000011FA                           161  
000011FA                           162  *********************************
000011FA                           163  *Checks if its valid print or invalid
000011FA                           164  * @pre checks invalid
000011FA                           165  * @post Branches to the respective branch
000011FA                           166  ************************************
000011FA                           167  check_print
000011FA  0C38 0001 10A2           168              CMP.B #1,IS_VALID                       ;Check if IS_VALID is set to 1
00001200  6700 0006                169              BEQ   print_instruction                 ;If it's valid do print_instruction
00001204  6600 000E                170              BNE   print_data                        ;If it's invalid do print_data
00001208                           171              
00001208                           172  print_instruction                               ;Prints the data in G_BUFFER
00001208                           173  *Print the opcode if valid
00001208  43F8 1000                174              LEA G_BUFFER,A1                     ;Points A1 to G_BUFFER
0000120C  4EB9 00001382            175              JSR TrapTask13                          ;Use Nash's console output
00001212  6084                     176              BRA MAIN_LOOP                           ;Go back to the main loop
00001214                           177   
00001214                           178  *Otherwise print data
00001214                           179  print_data  
00001214  23CD 00001314            180              MOVE.L A5, NUMBER_TO_CONVERT                    ;The current address is stored to A5, we need to convert it to load it in the buffers.
0000121A  13FC 0008 00001318       181              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
00001222  4EB9 00001322            182              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
00001228  23FC 00001319 0000128A   183              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Point the string buffer to the converted hex
00001232                           184              
00001232  23FC 00001050 0000128E   185              MOVE.L #B_BUFFER, BUFFER_POINTER                    ;Prepare the string buffer with the valid data
0000123C  4EB9 00001298            186              JSR AddStrToBuffer                          ;Add the string to the print buffer
00001242                           187  *Add bad data to bad buffer
00001242  23FC 000027DC 0000128A   188              MOVE.L #P_INVALID_OP, STRING_BUFFER_POINTER         ;Prepare the string buffer with the invalid data
0000124C  4EB9 00001298            189              JSR AddStrToBuffer                          ;Add the string to the print buffer
00001252                           190              
00001252  33F8 10A0 00001314       191              MOVE.W CUR_OP_CODE, NUMBER_TO_CONVERT               ;The current address is stored to A5, we need to convert it to load it in the buffers.
0000125A  13FC 0008 00001318       192              MOVE.B #8, CHARNUM_TO_CONVERT                   ;This specifies the number of characters that needs to be converted.
00001262  4EB9 00001322            193              JSR CONVERT_HEX_TO_STRING                       ;Convert the hex to string
00001268                           194              
00001268  23FC 00001319 0000128A   195              MOVE.L #CONVERTED_HEX_STRING, STRING_BUFFER_POINTER     ;Prepare the string buffer with the converted hex string
00001272  4EB9 00001298            196              JSR AddStrToBuffer                          ;Add the converted hex to buffer
00001278                           197              
00001278  43F8 1050                198              LEA B_BUFFER,A1                         ;Point A1 to the bad buffer
0000127C  4EB9 00001382            199              JSR TrapTask13                              ;Use Nash's console output
00001282  6000 FF14                200              BRA MAIN_LOOP                               ;Go back to the main loop
00001286                           201  
00001286                           202  
00001286                           203  DONE                                            ;We're finished at this point reading all the files
00001286  FFFF FFFF                204              SIMHALT                                 ;Halt the simulation
0000128A                           205              
0000128A                           206  **
0000128A                           207  * AddStrToBuffer
0000128A                           208  *****************************************************************************
0000128A                           209  * Description: Adds the a defined string constant into a buffer to print out
0000128A                           210  * Places a NULL terminating string to start with a default buffer length of 80.
0000128A                           211  *
0000128A                           212  * If the buffer length is exceeded, where length was improperly specified or no
0000128A                           213  * NULL terminating string was found, return 1, else return 0 for success.
0000128A                           214  *
0000128A                           215  * Additional Constants/Subroutines used:
0000128A                           216  * STRING_BUFFER_POINTER                 ;String pointer
0000128A                           217  * BUFFER_POINTER                        ;Buffer pointer
0000128A                           218  * BUFFER_POINTER_LENGTH                 ;Buffer length, 80 chars by default
0000128A                           219  * BUFFER_ADD_SUCCESS                    ;0 = success, 1 = failure
0000128A                           220  * FIND_NULL_IN_BUFFER                   ;Find NULL in buffer with a loop
0000128A                           221  * STRING_BUFFER_ADD_LOOP                    ;Add a string to the buffer with a loop
0000128A                           222  * STRING_ADD_SUCCESS                       ;Routine to run when string is added successfully
0000128A                           223  * BUFFER_LENGTH_FAIL                    ;Routine to run when buffer length is exceeded
0000128A                           224  * BUFFER_STRING_END                     ;Subroutine is finished
0000128A                           225  *****************************************************************************
0000128A                           226  * Constant definitions:
0000128A                           227  STRING_BUFFER_POINTER   DS.L    1
0000128E                           228  BUFFER_POINTER      DS.L    1
00001292= 00000050                 229  BUFFER_POINTER_LENGTH   DC.L    80
00001296                           230  BUFFER_ADD_SUCCESS      DS.B    1
00001297                           231  
00001298                           232  AddStrToBuffer:           DS.W    0                   ;Reserve a word
00001298  48E7 C0C0                233      MOVEM.L     D0-D1/A0-A1, -(SP)              ;Save registers to stack
0000129C                           234      
0000129C  2078 128A                235      MOVE.L      STRING_BUFFER_POINTER,A0        ;Load string pointer to A0
000012A0  2278 128E                236      MOVE.L      BUFFER_POINTER, A1          ;Load buffer pointer to A1
000012A4  2038 1292                237      MOVE.L      BUFFER_POINTER_LENGTH, D0       ;Load buffer length to D0
000012A8  4278 1296                238      CLR.W       BUFFER_ADD_SUCCESS          ;Clear any prior success bit
000012AC  4281                     239      CLR.L       D1                      ;Clear any prior loop counts
000012AE                           240  
000012AE                           241  STRING_BUFFER_LOOP
000012AE  0C11 0000                242      CMPI.B      #0, (A1)                    ;Check if buffer char is NULL or not
000012B2  6700 000E                243      BEQ         STRING_BUFFER_ADD_LOOP          ;If a 0 is found, start adding string(s) to the buffer
000012B6                           244      
000012B6  B280                     245      CMP.L       D0, D1                  ;Check if the counter is more than the max length
000012B8  6C00 0026                246      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
000012BC                           247      
000012BC  5289                     248      ADDQ.L      #1, A1                  ;Increment to the next character
000012BE  5201                     249      ADDQ.B      #1, D1                  ;Increment loop counter
000012C0  60EC                     250      BRA         STRING_BUFFER_LOOP          ;Loop back again
000012C2                           251      
000012C2                           252  STRING_BUFFER_ADD_LOOP
000012C2  0C10 0000                253      CMPI.B      #0, (A0)                       ;Check is the string char is NULL
000012C6  6700 0010                254      BEQ         STRING_ADD_SUCCESS          ;String has been added successfully
000012CA                           255      
000012CA  B200                     256      CMP.B       D0, D1                  ;Check if the counter is more than the max length
000012CC  6C00 0012                257      BGE         BUFFER_LENGTH_EXCEEDED          ;Exceeded the length
000012D0                           258      
000012D0  12D8                     259      MOVE.B      (A0)+,(A1)+             ;Add string to the buffer
000012D2  5201                     260      ADDQ.B      #1, D1                  ;Increment loop counter
000012D4  524C                     261      ADDQ.W      #1, A4                  ;Increment G_BUFFER counter
000012D6  60EA                     262      BRA         STRING_BUFFER_ADD_LOOP          ;Loop back again
000012D8                           263  
000012D8                           264  STRING_ADD_SUCCESS
000012D8  12BC 0000                265      MOVE.B      #0,(A1)                 ;Place NULL terminating 0 at the end
000012DC  6000 0008                266      BRA         BUFFER_STRING_END               ;Finish subroutine
000012E0                           267  
000012E0                           268  BUFFER_LENGTH_EXCEEDED
000012E0  31FC 0001 1296           269      MOVE.W      #1, BUFFER_ADD_SUCCESS          ;BUFFER failed to add
000012E6                           270  
000012E6                           271  BUFFER_STRING_END
000012E6  4CDF 0303                272      MOVEM.L     (SP)+, D0-D1/A0-A1          ;Restore registers from stack
000012EA  4E75                     273      RTS                                     ;Return to stack
000012EC                           274  **************************************************************************
000012EC                           275  * CLEAR_BUFFER
000012EC                           276  *****************************************************************************
000012EC                           277  * Description: Clears the defined buffer area with NULL terminating 0s
000012EC                           278  * The default size is 80 bytes
000012EC                           279  *
000012EC                           280  * Additional Constants/Subroutines used:
000012EC                           281  * CLEAR_BUFFER_POINTER                  ;Buffer pointer
000012EC                           282  * CLEAR_BUFFER_LENGTH                   ;Length of buffer, default 80 bytes
000012EC                           283  * CLEAR_BUFFER_LOOP                     ;Buffer loop
000012EC                           284  * CLEAR_BUFFER_END                      ;Finish subroutine
000012EC                           285  *****************************************************************************
000012EC                           286  * Constant definitions:
000012EC                           287  CLEAR_BUFFER_POINTER    DS.L    1
000012F0= 00000050                 288  CLEAR_BUFFER_LENGTH     DC.L    80
000012F4                           289  
000012F4                           290  CLEAR_BUFFER:           DS.W    0                  ;Reserve a word
000012F4  48E7 C080                291      MOVEM.L     D0-D1/A0, -(SP)             ;Save registers to stack
000012F8  2078 12EC                292      MOVEA.L     CLEAR_BUFFER_POINTER, A0        ;Load buffer address to A0
000012FC  2038 12F0                293      MOVE.L      CLEAR_BUFFER_LENGTH, D0         ;Load buffer length to D0
00001300  4281                     294      CLR.L       D1                      ;Clear any prior loop counter
00001302                           295      
00001302                           296  CLEAR_BUFFER_LOOP
00001302  B280                     297      CMP.L       D0, D1                  ;Check if the counter is more than the max length
00001304  6C00 0008                298      BGE         CLEAR_BUFFER_END                ;Finish subroutine
00001308                           299      
00001308  4218                     300      CLR.B       (A0)+                   ;Clear current character in clear buffer
0000130A  5241                     301      ADDQ        #1, D1                  ;Increment loop counter
0000130C  60F4                     302      BRA         CLEAR_BUFFER_LOOP               ;Loop back again
0000130E                           303      
0000130E                           304  CLEAR_BUFFER_END
0000130E  4CDF 0103                305      MOVEM.L     (SP)+, D0-D1/A0             ;Restore registers from stack
00001312  4E75                     306      RTS                         ;Return to stack
00001314                           307  
00001314                           308  
00001314                           309  **
00001314                           310  * CONVERT_HEX_TO_STRING
00001314                           311  *****************************************************************************
00001314                           312  * Description: Converts a given number to a hexadecimal string by the specified 
00001314                           313  * length. A null terminating string is added after (0). Conversion starts from the
00001314                           314  * rightmost bit.
00001314                           315  *
00001314                           316  * Default length of conversion is 8, but can be changed.
00001314                           317  
00001314                           318  * Additional Constants/Subroutines used:
00001314                           319  * NUMBER_TO_CONVERT                     ;Number to convert
00001314                           320  * CHARNUM_TO_CONVERT                    ;Character numbers to convert, valid range is 0-8
00001314                           321  * CONVERTED_HEX_STRING                  ;Converted hexadecimal character string
00001314                           322  * CHECK_POSITIVE_LENGTH                 ;Routine to check for positive length
00001314                           323  * CHECK_VALID_LENGTH                    ;Routine to check for valid length
00001314                           324  * DIGIT_LOOP                            ;Looping through each digit
00001314                           325  * CONVERT_TO_HEX_LETTER                 ;Routine to convert to hex letter
00001314                           326  * ADD_CHAR_TO_STRING                    ;Adds a character to the string
00001314                           327  *****************************************************************************
00001314                           328  * Constant definitions:
00001314                           329  NUMBER_TO_CONVERT       DS.L    1
00001318= 08                       330  CHARNUM_TO_CONVERT      DC.B    8
00001319                           331  CONVERTED_HEX_STRING    DS.B    9
00001322                           332  
00001322                           333  CONVERT_HEX_TO_STRING:  DS.W    0                 ;Reserve a word       
00001322  48E7 F0C0                334      MOVEM.L     D0-D3/A0-A1, -(SP)          ;Save registers to stack
00001326  4281                     335      CLR.L       D1                      ;Clear any prior number from D1
00001328  4280                     336      CLR.L       D0                      ;Clear any prior number from D0
0000132A  2038 1314                337      MOVE.L      NUMBER_TO_CONVERT, D0           ;Load number to D0
0000132E  1238 1318                338      MOVE.B      CHARNUM_TO_CONVERT, D1          ;Load length to D1
00001332  207C 00001319            339      MOVEA.L     #CONVERTED_HEX_STRING, A0       ;Load string address to convert
00001338                           340      
00001338  0C01 0001                341      CMPI.B      #1, D1                  ;Check if D1 is one or not
0000133C  6C00 0004                342      BGE         CHECK_POSITIVE_LENGTH           ;Check the length of the number
00001340  7201                     343      MOVEQ       #1, D1                  ;Move number 1 to D1 otherwise
00001342                           344      
00001342                           345  CHECK_POSITIVE_LENGTH                   ;Checks the positive length
00001342  0C01 0008                346      CMPI.B      #8, D1                  ;Check if the length is 8 or not
00001346  6F00 0004                347      BLE         CHECK_VALID_LENGTH          ;If it's less find and check the length
0000134A  7208                     348      MOVEQ       #8, D1                  ;Move number 8 into the length
0000134C                           349      
0000134C                           350  CHECK_VALID_LENGTH                      ;Checks to see if the length is valid
0000134C  2248                     351      MOVEA.L     A0, A1                  ;A0 contains start number, A1 contains current number
0000134E  D2C1                     352      ADDA.W      D1, A1                  ;Go to the last digit
00001350  4211                     353      CLR.B       (A1)                    ;Make the last digit NULL or 0
00001352  740F                     354      MOVEQ       #$0F,D2                 ;Bitmask last hex or nibble
00001354                           355      
00001354                           356  DIGIT_LOOP
00001354  1600                     357      MOVE.B      D0, D3                  ;Get 2 hex chars from number
00001356  C602                     358      AND.B       D2, D3                  ;Mask to get last hex char
00001358                           359      
00001358  0C03 0009                360      CMPI.B      #9, D3                  ;Check if the value is over 9
0000135C  6E00 000A                361      BGT         CONVERT_TO_HEX_LETTER           ;If so, it must be a letter, convert the letter
00001360                           362      
00001360  0603 0030                363      ADDI.B      #'0', D3                       ;Get the ASCII value for 0-9
00001364  6000 000A                364      BRA         ADD_CHAR_TO_STRING          ;Add char to the string
00001368                           365  
00001368                           366  CONVERT_TO_HEX_LETTER
00001368  0403 000A                367      SUBI.B      #10, D3                 ;Subtract 10 first to get correct ASCII
0000136C  0603 0041                368      ADDI.B      #'A', D3                    ;Get the ASCII value for letters A-F
00001370                           369  
00001370                           370  ADD_CHAR_TO_STRING
00001370  1303                     371      MOVE.B      D3, -(A1)                   ;Add char to string and decrement pointer
00001372  E888                     372      LSR.L       #4, D0                  ;Shift the 4 bits to the right
00001374  B3C8                     373      CMPA.L      A0, A1                  ;Check if the current pointer is greater than starting string
00001376  6EDC                     374      BGT         DIGIT_LOOP                     ;If so, loop back
00001378  42B8 1314                375      CLR.L  NUMBER_TO_CONVERT                          ;Clear any prior number  
0000137C                           376      
0000137C  4CDF 030F                377      MOVEM.L     (SP)+, D0-D3/A0-A1             ;Restore registers from stack
00001380  4E75                     378      RTS                         ;Finish subroutine
00001382                           379  
00001382                           380  
00001382                           381  ******************************************* START OF NASH CODE ******************   
00001382                           382  *********************************************************************************
00001382                           383  * Method Name: TrapTask13
00001382                           384  * Description: Creates a file if none exists, and appends bytes to that file
00001382                           385  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001382                           386  *   change this code.
00001382                           387  *
00001382                           388  * Calling Convention: Callee-Saved 
00001382                           389  *
00001382                           390  * Preconditions & Method Input:
00001382                           391  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001382                           392  *
00001382                           393  * Postconditions & Output:
00001382                           394  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001382                           395  *   See 'Output.txt' in directory for the results, also piped to the console
00001382                           396  *
00001382                           397  *
00001382                           398  *  A2 holds a pointer to null terminated string to write (input)
00001382                           399  *  A3 points to the null-terminated file name
00001382                           400  *  D3 holds the number of bytes already in the file to write
00001382                           401  *
00001382                           402  *  D5 holds number of bytes to write
00001382                           403  ********************************************************************************
00001382                           404  toSave REG D0-D5/A2-A3
00001382                           405  TrapTask13:
00001382                           406      *******************************************************************
00001382                           407      * Method initialization, register spilling, parameter saving, etc.
00001382                           408      *******************************************************************
00001382  48E7 FC30                409      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00001386                           410        
00001386  2449                     411      MOVEA.L A1, A2 ; save this buffer to write
00001388  47F9 00001712            412      LEA outFilename, A3  ; save this for later, too
0000138E                           413        
0000138E  303C 0032                414      move #50,d0   
00001392  4E4F                     415      trap #15 ; close all files, suggested to begin any IO 
00001394                           416      *******************************************************************
00001394                           417      * End Method Init
00001394                           418      *******************************************************************
00001394                           419  
00001394                           420      ******************************************************************************************
00001394                           421      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001394                           422      ******************************************************************************************
00001394  4285                     423      CLR.L D5 *D5 is now the number of bytes to write
00001396                           424  nullLoop:
00001396  1019                     425      MOVE.B (A1)+, D0
00001398  0C00 0000                426      CMPI.B #0,D0  * compare to null
0000139C  6700 0006                427      BEQ findNullLoopDone
000013A0  5245                     428      ADDI.W #1, D5
000013A2  60F2                     429      BRA nullLoop
000013A4                           430      
000013A4                           431  findNullLoopDone:
000013A4  224B                     432      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
000013A6                           433      
000013A6                           434      ;check if file exists, and open with task 51 if so, otherwise 52
000013A6                           435      ;(precondition here is A1 points to the null-terminated filename )
000013A6  103C 0033                436      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
000013AA  4E4F                     437      trap #15
000013AC                           438        
000013AC                           439      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
000013B2  103C 0034                440          MOVE.B #52, D0             ; open new file (52 is new)
000013B6  4E4F                     441          trap #15
000013B8                           442      endi
000013B8                           443      
000013B8                           444      ********************************************************************************************************* 
000013B8                           445      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
000013B8                           446      *    (first, count number of bytes already in the file to obtain seek position)
000013B8                           447      *********************************************************************************************************
000013B8  4283                     448      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
000013BA  7401                     449      MOVE.L #1, D2 ; read one byte at a time
000013BC  43F9 00001729            450      LEA byteRead, A1
000013C2                           451      
000013C2                           452  countLoop:
000013C2  103C 0035                453      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
000013C6  4E4F                     454      trap #15
000013C8                           455      
000013C8  0C40 0001                456      CMPI.W #1,D0  ;1 == EOF
000013CC  6700 0006                457      BEQ countDone
000013D0  5243                     458      ADDI #1, D3
000013D2  60EE                     459      BRA countLoop
000013D4                           460      
000013D4                           461  countDone:    
000013D4                           462      * close this file
000013D4  303C 0038                463       move #56,d0  
000013D8  4E4F                     464       trap #15 
000013DA                           465       
000013DA                           466       * reopen the target file
000013DA  224B                     467       MOVE.L A3,A1
000013DC  303C 0033                468       MOVE #51, D0
000013E0  4E4F                     469       trap #15
000013E2                           470       
000013E2                           471      * seek to right position, then continue with writing
000013E2  2403                     472      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000013E4  303C 0037                473      MOVE #55, D0  ; position file task
000013E8  4E4F                     474      trap #15
000013EA                           475  
000013EA                           476      ******************************************************************************
000013EA                           477      * Actually write the buffer to the file, after calculating the number of bytes 
000013EA                           478      *  to write and after seeking to the right location in the file for append
000013EA                           479      ******************************************************************************
000013EA                           480  
000013EA  2405                     481      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000013EC                           482      ; assumes A0 hasnt changed since handed to this method      
000013EC  224A                     483      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000013EE                           484      ; assumes file ID is still stored in D1.L  
000013EE  103C 0036                485      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000013F2  4E4F                     486      trap #15
000013F4                           487  
000013F4                           488      ; add a newline to the file output
000013F4  43F9 0000170C            489      LEA NEWLINE, A1
000013FA  103C 0036                490      MOVE.B #54, D0 
000013FE  143C 0002                491      MOVE.B #2,D2  ; kills # of bytes to write from input param
00001402  4E4F                     492      trap #15
00001404                           493      
00001404                           494      ; finally, close only this file
00001404  103C 0038                495      MOVE.B #56, D0 ; close file task
00001408  4E4F                     496      trap #15
0000140A                           497    
0000140A                           498      ; report to screen
0000140A  224A                     499      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
0000140C  103C 000D                500      MOVE.B #13, D0
00001410  4E4F                     501      trap #15
00001412                           502        
00001412                           503      ; restore context
00001412  4CDF 0C3F                504      MOVEM.L (SP)+, toSave
00001416                           505      
00001416  4E75                     506      RTS
00001418                           507      
00001418                           508      
00001418                           509  *----------------------------------------------------------------------------------
00001418                           510  * Method Name: AsciiToHex
00001418                           511  * Written by : Berger, Modified by Nash
00001418                           512  * Date       : 3/1/2019
00001418                           513  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
00001418                           514  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
00001418                           515  *              its (4b each) equivalent hex value 
00001418                           516  *  
00001418                           517  *  Preconditions & Input
00001418                           518  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
00001418                           519  *       This function calls another function (strip_ascii)
00001418                           520  *
00001418                           521  *  Postconditions & Output
00001418                           522  *       D7 (output) holds the converted value 
00001418                           523  *       Caller-Saved : D0 is temp, D6 is a loop var
00001418                           524  *----------------------------------------------------------------------------------
00001418                           525  AsciiToHexRegList REG D0,D6
00001418                           526  AsciiToHex     
00001418  48E7 8000                527      MOVEM.L asciiToHexRegList, -(SP)  *save context
0000141C  4287                     528      CLR.L D7 * clear our return value
0000141E  7C08                     529      MOVE.L #8, D6 ; and set up our loop counter
00001420                           530  
00001420                           531  chrLoop
00001420  1019                     532      MOVE.B (A1)+,D0 * Get the first byte
00001422  4EB9 0000143A            533      jsr strip_ascii * Get rid of the ascii code    
00001428  8E40                     534      OR.W D0,D7 * Load the bits into D7
0000142A                           535      
0000142A  5306                     536      subI.B #1,D6  *decrement our loop variable
0000142C  6700 0006                537      BEQ chrDone   *skip shifting if we are done
00001430                           538      
00001430  E987                     539      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
00001432  60EC                     540      BRA chrLoop
00001434                           541  
00001434                           542  chrDone
00001434  4CDF 0001                543      MOVEM.L (SP)+,asciiToHexRegList 
00001438  4E75                     544      RTS
0000143A                           545  
0000143A                           546  
0000143A                           547  **********************************************************************
0000143A                           548  * SUBROUTINE: strip_ascii
0000143A                           549  * remove the ascii code from the digits 0-9,a-f, or A-F
0000143A                           550  * Input Parameters: <D0> = ascii code
0000143A                           551  *
0000143A                           552  * Return parameters: D0.B = number 0...F, returned as 00...0F
0000143A                           553  * Registers used internally: D0
0000143A                           554  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
0000143A                           555  *
0000143A                           556  ***********************************************************************
0000143A                           557  strip_ascii
0000143A  B03C 0039                558        CMP.B #$39,D0 * Is it in range of 0-9?
0000143E  6F00 001A                559        BLE sub30 * Its a number
00001442  B03C 0046                560        CMP.B #$46,D0 * Is is A...F?
00001446  6F00 000A                561        BLE sub37 * Its A...F
0000144A  0400 0057                562        SUB.B #$57,D0 * Its a...f
0000144E  6000 000E                563        BRA ret_sa * Go back
00001452  0400 0037                564  sub37 SUB.B #$37,D0 * Strip 37
00001456  6000 0006                565        BRA ret_sa * Go back
0000145A  0400 0030                566  sub30 SUB.B #$30,D0 * Strip 30
0000145E  4E75                     567  ret_sa RTS * Go back
00001460                           568  ******************************************* END OF NASH CODE ********************
00001460                           569  MAIN_CONSOLE                                                            ;Main print message
00001460                           570     
00001460= 3D 3D 3D 3D 3D 3D ...    571        DC.B '============================================================',CR,LF
0000149E= 7C 7C 20 20 20 20 ...    572        DC.B '||                                                        ||',CR,LF
000014DC= 7C 7C 20 20 20 23 ...    573        DC.B '||   #####      ###    ##   ##                            ||',CR,LF
0000151A= 7C 7C 20 20 23 23 ...    574        DC.B '||  ##        ##   ##  ## ##                              ||',CR,LF
00001558= 7C 7C 20 23 23 20 ...    575        DC.B '|| ## ####     #####   ####                               ||',CR,LF
00001596= 7C 7C 20 23 23 20 ...    576        DC.B '|| ##    ##  ##    ##  ####                               ||',CR,LF
000015D4= 7C 7C 20 23 23 20 ...    577        DC.B '|| ##    ##  ##    ##  ## ##                              ||',CR,LF
00001612= 7C 7C 20 20 23 23 ...    578        DC.B '||  #####     ######   ##  ##                             ||',CR,LF
00001650= 7C 7C 20 20 20 20 ...    579        DC.B '||                                                        ||',CR,LF
0000168E= 7C 7C 20 20 20 44 ...    580        DC.B '||   Daniel Yan, Fahad Alshehri, Denny Park               ||',CR,LF
000016CC= 3D 3D 3D 3D 3D 3D ...    581        DC.B '============================================================',CR,LF,0
0000170B                           582      
0000170B                           583  * Required variables and constants go here for your Disassembler
0000170B  =0000000D                584  CR              EQU $0D                     ;Carriage return
0000170B  =0000000A                585  LF              EQU $0A                        ;Line feed
0000170C= 000D 000A 0000           586  NEWLINE         DC.W CR,LF,0                    ;Make a new line
00001712= 44 69 73 61 73 73 ...    587  outFilename     DC.B 'DisassemblerOutput.txt',0             ;Output file
00001729                           588  byteRead        DS.B 1                              ;Read a byte
0000172A= 31 41 30 30 31 41 ...    589  ascii_val       DC.B $31,$41,$30,$30,$31,$41,$30,$30            ;Test value $1A001A00
00001732                           590  
00001732                           591  * Variables and constants
00001732  =00000014                592  SIZE            EQU     20                          ;Max string size
00001732= 43 6F 6E 66 69 67 ...    593  fileName        DC.B    'Config.cfg',0                  ;Name of text file
0000173D                           594  IO_BUFFER       DS.B    SIZE                                    ;Variable for IO buffer
00001752                           595  fileID          DS.L    1                                   ;Variable for File ID
00001756= 496E 7661 6C69 6...      596  INVALID_ADDRES_MESSAGE DC.W 'Invalid Hex Address' ,CR,LF,0          ;Invalid message print
00001770                           597  
00001770                           598      INCLUDE "OP_Code_Routines.x68"                      ;OP role code to include
00001770                           599  
00001770                           600  OP_SIZE         DS.B    1   ;This constant refers to the size of the current OP code 
00001771                           601  MNEMONIC        DS.B    1   ;Constant for EA, first 4 bits (15-12) of a 4 hex OP code
00001772                           602  FIRST_3         DS.B    1   ;Constant for EA, 3 bits (11-9) of a 4 hex OP code
00001773                           603  SECOND_3        DS.B    1   ;Constant for EA, 3 bits (8-6) of a 4 hex OP code
00001774                           604  THIRD_3         DS.B    1   ;Constant for EA, 3 bits (5-3) of a 4 hex OP code
00001775                           605  FOURTH_3        DS.B    1   ;Constant for EA, 3 bits (2-0) of a 4 hex OP code
00001776                           606  
00001776                           607  
00001776                           608  
00001776                           609  
00001776                           610  OP_JSR_Routine:
00001776  48E7 C000                611      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
0000177A  3038 10A0                612      MOVE.W CUR_OP_CODE,D0          ;Move current instruction set to D0
0000177E  11FC 0001 10A2           613      MOVE.B #1,IS_VALID             ;Set IS_VALID bit to 1 by default
00001784  720C                     614      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
00001786  E2A8                     615      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
00001788                           616  
00001788                           617  GROUP_0:                           ;$0| ORI, BCLR (static and dynamic), CMPI                  
00001788  B03C 0000                618      CMP.B   #$0,D0                 ;Compare first nibble
0000178C  6600 000C                619      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
00001790  4EB9 000019B2            620      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
00001796  6000 010C                621      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000179A                           622      
0000179A                           623  GROUP_1:                           ;$1| MOVE.B
0000179A  B03C 0001                624      CMP.B   #$1,D0                 ;Compare first nibble
0000179E  6600 000C                625      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
000017A2  4EB9 00001B90            626      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
000017A8  6000 00FA                627      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017AC                           628  
000017AC                           629  GROUP_2:                           ;$2| MOVE.L, MOVEA.L
000017AC  B03C 0002                630      CMP.B   #$2,D0                 ;Compare first nibble
000017B0  6600 000C                631      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
000017B4  4EB9 00001BBA            632      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
000017BA  6000 00E8                633      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017BE                           634  
000017BE                           635  GROUP_3:                           ;$3| MOVE.W, MOVEA.W
000017BE  B03C 0003                636      CMP.B   #$3,D0                 ;Compare first nibble
000017C2  6600 000C                637      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
000017C6  4EB9 00001C1C            638      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
000017CC  6000 00D6                639      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017D0                           640  
000017D0                           641  GROUP_4:                           ;$4| LEA, JSR, RTS, NEG, MOVEM
000017D0  B03C 0004                642      CMP.B   #$4,D0                 ;Compare first nibble
000017D4  6600 000C                643      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
000017D8  4EB9 00001C7E            644      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
000017DE  6000 00C4                645      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017E2                           646  
000017E2                           647  
000017E2                           648  GROUP_5:                           ;$5| SUBQ
000017E2  B03C 0005                649      CMP.B   #$5,D0                 ;Compare first nibble
000017E6  6600 000C                650      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
000017EA  4EB9 00001F36            651      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
000017F0  6000 00B2                652      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000017F4                           653  
000017F4                           654  
000017F4                           655  GROUP_6:                           ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
000017F4  B03C 0006                656      CMP.B   #$6,D0                 ;Compare first nibble
000017F8  6600 000C                657      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
000017FC  4EB9 00001FA0            658      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
00001802  6000 00A0                659      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001806                           660  
00001806                           661  
00001806                           662  GROUP_7:                           ;$7| Display: DATA, $WXYZ (Unsupported)
00001806  B03C 0007                663      CMP.B   #$7,D0                 ;Compare first nibble
0000180A  6600 000C                664      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
0000180E  4EB9 000020E6            665      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
00001814  6000 008E                666      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001818                           667  
00001818                           668  
00001818                           669  GROUP_8:                           ;$8| DIVS, OR
00001818  B03C 0008                670      CMP.B   #$8,D0                 ;Compare first nibble
0000181C  6600 000C                671      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
00001820  4EB9 00002106            672      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
00001826  6000 007C                673      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000182A                           674  
0000182A                           675  
0000182A                           676  GROUP_9:                           ;$9| SUB
0000182A  B03C 0009                677      CMP.B   #$9,D0                 ;Compare first nibble
0000182E  6600 000C                678      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
00001832  4EB9 00002166            679      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
00001838  6000 006A                680      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000183C                           681  
0000183C                           682  
0000183C                           683  GROUP_A:                           ;$A| Display: DATA, $WXYZ (Unsupported)
0000183C  B03C 000A                684      CMP.B   #$A,D0                 ;Compare first nibble
00001840  6600 000C                685      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
00001844  4EB9 000021D8            686      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
0000184A  6000 0058                687      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
0000184E                           688  
0000184E                           689  
0000184E                           690  GROUP_B:                           ;$B| EOR, CMP
0000184E  B03C 000B                691      CMP.B   #$B,D0                 ;Compare first nibble
00001852  6600 000C                692      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
00001856  4EB9 000021E0            693      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
0000185C  6000 0046                694      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001860                           695  
00001860                           696  
00001860                           697  GROUP_C:                           ;$C| MULS
00001860  B03C 000C                698      CMP.B   #$C,D0                 ;Compare first nibble
00001864  6600 000C                699      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
00001868  4EB9 00002254            700      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
0000186E  6000 0034                701      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001872                           702  
00001872                           703  
00001872                           704  GROUP_D:                           ;$D| ADD, ADDA
00001872  B03C 000D                705      CMP.B   #$D,D0                 ;Compare first nibble
00001876  6600 000C                706      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
0000187A  4EB9 000022D8            707      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
00001880  6000 0022                708      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001884                           709  
00001884                           710  
00001884                           711  GROUP_E:                           ;$E| LSR, LSL, ASR, ASL, ROL, ROR
00001884  B03C 000E                712      CMP.B   #$E,D0                 ;Compare first nibble
00001888  6600 000C                713      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
0000188C  4EB9 00002338            714      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
00001892  6000 0010                715      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
00001896                           716  
00001896                           717  
00001896                           718  GROUP_F:                           ;$F| Display: DATA, $WXYZ (Unsupported)
00001896  B03C 000F                719      CMP.B   #$F,D0                 ;Compare first nibble
0000189A  4EB9 000024E8            720      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
000018A0  6000 0002                721      BRA     OP_JSR_DONE            ;Finish subroutine once checking is finished
000018A4                           722  
000018A4                           723  
000018A4                           724  OP_JSR_DONE:                       ;This subroutine is only called when identification has been finished
000018A4  4CDF 0003                725           MOVEM.L (SP)+,D0-D1       ;Recover register D0
000018A8  0C38 0001 10A2           726           CMP.B #1,IS_VALID         ;Checks if the IS_VALID bit is valid or not
000018AE  6700 1076                727           BEQ    main_EA            ;This runs EA's routines after OP code portion is finished
000018B2  6600 F946                728           BNE    check_print        ;If not valid, skip EA routine and call IO
000018B6                           729  FIND_2_BIT_SIZE_7_TO_6:         ;Move the 2 bit size field relevant register
000018B6  48E7 C000                730      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018BA  3038 10A0                731      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018BE  323C 0008                732      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
000018C2  E368                     733      LSL.W    D1,D0              ;Truncate to find the 2 size bits
000018C4  E268                     734      LSR.W    D1,D0              ;Reposition the bits
000018C6  323C 0006                735      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000018CA  E268                     736      LSR.W    D1,D0              ;Truncate to shift 2 bits to a byte
000018CC  11C0 1770                737      MOVE.B   D0,OP_SIZE         ;Move 2 size bits into OP_SIZE
000018D0  4CDF 0003                738      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018D4  4E75                     739      RTS                         ;Return to stack
000018D6                           740  
000018D6                           741  FIND_1_BIT_SIZE_6:              ;Move the 1 bit size field relevant register
000018D6  48E7 C000                742      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018DA  3038 10A0                743      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018DE  323C 0009                744      MOVE.W   #9,D1              ;Prepare 9 bit shift to D1
000018E2  E368                     745      LSL.W    D1,D0              ;Truncate to find the size bit
000018E4  E268                     746      LSR.W    D1,D0              ;Reposition the bits
000018E6  323C 0006                747      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000018EA  E268                     748      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000018EC  11C0 1770                749      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
000018F0  4CDF 0003                750      MOVEM.L (SP)+,D0-D1         ;Restore registers
000018F4  4E75                     751      RTS                         ;Return to stack
000018F6                           752  
000018F6                           753  FIND_1_BIT_SIZE_8:         ;Move the 1 bit size field relevant register
000018F6  48E7 C000                754      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000018FA  3038 10A0                755      MOVE.W   CUR_OP_CODE,D0     ;Move current OP code into D0
000018FE  323C 0007                756      MOVE.W   #7,D1              ;Prepare 7 bit shift to D1
00001902  E368                     757      LSL.W    D1,D0              ;Truncate to find the 1 size bit
00001904  E268                     758      LSR.W    D1,D0              ;Reposition the bits
00001906  323C 0008                759      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
0000190A  E268                     760      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
0000190C  11C0 1770                761      MOVE.B   D0,OP_SIZE         ;Move 1 size bit into OP_SIZE
00001910  4CDF 0003                762      MOVEM.L (SP)+,D0-D1         ;Restore registers
00001914  4E75                     763      RTS                         ;Return to stack
00001916                           764  
00001916                           765  MOVE_AND_MOVEA_PARSE_EA:     ;Move the 3 bit dynamic register bits to proper register
00001916  3038 10A0                766      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0
0000191A  323C 000A                767      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
0000191E  E368                     768      LSL.W   D1,D0            ;Truncate to find the last 6 bits
00001920  E268                     769      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
00001922  3E00                     770      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
00001924  323C 0003                771      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00001928  E26F                     772      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
0000192A  3A07                     773      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
0000192C  323C 000D                774      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
00001930  E368                     775      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
00001932  E268                     776      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
00001934  3800                     777      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
00001936                           778      
00001936  3038 10A0                779      MOVE.W CUR_OP_CODE,D0    ;Move current OP code into D0     
0000193A  323C 0004                780      MOVE.W  #4,D1            ;Prepare 4 bit shift to D1
0000193E  E368                     781      LSL.W   D1,D0            ;Truncate to find bits 11-6
00001940  E268                     782      LSR.W   D1,D0            ;Reposition bits
00001942  323C 0006                783      MOVE.W  #6,D1            ;Prepare 6 bit shift to D1
00001946  E268                     784      LSR.W   D1,D0            ;Truncate the SRC Reg/Mode bits
00001948  323C 0003                785      MOVE.W  #3,D1            ;Prepare a 3 bit shift to D1 for DST Reg/Mode
0000194C  3C00                     786      MOVE.W  D0,D6            ;Copy over the current 6 bits to D6
0000194E  E268                     787      LSR.W   D1,D0            ;Truncate DST Mode  
00001950  3E00                     788      MOVE.W  D0,D7            ;Move DST Reg to D7
00001952  323C 000D                789      MOVE.W  #13,D1             
00001956  E36E                     790      LSL.W   D1,D6            ;Truncate 13 bits in D6
00001958  E26E                     791      LSR.W   D1,D6            ;Reposition D6
0000195A                           792                               ;D6 now contains the DST Reg
0000195A  4E75                     793      RTS                      ;Return to stack
0000195C                           794  PARSE_EA_CONSTANT_BITS:
0000195C  48E7 C000                795      MOVEM.L D0-D1,-(SP)         ;Save register to stack
00001960                           796      *MNEMONIC SHIFT
00001960  3038 10A0                797      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D0
00001964  323C 000C                798      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
00001968  E268                     799      LSR.W D1,D0                 ;Shift 12 bits from D0 right
0000196A  11C0 1771                800      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
0000196E                           801      *FIRST_3 SHIFT
0000196E  323C 0009                802      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
00001972  3038 10A0                803      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001976  E948                     804      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
00001978  E848                     805      LSR.W #4,D0                 ;Reposition D0
0000197A  E268                     806      LSR.W  D1,D0                ;Shift D0 9 bits right
0000197C  11C0 1772                807      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
00001980                           808      *SECOND_3 SHIFT
00001980  3038 10A0                809      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001984  EF48                     810      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
00001986  EE48                     811      LSR.W #7,D0                 ;Reposition D0
00001988  EC48                     812      LSR.W #6,D0                 ;Shift D0 6 bits right
0000198A  11C0 1773                813      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
0000198E                           814      *THIRD_3 SHIFT
0000198E  3038 10A0                815      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
00001992  E648                     816      LSR.W #3,D0                 ;Shift D0 3 bits right
00001994  323C 000D                817      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
00001998  E368                     818      LSL.W D1,D0                 ;Truncate first 13 bits of D0
0000199A  E268                     819      LSR.W D1,D0                 ;Reposition D0
0000199C  11C0 1774                820      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
000019A0                           821      *FOURTH_3 SHIFT
000019A0  3038 10A0                822      MOVE.W CUR_OP_CODE,D0       ;Load in current instruction set into D
000019A4  E368                     823      LSL.W D1,D0                 ;Grab the fourth 3-bit group
000019A6  E268                     824      LSR.W D1,D0                 ;Shift D0 back into position
000019A8  11C0 1775                825      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
000019AC  4CDF 0003                826      MOVEM.L (SP)+,D0-D1         ;Restore registers
000019B0  4E75                     827      RTS                         ;Return to stack
000019B2                           828  
000019B2                           829  
000019B2                           830  
000019B2                           831  
000019B2                           832  
000019B2                           833  C_GROUP_0:
000019B2  48E7 C000                834      MOVEM.L D0-D1, -(SP)            ;Backup registers
000019B6                           835      
000019B6                           836  CHECK_OP_ORI_TO_CCR:
000019B6  3038 10A0                837      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019BA  B07C 003C                838      CMP.W #$003C,D0                 ;Compare the direct full bits
000019BE  6700 01C4                839      BEQ GROUP0_INVALID              ;INVALID OP code found
000019C2  6600 0002                840      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
000019C6                           841      
000019C6                           842  CHECK_OP_ORI_TO_SR:
000019C6  3038 10A0                843      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019CA  B07C 007C                844      CMP.W #$007C,D0                 ;Compare the direct full bits
000019CE  6700 01B4                845      BEQ GROUP0_INVALID              ;INVALID OP code found
000019D2  6600 0002                846      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
000019D6                           847      
000019D6                           848  CHECK_OP_ANDI_TO_CCR:
000019D6  3038 10A0                849      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019DA  B07C 023C                850      CMP.W #$023C,D0                 ;Compare the direct full bits
000019DE  6700 01A4                851      BEQ GROUP0_INVALID              ;INVALID OP code found
000019E2  6600 0002                852      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
000019E6                           853      
000019E6                           854  CHECK_OP_ANDI_TO_SR:
000019E6  3038 10A0                855      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019EA  B07C 027C                856      CMP.W #$027C,D0                 ;Compare the direct full bits
000019EE  6700 0194                857      BEQ GROUP0_INVALID              ;INVALID OP code found
000019F2  6600 0002                858      BNE CHECK_OP_EORI_TO_CCR                ;Check next routine
000019F6                           859  
000019F6                           860  CHECK_OP_EORI_TO_CCR:
000019F6  3038 10A0                861      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000019FA  B07C 0A3C                862      CMP.W #$0A3C,D0                 ;Compare the direct full bits
000019FE  6700 0184                863      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A02  6600 0002                864      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
00001A06                           865      
00001A06                           866  CHECK_OP_EORI_TO_SR:
00001A06  3038 10A0                867      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A0A  B07C 0A7C                868      CMP.W #$0A7C,D0                 ;Compare the direct full bits
00001A0E  6700 0174                869      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A12  6600 0002                870      BNE CHECK_OP_ANDI               ;Check next routine
00001A16                           871      
00001A16                           872  CHECK_OP_ANDI:
00001A16  3038 10A0                873      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A1A  0240 FF00                874      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A1E  B07C 0200                875      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
00001A22  6700 0160                876      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A26  6600 0002                877      BNE CHECK_OP_SUBI               Check next routine
00001A2A                           878      
00001A2A                           879  CHECK_OP_SUBI:
00001A2A  3038 10A0                880      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A2E  0240 FF00                881      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A32  B07C 0400                882      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
00001A36  6700 014C                883      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A3A  6600 0002                884      BNE CHECK_OP_ADDI               ;Check next routine
00001A3E                           885  
00001A3E                           886  CHECK_OP_ADDI:
00001A3E  3038 10A0                887      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A42  0240 FF00                888      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A46  B07C 0600                889      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00001A4A  6700 0138                890      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A4E  6600 0002                891      BNE CHECK_OP_EORI               ;Check next routine 
00001A52                           892  
00001A52                           893  CHECK_OP_EORI:
00001A52  3038 10A0                894      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A56  0240 FF00                895      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001A5A  B07C 0A00                896      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
00001A5E  6700 0124                897      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A62  6600 0002                898      BNE CHECK_OP_STATIC_BTST        ;Check next routine
00001A66                           899      
00001A66                           900  CHECK_OP_STATIC_BTST:
00001A66  3038 10A0                901      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A6A  0240 FFC0                902      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A6E  B07C 0800                903      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
00001A72  6700 0110                904      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A76  6600 0002                905      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
00001A7A                           906      
00001A7A                           907  CHECK_OP_STATIC_BCHG:
00001A7A  3038 10A0                908      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A7E  0240 FFC0                909      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A82  B07C 0840                910      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
00001A86  6700 00FC                911      BEQ GROUP0_INVALID              ;INVALID OP code found
00001A8A  6600 0002                912      BNE CHECK_OP_STATIC_BSET        ;Check next routine
00001A8E                           913  
00001A8E                           914  CHECK_OP_STATIC_BSET:
00001A8E  3038 10A0                915      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001A92  0240 FFC0                916      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001A96  B07C 08C0                917      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
00001A9A  6700 00E8                918      BEQ GROUP0_INVALID              ;INVALID OP code found   
00001A9E  6600 0002                919      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
00001AA2                           920  
00001AA2                           921  CHECK_OP_DYNAMIC_BTST:
00001AA2  3038 10A0                922      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001AA6  0240 F1C0                923      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001AAA  B07C 0100                924      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
00001AAE  6700 00D4                925      BEQ GROUP0_INVALID              ;INVALID OP code found
00001AB2  6600 0002                926      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
00001AB6                           927  
00001AB6                           928  CHECK_OP_DYNAMIC_BCHG:
00001AB6  3038 10A0                929      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001ABA  0240 F1C0                930      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00001ABE  B07C 0140                931      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00001AC2  6700 00C0                932      BEQ GROUP0_INVALID              ;INVALID OP code found
00001AC6  6600 0002                933      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00001ACA                           934      
00001ACA                           935  CHECK_OP_DYNAMIC_BSET:
00001ACA                           936  
00001ACA  3038 10A0                937      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001ACE  0240 F1C0                938      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001AD2  B07C 01C0                939      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
00001AD6  6700 0006                940      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00001ADA  6600 001C                941      BNE     CHECK_OP_MOVEP          ;Check next routine
00001ADE                           942  
00001ADE                           943  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00001ADE  3038 10A0                944      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001AE2  323C 000A                945      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
00001AE6  E368                     946      LSL.W   D1,D0                   ;Shift out 10 bits left 
00001AE8  E268                     947      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00001AEA  E648                     948      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00001AEC  B07C 0001                949      CMP.W   #$1,D0                  ;Compare bits to D0
00001AF0  6700 0006                950      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
00001AF4  6600 008E                951      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid
00001AF8                           952      
00001AF8                           953  CHECK_OP_MOVEP:
00001AF8  3038 10A0                954      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001AFC  0240 F138                955      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00001B00  B07C 0108                956      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
00001B04  6700 09EA                957      BEQ INVALID_OP                  ;INVALID OP code found
00001B08  6600 0002                958      BNE CHECK_OP_ORI                ;Check next routine
00001B0C                           959  
00001B0C                           960  CHECK_OP_ORI:
00001B0C  3038 10A0                961      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B10  0240 FF00                962      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001B14  B07C 0000                963      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00001B18  6600 0010                964      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00001B1C  4EB8 18B6                965      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B20  4EB9 00002506            966      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
00001B26  6000 0062                967      BRA     GROUP0_SUCCESS          ;Finish routine
00001B2A                           968      
00001B2A                           969  CHECK_OP_CMPI:
00001B2A  3038 10A0                970      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B2E  0240 FF00                971      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001B32  B07C 0C00                972      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
00001B36  6600 0010                973      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
00001B3A  4EB8 18B6                974      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B3E  4EB9 0000251A            975      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00001B44  6000 0044                976      BRA     GROUP0_SUCCESS          ;Finish routine
00001B48                           977      
00001B48                           978  CHECK_OP_STATIC_BCLR:
00001B48  3038 10A0                979      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B4C  0240 FF00                980      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00001B50  B07C 0800                981      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00001B54  6600 0010                982      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00001B58  4EB8 18B6                983      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B5C  4EB9 0000252E            984      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
00001B62  6000 0026                985      BRA     GROUP0_SUCCESS          ;Finish routine
00001B66                           986      
00001B66                           987  CHECK_OP_DYNAMIC_BCLR:
00001B66  3038 10A0                988      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001B6A  0240 0180                989      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
00001B6E  B07C 0180                990      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
00001B72  6600 0010                991      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
00001B76  4EB8 18B6                992      JSR     FIND_2_BIT_SIZE_7_TO_6
00001B7A  4EB9 00002542            993      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
00001B80  6000 0008                994      BRA     GROUP0_SUCCESS          ;Finish routine
00001B84                           995  
00001B84                           996  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
00001B84  4EB9 000024F0            997      JSR INVALID_OP                  ;INVALID OP code found
00001B8A                           998  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
00001B8A  4CDF 0003                999      MOVEM.L (SP)+,D0-D1             ;Restore registers
00001B8E  4E75                    1000      RTS                             ;Return to stack
00001B90                          1001      
00001B90                          1002  C_GROUP_1:
00001B90  48E7 C000               1003      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
00001B94                          1004  
00001B94                          1005  CHECK_OP_MOVE_B:
00001B94  3038 10A0               1006      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0          
00001B98  0240 F000               1007      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
00001B9C  B07C 1000               1008      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
00001BA0  6600 000C               1009      BNE     GROUP1_INVALID          ;Invalid OP code has been found
00001BA4  4EB9 00002556           1010      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
00001BAA  6000 0008               1011      BRA     GROUP1_SUCCESS          ;Finish routine
00001BAE                          1012      
00001BAE                          1013  GROUP1_INVALID:
00001BAE  4EB9 000024F0           1014      JSR INVALID_OP                  ;Invalid OP code found
00001BB4                          1015  GROUP1_SUCCESS:
00001BB4  4CDF 0003               1016      MOVEM.L (SP)+,D0-D1             ;Restore register
00001BB8  4E75                    1017      RTS                             ;Return to stack
00001BBA                          1018  C_GROUP_2:
00001BBA  48E7 E000               1019      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001BBE                          1020  
00001BBE                          1021  CHECK_OP_MOVEA_L:
00001BBE  3038 10A0               1022      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0  
00001BC2  0240 F000               1023      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001BC6  B07C 2000               1024      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001BCA  4EF9 00001BD0           1025      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00001BD0                          1026      
00001BD0                          1027  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00001BD0  3038 10A0               1028      MOVE.W   CUR_OP_CODE,D0         ;Move current OP code into D0
00001BD4  323C 0007               1029      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00001BD8  E368                    1030      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00001BDA  E268                    1031      LSR.W    D1,D0                  ;Reposition the bits
00001BDC  323C 0006               1032      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00001BE0  E268                    1033      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00001BE2  3400                    1034      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
00001BE4  B47C 0001               1035      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00001BE8  6600 000C               1036      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00001BEC  4EB9 00002564           1037      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00001BF2  6000 0022               1038      BRA     GROUP2_SUCCESS          ;Finish routine
00001BF6                          1039      
00001BF6                          1040      
00001BF6                          1041  CHECK_OP_MOVE_L:
00001BF6  3038 10A0               1042      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001BFA  0240 F000               1043      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00001BFE  B07C 2000               1044      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00001C02  6600 000C               1045      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
00001C06  4EB9 00002572           1046      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00001C0C  6000 0008               1047      BRA GROUP2_SUCCESS              ;Finish routine
00001C10                          1048      
00001C10                          1049  GROUP2_INVALID:    
00001C10  4EB9 000024F0           1050      JSR INVALID_OP                  ;Invalid OP code found
00001C16                          1051  GROUP2_SUCCESS:
00001C16  4CDF 0007               1052      MOVEM.L (SP)+,D0-D2             ;Restore register
00001C1A  4E75                    1053      RTS                             ;Return to stack
00001C1C                          1054  C_GROUP_3:
00001C1C  48E7 E000               1055      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00001C20                          1056      
00001C20                          1057  CHECK_OP_MOVEA_W:
00001C20  3038 10A0               1058      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001C24  0240 F000               1059      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001C28  B07C 3000               1060      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001C2C  4EF9 00001C32           1061      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
00001C32                          1062  
00001C32                          1063      
00001C32                          1064  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
00001C32  3038 10A0               1065      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001C36  323C 0007               1066      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00001C3A  E368                    1067      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00001C3C  E268                    1068      LSR.W    D1,D0                 ;Reposition the bits
00001C3E  323C 0006               1069      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
00001C42  E268                    1070      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
00001C44  3400                    1071      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
00001C46  B47C 0001               1072      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00001C4A  6600 000C               1073      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00001C4E  4EB9 00002580           1074      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
00001C54  6000 0022               1075      BRA      GROUP3_SUCCESS        ;Finish routine
00001C58                          1076      
00001C58                          1077  CHECK_OP_MOVE_W:
00001C58  3038 10A0               1078      MOVE.W   CUR_OP_CODE,D0        ;Move current instruction set into D0
00001C5C  0240 F000               1079      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00001C60  B07C 3000               1080      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00001C64  6600 000C               1081      BNE      GROUP3_INVALID        ;INVALID OP code found
00001C68  4EB9 0000258E           1082      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
00001C6E  6000 0008               1083      BRA      GROUP3_SUCCESS        ;Finish routine
00001C72                          1084      
00001C72                          1085  GROUP3_INVALID:
00001C72  4EB9 000024F0           1086      JSR INVALID_OP                 ;INVALID OP code found
00001C78                          1087  GROUP3_SUCCESS:
00001C78  4CDF 0007               1088      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
00001C7C  4E75                    1089      RTS                            ;Return to stack
00001C7E                          1090  
00001C7E                          1091  C_GROUP_4:
00001C7E  2F00                    1092      MOVE.L  D0,-(SP)            ;Save registers
00001C80                          1093      
00001C80                          1094  CHECK_OP_STOP:
00001C80  3038 10A0               1095      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C84  B07C 4E72               1096      CMP.W  #$4E72,D0                ;Compare the appropriate bits
00001C88  6700 02A0               1097      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C8C  6600 0002               1098      BNE    CHECK_OP_RESET           ;Check next OP code
00001C90                          1099      
00001C90                          1100  CHECK_OP_RESET:
00001C90  3038 10A0               1101      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001C94  B07C 4E70               1102      CMP.W  #$4E70,D0                ;Compare the appropriate bits
00001C98  6700 0290               1103      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001C9C  6600 0002               1104      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
00001CA0                          1105          
00001CA0                          1106  CHECK_OP_ILLEGAL:
00001CA0  3038 10A0               1107      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CA4  B07C 4AFC               1108      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
00001CA8  6700 0280               1109      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CAC  6600 0002               1110      BNE    CHECK_OP_RTE             ;Check next OP code
00001CB0                          1111      
00001CB0                          1112  CHECK_OP_RTE:    
00001CB0  3038 10A0               1113      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CB4  B07C 4E73               1114      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00001CB8  6700 0270               1115      BEQ   GROUP4_INVALID            ;INVALID OP code found
00001CBC  6600 0002               1116      BNE   CHECK_OP_TRAPV            ;Check next OP code
00001CC0                          1117      
00001CC0                          1118  CHECK_OP_TRAPV:
00001CC0  3038 10A0               1119      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CC4  B07C 4E76               1120      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00001CC8  6700 0260               1121      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CCC  6600 0002               1122      BNE    CHECK_OP_RTR             ;Check next OP code
00001CD0                          1123      
00001CD0                          1124  CHECK_OP_RTR:
00001CD0  3038 10A0               1125      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CD4  B07C 4E77               1126      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00001CD8  6700 0250               1127      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001CDC  6600 0002               1128      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00001CE0                          1129  
00001CE0                          1130  
00001CE0                          1131  CHECK_OP_MOVE_FROM_SR:
00001CE0  3038 10A0               1132      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CE4  0240 FFC0               1133      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CE8  B07C 40C0               1134      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00001CEC  6700 023C               1135      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00001CF0  6600 0002               1136      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
00001CF4                          1137      
00001CF4                          1138  CHECK_OP_MOVE_TO_CCR:
00001CF4  3038 10A0               1139      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001CF8  0240 FFC0               1140      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001CFC  B07C 44C0               1141      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00001D00  6700 0228               1142      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D04  6600 0002               1143      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00001D08                          1144      
00001D08                          1145  CHECK_OP_MOVE_TO_SR:
00001D08  3038 10A0               1146      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D0C  0240 FFC0               1147      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001D10  B07C 46C0               1148      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
00001D14  6700 0214               1149      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D18  6600 0002               1150      BNE    CHECK_OP_NEGX            ;Check next OP code
00001D1C                          1151      
00001D1C                          1152  CHECK_OP_NEGX:
00001D1C  3038 10A0               1153      MOVE.W CUR_OP_CODE,D0            ;Move current instruction set into D0
00001D20  0240 FF00               1154      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D24  B07C 4000               1155      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
00001D28  6700 0200               1156      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D2C  6600 0002               1157      BNE    CHECK_OP_CLR             ;Check next OP code
00001D30                          1158      
00001D30                          1159  CHECK_OP_CLR:
00001D30  3038 10A0               1160      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D34  0240 FF00               1161      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D38  B07C 4200               1162      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00001D3C  6700 01EC               1163      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D40  6600 0002               1164      BNE    CHECK_OP_NOT             ;Check next OP code
00001D44                          1165      
00001D44                          1166  CHECK_OP_NOT:
00001D44  3038 10A0               1167      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D48  0240 FF00               1168      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001D4C  B07C 4600               1169      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00001D50  6700 01D8               1170      BEQ    GROUP4_INVALID           ;INVALID OP code found
00001D54  6600 0002               1171      BNE    CHECK_OP_EXT             ;Check next OP code
00001D58                          1172      
00001D58                          1173  CHECK_OP_EXT:
00001D58  3038 10A0               1174      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D5C  0240 FFB8               1175      ANDI.W #$FFB8,D0                ;Mask relevant bits to D0
00001D60  B07C 4880               1176      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
00001D64  6700 01C4               1177      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
00001D68  6600 001C               1178      BNE    CHECK_OP_NBCD            ;Check next OP code
00001D6C                          1179  
00001D6C                          1180  BIT_CHECK_EXT:    
00001D6C  3038 10A0               1181      MOVE.W CUR_OP_CODE,D0           ;This is a special case to check against MOVEM
00001D70  323C 000A               1182      MOVE.W #10,D1                   ;Prepare a 10 bit shift into D1
00001D74  E368                    1183      LSL.W  D1,D0                    ;Shift D0 left 10 bits
00001D76  E068                    1184      LSR.W  D0,D0                    ;Reposition D0
00001D78  E648                    1185      LSR.W  #3,D0                    ;Shift D0 3 bits
00001D7A  B078 0000               1186      CMP.W  %000,D0                  ;Check the specific bits needed to differentiate EXT
00001D7E  6700 01AA               1187      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
00001D82  6600 015C               1188      BNE    MOVEM_BIT_SIZE_CHECK     ;This is the only other possibility 
00001D86                          1189      
00001D86                          1190  CHECK_OP_NBCD:
00001D86  3038 10A0               1191      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D8A  0240 FFC0               1192      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0           
00001D8E  B07C 4800               1193      CMP.W  #$4800,D0                ;Compare the appropriate masked bits
00001D92  6700 0196               1194      BEQ    GROUP4_INVALID           ;INVALID OP code
00001D96  6600 0002               1195      BNE    CHECK_OP_SWAP            ;Check next OP code
00001D9A                          1196      
00001D9A                          1197  CHECK_OP_SWAP:                      ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
00001D9A  3038 10A0               1198      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001D9E  0240 FFF8               1199      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001DA2  B07C 4840               1200      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001DA6  6700 0182               1201      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DAA  6600 0002               1202      BNE    CHECK_OP_PEA             ;Check next OP code
00001DAE                          1203   
00001DAE                          1204  CHECK_OP_PEA:                       ;This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
00001DAE  3038 10A0               1205      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DB2  0240 FFC0               1206      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001DB6  B07C 4840               1207      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00001DBA  6700 016E               1208      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DBE  6600 0002               1209      BNE    CHECK_OP_TAS             ;Check next OP code
00001DC2                          1210      
00001DC2                          1211  CHECK_OP_TAS:
00001DC2  3038 10A0               1212      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DC6  0240 FFC0               1213      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00001DCA  B07C 4AC0               1214      CMP.W  #$4AC0,D0                ;Compare the appropriate masked bits
00001DCE  6700 015A               1215      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DD2  6600 0002               1216      BNE    CHECK_OP_TST             ;Check next OP code
00001DD6                          1217  
00001DD6                          1218  CHECK_OP_TST:                       ;This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
00001DD6  3038 10A0               1219      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DDA  0240 FF00               1220      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00001DDE  B07C 4A00               1221      CMP.W  #$4A00,D0                ;Compare the appropriate masked bits
00001DE2  6700 0146               1222      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DE6  6600 0002               1223      BNE    CHECK_OP_TRAP            ;Check next OP code
00001DEA                          1224      
00001DEA                          1225  CHECK_OP_TRAP:
00001DEA  3038 10A0               1226      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001DEE  0240 FFF0               1227      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001DF2  B07C 4E40               1228      CMP.W  #$4E40,D0                ;Compare the appropriate masked bits
00001DF6  6700 0132               1229      BEQ    GROUP4_INVALID           ;INVALID OP code
00001DFA  6600 0002               1230      BNE    CHECK_OP_LINK            ;Check next OP code
00001DFE                          1231      
00001DFE                          1232  CHECK_OP_LINK:
00001DFE  3038 10A0               1233      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E02  0240 FFF8               1234      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001E06  B07C 4E50               1235      CMP.W  #$4E50,D0                ;Compare the appropriate masked bits
00001E0A  6700 011E               1236      BEQ    GROUP4_INVALID           ;INVALID OP code
00001E0E  6600 0002               1237      BNE    CHECK_OP_UNLK            ;Check next OP code
00001E12                          1238  
00001E12                          1239  CHECK_OP_UNLK:
00001E12  3038 10A0               1240      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E16  0240 FFF8               1241      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00001E1A  B07C 4E58               1242      CMP.W  #$4E58,D0                ;Compare the appropriate masked bits
00001E1E  6700 010A               1243      BEQ    GROUP4_INVALID           ;INVALID OP code
00001E22  6600 0002               1244      BNE    CHECK_OP_MOVE_USP        ;Check next OP
00001E26                          1245      
00001E26                          1246  CHECK_OP_MOVE_USP:
00001E26  3038 10A0               1247      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E2A  0240 FFF0               1248      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00001E2E  B07C 4E60               1249      CMP.W  #$4E60,D0                ;Compare the appropriate masked bits
00001E32  6700 00F6               1250      BEQ    GROUP4_INVALID           ;INVALID OP code
00001E36  6600 0002               1251      BNE    CHECK_OP_JMP             ;Check next OP
00001E3A                          1252  
00001E3A                          1253  CHECK_OP_JMP:
00001E3A  3038 10A0               1254       MOVE.W CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E3E  0240 FFC0               1255       ANDI.W #$FFC0,D0               ;Mask relevant bits to D0
00001E42  B07C 4EC0               1256       CMP.W  #$4EC0,D0               ;Compare the appropriate masked bits
00001E46  6700 00E2               1257       BEQ    GROUP4_INVALID          ;INVALID OP code
00001E4A  6600 0002               1258       BNE    CHECK_OP_CHK            ;Check next OP code
00001E4E                          1259       
00001E4E                          1260  CHECK_OP_CHK:
00001E4E  3038 10A0               1261      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00001E52  0240 F1C0               1262      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00001E56  B07C 4180               1263      CMP.W   #$4180,D0               ;Compare the appropriate masked bits
00001E5A  6700 0694               1264      BEQ     INVALID_OP              ;INVALID OP code
00001E5E  6600 0002               1265      BNE     CHECK_OP_NOP            ;Check next OP code
00001E62                          1266  
00001E62                          1267  CHECK_OP_NOP:                       ;While this code is not in the supported docs, Nash covered it in class and expects it to be implemented
00001E62  3038 10A0               1268      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E66  B07C 4E71               1269      CMP.W  #$4E71,D0                ;Compare the appropriate bits
00001E6A  6600 000C               1270      BNE    CHECK_OP_RTS             ;Check next OP code
00001E6E  4EB9 000025B8           1271      JSR    PRINT_OP_NOP             ;Print out OP code
00001E74  6000 00BA               1272      BRA    GROUP4_SUCCESS           ;Finish routine
00001E78                          1273      
00001E78                          1274  CHECK_OP_RTS:
00001E78  3038 10A0               1275      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E7C  B07C 4E75               1276      CMP.W  #$4E75,D0                ;Mask exact bits for RTS    
00001E80  6600 000C               1277      BNE    CHECK_OP_LEA             ;If it's equal check next code
00001E84  4EB9 000025AA           1278      JSR    PRINT_OP_RTS             ;Print out OP code
00001E8A  6000 00A4               1279      BRA    GROUP4_SUCCESS           ;Finish routine
00001E8E                          1280   
00001E8E                          1281  CHECK_OP_LEA:
00001E8E  3038 10A0               1282      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001E92  0240 F1C0               1283      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00001E96  B07C 41C0               1284      CMP.W  #$41C0,D0                ;Compare masked bits
00001E9A  6600 000C               1285      BNE    CHECK_OP_JSR             ;Check next OP code
00001E9E  4EB9 000025C6           1286      JSR    PRINT_OP_LEA             ;Print out OP code
00001EA4  6000 008A               1287      BRA    GROUP4_SUCCESS           ;Finish routine
00001EA8                          1288   
00001EA8                          1289  CHECK_OP_JSR:
00001EA8  3038 10A0               1290      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EAC  0240 FFC0               1291      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00001EB0  B07C 4E80               1292      CMP.W  #$4E80,D0                ;Compare masked bits
00001EB4  6600 000C               1293      BNE    CHECK_OP_NEG             ;Check next OP code
00001EB8  4EB9 0000259C           1294      JSR    PRINT_OP_JSR             ;Print out OP code
00001EBE  6000 0070               1295      BRA    GROUP4_SUCCESS           ;Finish routine
00001EC2                          1296      
00001EC2                          1297  CHECK_OP_NEG:
00001EC2  3038 10A0               1298      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EC6  0240 FF00               1299      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001ECA  B07C 4400               1300      CMP.W  #$4400,D0                ;Compare masked bits
00001ECE  6600 0010               1301      BNE    MOVEM_BIT_SIZE_CHECK     ;Check next OP code
00001ED2  4EB8 18B6               1302      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size field
00001ED6  4EB9 000025DA           1303      JSR    PRINT_OP_NEG             ;Print out OP code
00001EDC  6000 0052               1304      BRA    GROUP4_SUCCESS           ;Finish routine
00001EE0                          1305      
00001EE0                          1306  MOVEM_BIT_SIZE_CHECK:
00001EE0  3038 10A0               1307      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EE4  4EB8 18D6               1308      JSR    FIND_1_BIT_SIZE_6        ;Parse size for bit 6
00001EE8  0C38 0000 1770          1309      CMP.B  #%0,OP_SIZE              ;Check size bit
00001EEE  6700 0006               1310      BEQ    CHECK_OP_MOVEM_W         ;If 0 it's a word
00001EF2  6600 001C               1311      BNE    CHECK_OP_MOVEM_L         ;If 1 it's a long
00001EF6                          1312  
00001EF6                          1313  CHECK_OP_MOVEM_W:
00001EF6  3038 10A0               1314      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001EFA  0240 FB80               1315      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001EFE  B07C 4880               1316      CMP.W  #$4880,D0                ;Compare masked bits
00001F02  6600 0026               1317      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001F06  4EB9 000025EE           1318      JSR    PRINT_OP_MOVEM_W         ;PRINT OP code
00001F0C  6000 0022               1319      BRA    GROUP4_SUCCESS           ;Finish routine
00001F10                          1320      
00001F10                          1321  CHECK_OP_MOVEM_L:
00001F10  3038 10A0               1322      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F14  0240 FB80               1323      ANDI.W #$FB80,D0                ;Mask appropriate bits
00001F18  B07C 4880               1324      CMP.W  #$4880,D0                ;Compare masked bits
00001F1C  6600 000C               1325      BNE    GROUP4_INVALID           ;INVALID OP code is found
00001F20  4EB9 000025FC           1326      JSR    PRINT_OP_MOVEM_L         ;Print OP code
00001F26  6000 0008               1327      BRA    GROUP4_SUCCESS           ;Finish routine    
00001F2A                          1328      
00001F2A                          1329  GROUP4_INVALID:
00001F2A  4EB9 000024F0           1330      JSR INVALID_OP                  ;INVALID op code has been found, set IS_VALID to 0
00001F30                          1331  
00001F30                          1332  GROUP4_SUCCESS:
00001F30  4CDF 0001               1333      MOVEM.L (SP)+,D0                ;Restore saved registers
00001F34  4E75                    1334      RTS                             ;Return to stack
00001F36                          1335  C_GROUP_5:
00001F36  48E7 8000               1336      MOVEM.L D0,-(SP)                ;Save registers to stack
00001F3A                          1337  CHECK_OP_DBcc:                      ;These are ordered first due to checking bits 7-6
00001F3A  3038 10A0               1338      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F3E  0240 F0C8               1339      ANDI.W #$F0C8,D0                ;Mask appropriate bits
00001F42  B07C 50C8               1340      CMP.W  #$50C8,D0                ;Compare appropriate masked bits
00001F46  6700 004C               1341      BEQ    GROUP5_INVALID           ;INVALID op code found
00001F4A  6600 0002               1342      BNE    CHECK_OP_Scc             ;Check next OP code
00001F4E                          1343  
00001F4E                          1344  CHECK_OP_Scc:
00001F4E  3038 10A0               1345      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F52  0240 F0C0               1346      ANDI.W #$F0C0,D0                ;Mask appropriate bits
00001F56  B07C 50C0               1347      CMP.W  #$50C0,D0                ;Compare appropriate masked bits
00001F5A  6700 0038               1348      BEQ     GROUP5_INVALID          ;INVALID OP code found
00001F5E  6600 0002               1349      BNE     CHECK_OP_ADDQ           ;Check next OP code
00001F62                          1350  
00001F62                          1351  CHECK_OP_ADDQ:
00001F62  3038 10A0               1352      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001F66  0240 F100               1353      ANDI.W #$F100,D0                ;Mask appropriate bits
00001F6A  B07C 5000               1354      CMP.W  #$5000,D0                ;Compare appropriate masked bits
00001F6E  6700 0024               1355      BEQ    GROUP5_INVALID           ;INVALID OP code found
00001F72  6600 0002               1356      BNE    CHECK_OP_SUBQ            ;Check next OP code
00001F76                          1357  
00001F76                          1358  CHECK_OP_SUBQ     
00001F76  3038 10A0               1359      MOVE.W  CUR_OP_CODE,D0          ;Actual check for SUBQ
00001F7A  0240 F100               1360      ANDI.W #$F100,D0                ;Bitmask check for SUBQ
00001F7E  B07C 5100               1361      CMP.W  #$5100,D0                ;Compare the proper value
00001F82  6600 0010               1362      BNE    GROUP5_INVALID           ;Else the operand is invalid
00001F86  4EB8 18B6               1363      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Find size bit to print
00001F8A  4EB9 0000260A           1364      JSR    PRINT_OP_SUBQ            ;If equal print it out
00001F90  6000 0008               1365      BRA    GROUP5_SUCCESS           ;Finish routine
00001F94                          1366      
00001F94                          1367  GROUP5_INVALID: 
00001F94  4EB9 000024F0           1368      JSR INVALID_OP                  ;INVALID OP has been found, set IS_VALID to 0
00001F9A                          1369  GROUP5_SUCCESS:
00001F9A  4CDF 0001               1370      MOVEM.L (SP)+,D0                ;Restore registers from stack
00001F9E  4E75                    1371      RTS                             ;Return to stack
00001FA0                          1372      
00001FA0                          1373  C_GROUP_6:
00001FA0  48E7 8000               1374      MOVEM.L D0,-(SP)            ;Save register to stack
00001FA4                          1375  CHECK_OP_BSR:
00001FA4  3038 10A0               1376      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
00001FA8  0240 FF00               1377      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00001FAC  B07C 6100               1378      CMP.W   #$6100,D0               ;Compare masked bits
00001FB0  6700 0128               1379      BEQ     GROUP6_INVALID          ;INVALID OP code found
00001FB4  6600 0002               1380      BNE     CHECK_OP_BGT            ;Check next OP code
00001FB8                          1381      
00001FB8                          1382  CHECK_OP_BGT:
00001FB8  3038 10A0               1383      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FBC  0240 FF00               1384      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FC0  B07C 6E00               1385      CMP.W  #$6E00,D0                ;Compare masked bits
00001FC4  6700 0114               1386      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FC8  6600 0002               1387      BNE    CHECK_OP_BCC             ;Check next OP code
00001FCC                          1388  
00001FCC                          1389  CHECK_OP_BCC:
00001FCC  3038 10A0               1390      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FD0  0240 FF00               1391      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FD4  B07C 6400               1392      CMP.W  #$6400,D0                ;Compare masked bits
00001FD8  6700 0100               1393      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FDC  6600 0002               1394      BNE    CHECK_OP_BEQ             ;Check next OP code 
00001FE0                          1395  
00001FE0                          1396  CHECK_OP_BEQ:
00001FE0  3038 10A0               1397      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FE4  0240 FF00               1398      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FE8  B07C 6700               1399      CMP.W  #$6700,D0                ;Compare masked bits
00001FEC  6700 00EC               1400      BEQ    GROUP6_INVALID           ;INVALID OP code found
00001FF0  6600 0002               1401      BNE    CHECK_OP_BHI             ;Check next OP code
00001FF4                          1402  
00001FF4                          1403  CHECK_OP_BHI:
00001FF4  3038 10A0               1404      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00001FF8  0240 FF00               1405      ANDI.W #$FF00,D0                ;Mask appropriate bits
00001FFC  B07C 6200               1406      CMP.W  #$6200,D0                ;Compare masked bits
00002000  6700 00D8               1407      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002004  6600 0002               1408      BNE    CHECK_OP_BLS             ;Check next OP code
00002008                          1409  
00002008                          1410  CHECK_OP_BLS:
00002008  3038 10A0               1411      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
0000200C  0240 FF00               1412      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002010  B07C 6300               1413      CMP.W  #$6300,D0                ;Compare masked bits
00002014  6700 00C4               1414      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002018  6600 0002               1415      BNE    CHECK_OP_BMI             ;Check next OP code
0000201C                          1416  
0000201C                          1417  CHECK_OP_BMI:
0000201C  3038 10A0               1418      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002020  0240 FF00               1419      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002024  B07C 6B00               1420      CMP.W  #$6B00,D0                ;Compare masked bits
00002028  6700 00B0               1421      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000202C  6600 0002               1422      BNE    CHECK_OP_BNE             ;Check next OP code
00002030                          1423  
00002030                          1424  CHECK_OP_BNE:
00002030  3038 10A0               1425      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002034  0240 FF00               1426      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002038  B07C 6600               1427      CMP.W  #$6600,D0                ;Compare masked bits
0000203C  6700 009C               1428      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002040  6600 0002               1429      BNE    CHECK_OP_BPL             ;Check next OP code    
00002044                          1430  
00002044                          1431  CHECK_OP_BPL:
00002044  3038 10A0               1432      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002048  0240 FF00               1433      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000204C  B07C 6A00               1434      CMP.W  #$6A00,D0                ;Compare masked bits
00002050  6700 0088               1435      BEQ    GROUP6_INVALID           ;INVALID OP code found
00002054  6600 0002               1436      BNE    CHECK_OP_BRA             ;Check next OP code 
00002058                          1437  
00002058                          1438  
00002058                          1439  CHECK_OP_BRA:
00002058  3038 10A0               1440      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0       
0000205C  0240 FF00               1441      ANDI.W  #$FF00,D0               ;Mask appropriate bits
00002060  B07C 6000               1442      CMP.W   #$6000,D0               ;Compare masked bits
00002064  6600 000C               1443      BNE     CHECK_OP_BCS            ;Check next OP code
00002068  4EB9 0000266E           1444      JSR     PRINT_OP_BRA            ;Print out OP code
0000206E  6000 0070               1445      BRA     GROUP6_SUCCESS          ;Finish routine
00002072                          1446      
00002072                          1447  CHECK_OP_BCS:
00002072  3038 10A0               1448      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002076  0240 FF00               1449      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000207A  B07C 6500               1450      CMP.W  #$6500,D0                ;Compare masked bits
0000207E  6600 000C               1451      BNE    CHECK_OP_BGE             ;Check next OP code
00002082  4EB9 0000261E           1452      JSR    PRINT_OP_BCS             ;Print out OP code
00002088  6000 0056               1453      BRA    GROUP6_SUCCESS           ;Finish routine
0000208C                          1454  
0000208C                          1455      
0000208C                          1456  CHECK_OP_BGE:
0000208C  3038 10A0               1457      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
00002090  0240 FF00               1458      ANDI.W #$FF00,D0                ;Mask appropriate bits
00002094  B07C 6C00               1459      CMP.W  #$6C00,D0                ;Compare masked bits
00002098  6600 000C               1460      BNE    CHECK_OP_BLT             ;Check next OP code
0000209C  4EB9 00002632           1461      JSR    PRINT_OP_BGE             ;Print out OP code
000020A2  6000 003C               1462      BRA    GROUP6_SUCCESS           ;Finish routine
000020A6                          1463      
000020A6                          1464      
000020A6                          1465  CHECK_OP_BLT:
000020A6  3038 10A0               1466      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000020AA  0240 FF00               1467      ANDI.W #$FF00,D0                ;Mask appropriate bits
000020AE  B07C 6D00               1468      CMP.W  #$6D00,D0                ;Compare masked bits
000020B2  6600 000C               1469      BNE    CHECK_OP_BVC             ;Check next OP code
000020B6  4EB9 00002646           1470      JSR    PRINT_OP_BLT             ;Print out OP code
000020BC  6000 0022               1471      BRA    GROUP6_SUCCESS           ;Finish routine
000020C0                          1472      
000020C0                          1473  CHECK_OP_BVC:
000020C0  3038 10A0               1474      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000020C4  0240 FF00               1475      ANDI.W #$FF00,D0                ;Mask appropriate bits
000020C8  B07C 6800               1476      CMP.W  #$6800,D0                ;Compare masked bits
000020CC  6600 000C               1477      BNE    GROUP6_INVALID           ;Check next OP code
000020D0  4EB9 0000265A           1478      JSR    PRINT_OP_BVC             ;Print out OP code
000020D6  6000 0008               1479      BRA    GROUP6_SUCCESS           ;Finish routine
000020DA                          1480      
000020DA                          1481  GROUP6_INVALID:
000020DA  4EB9 000024F0           1482      JSR    INVALID_OP               ;INVALID OP code found, set IS_VALID to 0
000020E0                          1483  GROUP6_SUCCESS:
000020E0  4CDF 0001               1484      MOVEM.L (SP)+,D0                ;Restore registers from stack
000020E4  4E75                    1485      RTS                             ;Return from stack
000020E6                          1486      
000020E6                          1487  C_GROUP_7:
000020E6  48E7 8000               1488      MOVEM.L D0,-(SP)                ;Save register to stack
000020EA                          1489  CHECK_OP_MOVEQ
000020EA  3038 10A0               1490      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set to D0
000020EE  0240 F100               1491      ANDI.W  #$F100,D0               ;Mask appropriate bits
000020F2  B07C 7000               1492      CMP.W   #$7000,D0               ;Compare masked bits
000020F6  6000 0002               1493      BRA     GROUP7_INVALID          ;INVALID OP code found
000020FA                          1494  
000020FA                          1495  GROUP7_INVALID:
000020FA  4EB9 000024F0           1496      JSR     INVALID_OP              ;INVALID OP code found, set IS_VALID to 0
00002100                          1497  GROUP7_SUCCESS:    
00002100  4CDF 0001               1498      MOVEM.L (SP)+,D0                ;Restore registers from stack
00002104  4E75                    1499      RTS                             ;Return from stack
00002106                          1500  C_GROUP_8:
00002106  48E7 8000               1501      MOVEM.L D0,-(SP)
0000210A                          1502  CHECK_OP_DIVU:
0000210A  3038 10A0               1503      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000210E  0240 F1C0               1504      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002112  B07C 80C0               1505      CMP.W   #$80C0,D0               ;Compare masked bits
00002116  6700 0042               1506      BEQ     GROUP8_INVALID          ;INVALID OP code found
0000211A  6600 0002               1507      BNE     CHECK_OP_SBCD           ;Check next OP code
0000211E                          1508  
0000211E                          1509  CHECK_OP_SBCD:
0000211E  3038 10A0               1510      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002122  0240 F1F0               1511      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
00002126  B07C 8100               1512      CMP.W   #$8100,D0               ;Compare masked bits
0000212A  6700 002E               1513      BEQ     GROUP8_INVALID          ;INVALID OP code found
0000212E  6600 0002               1514      BNE     CHECK_OP_DIVS           ;Check next OP code
00002132                          1515      
00002132                          1516  CHECK_OP_DIVS:
00002132  3038 10A0               1517      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002136  0240 F1C0               1518      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
0000213A  B07C 81C0               1519      CMP.W   #$81C0,D0               ;Compare masked bits
0000213E  6600 000C               1520      BNE     CHECK_OP_OR             ;Check next OP code
00002142  4EB9 00002682           1521      JSR     PRINT_OP_DIVS           ;OP Code found
00002148  6000 0016               1522      BRA     GROUP8_SUCCESS          ;Finish routine
0000214C                          1523      
0000214C                          1524  CHECK_OP_OR:                        ;At this point only remaining $8 code is OR
0000214C  4EB8 18B6               1525      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Finding size bit to print out
00002150  4EB9 00002690           1526      JSR     PRINT_OP_OR             ;Print out OR
00002156  6000 0008               1527      BRA     GROUP8_SUCCESS          ;Finish routine
0000215A                          1528  GROUP8_INVALID:
0000215A  4EB9 000024F0           1529       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
00002160                          1530  GROUP8_SUCCESS:
00002160  4CDF 0001               1531       MOVEM.L (SP)+,D0               ;Restore register from stack
00002164  4E75                    1532       RTS                            ;Return to stack
00002166                          1533       
00002166                          1534  C_GROUP_9:
00002166  48E7 C000               1535      MOVEM.L D0-D1,-(SP)             ;Save the registers
0000216A                          1536  CHECK_SIZE_BIT_FOR_SUB:
0000216A  4EB8 18B6               1537      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bits in 7-6
0000216E  0C38 0003 1770          1538      CMP.B   #%11,OP_SIZE            ;If the bits are %11, it has to be SUBA
00002174  6700 0006               1539      BEQ     CHECK_OP_SUBA           ;If the bits equal it must be SUBA
00002178  6600 0016               1540      BNE     CHECK_OP_SUBX           ;If the bits are not equal it could be SUBX
0000217C                          1541      
0000217C                          1542  CHECK_OP_SUBA:                      ;Check SUBA first as it has static bits
0000217C  3038 10A0               1543      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002180  0240 F0C0               1544      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
00002184  B07C 90C0               1545      CMP.W   #$90C0,D0               ;Compare masked bits
00002188  6700 0042               1546      BEQ     GROUP9_INVALID          ;INVALID OP has been found
0000218C  6600 0002               1547      BNE     CHECK_OP_SUBX           ;Check next OP
00002190                          1548  
00002190                          1549  CHECK_OP_SUBX:
00002190  3038 10A0               1550      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002194  0240 F130               1551      ANDI.W  #$F130,D0               ;Mask appropriate bits
00002198  B07C 9100               1552      CMP.W   #$9100,D0               ;Compare masked bits
0000219C  6000 0002               1553      BRA     BIT_CHECK_SUBX          ;Checking if this code is SUBX through bit shifts
000021A0                          1554      
000021A0                          1555  BIT_CHECK_SUBX:    
000021A0  3038 10A0               1556      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021A4  323C 0007               1557      MOVE.W  #7,D1                   ;Prepare a shift of 7 bits into D1
000021A8  E368                    1558      LSL.W   D1,D0                   ;Shift left 7 bits truncate 15-9 bits
000021AA  E268                    1559      LSR.W   D1,D0                   ;Reposition D0
000021AC  E848                    1560      LSR.W   #4,D0                   ;Truncate 4 right most bits to
000021AE  0240 FF13               1561      ANDI.W  #$FF13,D0               ;Compare remaining static bits
000021B2  B07C 0010               1562      CMP.W   #$0010,D0               ;If equal to this value it's SUBX
000021B6  6700 0014               1563      BEQ     GROUP9_INVALID          ;INVALID OP code found
000021BA  6600 0002               1564      BNE     CHECK_OP_SUB            ;Not can only be SUB here
000021BE                          1565      
000021BE                          1566  CHECK_OP_SUB:                       ;At this point only remaining $9 is SUB
000021BE  4EB8 18B6               1567      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find the size bit to print out
000021C2  4EB9 000026A4           1568      JSR     PRINT_OP_SUB            ;Print out SUB
000021C8  6000 0008               1569      BRA     GROUP9_SUCCESS          ;Finish routine
000021CC                          1570      
000021CC                          1571  GROUP9_INVALID:
000021CC  4EB9 000024F0           1572       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID to 0
000021D2                          1573  GROUP9_SUCCESS: 
000021D2  4CDF 0003               1574      MOVEM.L (SP)+,D0-D1             ;Restore registers
000021D6  4E75                    1575      RTS                             ;Return to stack
000021D8                          1576  
000021D8                          1577  C_GROUP_A:
000021D8  4EB9 000024F0           1578      JSR INVALID_OP                  ;INVALID OP code found, set IS_VALID to 0
000021DE  4E75                    1579      RTS                             ;Return to stack
000021E0                          1580      
000021E0                          1581  C_GROUP_B:
000021E0  48E7 8000               1582      MOVEM.L D0,-(SP)                ;Save current registers to stack
000021E4                          1583  CHECK_OP_CMPM
000021E4  3038 10A0               1584      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021E8  0240 F138               1585      ANDI.W  #$F138,D0               ;Mask appropriate bits
000021EC  B07C B108               1586      CMP.W   #$B108,D0               ;Compare masked bits
000021F0  6700 0056               1587      BEQ     GROUPB_INVALID          ;INVALID OP found
000021F4  6600 0002               1588      BNE     CHECK_OP_CMPA           ;Check next OP
000021F8                          1589      
000021F8                          1590  CHECK_OP_CMPA:
000021F8  3038 10A0               1591      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000021FC  0240 F0C0               1592      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
00002200  B07C B0C0               1593      CMP.W   #$B0C0,D0               ;Compare masked bits
00002204  6700 0042               1594      BEQ     GROUPB_INVALID          ;INVALID OP found
00002208  6600 0002               1595      BNE     CHECK_OP_EOR            ;Check next OP
0000220C                          1596  
0000220C                          1597  CHECK_OP_EOR:
0000220C  3038 10A0               1598      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002210  0240 F100               1599      ANDI.W  #$F100,D0               ;Mask appropriate bits
00002214  B07C B100               1600      CMP.W   #$B100,D0               ;Compare masked bits
00002218  6600 0010               1601      BNE     CHECK_OP_CMP            ;Check next OP 
0000221C  4EB8 18B6               1602      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
00002220  4EB9 000026B8           1603      JSR     PRINT_OP_EOR            ;Print out OP code
00002226  6000 0026               1604      BRA     GROUPB_SUCCESS          ;Finish routine
0000222A                          1605      
0000222A                          1606  CHECK_OP_CMP:
0000222A  3038 10A0               1607      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000222E  0240 F100               1608      ANDI.W  #$F100,D0               ;Mask appropriate bits
00002232  B07C B000               1609      CMP.W   #$B000,D0               ;Compare masked bits
00002236  6600 0010               1610      BNE     GROUPB_INVALID          ;INVALID OP code found
0000223A  4EB8 18B6               1611      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Find size bit field to print out size
0000223E  4EB9 000026CC           1612      JSR     PRINT_OP_CMP            ;Print out OP code
00002244  6000 0008               1613      BRA     GROUPB_SUCCESS          ;Finish routine
00002248                          1614      
00002248                          1615  GROUPB_INVALID:
00002248  4EB9 000024F0           1616      JSR     INVALID_OP              ;INVALID OP has been found, set IS_VALID to 0
0000224E                          1617  GROUPB_SUCCESS:
0000224E  4CDF 0001               1618      MOVEM.L (SP)+,D0                ;Restore registers from stack
00002252  4E75                    1619      RTS                             ;Return to stack
00002254                          1620  C_GROUP_C:
00002254  48E7 C000               1621      MOVEM.L D0-D1,-(SP)
00002258                          1622      
00002258                          1623  CHECK_OP_MULU:
00002258  3038 10A0               1624      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
0000225C  0240 F1C0               1625      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
00002260  B07C C0C0               1626      CMP.W   #$C0C0,D0               ;Compare masked bits
00002264  6700 0066               1627      BEQ     GROUPC_INVALID          ;INVALID OP code found
00002268  6600 0002               1628      BNE     CHECK_OP_ABCD           ;Check next OP code
0000226C                          1629   
0000226C                          1630  CHECK_OP_ABCD:
0000226C  3038 10A0               1631      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002270  0240 F1F0               1632      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
00002274  B07C C100               1633      CMP.W   #$C100,D0               ;Compare masked bits
00002278  6700 0052               1634      BEQ     GROUPC_INVALID          ;INVALID OP code found
0000227C  6600 0002               1635      BNE     CHECK_OP_EXG            ;Check next OP code
00002280                          1636   
00002280                          1637  CHECK_OP_EXG:
00002280  6000 0002               1638      BRA     BIT_CHECK_EXG           ;Always do bit check here
00002284                          1639                          
00002284                          1640  BIT_CHECK_EXG:                      ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
00002284  3038 10A0               1641      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
00002288  323C 0007               1642      MOVE.W  #7,D1                   ;Prepare a bit shift of 7 into D1
0000228C  E368                    1643      LSL.W   D1,D0                   ;Shift D0 to 7 bits
0000228E  E268                    1644      LSR.W   D1,D0                   ;Reposition D0
00002290  E848                    1645      LSR.W   #4,D0                   ;Shift D0 4 bits right
00002292  0240 FF83               1646      ANDI.W  #$FF83,D0               ;Mask appropriate bits
00002296  B07C 0010               1647      CMP.W   #$0010,D0               ;Bit mask static EXG bits
0000229A  6700 0030               1648      BEQ     GROUPC_INVALID          ;If this equals, then OP must be EXG
0000229E  6600 0002               1649      BNE     CHECK_OP_MULS           ;Otherwise it's MULS
000022A2                          1650  CHECK_OP_MULS:
000022A2  3038 10A0               1651      MOVE.W CUR_OP_CODE,D0           ;Move current instruction set into D0
000022A6  0240 F1C0               1652      ANDI.W #$F1C0,D0                ;Mask appropriate bits
000022AA  B07C C1C0               1653      CMP.W  #$C1C0,D0                ;Compare masked bits
000022AE  6600 000C               1654      BNE    CHECK_OP_AND             ;OP_AND is completely dynamic outside of first nibble
000022B2  4EB9 000026E0           1655      JSR    PRINT_OP_MULS            ;Print OP code
000022B8  6000 0018               1656      BRA    GROUPC_SUCCESS           ;Finish routine
000022BC                          1657      
000022BC                          1658  CHECK_OP_AND:                       ;This would be the only possible OP code left after CHECK_OP_MULS
000022BC  3038 10A0               1659      MOVE.W  CUR_OP_CODE,D0          ;Move current instruction set into D0
000022C0  0240 F000               1660      ANDI.W  #$F000,D0               ;Mask appropriate bits
000022C4  B07C C000               1661      CMP.W   #$C000,D0               ;Compare masked bits
000022C8  6000 0002               1662      BRA    GROUPC_INVALID           ;INVALID OP code found
000022CC                          1663      
000022CC                          1664  GROUPC_INVALID:
000022CC  4EB9 000024F0           1665      JSR     INVALID_OP              ;Set IS_VALID to 0
000022D2                          1666      
000022D2                          1667  GROUPC_SUCCESS:
000022D2  4CDF 0003               1668      MOVEM.L (SP)+,D0-D1             ;Restore registers from stack
000022D6  4E75                    1669      RTS                             ;Return to stack
000022D8                          1670      
000022D8                          1671  C_GROUP_D:
000022D8  48E7 8000               1672      MOVEM.L D0,-(SP)                ;Save registers to stack
000022DC                          1673  BIT_SIZE_CHECK
000022DC  3038 10A0               1674      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
000022E0  4EB8 18B6               1675      JSR     FIND_2_BIT_SIZE_7_TO_6  ;Specific size bit checking to see if it's 11
000022E4  0C38 0003 1770          1676      CMP.B   #%11,OP_SIZE            ;If it's %11 it cannot be ADDX and is either ADDA or ADD
000022EA  6700 0024               1677      BEQ     CHECK_OP_ADDA           ;If it's equal check ADDA
000022EE  6600 0002               1678      BNE     CHECK_OP_ADDX           ;If it's not equal check ADDX
000022F2                          1679      
000022F2                          1680  CHECK_OP_ADDX:
000022F2  3038 10A0               1681      MOVE    CUR_OP_CODE,D0
000022F6  0240 F130               1682      ANDI.W #$F130,D0                ;Mask appropriate bits
000022FA  B07C D100               1683      CMP.W  #$D100,D0                ;Compare masked bits
000022FE  6700 002C               1684      BEQ    GROUPD_INVALID           ;INVALID OP code found
00002302  6600 0002               1685      BNE    CHECK_OP_ADD             ;Check next OP code
00002306                          1686      
00002306                          1687  CHECK_OP_ADD:
00002306  4EB9 000026EE           1688      JSR PRINT_OP_ADD                ;Only remaining OP in $D is ADD at this point
0000230C  6000 0024               1689      BRA GROUPD_SUCCESS              ;Finish routine
00002310                          1690  
00002310                          1691  CHECK_OP_ADDA:
00002310  3038 10A0               1692      MOVE    CUR_OP_CODE,D0          ;Move current instruction set into D0
00002314  0240 F0C0               1693      ANDI.W #$F0C0,D0                ;Mask applicable bits
00002318  B07C D0C0               1694      CMP.W  #$D0C0,D0                ;Compare masked bits
0000231C  66E8                    1695      BNE    CHECK_OP_ADD             ;Check next OP code
0000231E  4EB8 18F6               1696      JSR    FIND_1_BIT_SIZE_8        ;Size bit to print
00002322  4EB9 00002702           1697      JSR    PRINT_OP_ADDA            ;Print out OP code
00002328  6000 0008               1698      BRA    GROUPD_SUCCESS           ;Finish routine
0000232C                          1699      
0000232C                          1700  GROUPD_INVALID:
0000232C  4EB9 000024F0           1701      JSR INVALID_OP                  ;INVALID OP code found
00002332                          1702  GROUPD_SUCCESS:
00002332  4CDF 0001               1703      MOVEM.L (SP)+,D0                ;Restore registers from stack
00002336  4E75                    1704      RTS                             ;Return to stack
00002338                          1705      
00002338                          1706  C_GROUP_E:
00002338  48E7 8000               1707      MOVEM.L D0,-(SP)
0000233C                          1708  CHECK_OP_ROXR_NO_ROT:
0000233C  3038 10A0               1709      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002340  0240 FFC0               1710      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002344  B07C E4C0               1711      CMP.W  #$E4C0,D0                ;Compare masked bits
00002348  6700 0192               1712      BEQ    GROUPE_INVALID           ;INVALID OP code
0000234C  6600 0002               1713      BNE    CHECK_OP_ROXL_NO_ROT     ;Check next OP code
00002350                          1714  
00002350                          1715  CHECK_OP_ROXL_NO_ROT:
00002350  3038 10A0               1716      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002354  0240 FFC0               1717      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002358  B07C E5C0               1718      CMP.W  #$E5C0,D0                ;Compare masked bits
0000235C  6700 017E               1719      BEQ    GROUPE_INVALID           ;INVALID OP code
00002360  6600 0002               1720      BNE    CHECK_OP_ROR_NO_ROT      ;Check next OP code
00002364                          1721  
00002364                          1722  CHECK_OP_ROR_NO_ROT:
00002364  3038 10A0               1723      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002368  0240 FFC0               1724      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000236C  B07C E6C0               1725      CMP.W  #$E6C0,D0                ;Compare masked bits
00002370  6600 000C               1726      BNE    CHECK_OP_ROL_NO_ROT      ;Check next OP code
00002374  4EB9 0000277A           1727      JSR    PRINT_OP_ROR             ;Print out OP code
0000237A  6000 0166               1728      BRA    GROUPE_SUCCESS           ;Finish routine
0000237E                          1729      
0000237E                          1730  CHECK_OP_ROL_NO_ROT:
0000237E  3038 10A0               1731      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002382  0240 FFC0               1732      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00002386  B07C E7C0               1733      CMP.W  #$E7C0,D0                ;Compare masked bits
0000238A  6600 000C               1734      BNE    CHECK_OP_LSR_NO_ROT      ;Check next OP code
0000238E  4EB9 00002766           1735      JSR    PRINT_OP_ROL             ;Print out OP code
00002394  6000 014C               1736      BRA    GROUPE_SUCCESS           ;Finish routine
00002398                          1737   
00002398                          1738  CHECK_OP_LSR_NO_ROT:
00002398  3038 10A0               1739      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000239C  0240 FFC0               1740      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023A0  B07C E2C0               1741      CMP.W  #$E2C0,D0                ;Compare masked bits
000023A4  6600 000C               1742      BNE    CHECK_OP_LSL_NO_ROT      ;Check next OP code
000023A8  4EB9 0000272A           1743      JSR    PRINT_OP_LSR             ;Print out OP code
000023AE  6000 0132               1744      BRA    GROUPE_SUCCESS           ;Finish routine
000023B2                          1745  
000023B2                          1746  CHECK_OP_LSL_NO_ROT:
000023B2  3038 10A0               1747      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023B6  0240 FFC0               1748      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023BA  B07C E3C0               1749      CMP.W  #$E3C0,D0                ;Compare masked bits
000023BE  6600 000C               1750      BNE    CHECK_OP_ASR_NO_ROT      ;Check next OP code
000023C2  4EB9 00002716           1751      JSR    PRINT_OP_LSL             ;Print out OP code
000023C8  6000 0118               1752      BRA    GROUPE_SUCCESS           ;Finish routine
000023CC                          1753  
000023CC                          1754  CHECK_OP_ASR_NO_ROT:
000023CC  3038 10A0               1755      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023D0  0240 FFC0               1756      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023D4  B07C E0C0               1757      CMP.W  #$E0C0,D0                ;Compare masked bits
000023D8  6600 000C               1758      BNE    CHECK_OP_ASL_NO_ROT      ;Check next OP code
000023DC  4EB9 0000273E           1759      JSR    PRINT_OP_ASR             ;Print out OP code
000023E2  6000 00FE               1760      BRA    GROUPE_SUCCESS           ;Finish routine
000023E6                          1761              
000023E6                          1762  CHECK_OP_ASL_NO_ROT:
000023E6  3038 10A0               1763      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000023EA  0240 FFC0               1764      ANDI.W #$FFC0,D0                ;Mask appropriate bits
000023EE  B07C E1C0               1765      CMP.W  #$E1C0,D0                ;Compare masked bits
000023F2  6600 000C               1766      BNE    CHECK_OP_ROXR            ;Check next OP code
000023F6  4EB9 00002752           1767      JSR    PRINT_OP_ASL             Print out OP code
000023FC  6000 00E4               1768      BRA    GROUPE_SUCCESS           ;Finish routine
00002400                          1769  
00002400                          1770  CHECK_OP_ROXR:
00002400  3038 10A0               1771      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002404  0240 F118               1772      ANDI.W #$F118,D0                ;Mask appropriate bits
00002408  B07C E010               1773      CMP.W  #$E010,D0                ;Compare masked bits
0000240C  6700 00CE               1774      BEQ    GROUPE_INVALID           ;INVALID OP code found
00002410  6600 0002               1775      BNE    CHECK_OP_ROXL            ;Check next OP code
00002414                          1776      
00002414                          1777  CHECK_OP_ROXL:
00002414  3038 10A0               1778      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002418  0240 F118               1779      ANDI.W #$F118,D0                ;Mask appropriate bits
0000241C  B07C E110               1780      CMP.W  #$E110,D0                ;Compare masked bits
00002420  6700 00BA               1781      BEQ    GROUPE_INVALID           ;INVALID OP code found
00002424  6600 0002               1782      BNE    CHECK_OP_ROR             ;Check next OP code
00002428                          1783      
00002428                          1784  CHECK_OP_ROR:
00002428  3038 10A0               1785      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000242C  0240 F118               1786      ANDI.W #$F118,D0                ;Mask appropriate bits
00002430  B07C E018               1787      CMP.W  #$E018,D0                ;Compare masked bits
00002434  6600 0010               1788      BNE    CHECK_OP_ROL             ;Check next OP code
00002438  4EB8 18B6               1789      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size bits
0000243C  4EB9 0000277A           1790      JSR    PRINT_OP_ROR             ;Print out OP code
00002442  6000 009E               1791      BRA    GROUPE_SUCCESS           ;Finish routine
00002446                          1792  
00002446                          1793  CHECK_OP_ROL:
00002446  3038 10A0               1794      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
0000244A  0240 F118               1795      ANDI.W #$F118,D0                ;Mask appropriate bits
0000244E  B07C E118               1796      CMP.W  #$E118,D0                ;Compare masked bits
00002452  6600 0010               1797      BNE    CHECK_OP_LSR             ;Check next OP code
00002456  4EB8 18B6               1798      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
0000245A  4EB9 00002766           1799      JSR    PRINT_OP_ROL             ;Print out OP code
00002460  6000 0080               1800      BRA    GROUPE_SUCCESS           ;Finish routine
00002464                          1801      
00002464                          1802  CHECK_OP_LSR:
00002464  3038 10A0               1803      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002468  0240 F118               1804      ANDI.W #$F118,D0                ;Mask appropriate bits
0000246C  B07C E008               1805      CMP.W  #$E008,D0                ;Compare masked bits
00002470  6600 0010               1806      BNE    CHECK_OP_LSL             ;Check next OP code
00002474  4EB8 18B6               1807      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002478  4EB9 0000272A           1808      JSR    PRINT_OP_LSR             ;Print out OP code
0000247E  6000 0062               1809      BRA    GROUPE_SUCCESS           ;Finish routine
00002482                          1810  
00002482                          1811  CHECK_OP_LSL:
00002482  3038 10A0               1812      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
00002486  0240 F118               1813      ANDI.W #$F118,D0                ;Mask appropriate bits
0000248A  B07C E108               1814      CMP.W  #$E108,D0                ;Compare masked bits
0000248E  6600 0010               1815      BNE    CHECK_OP_ASR             ;Check next OP code
00002492  4EB8 18B6               1816      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
00002496  4EB9 00002716           1817      JSR    PRINT_OP_LSL             ;Print out OP code
0000249C  6000 0044               1818      BRA    GROUPE_SUCCESS           ;Finish routine
000024A0                          1819  
000024A0                          1820  CHECK_OP_ASR:
000024A0  3038 10A0               1821      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000024A4  0240 F118               1822      ANDI.W #$F118,D0                ;Mask appropriate bits
000024A8  B07C E000               1823      CMP.W  #$E000,D0                ;Compare masked bits
000024AC  6600 0010               1824      BNE    CHECK_OP_ASL             ;Check next OP code
000024B0  4EB8 18B6               1825      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
000024B4  4EB9 0000273E           1826      JSR    PRINT_OP_ASR             ;Print out OP code
000024BA  6000 0026               1827      BRA    GROUPE_SUCCESS           ;Finish routine
000024BE                          1828  
000024BE                          1829  CHECK_OP_ASL:
000024BE  3038 10A0               1830      MOVE CUR_OP_CODE,D0             ;Move current instruction set into D0
000024C2  0240 F118               1831      ANDI.W #$F118,D0                ;Mask appropriate bits
000024C6  B07C E100               1832      CMP.W  #$E100,D0                ;Compare masked bits
000024CA  6600 0010               1833      BNE    GROUPE_INVALID           ;Last possible OP code
000024CE  4EB8 18B6               1834      JSR    FIND_2_BIT_SIZE_7_TO_6   ;Parse size field
000024D2  4EB9 00002752           1835      JSR    PRINT_OP_ASL             ;Print out OP code
000024D8  6000 0008               1836      BRA    GROUPE_SUCCESS           ;Finish routine
000024DC                          1837  
000024DC                          1838  GROUPE_INVALID:
000024DC  4EB9 000024F0           1839      JSR     INVALID_OP              ;Set IS_VALID to 0
000024E2                          1840  GROUPE_SUCCESS:
000024E2  4CDF 0001               1841      MOVEM.L (SP)+,D0                ;Restore registers from stack
000024E6  4E75                    1842      RTS                             ;Return to stack
000024E8                          1843  C_GROUP_F:
000024E8  4EB9 000024F0           1844      JSR     INVALID_OP              ;Set IS_VALID to 0
000024EE  4E75                    1845      RTS                             ;Return to stack
000024F0                          1846      
000024F0                          1847  INVALID_OP:                         ; ONLY SETS IS_VALID TO 0
000024F0  11FC 0000 10A2          1848      MOVE.B #0,IS_VALID              ;Sets IS_VALID to 0
000024F6  4E75                    1849      RTS                             ;Return to stack
000024F8                          1850  
000024F8                          1851  
000024F8                          1852  PRINT_TO_BUFFER:
000024F8  21FC 00001000 128E      1853      MOVE.L #G_BUFFER, BUFFER_POINTER
00002500  4EB8 1298               1854      JSR AddStrToBuffer
00002504  4E75                    1855      RTS
00002506                          1856      
00002506                          1857  PRINT_OP_ORI:
00002506  21FC 000027F4 128A      1858      MOVE.L #P_OP_ORI, STRING_BUFFER_POINTER
0000250E  4EB8 24F8               1859      JSR PRINT_TO_BUFFER
00002512  4EB9 000027B8           1860      JSR PRINT_OP_SIZE
00002518  4E75                    1861      RTS
0000251A                          1862  PRINT_OP_CMPI:
0000251A  21FC 000027FB 128A      1863      MOVE.L #P_OP_CMPI, STRING_BUFFER_POINTER
00002522  4EB8 24F8               1864      JSR PRINT_TO_BUFFER
00002526  4EB9 000027B8           1865      JSR PRINT_OP_SIZE
0000252C  4E75                    1866      RTS
0000252E                          1867  PRINT_OP_STATIC_BCLR:
0000252E  21FC 00002803 128A      1868      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
00002536  4EB8 24F8               1869      JSR PRINT_TO_BUFFER
0000253A  4EB9 000027B8           1870      JSR PRINT_OP_SIZE
00002540  4E75                    1871      RTS
00002542                          1872      
00002542                          1873  PRINT_OP_DYNAMIC_BCLR:
00002542  21FC 00002803 128A      1874      MOVE.L #P_OP_BCLR, STRING_BUFFER_POINTER
0000254A  4EB8 24F8               1875      JSR PRINT_TO_BUFFER
0000254E  4EB9 000027B8           1876      JSR PRINT_OP_SIZE
00002554  4E75                    1877      RTS
00002556                          1878  
00002556                          1879  PRINT_OP_MOVEB:
00002556  21FC 0000280B 128A      1880      MOVE.L #P_OP_MOVEB, STRING_BUFFER_POINTER
0000255E  4EB8 24F8               1881      JSR PRINT_TO_BUFFER
00002562  4E75                    1882      RTS
00002564                          1883      
00002564                          1884  PRINT_OP_MOVEA_L:
00002564  21FC 00002816 128A      1885      MOVE.L #P_OP_MOVEA_L, STRING_BUFFER_POINTER
0000256C  4EB8 24F8               1886      JSR PRINT_TO_BUFFER
00002570  4E75                    1887      RTS
00002572                          1888  PRINT_OP_MOVE_L:
00002572  21FC 00002822 128A      1889      MOVE.L #P_OP_MOVE_L, STRING_BUFFER_POINTER
0000257A  4EB8 24F8               1890      JSR PRINT_TO_BUFFER
0000257E  4E75                    1891      RTS
00002580                          1892      
00002580                          1893  PRINT_OP_MOVEA_W:
00002580  21FC 0000282D 128A      1894      MOVE.L #P_OP_MOVEA_W, STRING_BUFFER_POINTER
00002588  4EB8 24F8               1895      JSR PRINT_TO_BUFFER
0000258C  4E75                    1896      RTS
0000258E                          1897  PRINT_OP_MOVE_W:
0000258E  21FC 00002839 128A      1898      MOVE.L #P_OP_MOVE_W, STRING_BUFFER_POINTER
00002596  4EB8 24F8               1899      JSR PRINT_TO_BUFFER
0000259A  4E75                    1900      RTS
0000259C                          1901  
0000259C                          1902  PRINT_OP_JSR:
0000259C  21FC 00002863 128A      1903      MOVE.L #P_OP_JSR, STRING_BUFFER_POINTER
000025A4  4EB8 24F8               1904      JSR PRINT_TO_BUFFER
000025A8  4E75                    1905      RTS
000025AA                          1906  PRINT_OP_RTS:
000025AA  21FC 00002871 128A      1907      MOVE.L #P_OP_RTS, STRING_BUFFER_POINTER
000025B2  4EB8 24F8               1908      JSR PRINT_TO_BUFFER
000025B6  4E75                    1909      RTS
000025B8                          1910  PRINT_OP_NOP:
000025B8  21FC 0000286A 128A      1911      MOVE.L #P_OP_NOP, STRING_BUFFER_POINTER
000025C0  4EB8 24F8               1912      JSR PRINT_TO_BUFFER
000025C4  4E75                    1913      RTS
000025C6                          1914  PRINT_OP_LEA:
000025C6  21FC 0000285C 128A      1915      MOVE.L #P_OP_LEA, STRING_BUFFER_POINTER
000025CE  4EB8 24F8               1916      JSR PRINT_TO_BUFFER
000025D2  4EB9 000027B8           1917      JSR PRINT_OP_SIZE
000025D8  4E75                    1918      RTS
000025DA                          1919  PRINT_OP_NEG:
000025DA  21FC 00002878 128A      1920      MOVE.L #P_OP_NEG, STRING_BUFFER_POINTER
000025E2  4EB8 24F8               1921      JSR PRINT_TO_BUFFER
000025E6  4EB9 000027B8           1922      JSR PRINT_OP_SIZE
000025EC  4E75                    1923      RTS
000025EE                          1924  PRINT_OP_MOVEM_W:
000025EE  21FC 00002844 128A      1925      MOVE.L #P_OP_MOVEM_W, STRING_BUFFER_POINTER
000025F6  4EB8 24F8               1926      JSR PRINT_TO_BUFFER
000025FA  4E75                    1927      RTS
000025FC                          1928  PRINT_OP_MOVEM_L:
000025FC  21FC 00002850 128A      1929      MOVE.L #P_OP_MOVEM_L, STRING_BUFFER_POINTER
00002604  4EB8 24F8               1930      JSR PRINT_TO_BUFFER
00002608  4E75                    1931      RTS
0000260A                          1932      
0000260A                          1933  PRINT_OP_SUBQ:
0000260A  21FC 0000287F 128A      1934      MOVE.L #P_OP_SUBQ, STRING_BUFFER_POINTER
00002612  4EB8 24F8               1935      JSR PRINT_TO_BUFFER
00002616  4EB9 000027B8           1936      JSR PRINT_OP_SIZE
0000261C  4E75                    1937      RTS
0000261E                          1938  
0000261E                          1939  PRINT_OP_BCS:
0000261E  21FC 0000288E 128A      1940      MOVE.L #P_OP_BCS, STRING_BUFFER_POINTER
00002626  4EB8 24F8               1941      JSR PRINT_TO_BUFFER
0000262A  4EB9 000027B8           1942      JSR PRINT_OP_SIZE
00002630  4E75                    1943      RTS
00002632                          1944  PRINT_OP_BGE:
00002632  21FC 00002895 128A      1945      MOVE.L #P_OP_BGE, STRING_BUFFER_POINTER
0000263A  4EB8 24F8               1946      JSR PRINT_TO_BUFFER
0000263E  4EB9 000027B8           1947      JSR PRINT_OP_SIZE
00002644  4E75                    1948      RTS
00002646                          1949  PRINT_OP_BLT:
00002646  21FC 0000289C 128A      1950      MOVE.L #P_OP_BLT, STRING_BUFFER_POINTER
0000264E  4EB8 24F8               1951      JSR PRINT_TO_BUFFER
00002652  4EB9 000027B8           1952      JSR PRINT_OP_SIZE
00002658  4E75                    1953      RTS
0000265A                          1954  PRINT_OP_BVC:
0000265A  21FC 000028A3 128A      1955      MOVE.L #P_OP_BVC, STRING_BUFFER_POINTER
00002662  4EB8 24F8               1956      JSR PRINT_TO_BUFFER
00002666  4EB9 000027B8           1957      JSR PRINT_OP_SIZE
0000266C  4E75                    1958      RTS
0000266E                          1959  PRINT_OP_BRA:
0000266E  21FC 00002887 128A      1960      MOVE.L #P_OP_BRA, STRING_BUFFER_POINTER
00002676  4EB8 24F8               1961      JSR PRINT_TO_BUFFER
0000267A  4EB9 000027B8           1962      JSR PRINT_OP_SIZE
00002680  4E75                    1963      RTS
00002682                          1964  
00002682                          1965  
00002682                          1966  PRINT_OP_DIVS:
00002682  21FC 000028AA 128A      1967      MOVE.L #P_OP_DIVS, STRING_BUFFER_POINTER
0000268A  4EB8 24F8               1968      JSR PRINT_TO_BUFFER
0000268E  4E75                    1969      RTS
00002690                          1970  PRINT_OP_OR:
00002690  21FC 000028B5 128A      1971      MOVE.L #P_OP_OR, STRING_BUFFER_POINTER
00002698  4EB8 24F8               1972      JSR PRINT_TO_BUFFER
0000269C  4EB9 000027B8           1973      JSR PRINT_OP_SIZE
000026A2  4E75                    1974      RTS
000026A4                          1975  
000026A4                          1976  PRINT_OP_SUB:
000026A4  21FC 000028BB 128A      1977      MOVE.L #P_OP_SUB, STRING_BUFFER_POINTER
000026AC  4EB8 24F8               1978      JSR PRINT_TO_BUFFER
000026B0  4EB9 000027B8           1979      JSR PRINT_OP_SIZE
000026B6  4E75                    1980      RTS
000026B8                          1981  
000026B8                          1982  
000026B8                          1983  PRINT_OP_EOR:
000026B8  21FC 000028C2 128A      1984      MOVE.L #P_OP_EOR, STRING_BUFFER_POINTER
000026C0  4EB8 24F8               1985      JSR PRINT_TO_BUFFER
000026C4  4EB9 000027B8           1986      JSR PRINT_OP_SIZE
000026CA  4E75                    1987      RTS
000026CC                          1988  PRINT_OP_CMP:
000026CC  21FC 000028C9 128A      1989      MOVE.L #P_OP_CMP, STRING_BUFFER_POINTER
000026D4  4EB8 24F8               1990      JSR PRINT_TO_BUFFER
000026D8  4EB9 000027B8           1991      JSR PRINT_OP_SIZE
000026DE  4E75                    1992      RTS
000026E0                          1993  
000026E0                          1994  PRINT_OP_MULS:
000026E0  21FC 000028D0 128A      1995      MOVE.L #P_OP_MULS, STRING_BUFFER_POINTER
000026E8  4EB8 24F8               1996      JSR PRINT_TO_BUFFER
000026EC  4E75                    1997      RTS
000026EE                          1998  
000026EE                          1999  PRINT_OP_ADD:
000026EE  21FC 000028E3 128A      2000      MOVE.L #P_OP_ADD, STRING_BUFFER_POINTER
000026F6  4EB8 24F8               2001      JSR PRINT_TO_BUFFER
000026FA  4EB9 000027B8           2002      JSR PRINT_OP_SIZE
00002700  4E75                    2003      RTS
00002702                          2004  PRINT_OP_ADDA:
00002702  21FC 000028DB 128A      2005      MOVE.L #P_OP_ADDA, STRING_BUFFER_POINTER
0000270A  4EB8 24F8               2006      JSR PRINT_TO_BUFFER
0000270E  4EB9 000027D2           2007      JSR PRINT_OP_SIZE_ADDA
00002714  4E75                    2008      RTS
00002716                          2009  
00002716                          2010  
00002716                          2011  PRINT_OP_LSL:
00002716  21FC 000028F1 128A      2012      MOVE.L #P_OP_LSL, STRING_BUFFER_POINTER
0000271E  4EB8 24F8               2013      JSR PRINT_TO_BUFFER
00002722  4EB9 000027B8           2014      JSR PRINT_OP_SIZE
00002728  4E75                    2015      RTS
0000272A                          2016  PRINT_OP_LSR:
0000272A  21FC 000028EA 128A      2017      MOVE.L #P_OP_LSR, STRING_BUFFER_POINTER
00002732  4EB8 24F8               2018      JSR PRINT_TO_BUFFER
00002736  4EB9 000027B8           2019      JSR PRINT_OP_SIZE
0000273C  4E75                    2020      RTS
0000273E                          2021  PRINT_OP_ASR:
0000273E  21FC 000028F8 128A      2022      MOVE.L #P_OP_ASR, STRING_BUFFER_POINTER
00002746  4EB8 24F8               2023      JSR PRINT_TO_BUFFER
0000274A  4EB9 000027B8           2024      JSR PRINT_OP_SIZE
00002750  4E75                    2025      RTS
00002752                          2026  PRINT_OP_ASL:
00002752  21FC 000028FF 128A      2027      MOVE.L #P_OP_ASL, STRING_BUFFER_POINTER
0000275A  4EB8 24F8               2028      JSR PRINT_TO_BUFFER
0000275E  4EB9 000027B8           2029      JSR PRINT_OP_SIZE
00002764  4E75                    2030      RTS
00002766                          2031  PRINT_OP_ROL:
00002766  21FC 0000290D 128A      2032      MOVE.L #P_OP_ROL, STRING_BUFFER_POINTER
0000276E  4EB8 24F8               2033      JSR PRINT_TO_BUFFER
00002772  4EB9 000027B8           2034      JSR PRINT_OP_SIZE
00002778  4E75                    2035      RTS
0000277A                          2036  PRINT_OP_ROR:
0000277A  21FC 00002906 128A      2037      MOVE.L #P_OP_ROR, STRING_BUFFER_POINTER
00002782  4EB8 24F8               2038      JSR PRINT_TO_BUFFER
00002786  4EB9 000027B8           2039      JSR PRINT_OP_SIZE
0000278C  4E75                    2040      RTS
0000278E                          2041  
0000278E                          2042  
0000278E                          2043  PRINT_SIZE_BYTE:
0000278E  21FC 000027E8 128A      2044      MOVE.L #P_SIZE_B, STRING_BUFFER_POINTER
00002796  4EB8 24F8               2045      JSR PRINT_TO_BUFFER
0000279A  4E75                    2046      RTS    
0000279C                          2047  
0000279C                          2048  PRINT_SIZE_WORD:
0000279C  21FC 000027EC 128A      2049      MOVE.L #P_SIZE_W, STRING_BUFFER_POINTER
000027A4  4EB8 24F8               2050      JSR PRINT_TO_BUFFER
000027A8  4E75                    2051      RTS
000027AA                          2052      
000027AA                          2053  PRINT_SIZE_LONG:
000027AA  21FC 000027F0 128A      2054      MOVE.L #P_SIZE_L, STRING_BUFFER_POINTER
000027B2  4EB8 24F8               2055      JSR PRINT_TO_BUFFER
000027B6  4E75                    2056      RTS
000027B8                          2057  
000027B8                          2058  PRINT_OP_SIZE:                      ;Prints current OP code byte size if applicable
000027B8  0C38 0000 1770          2059      CMP.B  #%00,OP_SIZE             ;Checks for byte size
000027BE  67CE                    2060      BEQ    PRINT_SIZE_BYTE          ;Print .B to buffer
000027C0  0C38 0001 1770          2061      CMP.B  #%01,OP_SIZE             ;Check for word size
000027C6  67D4                    2062      BEQ    PRINT_SIZE_WORD          ;Print .W to buffer
000027C8  0C38 0002 1770          2063      CMP.B  #%10,OP_SIZE             ;Check for long size
000027CE  67DA                    2064      BEQ    PRINT_SIZE_LONG          ;Print .L to buffer
000027D0  4E75                    2065      RTS
000027D2                          2066      
000027D2                          2067  PRINT_OP_SIZE_ADDA:                 ;Special  print for ADDA
000027D2  0C38 0000 1770          2068      CMP.B #%0,OP_SIZE               ;Checks if the OP_SIZE is 0
000027D8  67C2                    2069      BEQ    PRINT_SIZE_WORD          ;If it is the size is word
000027DA  66CE                    2070      BNE    PRINT_SIZE_LONG          ;If it's not the size is long
000027DC                          2071      
000027DC                          2072  
000027DC                          2073  
000027DC                          2074  
000027DC                          2075  
000027DC= 20 20 20 44 41 54 ...   2076  P_INVALID_OP    DC.B    '   DATA   $',0
000027E8= 2E 42 20 00             2077  P_SIZE_B        DC.B    '.B ',0
000027EC= 2E 57 20 00             2078  P_SIZE_W        DC.B    '.W ',0
000027F0= 2E 4C 20 00             2079  P_SIZE_L        DC.B    '.L ',0
000027F4= 20 20 20 4F 52 49 00    2080  P_OP_ORI        DC.B    '   ORI',0
000027FB= 20 20 20 43 4D 50 ...   2081  P_OP_CMPI       DC.B    '   CMPI',0
00002803= 20 20 20 42 43 4C ...   2082  P_OP_BCLR       DC.B    '   BCLR',0
0000280B= 20 20 20 4D 4F 56 ...   2083  P_OP_MOVEB      DC.B    '   MOVE.B ',0
00002816= 20 20 20 4D 4F 56 ...   2084  P_OP_MOVEA_L    DC.B    '   MOVEA.L ',0 
00002822= 20 20 20 4D 4F 56 ...   2085  P_OP_MOVE_L     DC.B    '   MOVE.L ',0
0000282D= 20 20 20 4D 4F 56 ...   2086  P_OP_MOVEA_W    DC.B    '   MOVEA.W ',0
00002839= 20 20 20 4D 4F 56 ...   2087  P_OP_MOVE_W     DC.B    '   MOVE.W ',0
00002844= 20 20 20 4D 4F 56 ...   2088  P_OP_MOVEM_W    DC.B    '   MOVEM.W ',0
00002850= 20 20 20 4D 4F 56 ...   2089  P_OP_MOVEM_L    DC.B    '   MOVEM.L ',0
0000285C= 20 20 20 4C 45 41 00    2090  P_OP_LEA        DC.B    '   LEA',0
00002863= 20 20 20 4A 53 52 00    2091  P_OP_JSR        DC.B    '   JSR',0
0000286A= 20 20 20 4E 4F 50 00    2092  P_OP_NOP        DC.B    '   NOP',0
00002871= 20 20 20 52 54 53 00    2093  P_OP_RTS        DC.B    '   RTS',0
00002878= 20 20 20 4E 45 47 00    2094  P_OP_NEG        DC.B    '   NEG',0
0000287F= 20 20 20 53 55 42 ...   2095  P_OP_SUBQ       DC.B    '   SUBQ',0
00002887= 20 20 20 42 52 41 00    2096  P_OP_BRA        DC.B    '   BRA',0
0000288E= 20 20 20 42 43 53 00    2097  P_OP_BCS        DC.B    '   BCS',0
00002895= 20 20 20 42 47 45 00    2098  P_OP_BGE        DC.B    '   BGE',0
0000289C= 20 20 20 42 4C 54 00    2099  P_OP_BLT        DC.B    '   BLT',0
000028A3= 20 20 20 42 56 43 00    2100  P_OP_BVC        DC.B    '   BVC',0
000028AA= 20 20 20 44 49 56 ...   2101  P_OP_DIVS       DC.B    '   DIVS.W ',0
000028B5= 20 20 20 4F 52 00       2102  P_OP_OR         DC.B    '   OR',0
000028BB= 20 20 20 53 55 42 00    2103  P_OP_SUB        DC.B    '   SUB',0
000028C2= 20 20 20 45 4F 52 00    2104  P_OP_EOR        DC.B    '   EOR',0
000028C9= 20 20 20 43 4D 50 00    2105  P_OP_CMP        DC.B    '   CMP',0
000028D0= 20 20 20 4D 55 4C ...   2106  P_OP_MULS       DC.B    '   MULS.W ',0
000028DB= 20 20 20 41 44 44 ...   2107  P_OP_ADDA       DC.B    '   ADDA',0
000028E3= 20 20 20 41 44 44 00    2108  P_OP_ADD        DC.B    '   ADD',0
000028EA= 20 20 20 4C 53 52 00    2109  P_OP_LSR        DC.B    '   LSR',0
000028F1= 20 20 20 4C 53 4C 00    2110  P_OP_LSL        DC.B    '   LSL',0
000028F8= 20 20 20 41 53 52 00    2111  P_OP_ASR        DC.B    '   ASR',0
000028FF= 20 20 20 41 53 4C 00    2112  P_OP_ASL        DC.B    '   ASL',0
00002906= 20 20 20 52 4F 52 00    2113  P_OP_ROR        DC.B    '   ROR',0
0000290D= 20 20 20 52 4F 4C 00    2114  P_OP_ROL        DC.B    '   ROL',0
00002914                          2115  
00002914                          2116  
00002914                          2117  
00002914                          2118  
00002914                          2119  
00002914                          2120  
00002914                          2121  -------------------- end include --------------------
00002914                          2122      INCLUDE "EA_FINAL.x68"                          ;EA role code to include
00002914                          2123  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002914                          2124  
00002914                          2125  
00002914= 41                      2126  ADDRESS         DC.B    $41
00002915= 44                      2127  DATA            DC.B    $44
00002916                          2128  
00002916= 28                      2129  PTHSIS_OPEN     DC.B    $28
00002917= 29                      2130  PTHSIS_CLSD     DC.B    $29
00002918= 24                      2131  HEX_SIGN        DC.B    $24
00002919= 23                      2132  IMMDTE_VALU     DC.B    $23
0000291A= 2B                      2133  PLUS_SIGN       DC.B    $2B
0000291B= 2D                      2134  MINUS_SIGN      DC.B    $2D
0000291C                          2135  
0000291C= 2C                      2136  COMMA           DC.B    $2C
0000291D= 20                      2137  SPACE           DC.B    $20
0000291E                          2138  
0000291E                          2139  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000291E                          2140  
0000291E                          2141  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0000291E                          2142  TRAILING_SIZE   DS.W    1                                   ;Size of any immediate or
00002920                          2143                                                              ;address values. Immediate or address
00002920                          2144                                                              ;value of a BYTE is still processed as
00002920                          2145                                                              ;WORD because the trailing bytes
00002920                          2146                                                              ;are represented as a word regardless.
00002920                          2147                                                              ;$1 = BYTE, $2 = WORD, $4 = LONG
00002920                          2148                                                              
00002920                          2149  MOVEM_FIRST_VAR             DS.B    1                       ;MOVEM constant
00002921                          2150  MOVEM_SECOND_VAR            DS.B    1                       ;Always MOVEM_FIRST_VAR-> MOVEM_SECOND_VAR
00002922                          2151  MOVEM_FIRST_VAR_COUNTER     DS.B    1                       ;MOVEM counter constant
00002923                          2152  MOVEM_SECOND_VAR_COUNTER        DS.B    1                       ;MOVEM counter constant
00002924                          2153  FIRST_VAR_MOVEM             DS.B    1                       ;Refers to the first X var assuming Dx1-Dx2/Ay1-Ay2
00002925                          2154                                                              ;Refers to the second X var assuming Dx1-Dx2/Ay1-Ay2
00002925                          2155  SECOND_VAR_MOVEM            DS.B    1                       ;Refers to the first Y var assuming Dx1-Dx2/Ay1-Ay2
00002926                          2156                                                              ;Refers to the second Y var assuming Dx1-Dx2/Ay1-Ay2
00002926                          2157  
00002926                          2158  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002926                          2159  
00002926                          2160  
00002926                          2161  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002926                          2162  
00002926                          2163  main_EA:
00002926  4EB8 195C               2164      JSR PARSE_EA_CONSTANT_BITS                              ;Parses and initializes all EA necessary values   
0000292A                          2165  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000292A                          2166  
0000292A                          2167  
0000292A                          2168  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
0000292A  4EB9 00002934           2169      JSR     CHECK_XXXX
00002930                          2170  EXT                                                         ;End point for EA address
00002930  4EF8 11FA               2171      JMP check_print                                         ;Jumps to IO's main printing method after finishing
00002934                          2172  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00002934                          2173  
00002934                          2174  CHECK_XXXX:
00002934  0C38 0008 1771          2175      CMPI.B  #$8, MNEMONIC                                   ;Check if MNEMONIC is $8
0000293A  6D00 0008               2176      BLT     CHECK_0XXX                                      ;If so it's in the 0XXX group
0000293E  4EF9 00002954           2177      JMP     CHECK_1XXX                                      ;If not it's in 1XXX
00002944                          2178  
00002944                          2179  CHECK_0XXX:
00002944  0C38 0004 1771          2180      CMPI.B  #$4, MNEMONIC                                   ;Check if MNEMONIC is in $4
0000294A  6D00 004C               2181      BLT     CHECK_00XX                                      ;If so it's in the 00XX group
0000294E  4EF9 000029A6           2182      JMP     CHECK_01XX                                      ;If not it's in 01XX
00002954                          2183  
00002954                          2184  CHECK_1XXX:
00002954  0C38 0008 1771          2185      CMPI.B  #$8, MNEMONIC                                   ;Check if MNEMONIC is $8
0000295A  6700 0308               2186      BEQ     LOAD_1000                                       ;If so load equivalent value into it
0000295E  0C38 0009 1771          2187      CMPI.B  #$9, MNEMONIC                                   ;Check if MNEMONIC is $8
00002964  6700 02F8               2188      BEQ     LOAD_1001                                       ;If so load equivalent value into it
00002968  0C38 000B 1771          2189      CMPI.B  #$B, MNEMONIC                                   ;Check if MNEMONIC is $8
0000296E  6700 02E8               2190      BEQ     LOAD_1011                                       ;If so load equivalent value into it
00002972  0C38 000C 1771          2191      CMPI.B  #$C, MNEMONIC                                   ;Check if MNEMONIC is $8
00002978  6700 02D8               2192      BEQ     LOAD_1100                                       ;If so load equivalent value into it
0000297C  0C38 000D 1771          2193      CMPI.B  #$D, MNEMONIC                                   ;Check if MNEMONIC is $8
00002982  6700 026C               2194      BEQ     LOAD_1101                                       ;If so load equivalent value into it
00002986  0C38 000E 1771          2195      CMPI.B  #$E, MNEMONIC                                   ;Check if MNEMONIC is $8
0000298C  6700 0038               2196      BEQ     LOAD_1110                                       ;If so load equivalent value into it
00002990                          2197      
00002990  4EF9 0000370E           2198      JMP     INVALID                                         ;Otherwise value is INVALID
00002996                          2199      
00002996  4E75                    2200      RTS                                                     ;Return to stack
00002998                          2201  
00002998                          2202  CHECK_00XX:
00002998  0C38 0001 1771          2203      CMPI.B  #$1, MNEMONIC                                   ;Check if MNEMONIC is equal to $1
0000299E  6D00 0970               2204      BLT     LOAD_0000                                       ;If so then it's 0000
000029A2  6C00 0AF2               2205      BGE     LOAD_00XX                                       ;Otherwise it's 00XX
000029A6                          2206  
000029A6                          2207  CHECK_01XX:
000029A6  0C38 0004 1771          2208      CMPI.B  #%0100, MNEMONIC                                    ;Check if MNEMONIC is $4
000029AC  6700 0458               2209      BEQ     LOAD_0100                                           ;Load equivalent value
000029B0  0C38 0005 1771          2210      CMPI.B  #%0101, MNEMONIC                                    ;Check if MNEMONIC is $5
000029B6  6700 03C4               2211      BEQ     LOAD_0101                                           ;Load equivalent value
000029BA  0C38 0006 1771          2212      CMPI.B  #%0110, MNEMONIC                                    ;Check if MNEMONIC is $6
000029C0  6700 0124               2213      BEQ     LOAD_0110                                           ;Load equivalent value
000029C4  4E75                    2214      RTS                                                         ;Return to stack
000029C6                          2215  
000029C6                          2216  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000029C6                          2217  
000029C6                          2218  
000029C6                          2219  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000029C6                          2220  
000029C6                          2221  LOAD_1110:
000029C6  247C 00000000           2222              MOVEA.L #0, A2                  
000029CC  267C 00000000           2223              MOVEA.L #0, A3
000029D2  4285                    2224              CLR.L   D5
000029D4                          2225      
000029D4  1A38 1773               2226              MOVE.B  SECOND_3, D5
000029D8  0205 0003               2227              ANDI.B  #%011, D5
000029DC                          2228      
000029DC  0C05 0003               2229              CMPI.B  #%11, D5
000029E0  6700 0006               2230              BEQ     MYBE_ASd_1
000029E4  6600 0068               2231              BNE     MYBE_ASd_2
000029E8                          2232  
000029E8  0C38 0000 1772          2233  MYBE_ASd_1  CMPI.B  #%000, FIRST_3
000029EE  6700 001C               2234              BEQ     ASd_1
000029F2  0C38 0001 1772          2235              CMPI.B  #%001, FIRST_3
000029F8  6700 0012               2236              BEQ     ASd_1 * LSd
000029FC  0C38 0003 1772          2237              CMPI.B  #%011, FIRST_3
00002A02  6700 0008               2238              BEQ     ASd_1 * ROd
00002A06  4EF9 0000370E           2239              JMP     INVALID
00002A0C                          2240  
00002A0C  0C38 0007 1774          2241  ASd_1       CMPI.B  #%111, THIRD_3
00002A12  6600 000C               2242              BNE     MOVEON  
00002A16  0C38 0004 1775          2243              CMPI.B  #%100, FOURTH_3
00002A1C  6700 0CF0               2244              BEQ     INVALID
00002A20                          2245  
00002A20  367C 2A38               2246  MOVEON      MOVEA.W #ASd_1_BACK, A3           
00002A24  0C38 0000 1775          2247              CMPI.B  #%000, FOURTH_3
00002A2A  6700 0B7A               2248              BEQ     SIZE_W
00002A2E  0C38 0001 1775          2249              CMPI.B  #%001, FOURTH_3
00002A34  6700 0B78               2250              BEQ     SIZE_L
00002A38                          2251  
00002A38  1638 1774               2252  ASd_1_BACK  MOVE.B  THIRD_3, D3
00002A3C  1438 1775               2253              MOVE.B  FOURTH_3, D2
00002A40                          2254              
00002A40  4EB9 000034FA           2255              JSR     LOAD_EA
00002A46  4EB9 0000365C           2256              JSR     LOAD_NEW_LINE
00002A4C  4E75                    2257              RTS
00002A4E                          2258  
00002A4E  4285                    2259  MYBE_ASd_2  CLR.L   D5
00002A50                          2260  
00002A50  1A38 1774               2261              MOVE.B  THIRD_3, D5
00002A54  0205 0003               2262              ANDI.B  #%011, D5
00002A58  0C05 0002               2263              CMPI.B  #%10, D5
00002A5C  6600 0006               2264              BNE     ASd_2 * or LSd or ROd
00002A60  6700 0CAC               2265              BEQ     INVALID
00002A64                          2266              
00002A64  4285                    2267  ASd_2       CLR.L   D5
00002A66                          2268  
00002A66  1A38 1774               2269              MOVE.B  THIRD_3, D5
00002A6A  0205 0004               2270              ANDI.B  #%100, D5
00002A6E  0C05 0004               2271              CMPI.B  #%100, D5
00002A72  6700 0048               2272              BEQ     ASd_2_REG
00002A76  6600 0002               2273              BNE     ASd_2_IMD
00002A7A                          2274              
00002A7A  347C 2AA0               2275  ASd_2_IMD   MOVEA.W #ASd_2_IMD_B, A2
00002A7E  0C38 0000 1772          2276              CMPI.B  #%000, FIRST_3
00002A84  6700 0006               2277              BEQ     LOAD_8
00002A88  6600 000C               2278              BNE     LOAD_FIRST3
00002A8C                          2279              
00002A8C  183C 0008               2280  LOAD_8      MOVE.B  #8, D4
00002A90  4EF9 00003628           2281              JMP     LOAD_IMMDTE
00002A96                          2282  
00002A96  1838 1772               2283  LOAD_FIRST3 MOVE.B  FIRST_3, D4
00002A9A  4EF9 00003628           2284              JMP     LOAD_IMMDTE
00002AA0                          2285  
00002AA0  4EB9 0000365E           2286  ASd_2_IMD_B JSR     LOAD_COMMA_SPACE
00002AA6                          2287  
00002AA6  163C 0000               2288              MOVE.B  #%000, D3
00002AAA  1438 1775               2289              MOVE.B  FOURTH_3, D2
00002AAE                          2290              
00002AAE  4EB9 000034FA           2291              JSR     LOAD_EA
00002AB4  4EB9 0000365C           2292              JSR     LOAD_NEW_LINE
00002ABA  4E75                    2293              RTS
00002ABC                          2294  
00002ABC  163C 0000               2295  ASd_2_REG   MOVE.B  #%000, D3
00002AC0  1438 1772               2296              MOVE.B  FIRST_3, D2
00002AC4                          2297              
00002AC4  4EB9 000034FA           2298              JSR     LOAD_EA
00002ACA  4EB9 0000365E           2299              JSR     LOAD_COMMA_SPACE
00002AD0                          2300              
00002AD0  163C 0000               2301              MOVE.B  #%000, D3
00002AD4  1438 1775               2302              MOVE.B  FOURTH_3, D2
00002AD8                          2303              
00002AD8  4EB9 000034FA           2304              JSR     LOAD_EA
00002ADE  4EB9 0000365C           2305              JSR     LOAD_NEW_LINE
00002AE4  4E75                    2306              RTS
00002AE6                          2307  
00002AE6                          2308  
00002AE6                          2309  
00002AE6                          2310  LOAD_0110:
00002AE6  247C 00000000           2311              MOVEA.L #0, A2
00002AEC  267C 00000000           2312              MOVEA.L #0, A3
00002AF2  4285                    2313              CLR.L   D5
00002AF4  4286                    2314              CLR.L   D6
00002AF6  4284                    2315              CLR.L   D4
00002AF8                          2316  
00002AF8  0C38 0000 1772          2317              CMPI.B  #%000, FIRST_3
00002AFE  6700 0006               2318              BEQ     MYBE_BRA
00002B02  6600 0010               2319              BNE     NOT_BRA
00002B06  0C38 0004 1773          2320  MYBE_BRA    CMPI.B  #%100, SECOND_3
00002B0C  6D00 003A               2321              BLT     BRA
00002B10  6C00 0002               2322              BGE     NOT_BRA
00002B14                          2323              
00002B14  1A38 1772               2324  NOT_BRA     MOVE.B  FIRST_3, D5
00002B18  E305                    2325              ASL.B   #1, D5
00002B1A  1C38 1773               2326              MOVE.B  SECOND_3, D6
00002B1E  E406                    2327              ASR.B   #2, D6
00002B20  DA06                    2328              ADD.B   D6, D5
00002B22                          2329              
00002B22  0C05 0005               2330              CMPI.B  #%0101, D5
00002B26  6700 0020               2331              BEQ     BRA * CS
00002B2A  0C05 0008               2332              CMPI.B  #%1000, D5
00002B2E  6700 0018               2333              BEQ     BRA * VC
00002B32  0C05 000C               2334              CMPI.B  #%1100, D5
00002B36  6700 0010               2335              BEQ     BRA * GE
00002B3A  0C05 000D               2336              CMPI.B  #%1101, D5
00002B3E  6700 0008               2337              BEQ     BRA * LT
00002B42                          2338              
00002B42  4EF9 0000370E           2339              JMP     INVALID
00002B48                          2340              
00002B48                          2341              
00002B48  4285                    2342  BRA         CLR.L   D5
00002B4A  4286                    2343              CLR.L   D6
00002B4C                          2344  
00002B4C  3A0D                    2345              MOVE.W  A5, D5 * D5 has $1002 (Starting + MNEMONICS)
00002B4E  3C38 10A0               2346              MOVE.W  CUR_OP_CODE, D6
00002B52  0246 00FF               2347              ANDI.W  #$00FF, D6 * D6 now has $E
00002B56  0C06 0000               2348              CMPI.B  #$00, D6
00002B5A  6700 0052               2349              BEQ     BRA_WORD * word. there is 4 hex trailing bits (word)
00002B5E                          2350  
00002B5E  0C06 00FF               2351              CMPI.B  #$FF, D6
00002B62  6700 0010               2352              BEQ     BRA_BYTE
00002B66  0C06 00FE               2353              CMPI.B  #$FE, D6
00002B6A  6700 0008               2354              BEQ     BRA_BYTE
00002B6E                          2355  
00002B6E  4EF9 0000370E           2356              JMP     INVALID
00002B74                          2357              
00002B74  0C06 00FE               2358  BRA_BYTE    CMPI.B  #$FE, D6
00002B78  6700 0010               2359              BEQ     DOWN_ZERO
00002B7C  0C06 00FF               2360              CMPI.B  #$FF, D6
00002B80  6700 0010               2361              BEQ     DOWN_ONE
00002B84                          2362              
00002B84  4EF9 0000370E           2363              JMP     INVALID
00002B8A                          2364              
00002B8A  5505                    2365  DOWN_ZERO   SUBI.B  #$2, D5 * D5 has $1000 (Starting)
00002B8C  4EF9 00002B9A           2366              JMP     BRA_BYTE2
00002B92                          2367              
00002B92  5305                    2368  DOWN_ONE    SUBI.B  #$1, D5 * D5 has $1001 (Starting + 1)
00002B94  4EF9 00002B9A           2369              JMP     BRA_BYTE2
00002B9A                          2370              
00002B9A  347C 2BA6               2371  BRA_BYTE2   MOVE.W  #BRA_BYTE3, A2
00002B9E  3805                    2372              MOVE.W  D5, D4
00002BA0  4EF9 00003604           2373              JMP     LOAD_ABS_SHORT
00002BA6  4EB9 0000365C           2374  BRA_BYTE3   JSR     LOAD_NEW_LINE
00002BAC  4E75                    2375              RTS
00002BAE                          2376  
00002BAE  381D                    2377  BRA_WORD    MOVE.W  (A5)+, D4 * D4 now has $000E
00002BB0                          2378  
00002BB0  0C84 00008000           2379              CMPI.L  #$8000, D4
00002BB6  6C00 001A               2380              BGE     NEG_WORD
00002BBA  6D00 0002               2381              BLT     POS_WORD
00002BBE                          2382              
00002BBE  347C 2BCA               2383  POS_WORD    MOVE.W  #BRA_WORD_BK, A2
00002BC2  D845                    2384              ADD.W   D5, D4 * D4 now has $100E
00002BC4  4EF9 00003604           2385              JMP     LOAD_ABS_SHORT
00002BCA  4EB9 0000365C           2386  BRA_WORD_BK JSR     LOAD_NEW_LINE
00002BD0  4E75                    2387              RTS
00002BD2                          2388  
00002BD2  347C 2BE8               2389  NEG_WORD    MOVE.W  #BRA_WRD_BK2, A2
00002BD6  4444                    2390              NEG     D4
00002BD8                          2391              
00002BD8  B885                    2392              CMP.L   D5, D4 * $4002 vs DISPLACEMENT
00002BDA  6E00 0B32               2393              BGT     INVALID
00002BDE                          2394              
00002BDE  9A44                    2395              SUB.W   D4, D5 * D5 now has $1000 - 2cmp'ed $000E
00002BE0  3805                    2396              MOVE.W  D5, D4
00002BE2  4EF9 00003604           2397              JMP     LOAD_ABS_SHORT
00002BE8  4EB9 0000365C           2398  BRA_WRD_BK2 JSR     LOAD_NEW_LINE
00002BEE  4E75                    2399              RTS
00002BF0                          2400  
00002BF0                          2401  
00002BF0                          2402  
00002BF0                          2403  LOAD_1101:
00002BF0  0C38 0003 1773          2404              CMPI.B  #%011, SECOND_3
00002BF6  6700 0012               2405              BEQ     ADDA
00002BFA  0C38 0007 1773          2406              CMPI.B  #%111, SECOND_3
00002C00  6700 0008               2407              BEQ     ADDA
00002C04                          2408              
00002C04  4EF9 00002C64           2409              JMP     LOAD_1000
00002C0A                          2410              
00002C0A  367C 2C28               2411  ADDA        MOVEA.W #ADDA_BACK, A3
00002C0E  4281                    2412              CLR.L   D1
00002C10  1238 1773               2413              MOVE.B  SECOND_3, D1
00002C14  0201 0004               2414              ANDI.B  #%100, D1
00002C18                          2415              
00002C18  0C01 0000               2416              CMPI.B  #%000, D1
00002C1C  6700 0988               2417              BEQ     SIZE_W
00002C20  0C01 0004               2418              CMPI.B  #%100, D1
00002C24  6700 0988               2419              BEQ     SIZE_L
00002C28                          2420              
00002C28  1638 1774               2421  ADDA_BACK   MOVE.B  THIRD_3, D3
00002C2C  1438 1775               2422              MOVE.B  FOURTH_3, D2
00002C30                          2423  
00002C30  4EB9 000034FA           2424              JSR     LOAD_EA
00002C36  4EB9 0000365E           2425              JSR     LOAD_COMMA_SPACE
00002C3C                          2426              
00002C3C  163C 0001               2427              MOVE.B  #%001, D3
00002C40  1438 1772               2428              MOVE.B  FIRST_3, D2
00002C44                          2429              
00002C44  4EB9 000034FA           2430              JSR     LOAD_EA
00002C4A  4EB9 0000365C           2431              JSR     LOAD_NEW_LINE
00002C50  4E75                    2432              RTS
00002C52                          2433  
00002C52                          2434  LOAD_1100:
00002C52  4EF9 00002C64           2435      JMP     LOAD_1000
00002C58                          2436      
00002C58                          2437  LOAD_1011:
00002C58  4EF9 00002C64           2438      JMP     LOAD_1000
00002C5E                          2439  
00002C5E                          2440  
00002C5E                          2441  LOAD_1001:
00002C5E  4EF9 00002C64           2442      JMP     LOAD_1000
00002C64                          2443  
00002C64                          2444  
00002C64                          2445  LOAD_1000:
00002C64  4283                    2446              CLR.L   D3
00002C66  4282                    2447              CLR.L   D2
00002C68  267C 00000000           2448              MOVEA.L #0, A3
00002C6E                          2449              
00002C6E  0C38 0007 1773          2450              CMPI.B  #%111, SECOND_3
00002C74  6700 00BA               2451              BEQ     DIVS
00002C78                          2452              
00002C78  0C38 0003 1773          2453              CMPI.B  #%011, SECOND_3
00002C7E  6700 0A8E               2454              BEQ     INVALID
00002C82                          2455              
00002C82  0C38 0004 1773          2456              CMPI.B  #%100, SECOND_3
00002C88  6D00 0006               2457              BLT     DIR_0                                   ;direction bit 0
00002C8C  6C00 0052               2458              BGE     DIR_1                                   ;direction bit 1
00002C90                          2459              
00002C90  4281                    2460  DIR_0       CLR.L   D1
00002C92  1238 1773               2461              MOVE.B  SECOND_3, D1
00002C96  0201 0003               2462              ANDI.B  #%011, D1
00002C9A                          2463      
00002C9A  367C 2CB6               2464              MOVEA.W #OR_BACK, A3
00002C9E  0C01 0000               2465              CMPI.B  #%00, D1
00002CA2  6700 08FA               2466              BEQ     SIZE_B
00002CA6  0C01 0001               2467              CMPI.B  #%01, D1
00002CAA  6700 08FA               2468              BEQ     SIZE_W
00002CAE  0C01 0002               2469              CMPI.B  #%10, D1
00002CB2  6700 08FA               2470              BEQ     SIZE_L
00002CB6                          2471              
00002CB6  1638 1774               2472  OR_BACK     MOVE.B  THIRD_3, D3
00002CBA  1438 1775               2473              MOVE.B  FOURTH_3, D2
00002CBE                          2474  
00002CBE  4EB9 000034FA           2475              JSR     LOAD_EA
00002CC4  4EB9 0000365E           2476              JSR     LOAD_COMMA_SPACE
00002CCA                          2477              
00002CCA  163C 0000               2478              MOVE.B  #%000, D3
00002CCE  1438 1772               2479              MOVE.B  FIRST_3, D2
00002CD2                          2480              
00002CD2  4EB9 000034FA           2481              JSR     LOAD_EA
00002CD8  4EB9 0000365C           2482              JSR     LOAD_NEW_LINE
00002CDE  4E75                    2483              RTS
00002CE0                          2484              
00002CE0  163C 0000               2485  DIR_1       MOVE.B  #%000, D3
00002CE4  1438 1772               2486              MOVE.B  FIRST_3, D2
00002CE8                          2487              
00002CE8  4EB9 000034FA           2488              JSR     LOAD_EA
00002CEE  4EB9 0000365E           2489              JSR     LOAD_COMMA_SPACE
00002CF4                          2490              
00002CF4  4281                    2491              CLR.L   D1
00002CF6  1238 1773               2492              MOVE.B  SECOND_3, D1
00002CFA  0201 0003               2493              ANDI.B  #%011, D1
00002CFE                          2494      
00002CFE  367C 2D1A               2495              MOVEA.W #OR_BACK2, A3
00002D02  0C01 0000               2496              CMPI.B  #%00, D1
00002D06  6700 0896               2497              BEQ     SIZE_B
00002D0A  0C01 0001               2498              CMPI.B  #%01, D1
00002D0E  6700 0896               2499              BEQ     SIZE_W
00002D12  0C01 0002               2500              CMPI.B  #%10, D1
00002D16  6700 0896               2501              BEQ     SIZE_L
00002D1A                          2502              
00002D1A  1638 1774               2503  OR_BACK2    MOVE.B  THIRD_3, D3
00002D1E  1438 1775               2504              MOVE.B  FOURTH_3, D2
00002D22                          2505  
00002D22  4EB9 000034FA           2506              JSR     LOAD_EA
00002D28  4EB9 0000365C           2507              JSR     LOAD_NEW_LINE
00002D2E  4E75                    2508              RTS    
00002D30                          2509              
00002D30  367C 2D52               2510  DIVS        MOVEA.W #DIVS_BACK, A3
00002D34  0C38 0000 1775          2511              CMPI.B  #%000, FOURTH_3
00002D3A  6700 086A               2512              BEQ     SIZE_W
00002D3E  0C38 0001 1775          2513              CMPI.B  #%001, FOURTH_3
00002D44  6700 09C8               2514              BEQ     INVALID
00002D48  0C38 0004 1775          2515              CMPI.B  #%100, FOURTH_3
00002D4E  6700 0856               2516              BEQ     SIZE_W
00002D52                          2517              
00002D52  1638 1774               2518  DIVS_BACK   MOVE.B  THIRD_3, D3
00002D56  1438 1775               2519              MOVE.B  FOURTH_3, D2
00002D5A                          2520  
00002D5A  4EB9 000034FA           2521              JSR     LOAD_EA
00002D60  4EB9 0000365E           2522              JSR     LOAD_COMMA_SPACE
00002D66                          2523  
00002D66  163C 0000               2524              MOVE.B  #%000, D3
00002D6A  1438 1772               2525              MOVE.B  FIRST_3, D2
00002D6E                          2526  
00002D6E  4EB9 000034FA           2527              JSR     LOAD_EA
00002D74  4EB9 0000365C           2528              JSR     LOAD_NEW_LINE
00002D7A  4E75                    2529              RTS
00002D7C                          2530  
00002D7C                          2531  
00002D7C                          2532  LOAD_0101:
00002D7C  4283                    2533              CLR.L   D3
00002D7E  4282                    2534              CLR.L   D2
00002D80  267C 00000000           2535              MOVEA.L #0, A3
00002D86                          2536  
00002D86  0C38 0007 1772          2537              CMPI.B  #%111, FIRST_3
00002D8C  6F00 0008               2538              BLE     MYBE_SUBQ1
00002D90  4EF9 0000370E           2539              JMP     INVALID
00002D96                          2540              
00002D96  0C38 0003 1773          2541  MYBE_SUBQ1  CMPI.B  #%011, SECOND_3
00002D9C  6E00 0008               2542              BGT     MYBE_SUBQ2
00002DA0  4EF9 0000370E           2543              JMP     INVALID
00002DA6                          2544  
00002DA6  0C38 0007 1773          2545  MYBE_SUBQ2  CMPI.B  #%111, SECOND_3
00002DAC  6D00 0008               2546              BLT     SUBQ
00002DB0  4EF9 0000370E           2547              JMP     INVALID
00002DB6                          2548  
00002DB6  5238 1772               2549  SUBQ        ADDI.B  #%1, FIRST_3
00002DBA  1838 1772               2550              MOVE.B  FIRST_3, D4
00002DBE                          2551              
00002DBE  347C 2DC8               2552              MOVEA.W #SUBQ_SAVED, A2
00002DC2  4EF9 00003628           2553              JMP     LOAD_IMMDTE
00002DC8                          2554              
00002DC8  4EB9 0000365E           2555  SUBQ_SAVED  JSR     LOAD_COMMA_SPACE
00002DCE                          2556  
00002DCE  367C 2DF0               2557              MOVEA.W #SUBQ_BACK, A3
00002DD2  0C38 0004 1773          2558              CMPI.B  #%100, SECOND_3
00002DD8  6700 07C4               2559              BEQ     SIZE_B
00002DDC  0C38 0005 1773          2560              CMPI.B  #%101, SECOND_3
00002DE2  6700 07C2               2561              BEQ     SIZE_W
00002DE6  0C38 0006 1773          2562              CMPI.B  #%110, SECOND_3
00002DEC  6700 07C0               2563              BEQ     SIZE_L
00002DF0                          2564              
00002DF0  1638 1774               2565  SUBQ_BACK   MOVE.B  THIRD_3, D3
00002DF4  1438 1775               2566              MOVE.B  FOURTH_3, D2
00002DF8                          2567  
00002DF8  4EB9 000034FA           2568              JSR     LOAD_EA
00002DFE  4EB9 0000365C           2569              JSR     LOAD_NEW_LINE
00002E04  4E75                    2570              RTS
00002E06                          2571  
00002E06                          2572  LOAD_0100:
00002E06  4283                    2573              CLR.L   D3
00002E08  4282                    2574              CLR.L   D2
00002E0A  267C 00000000           2575              MOVEA.L #0, A3
00002E10                          2576  
00002E10  0C38 0002 1772          2577              CMPI.B  #%010, FIRST_3
00002E16  6700 0006               2578              BEQ     MYBE_NEG
00002E1A  6600 000C               2579              BNE     NOT_NEG
00002E1E  0C38 0003 1773          2580  MYBE_NEG    CMPI.B  #%011, SECOND_3
00002E24  6D00 008E               2581              BLT     NEG
00002E28                          2582  
00002E28  0C38 0007 1772          2583  NOT_NEG     CMPI.B  #%111, FIRST_3
00002E2E  6700 0006               2584              BEQ     MYBE_RTS1
00002E32  6600 0032               2585              BNE     NOT_RTS
00002E36  0C38 0001 1773          2586  MYBE_RTS1   CMPI.B  #%001, SECOND_3
00002E3C  6700 0006               2587              BEQ     MYBE_RTS2
00002E40  6600 0024               2588              BNE     NOT_RTS
00002E44  0C38 0006 1774          2589  MYBE_RTS2   CMPI.B  #%110, THIRD_3
00002E4A  6700 0006               2590              BEQ     MYBE_RTS3
00002E4E  6600 0016               2591              BNE     NOT_RTS
00002E52  0C38 0005 1775          2592  MYBE_RTS3   CMPI.B  #%101, FOURTH_3
00002E58  6700 0092               2593              BEQ     RTS
00002E5C  0C38 0001 1775          2594              CMPI.B  #%001, FOURTH_3 
00002E62  6700 0088               2595              BEQ     RTS                                     ;It's actually NOP but it's the same in EA perspective
00002E66                          2596              
00002E66  0C38 0007 1772          2597  NOT_RTS     CMPI.B  #%111, FIRST_3
00002E6C  6700 0006               2598              BEQ     MYBE_JSR
00002E70  6600 000C               2599              BNE     NOT_JSR
00002E74  0C38 0002 1773          2600  MYBE_JSR    CMPI.B  #%010, SECOND_3
00002E7A  6700 0078               2601              BEQ     JSR
00002E7E                          2602  
00002E7E  4286                    2603  NOT_JSR     CLR.L   D6
00002E80  1C38 1772               2604              MOVE.B  FIRST_3, D6
00002E84  0206 0005               2605              ANDI.B  #%101, D6                               ;Making %1X0 -> %100
00002E88  0C06 0004               2606              CMPI.B  #%100, D6
00002E8C  6700 0006               2607              BEQ     MYBE_MOVEM
00002E90  6600 0012               2608              BNE     NOT_MOVEM
00002E94                          2609              
00002E94  1C38 1773               2610  MYBE_MOVEM  MOVE.B  SECOND_3, D6
00002E98  0206 0006               2611              ANDI.B  #%110, D6
00002E9C  0C06 0002               2612              CMPI.B  #%010, D6
00002EA0  6700 0080               2613              BEQ     MOVEM
00002EA4                          2614              
00002EA4  0C38 0007 1773          2615  NOT_MOVEM   CMPI.B  #%111, SECOND_3
00002EAA  6700 0084               2616              BEQ     LEA
00002EAE                          2617              
00002EAE  4EF9 0000370E           2618              JMP     INVALID
00002EB4                          2619  
00002EB4                          2620  NEG:
00002EB4  367C 2ED6               2621              MOVEA.W #NEG_BACK, A3
00002EB8  0C38 0000 1773          2622              CMPI.B  #%000, SECOND_3
00002EBE  6700 06DE               2623              BEQ     SIZE_B
00002EC2  0C38 0001 1773          2624              CMPI.B  #%001, SECOND_3
00002EC8  6700 06DC               2625              BEQ     SIZE_W
00002ECC  0C38 0002 1773          2626              CMPI.B  #%010, SECOND_3
00002ED2  6700 06DA               2627              BEQ     SIZE_L
00002ED6                          2628              
00002ED6  1638 1774               2629  NEG_BACK    MOVE.B  THIRD_3, D3
00002EDA  1438 1775               2630              MOVE.B  FOURTH_3, D2
00002EDE                          2631  
00002EDE  4EB9 000034FA           2632              JSR     LOAD_EA
00002EE4  4EB9 0000365C           2633              JSR     LOAD_NEW_LINE
00002EEA  4E75                    2634              RTS
00002EEC                          2635              
00002EEC                          2636  RTS:
00002EEC  4EB9 0000365C           2637              JSR     LOAD_NEW_LINE
00002EF2  4E75                    2638              RTS
00002EF4                          2639  
00002EF4                          2640  JSR:
00002EF4  367C 2F0C               2641              MOVEA.W #JSR_BACK, A3
00002EF8  0C38 0000 1775          2642              CMPI.B  #%000, FOURTH_3
00002EFE  6700 06A6               2643              BEQ     SIZE_W
00002F02  0C38 0001 1775          2644              CMPI.B  #%001, FOURTH_3
00002F08  6700 06A4               2645              BEQ     SIZE_L
00002F0C                          2646              
00002F0C  1638 1774               2647  JSR_BACK    MOVE.B  THIRD_3, D3
00002F10  1438 1775               2648              MOVE.B  FOURTH_3, D2
00002F14                          2649              
00002F14  4EB9 000034FA           2650              JSR     LOAD_EA
00002F1A  4EB9 0000365C           2651              JSR     LOAD_NEW_LINE
00002F20  4E75                    2652              RTS
00002F22                          2653  
00002F22                          2654  MOVEM:
00002F22  4EB9 00002F7C           2655              JSR     FUK_MOVEM
00002F28  4EB9 0000365C           2656              JSR     LOAD_NEW_LINE
00002F2E  4E75                    2657              RTS
00002F30                          2658      
00002F30                          2659  LEA:
00002F30  367C 2F52               2660              MOVEA.W #LEA_BACK, A3
00002F34  0C38 0000 1775          2661              CMPI.B  #%000, FOURTH_3
00002F3A  6700 066A               2662              BEQ     SIZE_W
00002F3E  0C38 0001 1775          2663              CMPI.B  #%001, FOURTH_3
00002F44  6700 0668               2664              BEQ     SIZE_L
00002F48  0C38 0004 1775          2665              CMPI.B  #%100, FOURTH_3
00002F4E  6700 07BE               2666              BEQ     INVALID 
00002F52                          2667              
00002F52  1638 1774               2668  LEA_BACK    MOVE.B  THIRD_3, D3
00002F56  1438 1775               2669              MOVE.B  FOURTH_3, D2
00002F5A                          2670              
00002F5A  4EB9 000034FA           2671              JSR     LOAD_EA
00002F60  4EB9 0000365E           2672              JSR     LOAD_COMMA_SPACE
00002F66                          2673              
00002F66  163C 0001               2674              MOVE.B  #%001, D3
00002F6A  1438 1772               2675              MOVE.B  FIRST_3, D2
00002F6E                          2676              
00002F6E  4EB9 000034FA           2677              JSR     LOAD_EA
00002F74  4EB9 0000365C           2678              JSR     LOAD_NEW_LINE
00002F7A  4E75                    2679              RTS 
00002F7C                          2680  
00002F7C                          2681  FUK_MOVEM:
00002F7C  4284                    2682              CLR.L   D4
00002F7E  4285                    2683              CLR.L   D5
00002F80  4286                    2684              CLR.L   D6
00002F82  267C 00000000           2685              MOVEA.L #0, A3
00002F88                          2686              
00002F88  1C38 1772               2687              MOVE.B  FIRST_3, D6
00002F8C  0206 0002               2688              ANDI.B  #%010, D6
00002F90  0C06 0002               2689              CMPI.B  #%010, D6
00002F94  6700 0006               2690              BEQ     MOVEM_POST
00002F98  6600 00CE               2691              BNE     MOVEM_PRE
00002F9C                          2692  
00002F9C  0C38 0003 1774          2693  MOVEM_POST  CMPI.B  #%011, THIRD_3
00002FA2  6700 001C               2694              BEQ     MOVEM_POST2
00002FA6  0C38 0002 1774          2695              CMPI.B  #%010, THIRD_3
00002FAC  6700 0012               2696              BEQ     MOVEM_POST2
00002FB0  0C38 0007 1774          2697              CMPI.B  #%111, THIRD_3
00002FB6  6700 0024               2698              BEQ     MOVEM_POST3
00002FBA  4EF9 0000370E           2699              JMP     INVALID
00002FC0                          2700  
00002FC0  1638 1774               2701  MOVEM_POST2 MOVE.B  THIRD_3, D3
00002FC4  1438 1775               2702              MOVE.B  FOURTH_3, D2
00002FC8  4EB9 000034FA           2703              JSR     LOAD_EA
00002FCE  4EB9 0000365E           2704              JSR     LOAD_COMMA_SPACE
00002FD4                          2705  
00002FD4  4EB9 000030C6           2706              JSR     MOVEM_PARSE
00002FDA  4E75                    2707              RTS
00002FDC                          2708  
00002FDC                          2709  MOVEM_POST3 * see if new displacement doesn't exceed END_ADDRESS or A6
00002FDC  4286                    2710              CLR.L   D6
00002FDE  3C0D                    2711              MOVE.W  A5, D6
00002FE0  5406                    2712              ADDI.B  #2, D6
00002FE2  BC4E                    2713              CMP.W   A6, D6
00002FE4  6E00 0728               2714              BGT     INVALID                                 ;Displacement exceeded address
00002FE8                          2715              
00002FE8                          2716              * push A5 pointer +2
00002FE8  544D                    2717              ADDA.W  #2, A5
00002FEA  0C38 0000 1775          2718              CMPI.B  #%000, FOURTH_3
00002FF0  6700 0012               2719              BEQ     MOVEM_POSTW
00002FF4  0C38 0001 1775          2720              CMPI.B  #%001, FOURTH_3
00002FFA  6700 003A               2721              BEQ     MOVEM_POSTL
00002FFE  4EF9 0000370E           2722              JMP     INVALID                                 ;Displacement exceeded address
00003004                          2723              
00003004                          2724  MOVEM_POSTW * see if new displacement doesn't exceed END_ADDRESS or A6
00003004  4286                    2725              CLR.L   D6
00003006  3C0D                    2726              MOVE.W  A5, D6
00003008  5406                    2727              ADDI.B  #2, D6
0000300A  BC4E                    2728              CMP.W   A6, D6
0000300C  6E00 0700               2729              BGT     INVALID                                 ;Displacement exceeded address
00003010                          2730              
00003010                          2731              * munch 2
00003010  31FC 0002 291E          2732              MOVE.W  #$2, TRAILING_SIZE
00003016  1638 1774               2733              MOVE.B  THIRD_3, D3
0000301A  1438 1775               2734              MOVE.B  FOURTH_3, D2
0000301E  4EB9 000034FA           2735              JSR     LOAD_EA
00003024  4EB9 0000365E           2736              JSR     LOAD_COMMA_SPACE
0000302A                          2737              
0000302A                          2738              * push back -4
0000302A  594D                    2739              SUBA.W  #4, A5
0000302C  4EB9 000030C6           2740              JSR     MOVEM_PARSE
00003032                          2741              * push 2
00003032  544D                    2742              ADDA.W  #2, A5
00003034  4E75                    2743              RTS
00003036                          2744  
00003036                          2745  MOVEM_POSTL * see if new displacement doesn't exceed END_ADDRESS or A6
00003036  4286                    2746              CLR.L   D6
00003038  3C0D                    2747              MOVE.W  A5, D6
0000303A  5406                    2748              ADDI.B  #2, D6
0000303C  BC4E                    2749              CMP.W   A6, D6
0000303E  6E00 06CE               2750              BGT     INVALID                                 ;Displacement exceeded address
00003042                          2751              
00003042                          2752              * munch 4
00003042  31FC 0004 291E          2753              MOVE.W  #$4, TRAILING_SIZE
00003048  1638 1774               2754              MOVE.B  THIRD_3, D3
0000304C  1438 1775               2755              MOVE.B  FOURTH_3, D2
00003050  4EB9 000034FA           2756              JSR     LOAD_EA
00003056  4EB9 0000365E           2757              JSR     LOAD_COMMA_SPACE
0000305C                          2758  
0000305C                          2759              * push back -6
0000305C  5D4D                    2760              SUBA.W  #6, A5
0000305E  4EB9 000030C6           2761              JSR     MOVEM_PARSE
00003064                          2762              * push 4
00003064  584D                    2763              ADDA.W  #4, A5
00003066  4E75                    2764              RTS
00003068                          2765  
00003068  4EB9 000030C6           2766  MOVEM_PRE   JSR     MOVEM_PARSE
0000306E  4EB9 0000365E           2767              JSR     LOAD_COMMA_SPACE
00003074                          2768  
00003074  367C 3092               2769              MOVEA.W #MOVEM_PRE_B, A3
00003078  0C38 0000 1775          2770              CMPI.B  #%000, FOURTH_3
0000307E  6700 0526               2771              BEQ     SIZE_W
00003082  0C38 0001 1775          2772              CMPI.B  #%001, FOURTH_3
00003088  6700 0524               2773              BEQ     SIZE_L
0000308C  4EF9 0000370E           2774              JMP     INVALID                                 ;Displacement exceeded address
00003092                          2775              
00003092  0C38 0000 1774          2776  MOVEM_PRE_B CMPI.B  #%000, THIRD_3
00003098  6700 0674               2777              BEQ     INVALID                                 ;Displacement exceeded address
0000309C  0C38 0003 1774          2778              CMPI.B  #%011, THIRD_3
000030A2  6700 066A               2779              BEQ     INVALID
000030A6  0C38 0001 1774          2780              CMPI.B  #%001, THIRD_3
000030AC  6700 0660               2781              BEQ     INVALID
000030B0                          2782              
000030B0  1638 1774               2783              MOVE.B  THIRD_3, D3
000030B4  1438 1775               2784              MOVE.B  FOURTH_3, D2
000030B8                          2785              
000030B8  4EB9 000034FA           2786              JSR     LOAD_EA
000030BE  4EB9 0000365C           2787              JSR     LOAD_NEW_LINE
000030C4  4E75                    2788              RTS
000030C6                          2789              
000030C6                          2790  MOVEM_PARSE:
000030C6  4284                    2791              CLR.L   D4
000030C8  381D                    2792              MOVE.W  (A5)+, D4 * D4 has $00FF
000030CA                          2793                          
000030CA  0C38 0004 1774          2794              CMPI.B  #%100, THIRD_3
000030D0  6600 0006               2795              BNE     ADDRESS_TO_DATA
000030D4  6700 002C               2796              BEQ     DATA_TO_ADDRESS
000030D8                          2797  
000030D8  11FC 0001 2920          2798  ADDRESS_TO_DATA     MOVE.B  #%001, MOVEM_FIRST_VAR          ; MOVEM_FIRST_VAR= A
000030DE  11FC 0000 2921          2799              MOVE.B  #%000, MOVEM_SECOND_VAR                 ; MOVEM_SECOND_VAR= D
000030E4  11FC 0008 2922          2800              MOVE.B  #$8, MOVEM_FIRST_VAR_COUNTER            ; start from 8
000030EA  11FC 0008 2923          2801              MOVE.B  #$8, MOVEM_SECOND_VAR_COUNTER           ; start from 8
000030F0  11FC 0000 2924          2802              MOVE.B  #0, FIRST_VAR_MOVEM
000030F6  11FC 0000 2925          2803              MOVE.B  #0, SECOND_VAR_MOVEM
000030FC                          2804  
000030FC  4EF9 0000321E           2805              JMP     GO_ADDRESS_TO_DATA
00003102                          2806              
00003102  11FC 0000 2920          2807  DATA_TO_ADDRESS     MOVE.B  #%000, MOVEM_FIRST_VAR          ; MOVEM_FIRST_VAR= D
00003108  11FC 0001 2921          2808              MOVE.B  #%001, MOVEM_SECOND_VAR                 ; MOVEM_SECOND_VAR= A
0000310E  11FC 00FF 2922          2809              MOVE.B  #$FF, MOVEM_FIRST_VAR_COUNTER           ; start from -1
00003114  11FC 00FF 2923          2810              MOVE.B  #$FF, MOVEM_SECOND_VAR_COUNTER          ; start from -1
0000311A  11FC 0000 2924          2811              MOVE.B  #0, FIRST_VAR_MOVEM
00003120  11FC 0000 2925          2812              MOVE.B  #0, SECOND_VAR_MOVEM
00003126                          2813              
00003126  4EF9 0000312C           2814              JMP     GO_DATA_TO_ADDRESS
0000312C                          2815  
0000312C  E35C                    2816  GO_DATA_TO_ADDRESS  ROL.W   #1, D4
0000312E  3A04                    2817              MOVE.W  D4, D5
00003130  0245 0001               2818              ANDI.W  #$1, D5
00003134                          2819              
00003134  0C38 0007 2922          2820              CMPI.B  #7, MOVEM_FIRST_VAR_COUNTER
0000313A  6C00 0010               2821              BGE     ADD_Y
0000313E  6D00 0002               2822              BLT     ADD_X
00003142                          2823              
00003142  5238 2922               2824  ADD_X       ADDI.B  #1, MOVEM_FIRST_VAR_COUNTER
00003146  4EF9 0000315C           2825              JMP     KEEP_GOING0
0000314C                          2826  
0000314C  5238 2923               2827  ADD_Y       ADDI.B  #1, MOVEM_SECOND_VAR_COUNTER
00003150  11FC 0008 2922          2828              MOVE.B  #8, MOVEM_FIRST_VAR_COUNTER
00003156  4EF9 0000315C           2829              JMP     KEEP_GOING0
0000315C                          2830              
0000315C  0C45 0001               2831  KEEP_GOING0 CMPI.W  #$1, D5
00003160  6700 0006               2832              BEQ     BIT_ON
00003164  6600 00AA               2833              BNE     KEEP_GOING
00003168                          2834              
00003168  0C38 0008 2922          2835  BIT_ON      CMPI.B  #8, MOVEM_FIRST_VAR_COUNTER
0000316E  6600 0006               2836              BNE     ITS_X
00003172  6700 0036               2837              BEQ     MYBE_Y
00003176                          2838              
00003176  1638 2920               2839  ITS_X       MOVE.B  MOVEM_FIRST_VAR, D3 * LOAD[XX COUNTER]
0000317A  1438 2922               2840              MOVE.B  MOVEM_FIRST_VAR_COUNTER, D2
0000317E  4EB9 000034FA           2841              JSR     LOAD_EA
00003184  0C38 0000 2924          2842              CMPI.B  #0, FIRST_VAR_MOVEM
0000318A  6700 0006               2843              BEQ     FST_X
0000318E  6600 0012               2844              BNE     SND_X
00003192                          2845  
00003192  18FC 002D               2846  FST_X       MOVE.B  #$2D, (A4)+ * LOAD '-'
00003196  11FC 0001 2924          2847              MOVE.B  #1, FIRST_VAR_MOVEM                     ;FIRST_VAR_MOVEM = 1
0000319C  4EF9 00003210           2848              JMP     KEEP_GOING
000031A2                          2849              
000031A2  554C                    2850  SND_X       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
000031A4  4EF9 00003210           2851              JMP     KEEP_GOING
000031AA                          2852  
000031AA  0C38 0008 2923          2853  MYBE_Y      CMPI.B  #8, MOVEM_SECOND_VAR_COUNTER
000031B0  6600 0006               2854              BNE     ITS_Y
000031B4  6700 005A               2855              BEQ     KEEP_GOING
000031B8                          2856  
000031B8  0C38 0000 2925          2857  ITS_Y       CMPI.B  #0, SECOND_VAR_MOVEM
000031BE  6700 001E               2858              BEQ     FST_Y1
000031C2  1638 2921               2859  ITS_Y_BACK  MOVE.B  MOVEM_SECOND_VAR, D3 * LOAD[YY COUNTER]
000031C6  1438 2923               2860              MOVE.B  MOVEM_SECOND_VAR_COUNTER, D2
000031CA  4EB9 000034FA           2861              JSR     LOAD_EA
000031D0  0C38 0000 2925          2862              CMPI.B  #0, SECOND_VAR_MOVEM
000031D6  6700 0020               2863              BEQ     FST_Y2
000031DA  6600 002C               2864              BNE     SND_Y
000031DE                          2865  
000031DE  0C38 0001 2924          2866  FST_Y1      CMPI.B  #1, FIRST_VAR_MOVEM
000031E4  6600 000E               2867              BNE     SKIP_HERE
000031E8                          2868              ;ADDA.W #2, A4 * push G_BUFFER pointer by 2
000031E8                          2869                          
000031E8  18FC 0020               2870              MOVE.B  #$20, (A4)+
000031EC  18FC 0020               2871              MOVE.B  #$20, (A4)+
000031F0                          2872  
000031F0  18FC 002F               2873              MOVE.B  #$2F, (A4)+ * LOAD '/'
000031F4  4EF8 31C2               2874  SKIP_HERE   JMP     ITS_Y_BACK
000031F8                          2875  
000031F8  18FC 002D               2876  FST_Y2      MOVE.B  #$2D, (A4)+ * LOAD '-'
000031FC  11FC 0001 2925          2877              MOVE.B  #1, SECOND_VAR_MOVEM                ; SECOND_VAR_MOVEM= 1
00003202  4EF9 00003210           2878              JMP     KEEP_GOING
00003208                          2879  
00003208  554C                    2880  SND_Y       SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
0000320A  4EF9 00003210           2881              JMP     KEEP_GOING
00003210                          2882  
00003210  0C38 0008 2923          2883  KEEP_GOING  CMPI.B  #8, MOVEM_SECOND_VAR_COUNTER
00003216  6600 FF14               2884              BNE     GO_DATA_TO_ADDRESS
0000321A                          2885              
0000321A  544C                    2886              ADDA.W  #2, A4 * push G_BUFFER pointer by 2
0000321C  4E75                    2887              RTS
0000321E                          2888  
0000321E                          2889  
0000321E  E35C                    2890  GO_ADDRESS_TO_DATA  ROL.W   #1, D4
00003220  3A04                    2891              MOVE.W  D4, D5
00003222  0245 0001               2892              ANDI.W  #$1, D5
00003226                          2893              
00003226  0C38 0000 2922          2894              CMPI.B  #0, MOVEM_FIRST_VAR_COUNTER
0000322C  6E00 0006               2895              BGT     SUBTRACT_X 
00003230  6F00 000C               2896              BLE     SUBTRACT_Y 
00003234                          2897              
00003234  5338 2922               2898  SUBTRACT_X  SUBI.B  #1, MOVEM_FIRST_VAR_COUNTER
00003238  4EF9 0000324E           2899              JMP     KEEP_GOING1
0000323E                          2900  
0000323E  5338 2923               2901  SUBTRACT_Y  SUBI.B  #1, MOVEM_SECOND_VAR_COUNTER
00003242  11FC 00FF 2922          2902              MOVE.B  #$FF, MOVEM_FIRST_VAR_COUNTER
00003248  4EF9 0000324E           2903              JMP     KEEP_GOING1
0000324E                          2904              
0000324E  0C45 0001               2905  KEEP_GOING1 CMPI.W  #$1, D5
00003252  6700 0006               2906              BEQ     BIT_ON2
00003256  6600 00AA               2907              BNE     KEEP_GOING2
0000325A                          2908              
0000325A  0C38 00FF 2922          2909  BIT_ON2     CMPI.B  #$FF, MOVEM_FIRST_VAR_COUNTER
00003260  6600 0006               2910              BNE     ITS_X2
00003264  6700 0036               2911              BEQ     MYBE_Y2
00003268                          2912              
00003268  1638 2920               2913  ITS_X2      MOVE.B  MOVEM_FIRST_VAR, D3 * LOAD[XX COUNTER]
0000326C  1438 2922               2914              MOVE.B  MOVEM_FIRST_VAR_COUNTER, D2
00003270  4EB9 000034FA           2915              JSR     LOAD_EA
00003276  0C38 0000 2924          2916              CMPI.B  #0, FIRST_VAR_MOVEM
0000327C  6700 0006               2917              BEQ     FST_X2
00003280  6600 0012               2918              BNE     SND_X2
00003284                          2919  
00003284  18FC 002D               2920  FST_X2      MOVE.B  #$2D, (A4)+ * LOAD '-'
00003288  11FC 0001 2924          2921              MOVE.B  #1, FIRST_VAR_MOVEM             ; FIRST_VAR_MOVEM = 1
0000328E  4EF9 00003302           2922              JMP     KEEP_GOING2
00003294                          2923              
00003294  554C                    2924  SND_X2      SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
00003296  4EF9 00003302           2925              JMP     KEEP_GOING2
0000329C                          2926  
0000329C  0C38 00FF 2923          2927  MYBE_Y2     CMPI.B  #$FF, MOVEM_SECOND_VAR_COUNTER
000032A2  6600 0006               2928              BNE     ITS_Y2
000032A6  6700 005A               2929              BEQ     KEEP_GOING2
000032AA                          2930  
000032AA  0C38 0000 2925          2931  ITS_Y2      CMPI.B  #0, SECOND_VAR_MOVEM
000032B0  6700 001E               2932              BEQ     FST_Y3
000032B4  1638 2921               2933  ITS_Y2_BACK MOVE.B  MOVEM_SECOND_VAR, D3 * LOAD[YY COUNTER]
000032B8  1438 2923               2934              MOVE.B  MOVEM_SECOND_VAR_COUNTER, D2
000032BC  4EB9 000034FA           2935              JSR     LOAD_EA
000032C2  0C38 0000 2925          2936              CMPI.B  #0, SECOND_VAR_MOVEM
000032C8  6700 0020               2937              BEQ     FST_Y4
000032CC  6600 002C               2938              BNE     SND_Y2
000032D0                          2939  
000032D0  0C38 0001 2924          2940  FST_Y3      CMPI.B  #1, FIRST_VAR_MOVEM
000032D6  6600 000E               2941              BNE     SKIP_HERE2
000032DA                          2942              ;ADDA.W #2, A4 * push G_BUFFER pointer by 2
000032DA                          2943              
000032DA  18FC 0020               2944              MOVE.B  #$20, (A4)+
000032DE  18FC 0020               2945              MOVE.B  #$20, (A4)+
000032E2                          2946              
000032E2  18FC 002F               2947              MOVE.B  #$2F, (A4)+ * LOAD '/'
000032E6  4EF8 32B4               2948  SKIP_HERE2  JMP     ITS_Y2_BACK
000032EA                          2949  
000032EA  18FC 002D               2950  FST_Y4      MOVE.B  #$2D, (A4)+ * LOAD '-'
000032EE  11FC 0001 2925          2951              MOVE.B  #1, SECOND_VAR_MOVEM                    ; SECOND_VAR_MOVEM= 1
000032F4  4EF9 00003302           2952              JMP     KEEP_GOING2
000032FA                          2953  
000032FA  554C                    2954  SND_Y2      SUBA.W  #2, A4 * push back G_BUFFER pointer by 2
000032FC  4EF9 00003302           2955              JMP     KEEP_GOING2
00003302                          2956  
00003302  0C38 00FF 2923          2957  KEEP_GOING2 CMPI.B  #$FF, MOVEM_SECOND_VAR_COUNTER
00003308  6600 FF14               2958              BNE     GO_ADDRESS_TO_DATA   
0000330C                          2959              
0000330C  544C                    2960              ADDA.W  #2, A4 * push G_BUFFER pointer by 2
0000330E  4E75                    2961              RTS
00003310                          2962  LOAD_0000:
00003310  4283                    2963              CLR.L   D3
00003312  4282                    2964              CLR.L   D2
00003314  267C 00000000           2965              MOVEA.L #0, A3
0000331A                          2966  
0000331A  0C38 0000 1772          2967              CMPI.B  #%000, FIRST_3
00003320  6700 0006               2968              BEQ     MYBE_ORI
00003324  6600 000C               2969              BNE     NOT_ORI
00003328  0C38 0003 1773          2970  MYBE_ORI    CMPI.B  #%011, SECOND_3
0000332E  6D00 0042               2971              BLT     ORI_CMPI            
00003332                          2972  
00003332  0C38 0006 1772          2973  NOT_ORI     CMPI.B  #%110, FIRST_3
00003338  6700 0006               2974              BEQ     MYBE_CMPI
0000333C  6600 000C               2975              BNE     NOT_CMPI
00003340  0C38 0003 1773          2976  MYBE_CMPI   CMPI.B  #%011, SECOND_3
00003346  6D00 002A               2977              BLT     ORI_CMPI
0000334A                          2978              
0000334A  0C38 0004 1772          2979  NOT_CMPI    CMPI.B  #%100, FIRST_3
00003350  6700 0006               2980              BEQ     MYBE_BCLR
00003354  6600 000C               2981              BNE     NOT_BCLR
00003358  0C38 0002 1773          2982  MYBE_BCLR   CMPI.B  #%010, SECOND_3
0000335E  6700 0080               2983              BEQ     BCLR
00003362                          2984  
00003362  0C38 0006 1773          2985  NOT_BCLR    CMPI.B  #%110, SECOND_3
00003368  6700 00E0               2986              BEQ     DYNMC_BCLR
0000336C                          2987              
0000336C  4EF9 0000370E           2988              JMP     INVALID
00003372                          2989              
00003372  367C 3394               2990  ORI_CMPI    MOVEA.W #BACK, A3
00003376  0C38 0000 1773          2991              CMPI.B  #%000, SECOND_3
0000337C  6700 0220               2992              BEQ     SIZE_B
00003380  0C38 0001 1773          2993              CMPI.B  #%001, SECOND_3
00003386  6700 021E               2994              BEQ     SIZE_W
0000338A  0C38 0002 1773          2995              CMPI.B  #%010, SECOND_3
00003390  6700 021C               2996              BEQ     SIZE_L
00003394                          2997  
00003394  163C 0007               2998  BACK        MOVE.B  #%111, D3
00003398  143C 0004               2999              MOVE.B  #%100, D2
0000339C                          3000              
0000339C  4EB9 000034FA           3001              JSR     LOAD_EA
000033A2  4EB9 0000365E           3002              JSR     LOAD_COMMA_SPACE
000033A8                          3003              
000033A8  367C 33CA               3004              MOVEA.W #BACK2, A3   
000033AC  0C38 0000 1775          3005              CMPI.B  #%000, FOURTH_3
000033B2  6700 01F2               3006              BEQ     SIZE_W
000033B6  0C38 0001 1775          3007              CMPI.B  #%001, FOURTH_3
000033BC  6700 01F0               3008              BEQ     SIZE_L
000033C0  0C38 0004 1775          3009              CMPI.B  #%100, FOURTH_3 
000033C6  6700 0346               3010              BEQ     INVALID 
000033CA                          3011  
000033CA  1638 1774               3012  BACK2       MOVE.B  THIRD_3, D3
000033CE  1438 1775               3013              MOVE.B  FOURTH_3, D2
000033D2                          3014          
000033D2  4EB9 000034FA           3015              JSR     LOAD_EA
000033D8  4EB9 0000365C           3016              JSR     LOAD_NEW_LINE
000033DE  4E75                    3017              RTS
000033E0                          3018  
000033E0  4285                    3019  BCLR        CLR.L   D5
000033E2  4284                    3020              CLR.L   D4
000033E4  247C 00000000           3021              MOVEA.L #0, A2
000033EA                          3022  
000033EA  3A0E                    3023              MOVE.W  A6, D5
000033EC  9A4D                    3024              SUB.W   A5, D5
000033EE  0C45 0002               3025              CMPI.W  #$2, D5
000033F2  6D00 031A               3026              BLT     INVALID
000033F6                          3027  
000033F6  381D                    3028              MOVE.W  (A5)+, D4
000033F8  4284                    3029              CLR.L   D4
000033FA  381D                    3030              MOVE.W  (A5)+, D4
000033FC  0244 00FF               3031              ANDI.W  #$00FF, D4
00003400  247C 0000340C           3032              MOVEA.L #BACK4, A2
00003406  4EF9 00003628           3033              JMP     LOAD_IMMDTE
0000340C                          3034              
0000340C  4EB9 0000365E           3035  BACK4       JSR     LOAD_COMMA_SPACE
00003412                          3036              
00003412  367C 3434               3037              MOVEA.W #BACK3, A3
00003416  0C38 0000 1775          3038              CMPI.B  #%000, FOURTH_3
0000341C  6700 0188               3039              BEQ     SIZE_W
00003420  0C38 0001 1775          3040              CMPI.B  #%001, FOURTH_3
00003426  6700 0186               3041              BEQ     SIZE_L
0000342A  0C38 0004 1775          3042              CMPI.B  #%100, FOURTH_3 
00003430  6700 02DC               3043              BEQ     INVALID 
00003434                          3044  
00003434  1638 1774               3045  BACK3       MOVE.B  THIRD_3, D3
00003438  1438 1775               3046              MOVE.B  FOURTH_3, D2
0000343C                          3047  
0000343C  4EB9 000034FA           3048              JSR     LOAD_EA
00003442  4EB9 0000365C           3049              JSR     LOAD_NEW_LINE
00003448                          3050  
00003448  4E75                    3051              RTS
0000344A                          3052  
0000344A  163C 0000               3053  DYNMC_BCLR  MOVE.B  #%000, D3
0000344E  1438 1772               3054              MOVE.B  FIRST_3, D2
00003452                          3055              
00003452  4EB9 000034FA           3056              JSR     LOAD_EA
00003458  4EB9 0000365E           3057              JSR     LOAD_COMMA_SPACE
0000345E                          3058  
0000345E  367C 3480               3059              MOVEA.W #BACK5, A3
00003462  0C38 0000 1775          3060              CMPI.B  #%000, FOURTH_3
00003468  6700 013C               3061              BEQ     SIZE_W
0000346C  0C38 0001 1775          3062              CMPI.B  #%001, FOURTH_3
00003472  6700 013A               3063              BEQ     SIZE_L
00003476  0C38 0004 1775          3064              CMPI.B  #%100, FOURTH_3 
0000347C  6700 0290               3065              BEQ     INVALID 
00003480                          3066              
00003480  1638 1774               3067  BACK5       MOVE.B  THIRD_3, D3
00003484  1438 1775               3068              MOVE.B  FOURTH_3, D2
00003488                          3069              
00003488  4EB9 000034FA           3070              JSR     LOAD_EA
0000348E  4EB9 0000365C           3071              JSR     LOAD_NEW_LINE
00003494                          3072              
00003494  4E75                    3073              RTS
00003496                          3074  
00003496                          3075  LOAD_00XX:
00003496  4283                    3076          CLR.L   D3
00003498  4282                    3077          CLR.L   D2
0000349A  267C 00000000           3078          MOVEA.L #0, A3
000034A0                          3079          
000034A0  367C 34B8               3080          MOVEA.W #GOO, A3
000034A4  0C38 0003 1771          3081          CMPI.B  #%0011, MNEMONIC
000034AA  6700 00FA               3082          BEQ     SIZE_W
000034AE  0C38 0002 1771          3083          CMPI.B  #%0010, MNEMONIC
000034B4  6700 00F8               3084          BEQ     SIZE_L
000034B8                          3085  
000034B8  1638 1774               3086  GOO     MOVE.B  THIRD_3, D3
000034BC  1438 1775               3087          MOVE.B  FOURTH_3, D2
000034C0                          3088      
000034C0  4EB9 000034FA           3089          JSR     LOAD_EA
000034C6  4EB9 0000365E           3090          JSR     LOAD_COMMA_SPACE
000034CC                          3091      
000034CC  367C 34E4               3092          MOVEA.W #GOO2, A3
000034D0  0C38 0000 1772          3093          CMPI.B  #%000, FIRST_3
000034D6  6700 00CE               3094          BEQ     SIZE_W
000034DA  0C38 0001 1772          3095          CMPI.B  #%001, FIRST_3
000034E0  6700 00CC               3096          BEQ     SIZE_L
000034E4                          3097      
000034E4  1638 1773               3098  GOO2    MOVE.B  SECOND_3, D3
000034E8  1438 1772               3099          MOVE.B  FIRST_3, D2
000034EC                          3100              
000034EC  4EB9 000034FA           3101          JSR     LOAD_EA
000034F2  4EB9 0000365C           3102          JSR     LOAD_NEW_LINE
000034F8                          3103      
000034F8  4E75                    3104          RTS
000034FA                          3105  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000034FA                          3106  
000034FA                          3107  
000034FA                          3108  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000034FA                          3109  
000034FA                          3110  LOAD_EA:
000034FA  347C 350A               3111          MOVEA.W #SAVED, A2 * remember to come back!
000034FE                          3112  
000034FE  0C43 0007               3113          CMPI    #%111, D3
00003502  6D00 0008               3114          BLT     LOAD_LT_111
00003506  6C00 0032               3115          BGE     LOAD_GE_111
0000350A                          3116      
0000350A  4E75                    3117  SAVED   RTS
0000350C                          3118  
0000350C                          3119  LOAD_LT_111:
0000350C  0C43 0000               3120      CMPI    #%000, D3 * e.g. D3
00003510  6700 00A4               3121      BEQ     LOAD_DATA_REGISTER
00003514  0C43 0001               3122      CMPI    #%001, D3 * e.g. A3
00003518  6700 00AE               3123      BEQ     LOAD_ADDR_REGISTER
0000351C  0C43 0002               3124      CMPI    #%010, D3 * e.g. (A3)
00003520  6700 00B8               3125      BEQ     LOAD_ADDRESS
00003524  0C43 0003               3126      CMPI    #%011, D3 * e.g. (A3)+
00003528  6700 00C2               3127      BEQ     LOAD_ADDRESS_W_POST_INC
0000352C  0C43 0004               3128      CMPI    #%100, D3 * e.g. -(A3)
00003530  6700 00C6               3129      BEQ     LOAD_ADDRESS_W_PRE_DEC
00003534                          3130      
00003534  4EF9 0000370E           3131      JMP     INVALID
0000353A                          3132      
0000353A                          3133  LOAD_GE_111:
0000353A  4285                    3134              CLR.L   D5
0000353C  4284                    3135              CLR.L   D4
0000353E                          3136  
0000353E  3A0E                    3137              MOVE.W  A6, D5
00003540  9A4D                    3138              SUB.W   A5, D5
00003542  BA78 291E               3139              CMP.W   TRAILING_SIZE, D5
00003546  6D00 01C6               3140              BLT     INVALID
0000354A                          3141  
0000354A  0C78 0001 291E          3142              CMPI.W  #$1, TRAILING_SIZE
00003550  6700 0016               3143              BEQ     CHUMP_BYTE
00003554  0C78 0002 291E          3144              CMPI.W  #$2, TRAILING_SIZE
0000355A  6700 0014               3145              BEQ     CHUMP_WORD
0000355E  0C78 0004 291E          3146              CMPI.W  #$4, TRAILING_SIZE
00003564  6700 0012               3147              BEQ     CHUMP_LONG
00003568                          3148  
00003568  381D                    3149  CHUMP_BYTE  MOVE.W  (A5)+, D4 * Minimum 4 hex (e.g. MOVE.B #1, $2 = XXXX 0001 0002)
0000356A  4EF9 00003580           3150              JMP     GO
00003570                          3151  
00003570  381D                    3152  CHUMP_WORD  MOVE.W  (A5)+, D4
00003572  4EF9 00003580           3153              JMP     GO
00003578                          3154              
00003578  281D                    3155  CHUMP_LONG  MOVE.L  (A5)+, D4
0000357A  4EF9 00003580           3156              JMP     GO
00003580                          3157  
00003580  0C42 0000               3158  GO          CMPI    #%000, D2
00003584  6700 007E               3159              BEQ     LOAD_ABS_SHORT
00003588  0C42 0001               3160              CMPI    #%001, D2
0000358C  6700 0088               3161              BEQ     LOAD_ABS_LONG
00003590  0C42 0004               3162              CMPI    #%100, D2
00003594  6700 0092               3163              BEQ     LOAD_IMMDTE
00003598                          3164      
00003598  4EF9 0000370E           3165              JMP     INVALID
0000359E                          3166  TRAILING_HELPER:            
0000359E  31FC 0002 291E          3167  SIZE_B  MOVE.W  #$2, TRAILING_SIZE
000035A4  4ED3                    3168          JMP     (A3)
000035A6                          3169  
000035A6  31FC 0002 291E          3170  SIZE_W  MOVE.W  #$2, TRAILING_SIZE
000035AC  4ED3                    3171          JMP     (A3)
000035AE                          3172          
000035AE  31FC 0004 291E          3173  SIZE_L  MOVE.W  #$4, TRAILING_SIZE
000035B4  4ED3                    3174          JMP     (A3)
000035B6                          3175  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000035B6                          3176  
000035B6                          3177  
000035B6                          3178  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000035B6                          3179  
000035B6                          3180  LOAD_DATA_REGISTER:
000035B6  4280                    3181      CLR.L   D0
000035B8                          3182      
000035B8  4EB9 00003676           3183      JSR     LOAD_D
000035BE  1002                    3184      MOVE.B  D2, D0
000035C0  4EB9 000036EA           3185      JSR     LOAD_NUM
000035C6  4ED2                    3186      JMP     (A2)
000035C8                          3187  
000035C8                          3188  LOAD_ADDR_REGISTER:
000035C8  4280                    3189      CLR.L   D0
000035CA                          3190  
000035CA  4EB9 00003684           3191      JSR     LOAD_A
000035D0  1002                    3192      MOVE.B  D2, D0
000035D2  4EB9 000036EA           3193      JSR     LOAD_NUM
000035D8  4ED2                    3194      JMP     (A2)
000035DA                          3195  
000035DA                          3196  LOAD_ADDRESS:
000035DA  4EB9 00003692           3197      JSR     LOAD_PTHSIS_OPEN
000035E0  4EB8 35C8               3198      JSR     LOAD_ADDR_REGISTER
000035E4  4EB9 000036A0           3199      JSR     LOAD_PTHSIS_CLSD
000035EA  4ED2                    3200      JMP     (A2)
000035EC                          3201  
000035EC                          3202  LOAD_ADDRESS_W_POST_INC:
000035EC  4EB8 35DA               3203      JSR     LOAD_ADDRESS
000035F0  4EB9 000036CA           3204      JSR     LOAD_PLUS_SIGN
000035F6  4ED2                    3205      JMP     (A2)
000035F8                          3206  
000035F8                          3207  LOAD_ADDRESS_W_PRE_DEC:
000035F8  4EB9 000036D8           3208      JSR     LOAD_MINUS_SIGN
000035FE  4EB8 35DA               3209      JSR     LOAD_ADDRESS
00003602  4ED2                    3210      JMP     (A2)
00003604                          3211  
00003604                          3212  LOAD_ABS_SHORT:
00003604  4280                    3213      CLR.L   D0
00003606                          3214  
00003606  4EB9 000036AE           3215      JSR     LOAD_HEX_SIGN
0000360C  3004                    3216      MOVE.W  D4, D0
0000360E  4EB9 00003632           3217      JSR     LOAD_BYTES
00003614  4ED2                    3218      JMP     (A2)
00003616                          3219  
00003616                          3220  LOAD_ABS_LONG:
00003616  4280                    3221      CLR.L   D0
00003618                          3222  
00003618  4EB9 000036AE           3223      JSR     LOAD_HEX_SIGN
0000361E  2004                    3224      MOVE.L  D4, D0
00003620  4EB9 00003632           3225      JSR     LOAD_BYTES
00003626  4ED2                    3226      JMP     (A2)
00003628                          3227  
00003628                          3228  LOAD_IMMDTE:
00003628  4EB9 000036BC           3229      JSR     LOAD_IMMDTE_VALU
0000362E  4EF8 3616               3230      JMP     LOAD_ABS_LONG
00003632                          3231  
00003632                          3232  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003632                          3233  
00003632                          3234  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003632                          3235  
00003632                          3236  LOAD_BYTES:
00003632  4285                    3237          CLR.L   D5
00003634  4281                    3238          CLR.L   D1
00003636                          3239  
00003636  2200                    3240          MOVE.L  D0, D1
00003638  1A3C 0008               3241          MOVE.B  #8, D5
0000363C  0C45 0000               3242  LOOP    CMPI    #0, D5
00003640  6E00 0004               3243          BGT     ROTATE
00003644  4E75                    3244          RTS
00003646                          3245      
00003646  E999                    3246  ROTATE  ROL.L   #$04, D1
00003648  1001                    3247          MOVE.B  D1, D0
0000364A  0280 0000000F           3248          ANDI.L  #$0000000F, D0
00003650  4EB9 000036EA           3249          JSR     LOAD_NUM
00003656  5345                    3250          SUBI    #1, D5
00003658  4EF8 363C               3251          JMP     LOOP        
0000365C                          3252  
0000365C                          3253  LOAD_NEW_LINE:
0000365C  4E75                    3254      RTS
0000365E                          3255  
0000365E                          3256  LOAD_COMMA_SPACE:
0000365E  4280                    3257      CLR.L   D0
00003660                          3258  
00003660  1038 291C               3259      MOVE.B  COMMA, D0
00003664  4EB9 000036E6           3260      JSR     LOAD_THIS_SHIT
0000366A  1038 291D               3261      MOVE.B  SPACE, D0
0000366E  4EB9 000036E6           3262      JSR     LOAD_THIS_SHIT
00003674                          3263      
00003674  4E75                    3264      RTS
00003676                          3265  
00003676                          3266  LOAD_D:
00003676  4280                    3267      CLR.L   D0
00003678                          3268  
00003678  1038 2915               3269      MOVE.B  DATA, D0
0000367C  4EB9 000036E6           3270      JSR     LOAD_THIS_SHIT
00003682  4E75                    3271      RTS
00003684                          3272  
00003684                          3273  LOAD_A:
00003684  4280                    3274      CLR.L   D0
00003686                          3275  
00003686  1038 2914               3276      MOVE.B  ADDRESS, D0
0000368A  4EB9 000036E6           3277      JSR     LOAD_THIS_SHIT
00003690  4E75                    3278      RTS
00003692                          3279  
00003692                          3280  LOAD_PTHSIS_OPEN:
00003692  4280                    3281      CLR.L   D0
00003694                          3282  
00003694  1038 2916               3283      MOVE.B  PTHSIS_OPEN, D0
00003698  4EB9 000036E6           3284      JSR     LOAD_THIS_SHIT
0000369E  4E75                    3285      RTS
000036A0                          3286  
000036A0                          3287  LOAD_PTHSIS_CLSD:
000036A0  4280                    3288      CLR.L   D0
000036A2                          3289  
000036A2  1038 2917               3290      MOVE.B  PTHSIS_CLSD, D0
000036A6  4EB9 000036E6           3291      JSR     LOAD_THIS_SHIT
000036AC  4E75                    3292      RTS
000036AE                          3293  
000036AE                          3294  LOAD_HEX_SIGN:
000036AE  4280                    3295      CLR.L   D0
000036B0                          3296  
000036B0  1038 2918               3297      MOVE.B  HEX_SIGN, D0
000036B4  4EB9 000036E6           3298      JSR     LOAD_THIS_SHIT
000036BA  4E75                    3299      RTS
000036BC                          3300  
000036BC                          3301  LOAD_IMMDTE_VALU:
000036BC  4280                    3302      CLR.L   D0
000036BE                          3303  
000036BE  1038 2919               3304      MOVE.B  IMMDTE_VALU, D0
000036C2  4EB9 000036E6           3305      JSR     LOAD_THIS_SHIT
000036C8  4E75                    3306      RTS
000036CA                          3307  
000036CA                          3308  LOAD_PLUS_SIGN:
000036CA  4280                    3309      CLR.L   D0
000036CC                          3310  
000036CC  1038 291A               3311      MOVE.B  PLUS_SIGN, D0
000036D0  4EB9 000036E6           3312      JSR     LOAD_THIS_SHIT
000036D6  4E75                    3313      RTS
000036D8                          3314  
000036D8                          3315  LOAD_MINUS_SIGN:
000036D8  4280                    3316      CLR.L   D0
000036DA                          3317  
000036DA  1038 291B               3318      MOVE.B  MINUS_SIGN, D0
000036DE  4EB9 000036E6           3319      JSR     LOAD_THIS_SHIT
000036E4  4E75                    3320      RTS
000036E6                          3321  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000036E6                          3322  
000036E6                          3323  
000036E6                          3324  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000036E6                          3325  LOAD_THIS_SHIT:
000036E6  18C0                    3326      MOVE.B  D0, (A4)+                                       ;Post-increment G_BUFFER and load value into it
000036E8  4E75                    3327      RTS                                                     ;Return to stack
000036EA                          3328  
000036EA                          3329  LOAD_NUM:
000036EA  0C00 0009               3330      CMPI.B  #$9, D0
000036EE  6E00 0006               3331      BGT     GT
000036F2  6F00 000C               3332      BLE     LE
000036F6                          3333      
000036F6  0600 0037               3334  GT  ADDI.B  #$37, D0 * A~F
000036FA  4EF9 0000370A           3335      JMP     END
00003700  0600 0030               3336  LE  ADDI.B  #$30, D0 * 0~9
00003704  4EF9 0000370A           3337      JMP     END
0000370A                          3338  
0000370A  18C0                    3339  END MOVE.B  D0, (A4)+
0000370C  4E75                    3340      RTS
0000370E                          3341  
0000370E                          3342  INVALID:
0000370E  11FC 0000 10A2          3343              MOVE.B  #%0, IS_VALID
00003714  4EF8 2930               3344              JMP     EXT
00003718                          3345  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00003718                          3346  
00003718                          3347  -------------------- end include --------------------
00003718                          3348      INCLUDE "MOVEM_TEST.x68"                                ;Test program to include
00003718                          3349      
00009000                          3350      ORG $9000
00009000  48A1 787F               3351      MOVEM.W   D1-D4/A1-A7,-(A1)
00009004                          3352  
00009004  48A1 7F7F               3353      MOVEM.W   A1-A7/D1-D7,-(A1)
00009008                          3354  
00009008  48E1 7F00               3355      MOVEM.L   D1-D7,-(A1)
0000900C                          3356  
0000900C  48A1 0140               3357      MOVEM.W   A1/D7,-(A1)
00009010                          3358  
00009010  48E1 0140               3359      MOVEM.L   A1/D7,-(A1)
00009014                          3360  
00009014  4891 FE00               3361      MOVEM.W   A1-A7,(A1)
00009018                          3362  
00009018  48D1 00FE               3363      MOVEM.L   D1-D7,(A1)
0000901C                          3364  
0000901C  4891 0280               3365      MOVEM.W   A1/D7,(A1)
00009020                          3366  
00009020  48D1 0280               3367      MOVEM.L   A1/D7,(A1)
00009024                          3368  
00009024  4C99 FE00               3369      MOVEM.W   (A1)+,A1-A7
00009028                          3370  
00009028  4CD9 00FE               3371      MOVEM.L   (A1)+,D1-D7
0000902C                          3372  
0000902C  4C99 0280               3373      MOVEM.W   (A1)+,A1/D7
00009030                          3374  
00009030  4CD9 0280               3375      MOVEM.L   (A1)+,A1/D7
00009034                          3376  
00009034  4C91 FE00               3377      MOVEM.W   (A1),A1-A7
00009038                          3378  
00009038  4CD1 00FE               3379      MOVEM.L   (A1),D1-D7
0000903C                          3380  
0000903C  4C91 0280               3381      MOVEM.W   (A1),A1/D7
00009040                          3382  
00009040  4CD1 0280               3383      MOVEM.L   (A1),A1/D7
00009044                          3384      
00009044                          3385  
00009044                          3386  
00009044                          3387  
00009044                          3388  -------------------- end include --------------------
00009044                          3389      
00009044                          3390      
Line 3391 WARNING: Origin value is odd (Location counter set to next highest address)
00009044                          3391     END    START                                 ;Last line of program

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA                2C0A
ADDA_BACK           2C28
ADDRESS             2914
ADDRESS_TO_DATA     30D8
ADDSTRTOBUFFER      1298
ADD_CHAR_TO_STRING  1370
ADD_X               3142
ADD_Y               314C
ASCIITOHEX          1418
ASCIITOHEXREGLIST   1
ASCII_VAL           172A
ASD_1               2A0C
ASD_1_BACK          2A38
ASD_2               2A64
ASD_2_IMD           2A7A
ASD_2_IMD_B         2AA0
ASD_2_REG           2ABC
BACK                3394
BACK2               33CA
BACK3               3434
BACK4               340C
BACK5               3480
BCLR                33E0
BIT_CHECK_EXG       2284
BIT_CHECK_EXT       1D6C
BIT_CHECK_MOVEP     1ADE
BIT_CHECK_SUBX      21A0
BIT_ON              3168
BIT_ON2             325A
BIT_SIZE_CHECK      22DC
BRA                 2B48
BRA_BYTE            2B74
BRA_BYTE2           2B9A
BRA_BYTE3           2BA6
BRA_WORD            2BAE
BRA_WORD_BK         2BCA
BRA_WRD_BK2         2BE8
BUFFER_ADD_SUCCESS  1296
BUFFER_LENGTH_EXCEEDED  12E0
BUFFER_POINTER      128E
BUFFER_POINTER_LENGTH  1292
BUFFER_STRING_END   12E6
BYTEREAD            1729
B_BUFFER            1050
CHARNUM_TO_CONVERT  1318
CHECK_00XX          2998
CHECK_01XX          29A6
CHECK_0XXX          2944
CHECK_1XXX          2954
CHECK_OP_ABCD       226C
CHECK_OP_ADD        2306
CHECK_OP_ADDA       2310
CHECK_OP_ADDI       1A3E
CHECK_OP_ADDQ       1F62
CHECK_OP_ADDX       22F2
CHECK_OP_AND        22BC
CHECK_OP_ANDI       1A16
CHECK_OP_ANDI_TO_CCR  19D6
CHECK_OP_ANDI_TO_SR  19E6
CHECK_OP_ASL        24BE
CHECK_OP_ASL_NO_ROT  23E6
CHECK_OP_ASR        24A0
CHECK_OP_ASR_NO_ROT  23CC
CHECK_OP_BCC        1FCC
CHECK_OP_BCS        2072
CHECK_OP_BEQ        1FE0
CHECK_OP_BGE        208C
CHECK_OP_BGT        1FB8
CHECK_OP_BHI        1FF4
CHECK_OP_BLS        2008
CHECK_OP_BLT        20A6
CHECK_OP_BMI        201C
CHECK_OP_BNE        2030
CHECK_OP_BPL        2044
CHECK_OP_BRA        2058
CHECK_OP_BSR        1FA4
CHECK_OP_BVC        20C0
CHECK_OP_CHK        1E4E
CHECK_OP_CLR        1D30
CHECK_OP_CMP        222A
CHECK_OP_CMPA       21F8
CHECK_OP_CMPI       1B2A
CHECK_OP_CMPM       21E4
CHECK_OP_DBCC       1F3A
CHECK_OP_DIVS       2132
CHECK_OP_DIVU       210A
CHECK_OP_DYNAMIC_BCHG  1AB6
CHECK_OP_DYNAMIC_BCLR  1B66
CHECK_OP_DYNAMIC_BSET  1ACA
CHECK_OP_DYNAMIC_BTST  1AA2
CHECK_OP_EOR        220C
CHECK_OP_EORI       1A52
CHECK_OP_EORI_TO_CCR  19F6
CHECK_OP_EORI_TO_SR  1A06
CHECK_OP_EXG        2280
CHECK_OP_EXT        1D58
CHECK_OP_ILLEGAL    1CA0
CHECK_OP_JMP        1E3A
CHECK_OP_JSR        1EA8
CHECK_OP_LEA        1E8E
CHECK_OP_LINK       1DFE
CHECK_OP_LSL        2482
CHECK_OP_LSL_NO_ROT  23B2
CHECK_OP_LSR        2464
CHECK_OP_LSR_NO_ROT  2398
CHECK_OP_MOVEA_L    1BBE
CHECK_OP_MOVEA_W    1C20
CHECK_OP_MOVEM_L    1F10
CHECK_OP_MOVEM_W    1EF6
CHECK_OP_MOVEP      1AF8
CHECK_OP_MOVEQ      20EA
CHECK_OP_MOVE_B     1B94
CHECK_OP_MOVE_FROM_SR  1CE0
CHECK_OP_MOVE_L     1BF6
CHECK_OP_MOVE_TO_CCR  1CF4
CHECK_OP_MOVE_TO_SR  1D08
CHECK_OP_MOVE_USP   1E26
CHECK_OP_MOVE_W     1C58
CHECK_OP_MULS       22A2
CHECK_OP_MULU       2258
CHECK_OP_NBCD       1D86
CHECK_OP_NEG        1EC2
CHECK_OP_NEGX       1D1C
CHECK_OP_NOP        1E62
CHECK_OP_NOT        1D44
CHECK_OP_OR         214C
CHECK_OP_ORI        1B0C
CHECK_OP_ORI_TO_CCR  19B6
CHECK_OP_ORI_TO_SR  19C6
CHECK_OP_PEA        1DAE
CHECK_OP_RESET      1C90
CHECK_OP_ROL        2446
CHECK_OP_ROL_NO_ROT  237E
CHECK_OP_ROR        2428
CHECK_OP_ROR_NO_ROT  2364
CHECK_OP_ROXL       2414
CHECK_OP_ROXL_NO_ROT  2350
CHECK_OP_ROXR       2400
CHECK_OP_ROXR_NO_ROT  233C
CHECK_OP_RTE        1CB0
CHECK_OP_RTR        1CD0
CHECK_OP_RTS        1E78
CHECK_OP_SBCD       211E
CHECK_OP_SCC        1F4E
CHECK_OP_STATIC_BCHG  1A7A
CHECK_OP_STATIC_BCLR  1B48
CHECK_OP_STATIC_BSET  1A8E
CHECK_OP_STATIC_BTST  1A66
CHECK_OP_STOP       1C80
CHECK_OP_SUB        21BE
CHECK_OP_SUBA       217C
CHECK_OP_SUBI       1A2A
CHECK_OP_SUBQ       1F76
CHECK_OP_SUBX       2190
CHECK_OP_SWAP       1D9A
CHECK_OP_TAS        1DC2
CHECK_OP_TRAP       1DEA
CHECK_OP_TRAPV      1CC0
CHECK_OP_TST        1DD6
CHECK_OP_UNLK       1E12
CHECK_POSITIVE_LENGTH  1342
CHECK_PRINT         11FA
CHECK_SIZE_BIT_FOR_SUB  216A
CHECK_VALID_LENGTH  134C
CHECK_XXXX          2934
CHRDONE             1434
CHRLOOP             1420
CHUMP_BYTE          3568
CHUMP_LONG          3578
CHUMP_WORD          3570
CLEAR_BUFFER        12F4
CLEAR_BUFFER_END    130E
CLEAR_BUFFER_LENGTH  12F0
CLEAR_BUFFER_LOOP   1302
CLEAR_BUFFER_POINTER  12EC
COMMA               291C
CONVERTED_HEX_STRING  1319
CONVERT_HEX_TO_STRING  1322
CONVERT_TO_HEX_LETTER  1368
COUNTDONE           13D4
COUNTLOOP           13C2
CR                  D
CUR_OP_CODE         10A0
C_GROUP_0           19B2
C_GROUP_1           1B90
C_GROUP_2           1BBA
C_GROUP_3           1C1C
C_GROUP_4           1C7E
C_GROUP_5           1F36
C_GROUP_6           1FA0
C_GROUP_7           20E6
C_GROUP_8           2106
C_GROUP_9           2166
C_GROUP_A           21D8
C_GROUP_B           21E0
C_GROUP_C           2254
C_GROUP_D           22D8
C_GROUP_E           2338
C_GROUP_F           24E8
DATA                2915
DATA_TO_ADDRESS     3102
DIGIT_LOOP          1354
DIR_0               2C90
DIR_1               2CE0
DIVS                2D30
DIVS_BACK           2D52
DONE                1286
DOWN_ONE            2B92
DOWN_ZERO           2B8A
DYNMC_BCLR          344A
END                 370A
EXT                 2930
FILEID              1752
FILENAME            1732
FINDNULLLOOPDONE    13A4
FIND_1_BIT_SIZE_6   18D6
FIND_1_BIT_SIZE_8   18F6
FIND_2_BIT_SIZE_7_TO_6  18B6
FIND_MOVEA_L_DIFFERENCE  1BD0
FIND_MOVEA_W_DIFF   1C32
FIRST_3             1772
FIRST_VAR_MOVEM     2924
FOURTH_3            1775
FST_X               3192
FST_X2              3284
FST_Y1              31DE
FST_Y2              31F8
FST_Y3              32D0
FST_Y4              32EA
FUK_MOVEM           2F7C
GO                  3580
GOO                 34B8
GOO2                34E4
GO_ADDRESS_TO_DATA  321E
GO_DATA_TO_ADDRESS  312C
GROUP0_INVALID      1B84
GROUP0_SUCCESS      1B8A
GROUP1_INVALID      1BAE
GROUP1_SUCCESS      1BB4
GROUP2_INVALID      1C10
GROUP2_SUCCESS      1C16
GROUP3_INVALID      1C72
GROUP3_SUCCESS      1C78
GROUP4_INVALID      1F2A
GROUP4_SUCCESS      1F30
GROUP5_INVALID      1F94
GROUP5_SUCCESS      1F9A
GROUP6_INVALID      20DA
GROUP6_SUCCESS      20E0
GROUP7_INVALID      20FA
GROUP7_SUCCESS      2100
GROUP8_INVALID      215A
GROUP8_SUCCESS      2160
GROUP9_INVALID      21CC
GROUP9_SUCCESS      21D2
GROUPB_INVALID      2248
GROUPB_SUCCESS      224E
GROUPC_INVALID      22CC
GROUPC_SUCCESS      22D2
GROUPD_INVALID      232C
GROUPD_SUCCESS      2332
GROUPE_INVALID      24DC
GROUPE_SUCCESS      24E2
GROUP_0             1788
GROUP_1             179A
GROUP_2             17AC
GROUP_3             17BE
GROUP_4             17D0
GROUP_5             17E2
GROUP_6             17F4
GROUP_7             1806
GROUP_8             1818
GROUP_9             182A
GROUP_A             183C
GROUP_B             184E
GROUP_C             1860
GROUP_D             1872
GROUP_E             1884
GROUP_F             1896
GT                  36F6
G_BUFFER            1000
HEX_SIGN            2918
IMMDTE_VALU         2919
INVALID             370E
INVALID_ADDRES_MESSAGE  1756
INVALID_OP          24F0
IO_BUFFER           173D
IS_VALID            10A2
ITS_X               3176
ITS_X2              3268
ITS_Y               31B8
ITS_Y2              32AA
ITS_Y2_BACK         32B4
ITS_Y_BACK          31C2
JSR                 2EF4
JSR_BACK            2F0C
KEEP_GOING          3210
KEEP_GOING0         315C
KEEP_GOING1         324E
KEEP_GOING2         3302
LE                  3700
LEA                 2F30
LEA_BACK            2F52
LF                  A
LOAD_0000           3310
LOAD_00XX           3496
LOAD_0100           2E06
LOAD_0101           2D7C
LOAD_0110           2AE6
LOAD_1000           2C64
LOAD_1001           2C5E
LOAD_1011           2C58
LOAD_1100           2C52
LOAD_1101           2BF0
LOAD_1110           29C6
LOAD_8              2A8C
LOAD_A              3684
LOAD_ABS_LONG       3616
LOAD_ABS_SHORT      3604
LOAD_ADDRESS        35DA
LOAD_ADDRESS_W_POST_INC  35EC
LOAD_ADDRESS_W_PRE_DEC  35F8
LOAD_ADDR_REGISTER  35C8
LOAD_BYTES          3632
LOAD_COMMA_SPACE    365E
LOAD_D              3676
LOAD_DATA_REGISTER  35B6
LOAD_EA             34FA
LOAD_FIRST3         2A96
LOAD_GE_111         353A
LOAD_HEX_SIGN       36AE
LOAD_IMMDTE         3628
LOAD_IMMDTE_VALU    36BC
LOAD_LT_111         350C
LOAD_MINUS_SIGN     36D8
LOAD_NEW_LINE       365C
LOAD_NUM            36EA
LOAD_PLUS_SIGN      36CA
LOAD_PTHSIS_CLSD    36A0
LOAD_PTHSIS_OPEN    3692
LOAD_THIS_SHIT      36E6
LOOP                363C
MAIN_CONSOLE        1460
MAIN_EA             2926
MAIN_LOOP           1198
MINUS_SIGN          291B
MNEMONIC            1771
MOVEM               2F22
MOVEM_BIT_SIZE_CHECK  1EE0
MOVEM_FIRST_VAR     2920
MOVEM_FIRST_VAR_COUNTER  2922
MOVEM_PARSE         30C6
MOVEM_POST          2F9C
MOVEM_POST2         2FC0
MOVEM_POST3         2FDC
MOVEM_POSTL         3036
MOVEM_POSTW         3004
MOVEM_PRE           3068
MOVEM_PRE_B         3092
MOVEM_SECOND_VAR    2921
MOVEM_SECOND_VAR_COUNTER  2923
MOVEON              2A20
MOVE_AND_MOVEA_PARSE_EA  1916
MYBE_ASD_1          29E8
MYBE_ASD_2          2A4E
MYBE_BCLR           3358
MYBE_BRA            2B06
MYBE_CMPI           3340
MYBE_JSR            2E74
MYBE_MOVEM          2E94
MYBE_NEG            2E1E
MYBE_ORI            3328
MYBE_RTS1           2E36
MYBE_RTS2           2E44
MYBE_RTS3           2E52
MYBE_SUBQ1          2D96
MYBE_SUBQ2          2DA6
MYBE_Y              31AA
MYBE_Y2             329C
NEG                 2EB4
NEG_BACK            2ED6
NEG_WORD            2BD2
NEWLINE             170C
NOT_BCLR            3362
NOT_BRA             2B14
NOT_CMPI            334A
NOT_JSR             2E7E
NOT_MOVEM           2EA4
NOT_NEG             2E28
NOT_ORI             3332
NOT_RTS             2E66
NULLLOOP            1396
NUMBER_TO_CONVERT   1314
OP_JSR_DONE         18A4
OP_JSR_ROUTINE      1776
OP_SIZE             1770
ORI_CMPI            3372
OR_BACK             2CB6
OR_BACK2            2D1A
OUTFILENAME         1712
PARSE_EA_CONSTANT_BITS  195C
PLUS_SIGN           291A
POS_WORD            2BBE
PRINT_DATA          1214
PRINT_INSTRUCTION   1208
PRINT_OP_ADD        26EE
PRINT_OP_ADDA       2702
PRINT_OP_ASL        2752
PRINT_OP_ASR        273E
PRINT_OP_BCS        261E
PRINT_OP_BGE        2632
PRINT_OP_BLT        2646
PRINT_OP_BRA        266E
PRINT_OP_BVC        265A
PRINT_OP_CMP        26CC
PRINT_OP_CMPI       251A
PRINT_OP_DIVS       2682
PRINT_OP_DYNAMIC_BCLR  2542
PRINT_OP_EOR        26B8
PRINT_OP_JSR        259C
PRINT_OP_LEA        25C6
PRINT_OP_LSL        2716
PRINT_OP_LSR        272A
PRINT_OP_MOVEA_L    2564
PRINT_OP_MOVEA_W    2580
PRINT_OP_MOVEB      2556
PRINT_OP_MOVEM_L    25FC
PRINT_OP_MOVEM_W    25EE
PRINT_OP_MOVE_L     2572
PRINT_OP_MOVE_W     258E
PRINT_OP_MULS       26E0
PRINT_OP_NEG        25DA
PRINT_OP_NOP        25B8
PRINT_OP_OR         2690
PRINT_OP_ORI        2506
PRINT_OP_ROL        2766
PRINT_OP_ROR        277A
PRINT_OP_RTS        25AA
PRINT_OP_SIZE       27B8
PRINT_OP_SIZE_ADDA  27D2
PRINT_OP_STATIC_BCLR  252E
PRINT_OP_SUB        26A4
PRINT_OP_SUBQ       260A
PRINT_SIZE_BYTE     278E
PRINT_SIZE_LONG     27AA
PRINT_SIZE_WORD     279C
PRINT_TO_BUFFER     24F8
PTHSIS_CLSD         2917
PTHSIS_OPEN         2916
P_INVALID_OP        27DC
P_OP_ADD            28E3
P_OP_ADDA           28DB
P_OP_ASL            28FF
P_OP_ASR            28F8
P_OP_BCLR           2803
P_OP_BCS            288E
P_OP_BGE            2895
P_OP_BLT            289C
P_OP_BRA            2887
P_OP_BVC            28A3
P_OP_CMP            28C9
P_OP_CMPI           27FB
P_OP_DIVS           28AA
P_OP_EOR            28C2
P_OP_JSR            2863
P_OP_LEA            285C
P_OP_LSL            28F1
P_OP_LSR            28EA
P_OP_MOVEA_L        2816
P_OP_MOVEA_W        282D
P_OP_MOVEB          280B
P_OP_MOVEM_L        2850
P_OP_MOVEM_W        2844
P_OP_MOVE_L         2822
P_OP_MOVE_W         2839
P_OP_MULS           28D0
P_OP_NEG            2878
P_OP_NOP            286A
P_OP_OR             28B5
P_OP_ORI            27F4
P_OP_ROL            290D
P_OP_ROR            2906
P_OP_RTS            2871
P_OP_SUB            28BB
P_OP_SUBQ           287F
P_SIZE_B            27E8
P_SIZE_L            27F0
P_SIZE_W            27EC
RET_SA              145E
ROTATE              3646
RTS                 2EEC
SAVED               350A
SECOND_3            1773
SECOND_VAR_MOVEM    2925
SIZE                14
SIZE_B              359E
SIZE_L              35AE
SIZE_W              35A6
SKIP_HERE           31F4
SKIP_HERE2          32E6
SND_X               31A2
SND_X2              3294
SND_Y               3208
SND_Y2              32FA
SPACE               291D
START               10A3
STRING_ADD_SUCCESS  12D8
STRING_BUFFER_ADD_LOOP  12C2
STRING_BUFFER_LOOP  12AE
STRING_BUFFER_POINTER  128A
STRIP_ASCII         143A
SUB30               145A
SUB37               1452
SUBQ                2DB6
SUBQ_BACK           2DF0
SUBQ_SAVED          2DC8
SUBTRACT_X          3234
SUBTRACT_Y          323E
THIRD_3             1774
TOSAVE              C3F
TRAILING_HELPER     359E
TRAILING_SIZE       291E
TRAPTASK13          1382
VALIDATE_ADDRESS_RANGE  1182
VALIDATE_END_EVEN   1160
VALIDATE_END_POS    111C
VALIDATE_POSITIVE_ADDRESS  10FA
VALIDATE_START_ADDRESS  10F8
VALIDATE_START_EVEN  113E
_00000000           13B8
