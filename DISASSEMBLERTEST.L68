000010A4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/17/2019 7:57:53 PM

00000000                             1  **--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler in Motorola 68k
00000000                             3  * Written by : TEAM REEE Denny, Daniel, Fahad
00000000                             4  * Date       : 3/17/2019 
00000000                             5  * 
00000000                             6  * 
00000000                             7  * Description: This disassembler reverse assembles or decompiles a given
00000000                             8  * test program (with validity checking) from their machine code hex
00000000                             9  * equivalents to outputting them onto a console file and a log.
00000000                            10  *
00000000                            11  * This disassembler will print out <MEMORY ADDRESS> <OPERAND> <EA MODE/REG>
00000000                            12  * If the identified code is valid.
00000000                            13  *
00000000                            14  * This disassembler will print out <MEMORY ADDRESS> DATA $<INVALID HEX>
00000000                            15  * If the identified code is invalid.
00000000                            16  *---------------------------------------------------------------------------
00009000                            17      ORG    $9000    
00009000                            18  *---------------------------------------------------------------------------
00009000                            19  G_BUFFER_1        DS.B    80            ;Used to print out the needed letters to the buffer
00009050                            20  B_BUFFER_1        DS.B    80            ;Bad buffer used to load bad data
000090A0                            21  CUR_OP_CODE_1     DS.W    1         ;Used to determine the current 4 hex OP code
000090A2                            22  IS_VALID_1        DS.B    1         ;Validity bit to check if a code is valid or not
000090A3                            23                          ;1 = valid, 0 = invalid
000090A3                            24  
000090A3                            25  ;START:                     ;Start of the program
000090A3                            26  
000090A4  43F9 0000944A             27      LEA MAIN_CONSOLE_1, A1          ;Loads the main message into A1
000090AA  4EB9 0000936C             28      JSR TrapTask13_1                   ;Prints message out to console and log
000090B0                            29  
000090B0                            30      
000090B0                            31      
000090B0                            32      ******************************************
000090B0                            33      **
000090B0                            34      **     ___         ___        /  __  
000090B0                            35      **    |__  | |    |__     |  /  /  \  
000090B0                            36      **    |    | |___ |___    | /   \__/ 
000090B0                            37      **                           
000090B0                            38      **
000090B0                            39      ** This is the beginning of the code for reading from files
000090B0                            40      ******************************************
000090B0                            41  * Attempt to open file for input
000090B0  43F9 0000971C             42          LEA     fileName_1,A1                    ;Name of file to open
000090B6  103C 0033                 43          MOVE.B  #51,D0                         ;Trap task #51, open existing file
000090BA  4E4F                      44          TRAP    #15                            ;Perform task
000090BC  23C1 0000973C             45          MOVE.L  D1,fileID_1                      ;Save file ID
000090C2                            46  
000090C2                            47  * Read string from file
000090C2  43F9 00009727             48          LEA     IO_BUFFER_1,A1                   ;Location of string buffer
000090C8  2239 0000973C             49          MOVE.L  fileID_1,D1                      ;File ID of file to read from
000090CE  4282                      50          CLR.L   D2
000090D0  343C 0014                 51          MOVE.W  #SIZE_1,D2                       ;Number of bytes to read
000090D4  103C 0035                 52          MOVE.B  #53,D0                         ;Trap task #53, read from file
000090D8  4E4F                      53          TRAP    #15                            ;Perform task
000090DA                            54  * Close file when finished
000090DA  103C 0038                 55          MOVE.B  #56,D0                         ;Trap task #56, close file, D1 contains fileID_1
000090DE  4E4F                      56          TRAP    #15                            ;Perform task
000090E0                            57  
000090E0                            58  
000090E0                            59  *Load start and end address as longs
000090E0                            60  *Start Address is in A5     
000090E0  43F9 00009727             61      LEA IO_BUFFER_1, A1             ;Load string or IO buffer to A1
000090E6  4EB9 00009402             62      JSR AsciiToHex_1                    ;Convert ASCII to Hex
000090EC  2A47                      63      MOVE.L D7, A5                   ;Loop counter prep
000090EE                            64      
000090EE                            65  *End Address is in A6
000090EE  5489                      66      ADDA.L #2, A1                   ;Add #2 to A1
000090F0  4EB9 00009402             67      JSR AsciiToHex_1                    ;Convert ASCII to Hex
000090F6  2C47                      68      MOVE.L D7, A6                   ;Loop counter prep
000090F8                            69      
000090F8                            70  VALIDATE_START_ADDRESS_1                ;Validates starting address
000090F8  200D                      71      MOVE.L A5, D0                   ;Move stating address to D0
000090FA                            72  *----------------------------------------------------------------------------------
000090FA                            73  * Method Name: VALIDATE_POSITIVE_ADDRESS_1
000090FA                            74  * Description: Checks if the start address is positive it then branches
000090FA                            75  *              to validate if the address in the Config.cfg file is even
000090FA                            76  *
000090FA                            77  *  Preconditions & Input of a start address that is even
000090FA                            78  *       A1 (input) points to a memory buffer holding 8 ASCII chars (not null-terminated) 
000090FA                            79  *       This function calls another function (strip_ascii)
000090FA                            80  *
000090FA                            81  *  Postconditions & Output
000090FA                            82  *   
000090FA                            83  *----------------------------------------------------------------------------------
000090FA                            84  VALIDATE_POSITIVE_ADDRESS_1
000090FA  200D                      85      MOVE.L A5, D0                   ;Move starting address to D0
000090FC  0280 80000000             86      ANDI.L #$80000000, D0           ;Checking if the start address address is positive
00009102  B0BC 00000000             87      CMP.L #0, D0                    ;Compare 0 to D0
00009108  6700 0034                 88      BEQ VALIDATE_EVEN_1             ;Check if the address is even
0000910C                            89      
0000910C  43F9 00009740             90      LEA INVALID_ADDRES_MESSAGE_1, A1           ;Load INVALID message to A1
00009112  4EB9 0000936C             91      JSR TrapTask13_1                             ;Use Nash's Console Output
00009118  6000 0142                 92      BRA DONE_1                      ;Finish routine
0000911C                            93  
0000911C                            94  VALIDATE_END_POS_1
0000911C  200E                      95      MOVE.L A6, D0                   ;Move ending address to D0
0000911E  0280 80000000             96      ANDI.L #$80000000, D0                  ;Checking if the end address address is positive
00009124  B0BC 00000000             97      CMP.L #0, D0                    ;Compare address to 0
0000912A  6700 0012                 98      BEQ VALIDATE_EVEN_1             ;Check if the end address is even
0000912E                            99      
0000912E  43F9 00009740            100      LEA INVALID_ADDRES_MESSAGE_1, A1           ;Load INVALID message to A1
00009134  4EB9 0000936C            101      JSR TrapTask13_1                             ;Use Nash's Console Output      
0000913A  6000 0120                102      BRA DONE_1                      ;Finish routine
0000913E                           103      
0000913E                           104  VALIDATE_EVEN_1
0000913E  200D                     105      MOVE.L A5, D0                   ;MOVE STARTING ADDRESS TO D0
00009140  0280 00000001            106      ANDI.L #$00000001,D0                   ;Bitmask 1 a single bit to D0
00009146  B0BC 00000000            107      CMP.L #0, D0                    ;Check if even
0000914C  6700 0012                108      BEQ MAIN_LOOP_1                 ;Go to the main loop if even
00009150                           109  *Handle odd addresses
00009150  43F9 00009740            110      LEA INVALID_ADDRES_MESSAGE_1, A1           ;Load INVALID message to A1
00009156  4EB9 0000936C            111      JSR TrapTask13_1                             ;Use Nash's Console Output
0000915C  6000 00FE                112      BRA DONE_1                      ;Finish routine
00009160                           113              
00009160                           114  
00009160                           115  
00009160                           116  *Comments are shifted if variable names get too long
00009160                           117  MAIN_LOOP_1                                 ;Main loop to run each instruction
00009160  49F9 00009000            118           LEA G_BUFFER_1,A4                          ;Point G_BUFFER_1 to A4
00009166                           119      
00009166  BDCD                     120              CMPA.L A5, A6                           ;Compare Starting to ending address
00009168  6D00 00F2                121              BLT DONE_1                          ;If it's less then stop the loop
0000916C                           122              
0000916C                           123  *Clear both buffers 
0000916C  23FC 00009000 000092CC   124              MOVE.L #G_BUFFER_1, CLEAR_BUFFER_1_POINTER_1            ;Point the clear pointer to G_BUFFER_1
00009176  4EB9 000092D4            125              JSR CLEAR_BUFFER_1                      ;Clear the buffer
0000917C                           126              
0000917C  23FC 00009050 000092CC   127              MOVE.L #B_BUFFER_1, CLEAR_BUFFER_1_POINTER_1            ;Point the clear pointer to B_BUFFER_1
00009186  4EB9 000092D4            128              JSR CLEAR_BUFFER_1                      ;Clear the buffer
0000918C                           129              
0000918C                           130  *Add address to both buffers
0000918C                           131              
0000918C  23CD 000092F8            132              MOVE.L A5, NUMBER_TO_CONVERT_1              ;The current address is stored to A5, we need to convert it to load it in the buffers.
00009192  13FC 0008 000092FC       133              MOVE.B #8, CHARNUM_TO_CONVERT_1             ;This specifies the number of characters that needs to be converted.
0000919A  4EB9 00009306            134              JSR CONVERT_HEX_TO_STRING_1                 ;Convert hex to string
000091A0                           135              
000091A0  23FC 000092FD 00009260   136              MOVE.L #CONVERTED_HEX_STRING_1, STRING_BUFFER_1_POINTER_1   ;Prepare the string buffer with the converted hex string
000091AA  23FC 00009000 00009264   137              MOVE.L #G_BUFFER_1, BUFFER_POINTER_1                   ;Point G_BUFFER_1 to the print buffer
000091B4  4EB9 0000926E            138              JSR AddStrToBuffer_1                        ;Add the string to the print buffer
000091BA                           139      
000091BA  33DD 000090A0            140              MOVE.W (A5)+, CUR_OP_CODE_1                 ;Read the current opcode
000091C0  4EF9 00009760            141              JMP OP_JSR_Routine_1                        ;Run main OP code routine
000091C6                           142  
000091C6                           143  *********************************
000091C6                           144  *Checks if its valid print or invalid
000091C6                           145  * @pre checks invalid
000091C6                           146  * @post Branches to the respective branch
000091C6                           147  ************************************
000091C6                           148  check_print
000091C6  0C39 0001 000090A2       149              CMP.B #1,IS_VALID_1                     ;Check if IS_VALID_1 is set to 1
000091CE  6700 0006                150              BEQ   print_instruction                 ;If it's valid do print_instruction
000091D2  6600 0012                151              BNE   print_data                        ;If it's invalid do print_data
000091D6                           152              
000091D6                           153  print_instruction                               ;Prints the data in G_BUFFER_1
000091D6                           154  *Print the opcode if valid
000091D6  43F9 00009000            155              LEA G_BUFFER_1,A1                       ;Points A1 to G_BUFFER_1
000091DC  4EB9 0000936C            156              JSR TrapTask13_1                            ;Use Nash's console output
000091E2  6000 FF7C                157              BRA MAIN_LOOP_1                         ;Go back to the main loop
000091E6                           158   
000091E6                           159  *Otherwise print data
000091E6                           160  print_data  
000091E6  23CD 000092F8            161              MOVE.L A5, NUMBER_TO_CONVERT_1                  ;The current address is stored to A5, we need to convert it to load it in the buffers.
000091EC  13FC 0008 000092FC       162              MOVE.B #8, CHARNUM_TO_CONVERT_1                 ;This specifies the number of characters that needs to be converted.
000091F4  4EB9 00009306            163              JSR CONVERT_HEX_TO_STRING_1                     ;Convert the hex to string
000091FA  23FC 000092FD 00009260   164              MOVE.L #CONVERTED_HEX_STRING_1, STRING_BUFFER_1_POINTER_1       ;Point the string buffer to the converted hex
00009204                           165              
00009204  23FC 00009050 00009264   166              MOVE.L #B_BUFFER_1, BUFFER_POINTER_1                    ;Prepare the string buffer with the valid data
0000920E  4EB9 0000926E            167              JSR AddStrToBuffer_1                            ;Add the string to the print buffer
00009214                           168  *Add bad data to bad buffer
00009214  23FC 0000A9AE 00009260   169              MOVE.L #P_INVALID_OP, STRING_BUFFER_1_POINTER_1         ;Prepare the string buffer with the invalid data
0000921E  4EB9 0000926E            170              JSR AddStrToBuffer_1                            ;Add the string to the print buffer
00009224                           171              
00009224  33F9 000090A0 000092F8   172              MOVE.W CUR_OP_CODE_1, NUMBER_TO_CONVERT_1               ;The current address is stored to A5, we need to convert it to load it in the buffers.
0000922E  13FC 0008 000092FC       173              MOVE.B #8, CHARNUM_TO_CONVERT_1                 ;This specifies the number of characters that needs to be converted.
00009236  4EB9 00009306            174              JSR CONVERT_HEX_TO_STRING_1                         ;Convert the hex to string
0000923C                           175              
0000923C  23FC 000092FD 00009260   176              MOVE.L #CONVERTED_HEX_STRING_1, STRING_BUFFER_1_POINTER_1       ;Prepare the string buffer with the converted hex string
00009246  4EB9 0000926E            177              JSR AddStrToBuffer_1                            ;Add the converted hex to buffer
0000924C                           178              
0000924C  43F9 00009050            179              LEA B_BUFFER_1,A1                           ;Point A1 to the bad buffer
00009252  4EB9 0000936C            180              JSR TrapTask13_1                                ;Use Nash's console output
00009258  6000 FF06                181              BRA MAIN_LOOP_1                             ;Go back to the main loop
0000925C                           182  
0000925C                           183  
0000925C                           184  DONE_1                                          ;We're finished at this point reading all the files
0000925C  FFFF FFFF                185              SIMHALT                                 ;Halt the simulation
00009260                           186              
00009260                           187  **
00009260                           188  * AddStrToBuffer_1
00009260                           189  *****************************************************************************
00009260                           190  * Description: Adds the a defined string constant into a buffer to print out
00009260                           191  * Places a NULL terminating string to start with a default buffer length of 80.
00009260                           192  *
00009260                           193  * If the buffer length is exceeded, where length was improperly specified or no
00009260                           194  * NULL terminating string was found, return 1, else return 0 for success.
00009260                           195  *
00009260                           196  * Additional Constants/Subroutines used:
00009260                           197  * STRING_BUFFER_1_POINTER_1                 ;String pointer
00009260                           198  * BUFFER_POINTER_1                      ;Buffer pointer
00009260                           199  * BUFFER_POINTER_1_LENGTH                   ;Buffer length, 80 chars by default
00009260                           200  * BUFFER_ADD_SUCCESS_1                  ;0 = success, 1 = failure
00009260                           201  * FIND_NULL_IN_BUFFER                   ;Find NULL in buffer with a loop
00009260                           202  * STRING_BUFFER_1_ADD_LOOP                  ;Add a string to the buffer with a loop
00009260                           203  * STRING_ADD_SUCCESS                       ;Routine to run when string is added successfully
00009260                           204  * BUFFER_LENGTH_FAIL                    ;Routine to run when buffer length is exceeded
00009260                           205  * BUFFER_STRING_END                     ;Subroutine is finished
00009260                           206  *****************************************************************************
00009260                           207  * Constant definitions:
00009260                           208  STRING_BUFFER_1_POINTER_1   DS.L    1
00009264                           209  BUFFER_POINTER_1        DS.L    1
00009268= 00000050                 210  BUFFER_POINTER_1_LENGTH DC.L    80
0000926C                           211  BUFFER_ADD_SUCCESS_1        DS.B    1
0000926D                           212  
0000926E                           213  AddStrToBuffer_1:           DS.W    0                   ;Reserve a word
0000926E  48E7 C0C0                214      MOVEM.L     D0-D1/A0-A1, -(SP)              ;Save registers to stack
00009272                           215      
00009272  2079 00009260            216      MOVE.L      STRING_BUFFER_1_POINTER_1,A0        ;Load string pointer to A0
00009278  2279 00009264            217      MOVE.L      BUFFER_POINTER_1, A1            ;Load buffer pointer to A1
0000927E  2039 00009268            218      MOVE.L      BUFFER_POINTER_1_LENGTH, D0     ;Load buffer length to D0
00009284  4279 0000926C            219      CLR.W       BUFFER_ADD_SUCCESS_1            ;Clear any prior success bit
0000928A  4281                     220      CLR.L       D1                      ;Clear any prior loop counts
0000928C                           221  
0000928C                           222  STRING_BUFFER_1_LOOP
0000928C  0C11 0000                223      CMPI.B      #0, (A1)                    ;Check if buffer char is NULL or not
00009290  6700 000E                224      BEQ         STRING_BUFFER_1_ADD_LOOP            ;If a 0 is found, start adding string(s) to the buffer
00009294                           225      
00009294  B280                     226      CMP.L       D0, D1                  ;Check if the counter is more than the max length
00009296  6C00 0026                227      BGE         BUFFER_LENGTH_EXCEEDED_1            ;Exceeded the length
0000929A                           228      
0000929A  5289                     229      ADDQ.L      #1, A1                  ;Increment to the next character
0000929C  5201                     230      ADDQ.B      #1, D1                  ;Increment loop counter
0000929E  60EC                     231      BRA         STRING_BUFFER_1_LOOP            ;Loop back again
000092A0                           232      
000092A0                           233  STRING_BUFFER_1_ADD_LOOP
000092A0  0C10 0000                234      CMPI.B      #0, (A0)                       ;Check is the string char is NULL
000092A4  6700 0010                235      BEQ         STRING_ADD_SUCCESS          ;String has been added successfully
000092A8                           236      
000092A8  B200                     237      CMP.B       D0, D1                  ;Check if the counter is more than the max length
000092AA  6C00 0012                238      BGE         BUFFER_LENGTH_EXCEEDED_1            ;Exceeded the length
000092AE                           239      
000092AE  12D8                     240      MOVE.B      (A0)+,(A1)+             ;Add string to the buffer
000092B0  5201                     241      ADDQ.B      #1, D1                  ;Increment loop counter
000092B2  524C                     242      ADDQ.W      #1, A4                  ;Increment G_BUFFER_1 counter
000092B4  60EA                     243      BRA         STRING_BUFFER_1_ADD_LOOP            ;Loop back again
000092B6                           244  
000092B6                           245  STRING_ADD_SUCCESS
000092B6  12BC 0000                246      MOVE.B      #0,(A1)                 ;Place NULL terminating 0 at the end
000092BA  6000 000A                247      BRA         BUFFER_STRING_END               ;Finish subroutine
000092BE                           248  
000092BE                           249  BUFFER_LENGTH_EXCEEDED_1
000092BE  33FC 0001 0000926C       250      MOVE.W      #1, BUFFER_ADD_SUCCESS_1            ;BUFFER failed to add
000092C6                           251  
000092C6                           252  BUFFER_STRING_END
000092C6  4CDF 0303                253      MOVEM.L     (SP)+, D0-D1/A0-A1          ;Restore registers from stack
000092CA  4E75                     254      RTS                                     ;Return to stack
000092CC                           255  **************************************************************************
000092CC                           256  * CLEAR_BUFFER_1
000092CC                           257  *****************************************************************************
000092CC                           258  * Description: Clears the defined buffer area with NULL terminating 0s
000092CC                           259  * The default size is 80 bytes
000092CC                           260  *
000092CC                           261  * Additional Constants/Subroutines used:
000092CC                           262  * CLEAR_BUFFER_1_POINTER_1                  ;Buffer pointer
000092CC                           263  * CLEAR_BUFFER_1_LENGTH_1                   ;Length of buffer, default 80 bytes
000092CC                           264  * CLEAR_BUFFER_1_LOOP                       ;Buffer loop
000092CC                           265  * CLEAR_BUFFER_1_END                        ;Finish subroutine
000092CC                           266  *****************************************************************************
000092CC                           267  * Constant definitions:
000092CC                           268  CLEAR_BUFFER_1_POINTER_1    DS.L    1
000092D0= 00000050                 269  CLEAR_BUFFER_1_LENGTH_1     DC.L    80
000092D4                           270  
000092D4                           271  CLEAR_BUFFER_1:         DS.W    0                  ;Reserve a word
000092D4  48E7 C080                272      MOVEM.L     D0-D1/A0, -(SP)             ;Save registers to stack
000092D8  2079 000092CC            273      MOVEA.L     CLEAR_BUFFER_1_POINTER_1, A0        ;Load buffer address to A0
000092DE  2039 000092D0            274      MOVE.L      CLEAR_BUFFER_1_LENGTH_1, D0         ;Load buffer length to D0
000092E4  4281                     275      CLR.L       D1                      ;Clear any prior loop counter
000092E6                           276      
000092E6                           277  CLEAR_BUFFER_1_LOOP
000092E6  B280                     278      CMP.L       D0, D1                  ;Check if the counter is more than the max length
000092E8  6C00 0008                279      BGE         CLEAR_BUFFER_1_END              ;Finish subroutine
000092EC                           280      
000092EC  4218                     281      CLR.B       (A0)+                   ;Clear current character in clear buffer
000092EE  5241                     282      ADDQ        #1, D1                  ;Increment loop counter
000092F0  60F4                     283      BRA         CLEAR_BUFFER_1_LOOP             ;Loop back again
000092F2                           284      
000092F2                           285  CLEAR_BUFFER_1_END
000092F2  4CDF 0103                286      MOVEM.L     (SP)+, D0-D1/A0             ;Restore registers from stack
000092F6  4E75                     287      RTS                         ;Return to stack
000092F8                           288  
000092F8                           289  
000092F8                           290  **
000092F8                           291  * CONVERT_HEX_TO_STRING_1
000092F8                           292  *****************************************************************************
000092F8                           293  * Description: Converts a given number to a hexadecimal string by the specified 
000092F8                           294  * length. A null terminating string is added after (0). Conversion starts from the
000092F8                           295  * rightmost bit.
000092F8                           296  *
000092F8                           297  * Default length of conversion is 8, but can be changed.
000092F8                           298  
000092F8                           299  * Additional Constants/Subroutines used:
000092F8                           300  * NUMBER_TO_CONVERT_1                       ;Number to convert
000092F8                           301  * CHARNUM_TO_CONVERT_1                  ;Character numbers to convert, valid range is 0-8
000092F8                           302  * CONVERTED_HEX_STRING_1                    ;Converted hexadecimal character string
000092F8                           303  * CHECK_POSITIVE_LENGTH                 ;Routine to check for positive length
000092F8                           304  * CHECK_VALID_LENGTH                    ;Routine to check for valid length
000092F8                           305  * DIGIT_LOOP                            ;Looping through each digit
000092F8                           306  * CONVERT_TO_HEX_LETTER                 ;Routine to convert to hex letter
000092F8                           307  * ADD_CHAR_TO_STRING                    ;Adds a character to the string
000092F8                           308  *****************************************************************************
000092F8                           309  * Constant definitions:
000092F8                           310  NUMBER_TO_CONVERT_1     DS.L    1
000092FC= 08                       311  CHARNUM_TO_CONVERT_1        DC.B    8
000092FD                           312  CONVERTED_HEX_STRING_1  DS.B    9
00009306                           313  
00009306                           314  CONVERT_HEX_TO_STRING_1:    DS.W    0                 ;Reserve a word       
00009306  48E7 F0C0                315      MOVEM.L     D0-D3/A0-A1, -(SP)          ;Save registers to stack
0000930A  4281                     316      CLR.L       D1                      ;Clear any prior number from D1
0000930C  4280                     317      CLR.L       D0                      ;Clear any prior number from D0
0000930E  2039 000092F8            318      MOVE.L      NUMBER_TO_CONVERT_1, D0         ;Load number to D0
00009314  1239 000092FC            319      MOVE.B      CHARNUM_TO_CONVERT_1, D1            ;Load length to D1
0000931A  207C 000092FD            320      MOVEA.L     #CONVERTED_HEX_STRING_1, A0     ;Load string address to convert
00009320                           321      
00009320  0C01 0001                322      CMPI.B      #1, D1                  ;Check if D1 is one or not
00009324  6C00 0004                323      BGE         CHECK_POSITIVE_LENGTH           ;Check the length of the number
00009328  7201                     324      MOVEQ       #1, D1                  ;Move number 1 to D1 otherwise
0000932A                           325      
0000932A                           326  CHECK_POSITIVE_LENGTH                   ;Checks the positive length
0000932A  0C01 0008                327      CMPI.B      #8, D1                  ;Check if the length is 8 or not
0000932E  6F00 0004                328      BLE         CHECK_VALID_LENGTH          ;If it's less find and check the length
00009332  7208                     329      MOVEQ       #8, D1                  ;Move number 8 into the length
00009334                           330      
00009334                           331  CHECK_VALID_LENGTH                      ;Checks to see if the length is valid
00009334  2248                     332      MOVEA.L     A0, A1                  ;A0 contains start number, A1 contains current number
00009336  D2C1                     333      ADDA.W      D1, A1                  ;Go to the last digit
00009338  4211                     334      CLR.B       (A1)                    ;Make the last digit NULL or 0
0000933A  740F                     335      MOVEQ       #$0F,D2                 ;Bitmask last hex or nibble
0000933C                           336      
0000933C                           337  DIGIT_LOOP
0000933C  1600                     338      MOVE.B      D0, D3                  ;Get 2 hex chars from number
0000933E  C602                     339      AND.B       D2, D3                  ;Mask to get last hex char
00009340                           340      
00009340  0C03 0009                341      CMPI.B      #9, D3                  ;Check if the value is over 9
00009344  6E00 000A                342      BGT         CONVERT_TO_HEX_LETTER           ;If so, it must be a letter, convert the letter
00009348                           343      
00009348  0603 0030                344      ADDI.B      #'0', D3                       ;Get the ASCII value for 0-9
0000934C  6000 000A                345      BRA         ADD_CHAR_TO_STRING          ;Add char to the string
00009350                           346  
00009350                           347  CONVERT_TO_HEX_LETTER
00009350  0403 000A                348      SUBI.B      #10, D3                 ;Subtract 10 first to get correct ASCII
00009354  0603 0041                349      ADDI.B      #'A', D3                    ;Get the ASCII value for letters A-F
00009358                           350  
00009358                           351  ADD_CHAR_TO_STRING
00009358  1303                     352      MOVE.B      D3, -(A1)                   ;Add char to string and decrement pointer
0000935A  E888                     353      LSR.L       #4, D0                  ;Shift the 4 bits to the right
0000935C  B3C8                     354      CMPA.L      A0, A1                  ;Check if the current pointer is greater than starting string
0000935E  6EDC                     355      BGT         DIGIT_LOOP                     ;If so, loop back
00009360  42B9 000092F8            356      CLR.L  NUMBER_TO_CONVERT_1                          ;Clear any prior number  
00009366                           357      
00009366  4CDF 030F                358      MOVEM.L     (SP)+, D0-D3/A0-A1             ;Restore registers from stack
0000936A  4E75                     359      RTS                         ;Finish subroutine
0000936C                           360  
0000936C                           361  
0000936C                           362  ******************************************* START OF NASH CODE ******************   
0000936C                           363  *********************************************************************************
0000936C                           364  * Method Name: TrapTask13_1
0000936C                           365  * Description: Creates a file if none exists, and appends bytes to that file
0000936C                           366  *   while also echoing the written bytes to the screen.  You shouldn't need to
0000936C                           367  *   change this code.
0000936C                           368  *
0000936C                           369  * Calling Convention: Callee-Saved 
0000936C                           370  *
0000936C                           371  * Preconditions & Method Input:
0000936C                           372  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000936C                           373  *
0000936C                           374  * Postconditions & Output:
0000936C                           375  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000936C                           376  *   See 'Output.txt' in directory for the results, also piped to the console
0000936C                           377  *
0000936C                           378  *
0000936C                           379  *  A2 holds a pointer to null terminated string to write (input)
0000936C                           380  *  A3 points to the null-terminated file name
0000936C                           381  *  D3 holds the number of bytes already in the file to write
0000936C                           382  *
0000936C                           383  *  D5 holds number of bytes to write
0000936C                           384  ********************************************************************************
0000936C                           385  toSave REG D0-D5/A2-A3
0000936C                           386  TrapTask13_1:
0000936C                           387      *******************************************************************
0000936C                           388      * Method initialization, register spilling, parameter saving, etc.
0000936C                           389      *******************************************************************
0000936C  48E7 FC30                390      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
00009370                           391        
00009370  2449                     392      MOVEA.L A1, A2 ; save this buffer to write
00009372  47F9 000096FC            393      LEA outFilename, A3  ; save this for later, too
00009378                           394        
00009378  303C 0032                395      move #50,d0   
0000937C  4E4F                     396      trap #15 ; close all files, suggested to begin any IO 
0000937E                           397      *******************************************************************
0000937E                           398      * End Method Init
0000937E                           399      *******************************************************************
0000937E                           400  
0000937E                           401      ******************************************************************************************
0000937E                           402      * Calculate the number of bytes to write by searching for the null in the target buffer A0
0000937E                           403      ******************************************************************************************
0000937E  4285                     404      CLR.L D5 *D5 is now the number of bytes to write
00009380                           405  nullLoop:
00009380  1019                     406      MOVE.B (A1)+, D0
00009382  0C00 0000                407      CMPI.B #0,D0  * compare to null
00009386  6700 0006                408      BEQ findNullLoopDone
0000938A  5245                     409      ADDI.W #1, D5
0000938C  60F2                     410      BRA nullLoop
0000938E                           411      
0000938E                           412  findNullLoopDone:
0000938E  224B                     413      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00009390                           414      
00009390                           415      ;check if file exists, and open with task 51 if so, otherwise 52
00009390                           416      ;(precondition here is A1 points to the null-terminated filename )
00009390  103C 0033                417      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00009394  4E4F                     418      trap #15
00009396                           419        
00009396                           420      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
0000939C  103C 0034                421          MOVE.B #52, D0             ; open new file (52 is new)
000093A0  4E4F                     422          trap #15
000093A2                           423      endi
000093A2                           424      
000093A2                           425      ********************************************************************************************************* 
000093A2                           426      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
000093A2                           427      *    (first, count number of bytes already in the file to obtain seek position)
000093A2                           428      *********************************************************************************************************
000093A2  4283                     429      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
000093A4  7401                     430      MOVE.L #1, D2 ; read one byte at a time
000093A6  43F9 00009713            431      LEA byteRead, A1
000093AC                           432      
000093AC                           433  countLoop:
000093AC  103C 0035                434      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
000093B0  4E4F                     435      trap #15
000093B2                           436      
000093B2  0C40 0001                437      CMPI.W #1,D0  ;1 == EOF
000093B6  6700 0006                438      BEQ countDone
000093BA  5243                     439      ADDI #1, D3
000093BC  60EE                     440      BRA countLoop
000093BE                           441      
000093BE                           442  countDone:    
000093BE                           443      * close this file
000093BE  303C 0038                444       move #56,d0  
000093C2  4E4F                     445       trap #15 
000093C4                           446       
000093C4                           447       * reopen the target file
000093C4  224B                     448       MOVE.L A3,A1
000093C6  303C 0033                449       MOVE #51, D0
000093CA  4E4F                     450       trap #15
000093CC                           451       
000093CC                           452      * seek to right position, then continue with writing
000093CC  2403                     453      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000093CE  303C 0037                454      MOVE #55, D0  ; position file task
000093D2  4E4F                     455      trap #15
000093D4                           456  
000093D4                           457      ******************************************************************************
000093D4                           458      * Actually write the buffer to the file, after calculating the number of bytes 
000093D4                           459      *  to write and after seeking to the right location in the file for append
000093D4                           460      ******************************************************************************
000093D4                           461  
000093D4  2405                     462      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
000093D6                           463      ; assumes A0 hasnt changed since handed to this method      
000093D6  224A                     464      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000093D8                           465      ; assumes file ID is still stored in D1.L  
000093D8  103C 0036                466      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000093DC  4E4F                     467      trap #15
000093DE                           468  
000093DE                           469      ; add a newline to the file output
000093DE  43F9 000096F6            470      LEA NEWLINE, A1
000093E4  103C 0036                471      MOVE.B #54, D0 
000093E8  143C 0002                472      MOVE.B #2,D2  ; kills # of bytes to write from input param
000093EC  4E4F                     473      trap #15
000093EE                           474      
000093EE                           475      ; finally, close only this file
000093EE  103C 0038                476      MOVE.B #56, D0 ; close file task
000093F2  4E4F                     477      trap #15
000093F4                           478    
000093F4                           479      ; report to screen
000093F4  224A                     480      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000093F6  103C 000D                481      MOVE.B #13, D0
000093FA  4E4F                     482      trap #15
000093FC                           483        
000093FC                           484      ; restore context
000093FC  4CDF 0C3F                485      MOVEM.L (SP)+, toSave
00009400                           486      
00009400  4E75                     487      RTS
00009402                           488      
00009402                           489      
00009402                           490  *----------------------------------------------------------------------------------
00009402                           491  * Method Name: AsciiToHex_1
00009402                           492  * Written by : Berger, Modified by Nash
00009402                           493  * Date       : 3/1/2019
00009402                           494  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
00009402                           495  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
00009402                           496  *              its (4b each) equivalent hex value 
00009402                           497  *  
00009402                           498  *  Preconditions & Input
00009402                           499  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
00009402                           500  *       This function calls another function (strip_ascii)
00009402                           501  *
00009402                           502  *  Postconditions & Output
00009402                           503  *       D7 (output) holds the converted value 
00009402                           504  *       Caller-Saved : D0 is temp, D6 is a loop var
00009402                           505  *----------------------------------------------------------------------------------
00009402                           506  asciiToHexRegList_1HexRegList REG D0,D6
00009402                           507  AsciiToHex_1     
00009402  48E7 8000                508      MOVEM.L asciiToHexRegList_1HexRegList, -(SP)  *save context
00009406  4287                     509      CLR.L D7 * clear our return value
00009408  7C08                     510      MOVE.L #8, D6 ; and set up our loop counter
0000940A                           511  
0000940A                           512  chrLoop
0000940A  1019                     513      MOVE.B (A1)+,D0 * Get the first byte
0000940C  4EB9 00009424            514      jsr strip_ascii * Get rid of the ascii code    
00009412  8E40                     515      OR.W D0,D7 * Load the bits into D7
00009414                           516      
00009414  5306                     517      subI.B #1,D6  *decrement our loop variable
00009416  6700 0006                518      BEQ chrDone   *skip shifting if we are done
0000941A                           519      
0000941A  E987                     520      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
0000941C  60EC                     521      BRA chrLoop
0000941E                           522  
0000941E                           523  chrDone
0000941E  4CDF 0001                524      MOVEM.L (SP)+,asciiToHexRegList_1HexRegList 
00009422  4E75                     525      RTS
00009424                           526  
00009424                           527  
00009424                           528  **********************************************************************
00009424                           529  * SUBROUTINE: strip_ascii
00009424                           530  * remove the ascii code from the digits 0-9,a-f, or A-F
00009424                           531  * Input Parameters: <D0> = ascii code
00009424                           532  *
00009424                           533  * Return parameters: D0.B = number 0...F, returned as 00...0F
00009424                           534  * Registers used internally: D0
00009424                           535  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00009424                           536  *
00009424                           537  ***********************************************************************
00009424                           538  strip_ascii
00009424  B03C 0039                539        CMP.B #$39,D0 * Is it in range of 0-9?
00009428  6F00 001A                540        BLE sub30 * Its a number
0000942C  B03C 0046                541        CMP.B #$46,D0 * Is is A...F?
00009430  6F00 000A                542        BLE sub37 * Its A...F
00009434  0400 0057                543        SUB.B #$57,D0 * Its a...f
00009438  6000 000E                544        BRA ret_sa * Go back
0000943C  0400 0037                545  sub37 SUB.B #$37,D0 * Strip 37
00009440  6000 0006                546        BRA ret_sa * Go back
00009444  0400 0030                547  sub30 SUB.B #$30,D0 * Strip 30
00009448  4E75                     548  ret_sa RTS * Go back
0000944A                           549  ******************************************* END OF NASH CODE ********************
0000944A                           550  MAIN_CONSOLE_1                                                            ;Main print message
0000944A                           551     
0000944A= 3D 3D 3D 3D 3D 3D ...    552        DC.B '============================================================',CR,LF
00009488= 7C 7C 20 20 20 20 ...    553        DC.B '||                                                        ||',CR,LF
000094C6= 7C 7C 20 20 20 23 ...    554        DC.B '||   #####      ###    ##   ##                            ||',CR,LF
00009504= 7C 7C 20 20 23 23 ...    555        DC.B '||  ##        ##   ##  ## ##                              ||',CR,LF
00009542= 7C 7C 20 23 23 20 ...    556        DC.B '|| ## ####     #####   ####                               ||',CR,LF
00009580= 7C 7C 20 23 23 20 ...    557        DC.B '|| ##    ##  ##    ##  ####                               ||',CR,LF
000095BE= 7C 7C 20 23 23 20 ...    558        DC.B '|| ##    ##  ##    ##  ## ##                              ||',CR,LF
000095FC= 7C 7C 20 20 23 23 ...    559        DC.B '||  #####     ######   ##  ##                             ||',CR,LF
0000963A= 7C 7C 20 20 20 20 ...    560        DC.B '||                                                        ||',CR,LF
00009678= 7C 7C 20 20 20 44 ...    561        DC.B '||   Daniel Yan, Fahad Alshehri, Denny Park               ||',CR,LF
000096B6= 3D 3D 3D 3D 3D 3D ...    562        DC.B '============================================================',CR,LF,0
000096F5                           563      
000096F5                           564  * Required variables and constants go here for your Disassembler
000096F5  =0000000D                565  CR              EQU $0D                     ;Carriage return
000096F5  =0000000A                566  LF              EQU $0A                        ;Line feed
000096F6= 000D 000A 0000           567  NEWLINE         DC.W CR,LF,0                    ;Make a new line
000096FC= 44 69 73 61 73 73 ...    568  outFilename     DC.B 'DisassemblerOutput.txt',0             ;Output file
00009713                           569  byteRead        DS.B 1                              ;Read a byte
00009714= 31 41 30 30 31 41 ...    570  ascii_val       DC.B $31,$41,$30,$30,$31,$41,$30,$30            ;Test value $1A001A00
0000971C                           571  
0000971C                           572  * Variables and constants
0000971C  =00000014                573  SIZE_1          EQU     20                          ;Max string size
0000971C= 43 6F 6E 66 69 67 ...    574  fileName_1      DC.B    'Config.cfg',0                  ;Name of text file
00009727                           575  IO_BUFFER_1     DS.B    SIZE_1                                  ;Variable for IO buffer
0000973C                           576  fileID_1            DS.L    1                                   ;Variable for File ID
00009740= 496E 7661 6C69 6...      577  INVALID_ADDRES_MESSAGE_1 DC.W 'Invalid Hex Address' ,CR,LF,0            ;Invalid message print
0000975A                           578  
0000975A                           579      ;INCLUDE "OP_Code_Routines.x68"                     ;OP role code to include
0000975A                           580      ;INCLUDE "EA_Integrated.x68"                            ;EA role code to include
0000975A                           581      ;INCLUDE "MOVEM_TEST.x68"                               ;Test program to include
0000975A                           582  *-----------------------------------------------------------
0000975A                           583  * Title      : OP Code routines for Disassembler
0000975A                           584  * Written by : Daniel Yan
0000975A                           585  * Date       : 2/28/2019, Updated 3/17/2019
0000975A                           586  
0000975A                           587  * Description: Disassembler routines to identify any valid
0000975A                           588  * OP code dependent on current supported list.
0000975A                           589  *------------------------------------------------------------
0000975A                           590  OP_SIZE_1         DS.B    1   ;This constant refers to the size of the current OP code 
0000975B                           591  MNEMONIC        DS.B    1   ;Constant for EA, first 4 bits (15-12) of a 4 hex OP code
0000975C                           592  FIRST_3         DS.B    1   ;Constant for EA, 3 bits (11-9) of a 4 hex OP code
0000975D                           593  SECOND_3        DS.B    1   ;Constant for EA, 3 bits (8-6) of a 4 hex OP code
0000975E                           594  THIRD_3         DS.B    1   ;Constant for EA, 3 bits (5-3) of a 4 hex OP code
0000975F                           595  FOURTH_3        DS.B    1   ;Constant for EA, 3 bits (2-0) of a 4 hex OP code
00009760                           596  
00009760                           597  ************************************************************************************
00009760                           598  *First Nibble Values (15-12)
00009760                           599  *Value                  Operations
00009760                           600  *$0                     GROUP_0: ORI,BCLR (static and dynamic),CMPI 
00009760                           601  *$1                     GROUP_1: MOVE.B                             
00009760                           602  *$2                     GROUP_2: MOVE.L, MOVEA.L                    
00009760                           603  *$3                     GROUP_3: MOVE.W, MOVEA.W                    
00009760                           604  *$4                     GROUP_4: LEA,JSR,RTS,NEG,MOVEM              
00009760                           605  *$5                     GROUP_5: SUBQ                               
00009760                           606  *$6                     GROUP_6: Bcc(BCS,BGE,BLT,BVC), BRA          
00009760                           607  *$7                     GROUP_7: INVALID_OP                         
00009760                           608  *$8                     GROUP_8: DIVS, OR                           
00009760                           609  *$9                     GROUP_9: SUB                                
00009760                           610  *$A                     GROUP_A: INVALID_OP                         
00009760                           611  *$B                     GROUP_B: EOR, CMP                           
00009760                           612  *$C                     GROUP_C: MULS                               
00009760                           613  *$D                     GROUP_D: ADD, ADDA                          
00009760                           614  *$E                     GROUP_E: LSR, LSL, ASR, ASL, ROL, ROR       
00009760                           615  *$F                     GROUP_F: INVALID_OP                         
00009760                           616  
00009760                           617  * OP_JSR_Routine_1
00009760                           618  **********************************************************************************
00009760                           619  * Description: Catalog all supported OP codes into groupings based on their hex
00009760                           620  * values. Sort the supported OP codes by looking at the first nibble for their
00009760                           621  * grouping value. Call underlying subroutines for further identification of the
00009760                           622  * op code.
00009760                           623  *
00009760                           624  * Registers used: A6,D0,D1 
00009760                           625  *
00009760                           626  * Precondition: Instruction set (size Word) has been loaded in the appropriate
00009760                           627  * address to be parsed and read.
00009760                           628  
00009760                           629  * Postcondition: OP code has been identified as either valid or invalid. If it is
00009760                           630  * valid, it is stored into A6 and EA parsing methods are called to pass needed
00009760                           631  * information to EA. If invalid, DATA output will be utilized to indicate so.
00009760                           632  **********************************************************************************
00009760                           633  * These valid operand codes refer to the basic supported operand codes
00009760                           634  * Groups refer to the first nibble value that is supported by the operand
00009760                           635  
00009760                           636  OP_JSR_Routine_1:
00009760  48E7 C000                637      MOVEM.L D0-D1, -(SP)           ;Backup registers D0 and D1 by pushing it on the Stack
00009764  3039 000090A0            638      MOVE.W CUR_OP_CODE_1,D0        ;Move current instruction set to D0
0000976A  13FC 0001 000090A2       639      MOVE.B #1,IS_VALID_1               ;Set IS_VALID_1 bit to 1 by default
00009772  720C                     640      MOVE.L #12, D1                 ;Prepare bit shift left for D1   
00009774  E2A8                     641      LSR.L   D1,D0                  ;Shift 12 bits to only get first 4 bits for D0
00009776                           642  
00009776                           643  GROUP_0:                           ;$0| ORI, BCLR (static and dynamic), CMPI                  
00009776  B03C 0000                644      CMP.B   #$0,D0                 ;Compare first nibble
0000977A  6600 000C                645      BNE     GROUP_1                ;If first nibble value isn't $0, branch to next
0000977E  4EB9 000099C6            646      JSR     C_GROUP_0              ;Jump to group 0 checking if nibble value is $0
00009784  6000 010C                647      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009788                           648      
00009788                           649  GROUP_1:                           ;$1| MOVE.B
00009788  B03C 0001                650      CMP.B   #$1,D0                 ;Compare first nibble
0000978C  6600 000C                651      BNE     GROUP_2                ;If first nibble value isn't $1, branch to next
00009790  4EB9 00009BD8            652      JSR     C_GROUP_1              ;Jump to group 1 checking if nibble value is $1
00009796  6000 00FA                653      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
0000979A                           654  
0000979A                           655  GROUP_2:                           ;$2| MOVE.L, MOVEA.L
0000979A  B03C 0002                656      CMP.B   #$2,D0                 ;Compare first nibble
0000979E  6600 000C                657      BNE     GROUP_3                ;If first nibble value isn't $2, branch to next
000097A2  4EB9 00009C04            658      JSR     C_GROUP_2              ;Jump to group 2 checking if nibble value is $2
000097A8  6000 00E8                659      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
000097AC                           660  
000097AC                           661  GROUP_3:                           ;$3| MOVE.W, MOVEA.W
000097AC  B03C 0003                662      CMP.B   #$3,D0                 ;Compare first nibble
000097B0  6600 000C                663      BNE     GROUP_4                ;If first nibble value isn't $3, branch to next
000097B4  4EB9 00009C6C            664      JSR     C_GROUP_3              ;Jump to group 3 checking if nibble value is $3
000097BA  6000 00D6                665      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
000097BE                           666  
000097BE                           667  GROUP_4:                           ;$4| LEA, JSR, RTS, NEG, MOVEM
000097BE  B03C 0004                668      CMP.B   #$4,D0                 ;Compare first nibble
000097C2  6600 000C                669      BNE     GROUP_5                ;If first nibble value isn't $4, branch to next
000097C6  4EB9 00009CD4            670      JSR     C_GROUP_4              ;Jump to group 4 checking if nibble value is $4
000097CC  6000 00C4                671      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
000097D0                           672  
000097D0                           673  
000097D0                           674  GROUP_5:                           ;$5| SUBQ
000097D0  B03C 0005                675      CMP.B   #$5,D0                 ;Compare first nibble
000097D4  6600 000C                676      BNE     GROUP_6                ;If first nibble value isn't $5, branch to next
000097D8  4EB9 00009FD4            677      JSR     C_GROUP_5              ;Jump to group 5 checking if nibble value is $5
000097DE  6000 00B2                678      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
000097E2                           679  
000097E2                           680  
000097E2                           681  GROUP_6:                           ;$6| Bcc (BCS,BGE,BLT,BVC) BRA
000097E2  B03C 0006                682      CMP.B   #$6,D0                 ;Compare first nibble
000097E6  6600 000C                683      BNE     GROUP_7                ;If first nibble value isn't $6, branch to next
000097EA  4EB9 0000A048            684      JSR     C_GROUP_6              ;Jump to group 6 checking if nibble value is $6
000097F0  6000 00A0                685      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
000097F4                           686  
000097F4                           687  
000097F4                           688  GROUP_7:                           ;$7| Display: DATA, $WXYZ (Unsupported)
000097F4  B03C 0007                689      CMP.B   #$7,D0                 ;Compare first nibble
000097F8  6600 000C                690      BNE     GROUP_8                ;If first nibble value isn't $7, branch to next
000097FC  4EB9 0000A1AA            691      JSR     C_GROUP_7              ;Jump to group 7 checking if nibble value is $7
00009802  6000 008E                692      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009806                           693  
00009806                           694  
00009806                           695  GROUP_8:                           ;$8| DIVS, OR
00009806  B03C 0008                696      CMP.B   #$8,D0                 ;Compare first nibble
0000980A  6600 000C                697      BNE     GROUP_9                ;If first nibble value isn't $8, branch to next
0000980E  4EB9 0000A1CC            698      JSR     C_GROUP_8              ;Jump to group 8 checking if nibble value is $8
00009814  6000 007C                699      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009818                           700  
00009818                           701  
00009818                           702  GROUP_9:                           ;$9| SUB
00009818  B03C 0009                703      CMP.B   #$9,D0                 ;Compare first nibble
0000981C  6600 000C                704      BNE     GROUP_A                ;If first nibble value isn't $9, branch to next
00009820  4EB9 0000A234            705      JSR     C_GROUP_9              ;Jump to group 9 checking if nibble value is $9
00009826  6000 006A                706      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
0000982A                           707  
0000982A                           708  
0000982A                           709  GROUP_A:                           ;$A| Display: DATA, $WXYZ (Unsupported)
0000982A  B03C 000A                710      CMP.B   #$A,D0                 ;Compare first nibble
0000982E  6600 000C                711      BNE     GROUP_B                ;If first nibble value isn't $A, branch to next
00009832  4EB9 0000A2B2            712      JSR     C_GROUP_A              ;Jump to group A checking if nibble value is $A
00009838  6000 0058                713      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
0000983C                           714  
0000983C                           715  
0000983C                           716  GROUP_B:                           ;$B| EOR, CMP
0000983C  B03C 000B                717      CMP.B   #$B,D0                 ;Compare first nibble
00009840  6600 000C                718      BNE     GROUP_C                ;If first nibble value isn't $B, branch to next
00009844  4EB9 0000A2BA            719      JSR     C_GROUP_B              ;Jump to group B checking if nibble value is $B
0000984A  6000 0046                720      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
0000984E                           721  
0000984E                           722  
0000984E                           723  GROUP_C:                           ;$C| MULS
0000984E  B03C 000C                724      CMP.B   #$C,D0                 ;Compare first nibble
00009852  6600 000C                725      BNE     GROUP_D                ;If first nibble value isn't $C, branch to next
00009856  4EB9 0000A33A            726      JSR     C_GROUP_C              ;Jump to group C checking if nibble value is $C
0000985C  6000 0034                727      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009860                           728  
00009860                           729  
00009860                           730  GROUP_D:                           ;$D| ADD, ADDA
00009860  B03C 000D                731      CMP.B   #$D,D0                 ;Compare first nibble
00009864  6600 000C                732      BNE     GROUP_E                ;If first nibble value isn't $D, branch to next
00009868  4EB9 0000A3C8            733      JSR     C_GROUP_D              ;Jump to group D checking if nibble value is $D
0000986E  6000 0022                734      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009872                           735  
00009872                           736  
00009872                           737  GROUP_E:                           ;$E| LSR, LSL, ASR, ASL, ROL, ROR
00009872  B03C 000E                738      CMP.B   #$E,D0                 ;Compare first nibble
00009876  6600 000C                739      BNE     GROUP_F                ;If first nibble value isn't $E, branch to next
0000987A  4EB9 0000A434            740      JSR     C_GROUP_E              ;Jump to group E checking if nibble value is $E
00009880  6000 0010                741      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009884                           742  
00009884                           743  
00009884                           744  GROUP_F:                           ;$F| Display: DATA, $WXYZ (Unsupported)
00009884  B03C 000F                745      CMP.B   #$F,D0                 ;Compare first nibble
00009888  4EB9 0000A610            746      JSR     C_GROUP_F              ;Jump to group F checking if nibble value is $F
0000988E  6000 0002                747      BRA     OP_JSR_DONE_1            ;Finish subroutine once checking is finished
00009892                           748  
00009892                           749  
00009892                           750  OP_JSR_DONE_1:                     ;This subroutine is only called when identification has been finished
00009892  4CDF 0003                751           MOVEM.L (SP)+,D0-D1       ;Recover register D0
00009896  0C39 0001 000090A2       752           CMP.B #1,IS_VALID_1           ;Checks if the IS_VALID_1 bit is valid or not
0000989E  6700 1258                753           BEQ    main_EA            ;This runs EA's routines after OP code portion is finished
000098A2  6600 F922                754           BNE    check_print        ;If not valid, skip EA routine and call IO
000098A6                           755  **********************************************************************************    
000098A6                           756  * FIND_2_BIT_SIZE_1_7_TO_6
000098A6                           757  **********************************************************************************
000098A6                           758  * Description: For OP codes with 2 bit size fields, the 2 relevant bits (7-6) will 
000098A6                           759  * be parsed and moved to the appropriate registers.
000098A6                           760  *
000098A6                           761  * Registers used: D0,D1
000098A6                           762  *
000098A6                           763  * Precondition: OP code has been identified with 2 size bit field for CUR_OP_CODE_1.
000098A6                           764  *
000098A6                           765  * Postcondition: 2 bit size field has been isolated and stored into OP_SIZE_1.
000098A6                           766  **********************************************************************************
000098A6                           767  FIND_2_BIT_SIZE_1_7_TO_6:         ;Move the 2 bit size field relevant register
000098A6  48E7 C000                768      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000098AA  3039 000090A0            769      MOVE.W   CUR_OP_CODE_1,D0     ;Move current OP code into D0
000098B0  323C 0008                770      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
000098B4  E368                     771      LSL.W    D1,D0              ;Truncate to find the 2 size bits
000098B6  E268                     772      LSR.W    D1,D0              ;Reposition the bits
000098B8  323C 0006                773      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000098BC  E268                     774      LSR.W    D1,D0              ;Truncate to shift 2 bits to a byte
000098BE  13C0 0000975A            775      MOVE.B   D0,OP_SIZE_1         ;Move 2 size bits into OP_SIZE_1
000098C4  4CDF 0003                776      MOVEM.L (SP)+,D0-D1         ;Restore registers
000098C8  4E75                     777      RTS                         ;Return to stack
000098CA                           778  **********************************************************************************
000098CA                           779  
000098CA                           780  * FIND_1_BIT_SIZE_1_6
000098CA                           781  **********************************************************************************
000098CA                           782  * Description: For OP codes with 1 bit size fields, the 1 relevant bit 6 will 
000098CA                           783  * be parsed and moved to the appropriate registers.
000098CA                           784  * This particular size parsing is used for MOVEM
000098CA                           785  *
000098CA                           786  * Registers used: D0,D1
000098CA                           787  *
000098CA                           788  * Precondition: OP code has been identified with 1 size bit field for CUR_OP_CODE_1.
000098CA                           789  *
000098CA                           790  * Postcondition: 1 bit size field has been isolated and stored into OP_SIZE_1.
000098CA                           791  **********************************************************************************
000098CA                           792  FIND_1_BIT_SIZE_1_6:              ;Move the 1 bit size field relevant register
000098CA  48E7 C000                793      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000098CE  3039 000090A0            794      MOVE.W   CUR_OP_CODE_1,D0     ;Move current OP code into D0
000098D4  323C 0009                795      MOVE.W   #9,D1              ;Prepare 9 bit shift to D1
000098D8  E368                     796      LSL.W    D1,D0              ;Truncate to find the size bit
000098DA  E268                     797      LSR.W    D1,D0              ;Reposition the bits
000098DC  323C 0006                798      MOVE.W   #6,D1              ;Prepare 6 bit shift to D1
000098E0  E268                     799      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
000098E2  13C0 0000975A            800      MOVE.B   D0,OP_SIZE_1         ;Move 1 size bit into OP_SIZE_1
000098E8  4CDF 0003                801      MOVEM.L (SP)+,D0-D1         ;Restore registers
000098EC  4E75                     802      RTS                         ;Return to stack
000098EE                           803  **********************************************************************************
000098EE                           804  
000098EE                           805  * FIND_1_BIT_SIZE_1_8
000098EE                           806  **********************************************************************************
000098EE                           807  * Description: For OP codes with 1 bit size fields, the 1 relevant bit 8 will 
000098EE                           808  * be parsed and moved to the appropriate registers.
000098EE                           809  * This particular size parsing is used for ADDA
000098EE                           810  *
000098EE                           811  * Registers used: D0,D1
000098EE                           812  *
000098EE                           813  * Precondition: OP code has been identified with 1 size bit field for CUR_OP_CODE_1.
000098EE                           814  *
000098EE                           815  * Postcondition: 1 bit size field has been isolated and stored into OP_SIZE_1.
000098EE                           816  *
000098EE                           817  **********************************************************************************
000098EE                           818  FIND_1_BIT_SIZE_1_8:         ;Move the 1 bit size field relevant register
000098EE  48E7 C000                819      MOVEM.L  D0-D1,-(SP)        ;Save all changed registers
000098F2  3039 000090A0            820      MOVE.W   CUR_OP_CODE_1,D0     ;Move current OP code into D0
000098F8  323C 0007                821      MOVE.W   #7,D1              ;Prepare 7 bit shift to D1
000098FC  E368                     822      LSL.W    D1,D0              ;Truncate to find the 1 size bit
000098FE  E268                     823      LSR.W    D1,D0              ;Reposition the bits
00009900  323C 0008                824      MOVE.W   #8,D1              ;Prepare 8 bit shift to D1
00009904  E268                     825      LSR.W    D1,D0              ;Truncate to shift 1 bit to a byte
00009906  13C0 0000975A            826      MOVE.B   D0,OP_SIZE_1         ;Move 1 size bit into OP_SIZE_1
0000990C  4CDF 0003                827      MOVEM.L (SP)+,D0-D1         ;Restore registers
00009910  4E75                     828      RTS                         ;Return to stack
00009912                           829  **********************************************************************************
00009912                           830  
00009912                           831  * MOVE_AND_MOVEA_PARSE_EA
00009912                           832  **********************************************************************************
00009912                           833  * Description: Special parsing for the SRC and DST Mode/Reg for MOVE/MOVE
00009912                           834  *
00009912                           835  * Registers used: A6,D0,D1,D7,D6,D5,D4
00009912                           836  *
00009912                           837  * Precondition: OP code has been identified with either MOVE or MOVEA
00009912                           838  *
00009912                           839  * Postcondition: Store all relevant EA bits into associated register.
00009912                           840  * This particular routine is not Callee saved as it needs to change D7 and D6
00009912                           841  **********************************************************************************
00009912                           842  MOVE_AND_MOVEA_PARSE_EA:     ;Move the 3 bit dynamic register bits to proper register
00009912  3039 000090A0            843      MOVE.W CUR_OP_CODE_1,D0    ;Move current OP code into D0
00009918  323C 000A                844      MOVE.W  #10,D1           ;Prepare 10 bit shift to D1
0000991C  E368                     845      LSL.W   D1,D0            ;Truncate to find the last 6 bits
0000991E  E268                     846      LSR.W   D1,D0            ;Shift back to get the proper 6 bits
00009920  3E00                     847      MOVE.W  D0,D7            ;Move last 6 bits into D7, SRC REG MODE
00009922  323C 0003                848      MOVE.W  #3,D1            ;Prepare 3 bit shift into D1
00009926  E26F                     849      LSR.W   D1,D7            ;Shift 3 bits off D7 to obtain EA Mode
00009928  3A07                     850      MOVE.W  D7,D5            ;Move the 'upper' 3 bits into D6
0000992A  323C 000D                851      MOVE.W  #13,D1           ;Prepare 13 bit shift into D1
0000992E  E368                     852      LSL.W   D1,D0            ;Shift D0 left 13 bits to reposition current 3 bits
00009930  E268                     853      LSR.W   D1,D0            ;Shift D0 right 13 bits to reposition current 3 bits
00009932  3800                     854      MOVE.W  D0,D4            ;Move the 'lower' 3 bits into D7
00009934                           855      
00009934                           856  ****MOVING_SOURCE***********
00009934  3039 000090A0            857      MOVE.W CUR_OP_CODE_1,D0    ;Move current OP code into D0     
0000993A  323C 0004                858      MOVE.W  #4,D1            ;Prepare 4 bit shift to D1
0000993E  E368                     859      LSL.W   D1,D0            ;Truncate to find bits 11-6
00009940  E268                     860      LSR.W   D1,D0            ;Reposition bits
00009942  323C 0006                861      MOVE.W  #6,D1            ;Prepare 6 bit shift to D1
00009946  E268                     862      LSR.W   D1,D0            ;Truncate the SRC Reg/Mode bits
00009948  323C 0003                863      MOVE.W  #3,D1            ;Prepare a 3 bit shift to D1 for DST Reg/Mode
0000994C  3C00                     864      MOVE.W  D0,D6            ;Copy over the current 6 bits to D6
0000994E  E268                     865      LSR.W   D1,D0            ;Truncate DST Mode  
00009950  3E00                     866      MOVE.W  D0,D7            ;Move DST Reg to D7
00009952  323C 000D                867      MOVE.W  #13,D1             
00009956  E36E                     868      LSL.W   D1,D6            ;Truncate 13 bits in D6
00009958  E26E                     869      LSR.W   D1,D6            ;Reposition D6
0000995A                           870                               ;D6 now contains the DST Reg
0000995A  4E75                     871      RTS                      ;Return to stack
0000995C                           872  **********************************************************************************
0000995C                           873  ********** EA Parsing ************************************************************
0000995C                           874  *PARSE_EA_CONSTANT_BITS
0000995C                           875  **********************************************************************************
0000995C                           876  * Definition: Uses CUR_OP_CODE_1 to shift the proper bits into the global constants
0000995C                           877  * used for EA (MNEMONIC,FIRST_3,SECOND_3,THIRD_3,FOURTH_3. Where MNEMONIC refers
0000995C                           878  * to the first 4 bits of CUR_OP_CODE_1 (15-12), FIRST_3 refers to the first group
0000995C                           879  * of 3 bits (11-9), SECOND_3 refers to the second group of 3 bits (8-6), THIRD_3
0000995C                           880  * refers to the third group of 3 bits (5-3), and FOURTH_3 refers to the fourth
0000995C                           881  * group of 3 bits (2-0). Shifts CUR_OP_CODE_1 bits to initialize constants.
0000995C                           882  *
0000995C                           883  * Registers used: D0,D1
0000995C                           884  *
0000995C                           885  * Precondition: CUR_OP_CODE_1 has been set with an 4 hex instruction set
0000995C                           886  * 
0000995C                           887  * Postcondition: MNEMONIC, FIRST_3, SECOND_3, THIRD_3, FOURTH_3 have been set
0000995C                           888  * to the corresponding values.
0000995C                           889  **********************************************************************************
0000995C                           890  PARSE_EA_CONSTANT_BITS:
0000995C  48E7 C000                891      MOVEM.L D0-D1,-(SP)         ;Save register to stack
00009960                           892      *MNEMONIC SHIFT
00009960  3039 000090A0            893      MOVE.W CUR_OP_CODE_1,D0       ;Load in current instruction set into D0
00009966  323C 000C                894      MOVE.W #12,D1               ;Prepare a bit shift of 12 into D1
0000996A  E268                     895      LSR.W D1,D0                 ;Shift 12 bits from D0 right
0000996C  13C0 0000975B            896      MOVE.B D0,MNEMONIC          ;Set MNEMONIC to D0
00009972                           897      *FIRST_3 SHIFT
00009972  323C 0009                898      MOVE.W #9,D1                ;Prepare a bit shift of 9 into D1
00009976  3039 000090A0            899      MOVE.W CUR_OP_CODE_1,D0       ;Load in current instruction set into D
0000997C  E948                     900      LSL.W #4,D0                 ;Shift out bits 15-12 in D0
0000997E  E848                     901      LSR.W #4,D0                 ;Reposition D0
00009980  E268                     902      LSR.W  D1,D0                ;Shift D0 9 bits right
00009982  13C0 0000975C            903      MOVE.B D0,FIRST_3           ;Set FIRST_3 to D0
00009988                           904      *SECOND_3 SHIFT
00009988  3039 000090A0            905      MOVE.W CUR_OP_CODE_1,D0       ;Load in current instruction set into D
0000998E  EF48                     906      LSL.W #7,D0                 ;Shift out bits 15-9 in D0
00009990  EE48                     907      LSR.W #7,D0                 ;Reposition D0
00009992  EC48                     908      LSR.W #6,D0                 ;Shift D0 6 bits right
00009994  13C0 0000975D            909      MOVE.B D0,SECOND_3          ;Set SECOND_3 to D0
0000999A                           910      *THIRD_3 SHIFT
0000999A  3039 000090A0            911      MOVE.W CUR_OP_CODE_1,D0       ;Load in current instruction set into D
000099A0  E648                     912      LSR.W #3,D0                 ;Shift D0 3 bits right
000099A2  323C 000D                913      MOVE.W #13,D1               ;Prepare a 13 bit shift into D1
000099A6  E368                     914      LSL.W D1,D0                 ;Truncate first 13 bits of D0
000099A8  E268                     915      LSR.W D1,D0                 ;Reposition D0
000099AA  13C0 0000975E            916      MOVE.B D0,THIRD_3           ;Set THIRD_3 to D0
000099B0                           917      *FOURTH_3 SHIFT
000099B0  3039 000090A0            918      MOVE.W CUR_OP_CODE_1,D0       ;Load in current instruction set into D
000099B6  E368                     919      LSL.W D1,D0                 ;Grab the fourth 3-bit group
000099B8  E268                     920      LSR.W D1,D0                 ;Shift D0 back into position
000099BA  13C0 0000975F            921      MOVE.B D0,FOURTH_3          ;Set FOURTH_3 to Do
000099C0  4CDF 0003                922      MOVEM.L (SP)+,D0-D1         ;Restore registers
000099C4  4E75                     923      RTS                         ;Return to stack
000099C6                           924  **********************************************************************************
000099C6                           925  ********** End of EA Parsing *****************************************************
000099C6                           926  
000099C6                           927  *******************JMP LABELS ****************************************************
000099C6                           928  * Labeling for group codes will be in the following format
000099C6                           929  
000099C6                           930  * <JMP Label Name>
000099C6                           931  ********************************************************************************
000099C6                           932  * Checking List Order (If more than one value)
000099C6                           933  * Operand1 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000099C6                           934  * Operand2 - $<nibble value>, a-b <specifier>, c-d <specifier> ...
000099C6                           935  
000099C6                           936  * Where a-b will refer to the bit corresponding bit value in the instruction
000099C6                           937  * format, and a specifier will be attached such as Size, EA Mode, SRC Reg, etc
000099C6                           938  * to clarify what a specific bit range means.
000099C6                           939  * Checking order refers to what order the checks will be performed in. 
000099C6                           940  * Any other code outside of the listed supported ones will be routed toINVALID_OP.
000099C6                           941  ********************************************************************************
000099C6                           942  
000099C6                           943  ********************************************************************************
000099C6                           944  * Global Field Descriptions
000099C6                           945  * Size Field: Byte = 00 Word = 01 Long = 10
000099C6                           946  * EA Mode: Refer to EA Address Modes
000099C6                           947  * EA Reg: 3-bit input that is mapped to the respective binary value
000099C6                           948  ********************************************************************************
000099C6                           949  
000099C6                           950  * GROUP_0                      
000099C6                           951  ********************************************************************************
000099C6                           952  * Description: Checks for the following listed OP codes to be present or not
000099C6                           953  * Supported OP codes:
000099C6                           954  * ORI: $00, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000099C6                           955  * CMPI: $0C, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
000099C6                           956  * Dynamic BCLR: $0, 11-9 Register, 8-6 %110, 5-3 EA Mode, 2-0 EA Reg
000099C6                           957  * Static BCLR: $01, 7-6 10, 5-3 EA Mode, 2-0 EA Reg
000099C6                           958  *
000099C6                           959  * Register(s) used: D0
000099C6                           960  *
000099C6                           961  * Precondition: First nibble has been identified as $0
000099C6                           962  *
000099C6                           963  * Postcondition: Parses proper OP code with a nibble value of $0 or finds an
000099C6                           964  * invalid OP code.
000099C6                           965  * 
000099C6                           966  * Unsupported OP codes:
000099C6                           967  * ORI_TO_CCR, ORI_TO_SR, ANDI_TO_CCR, ANDI_TO_SR, ANDI, SUBI, ADDI, EORI_TO_CCR
000099C6                           968  * EORI_TO_SR, EORI, STATIC_BTST, STATIC_BCHG, STATIC_BSET, DYNAMIC_BTST,
000099C6                           969  * DYNAMIC_BCHG, DYNAMIC_BSET, MOVEP 
000099C6                           970  ********************************************************************************
000099C6                           971  C_GROUP_0:
000099C6  48E7 C000                972      MOVEM.L D0-D1, -(SP)            ;Backup registers
000099CA                           973      
000099CA                           974  *Unsupported OP codes that are fully static in bits
000099CA                           975  CHECK_OP_ORI_TO_CCR:
000099CA  3039 000090A0            976      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
000099D0  B07C 003C                977      CMP.W #$003C,D0                 ;Compare the direct full bits
000099D4  6700 01F6                978      BEQ GROUP0_INVALID              ;INVALID OP code found
000099D8  6600 0002                979      BNE CHECK_OP_ORI_TO_SR          ;Check next routine
000099DC                           980      
000099DC                           981  CHECK_OP_ORI_TO_SR:
000099DC  3039 000090A0            982      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
000099E2  B07C 007C                983      CMP.W #$007C,D0                 ;Compare the direct full bits
000099E6  6700 01E4                984      BEQ GROUP0_INVALID              ;INVALID OP code found
000099EA  6600 0002                985      BNE CHECK_OP_ANDI_TO_CCR        ;Check next routine
000099EE                           986      
000099EE                           987  CHECK_OP_ANDI_TO_CCR:
000099EE  3039 000090A0            988      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
000099F4  B07C 023C                989      CMP.W #$023C,D0                 ;Compare the direct full bits
000099F8  6700 01D2                990      BEQ GROUP0_INVALID              ;INVALID OP code found
000099FC  6600 0002                991      BNE CHECK_OP_ANDI_TO_SR         ;Check next routine
00009A00                           992      
00009A00                           993  CHECK_OP_ANDI_TO_SR:
00009A00  3039 000090A0            994      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A06  B07C 027C                995      CMP.W #$027C,D0                 ;Compare the direct full bits
00009A0A  6700 01C0                996      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A0E  6600 0002                997      BNE CHECK_OP_EORI_TO_CCR                ;Check next routine
00009A12                           998  
00009A12                           999  CHECK_OP_EORI_TO_CCR:
00009A12  3039 000090A0           1000      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A18  B07C 0A3C               1001      CMP.W #$0A3C,D0                 ;Compare the direct full bits
00009A1C  6700 01AE               1002      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A20  6600 0002               1003      BNE CHECK_OP_EORI_TO_SR         ;Check next routine
00009A24                          1004      
00009A24                          1005  CHECK_OP_EORI_TO_SR:
00009A24  3039 000090A0           1006      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A2A  B07C 0A7C               1007      CMP.W #$0A7C,D0                 ;Compare the direct full bits
00009A2E  6700 019C               1008      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A32  6600 0002               1009      BNE CHECK_OP_ANDI               ;Check next routine
00009A36                          1010      
00009A36                          1011  *Unsupported OP codes to check with partial static bits
00009A36                          1012  CHECK_OP_ANDI:
00009A36  3039 000090A0           1013      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A3C  0240 FF00               1014      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009A40  B07C 0200               1015      CMP.W #$0200,D0                 ;Compare the appropriate masked bits
00009A44  6700 0186               1016      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A48  6600 0002               1017      BNE CHECK_OP_SUBI               Check next routine
00009A4C                          1018      
00009A4C                          1019  CHECK_OP_SUBI:
00009A4C  3039 000090A0           1020      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A52  0240 FF00               1021      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009A56  B07C 0400               1022      CMP.W #$0400,D0                 ;Compare the appropriate masked bits
00009A5A  6700 0170               1023      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A5E  6600 0002               1024      BNE CHECK_OP_ADDI               ;Check next routine
00009A62                          1025  
00009A62                          1026  CHECK_OP_ADDI:
00009A62  3039 000090A0           1027      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A68  0240 FF00               1028      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009A6C  B07C 0600               1029      CMP.W #$0600,D0                 ;Compare the appropriate masked bits
00009A70  6700 015A               1030      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A74  6600 0002               1031      BNE CHECK_OP_EORI               ;Check next routine 
00009A78                          1032  
00009A78                          1033  CHECK_OP_EORI:
00009A78  3039 000090A0           1034      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A7E  0240 FF00               1035      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009A82  B07C 0A00               1036      CMP.W #$0A00,D0                 ;Compare the appropriate masked bits
00009A86  6700 0144               1037      BEQ GROUP0_INVALID              ;INVALID OP code found
00009A8A  6600 0002               1038      BNE CHECK_OP_STATIC_BTST        ;Check next routine
00009A8E                          1039      
00009A8E                          1040  CHECK_OP_STATIC_BTST:
00009A8E  3039 000090A0           1041      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009A94  0240 FFC0               1042      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009A98  B07C 0800               1043      CMP.W #$0800,D0                 ;Compare the appropriate masked bits
00009A9C  6700 012E               1044      BEQ GROUP0_INVALID              ;INVALID OP code found
00009AA0  6600 0002               1045      BNE CHECK_OP_STATIC_BCHG        ;Check next routine
00009AA4                          1046      
00009AA4                          1047  CHECK_OP_STATIC_BCHG:
00009AA4  3039 000090A0           1048      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009AAA  0240 FFC0               1049      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009AAE  B07C 0840               1050      CMP.W #$0840,D0                 ;Compare the appropriate masked bits
00009AB2  6700 0118               1051      BEQ GROUP0_INVALID              ;INVALID OP code found
00009AB6  6600 0002               1052      BNE CHECK_OP_STATIC_BSET        ;Check next routine
00009ABA                          1053  
00009ABA                          1054  CHECK_OP_STATIC_BSET:
00009ABA  3039 000090A0           1055      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009AC0  0240 FFC0               1056      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009AC4  B07C 08C0               1057      CMP.W #$08C0,D0                 ;Compare the appropriate masked bits
00009AC8  6700 0102               1058      BEQ GROUP0_INVALID              ;INVALID OP code found   
00009ACC  6600 0002               1059      BNE CHECK_OP_DYNAMIC_BTST       ;Check next routine
00009AD0                          1060  
00009AD0                          1061  CHECK_OP_DYNAMIC_BTST:
00009AD0  3039 000090A0           1062      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009AD6  0240 F1C0               1063      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00009ADA  B07C 0100               1064      CMP.W #$0100,D0                 ;Compare the appropriate masked bits
00009ADE  6700 00EC               1065      BEQ GROUP0_INVALID              ;INVALID OP code found
00009AE2  6600 0002               1066      BNE CHECK_OP_DYNAMIC_BCHG       ;Check next routine
00009AE6                          1067  
00009AE6                          1068  CHECK_OP_DYNAMIC_BCHG:
00009AE6  3039 000090A0           1069      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009AEC  0240 F1C0               1070      ANDI.W #$F1C0,D0                ;Mask relevant bits to D0
00009AF0  B07C 0140               1071      CMP.W #$0140,D0                 ;Compare the appropriate masked bits 
00009AF4  6700 00D6               1072      BEQ GROUP0_INVALID              ;INVALID OP code found
00009AF8  6600 0002               1073      BNE CHECK_OP_DYNAMIC_BSET       ;Check next routine
00009AFC                          1074      
00009AFC                          1075  CHECK_OP_DYNAMIC_BSET:
00009AFC                          1076  
00009AFC  3039 000090A0           1077      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
00009B02  0240 F1C0               1078      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00009B06  B07C 01C0               1079      CMP.W   #$01C0,D0               ;Compare the appropriate masked bits 
00009B0A  6700 0006               1080      BEQ     BIT_CHECK_MOVEP         ;Check special case for MOVEP
00009B0E  6600 001E               1081      BNE     CHECK_OP_MOVEP          ;Check next routine
00009B12                          1082  
00009B12                          1083  BIT_CHECK_MOVEP:                                ;This is a special case check for MOVEP
00009B12  3039 000090A0           1084      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
00009B18  323C 000A               1085      MOVE.W  #10,D1                  ;Prepare a 10-bit shift
00009B1C  E368                    1086      LSL.W   D1,D0                   ;Shift out 10 bits left 
00009B1E  E268                    1087      LSR.W   D1,D0                   ;Reposition D0 for last 6 bits
00009B20  E648                    1088      LSR.W   #3,D0                   ;Shift out 3 bits right, D0 contains bits 5-3
00009B22  B07C 0001               1089      CMP.W   #$1,D0                  ;Compare bits to D0
00009B26  6700 0006               1090      BEQ     CHECK_OP_MOVEP          ;If bits are $1 then it's addressing, goto MOVEP
00009B2A  6600 00A0               1091      BNE     GROUP0_INVALID          ;If not then it's DYNAMIC_BSET which is invalid
00009B2E                          1092      
00009B2E                          1093  CHECK_OP_MOVEP:
00009B2E  3039 000090A0           1094      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009B34  0240 F138               1095      ANDI.W #$F138,D0                ;Mask relevant bits to D0
00009B38  B07C 0108               1096      CMP.W #$0108,D0                 ;Compare the appropriate masked bits
00009B3C  6700 0ADA               1097      BEQ INVALID_OP                  ;INVALID OP code found
00009B40  6600 0002               1098      BNE CHECK_OP_ORI                ;Check next routine
00009B44                          1099  
00009B44                          1100  *Supported OP code checks
00009B44                          1101  CHECK_OP_ORI:
00009B44  3039 000090A0           1102      MOVE.W  CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009B4A  0240 FF00               1103      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00009B4E  B07C 0000               1104      CMP.W   #$0000,D0               ;Compare the appropriate masked bits     
00009B52  6600 0012               1105      BNE     CHECK_OP_CMPI           ;Branch to next comparison if not equal
00009B56  4EB9 000098A6           1106      JSR     FIND_2_BIT_SIZE_1_7_TO_6
00009B5C  4EB9 0000A634           1107      JSR     PRINT_OP_ORI            ;Print the OP code if equal    
00009B62  6000 006E               1108      BRA     GROUP0_SUCCESS          ;Finish routine
00009B66                          1109      
00009B66                          1110  CHECK_OP_CMPI:
00009B66  3039 000090A0           1111      MOVE.W  CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009B6C  0240 FF00               1112      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00009B70  B07C 0C00               1113      CMP.W   #$0C00,D0               ;Compare the appropriate masked bits   
00009B74  6600 0012               1114      BNE     CHECK_OP_STATIC_BCLR    ;Branch to next comparison if not equal       
00009B78  4EB9 000098A6           1115      JSR     FIND_2_BIT_SIZE_1_7_TO_6
00009B7E  4EB9 0000A64C           1116      JSR     PRINT_OP_CMPI           ;Print the OP code if equal
00009B84  6000 004C               1117      BRA     GROUP0_SUCCESS          ;Finish routine
00009B88                          1118      
00009B88                          1119  CHECK_OP_STATIC_BCLR:
00009B88  3039 000090A0           1120      MOVE.W  CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009B8E  0240 FF00               1121      ANDI.W  #$FF00,D0               ;Mask relevant bits to D0
00009B92  B07C 0800               1122      CMP.W   #$0800,D0               ;Compare the appropriate masked bits
00009B96  6600 0012               1123      BNE     CHECK_OP_DYNAMIC_BCLR   ;Branch to next comparison if not equal
00009B9A  4EB9 000098A6           1124      JSR     FIND_2_BIT_SIZE_1_7_TO_6
00009BA0  4EB9 0000A664           1125      JSR     PRINT_OP_STATIC_BCLR    ;Print the OP code if equal
00009BA6  6000 002A               1126      BRA     GROUP0_SUCCESS          ;Finish routine
00009BAA                          1127      
00009BAA                          1128  CHECK_OP_DYNAMIC_BCLR:
00009BAA  3039 000090A0           1129      MOVE.W  CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009BB0  0240 0180               1130      ANDI.W  #$0180,D0               ;Mask relevant bits to D0
00009BB4  B07C 0180               1131      CMP.W   #$0180,D0               ;Compare the appropriate masked bits
00009BB8  6600 0012               1132      BNE     GROUP0_INVALID          ;If not equal this must be an invalid OP code
00009BBC  4EB9 000098A6           1133      JSR     FIND_2_BIT_SIZE_1_7_TO_6
00009BC2  4EB9 0000A67C           1134      JSR     PRINT_OP_DYNAMIC_BCLR   ;Print the OP code if equal
00009BC8  6000 0008               1135      BRA     GROUP0_SUCCESS          ;Finish routine
00009BCC                          1136  
00009BCC                          1137  GROUP0_INVALID:                     ;Checks have been finished, invalid OP code has been found
00009BCC  4EB9 0000A618           1138      JSR INVALID_OP                  ;INVALID OP code found
00009BD2                          1139  GROUP0_SUCCESS:                     ;Checks have been finished,a valid OP code has been found
00009BD2  4CDF 0003               1140      MOVEM.L (SP)+,D0-D1             ;Restore registers
00009BD6  4E75                    1141      RTS                             ;Return to stack
00009BD8                          1142      
00009BD8                          1143  * GROUP_1                      
00009BD8                          1144  ********************************************************************************
00009BD8                          1145  * Description: Checks for the following OP code to be present or not.
00009BD8                          1146  * Supported OP code:
00009BD8                          1147  * MOVE.B: $1, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00009BD8                          1148  *
00009BD8                          1149  * Register(s) used: D0,D1
00009BD8                          1150  *
00009BD8                          1151  * Precondition: First nibble has been identified as $1
00009BD8                          1152  *
00009BD8                          1153  * Postcondition: Parses proper OP code with a nibble value of $1 or finds an
00009BD8                          1154  * invalid OP code.********************************************************************************
00009BD8                          1155  C_GROUP_1:
00009BD8  48E7 C000               1156      MOVEM.L D0-D1,-(SP)             ;Save registers to stack
00009BDC                          1157  
00009BDC                          1158  CHECK_OP_MOVE_B:
00009BDC  3039 000090A0           1159      MOVE.W  CUR_OP_CODE_1,D0          ;Move current instruction set into D0          
00009BE2  0240 F000               1160      ANDI.W  #$F000,D0               ;Mask relevant bits to D0
00009BE6  B07C 1000               1161      CMP.W   #$1000,D0               ;Compare the appropriate masked bits 
00009BEA  6600 000C               1162      BNE     GROUP1_INVALID          ;Invalid OP code has been found
00009BEE  4EB9 0000A694           1163      JSR     PRINT_OP_MOVEB          ;Print the OP code if equal
00009BF4  6000 0008               1164      BRA     GROUP1_SUCCESS          ;Finish routine
00009BF8                          1165      
00009BF8                          1166  GROUP1_INVALID:
00009BF8  4EB9 0000A618           1167      JSR INVALID_OP                  ;Invalid OP code found
00009BFE                          1168  GROUP1_SUCCESS:
00009BFE  4CDF 0003               1169      MOVEM.L (SP)+,D0-D1             ;Restore register
00009C02  4E75                    1170      RTS                             ;Return to stack
00009C04                          1171  * GROUP_2
00009C04                          1172  ********************************************************************************
00009C04                          1173  * Description: Checks for the following list of OP codes to be present or not.
00009C04                          1174  * Supported OP codes:
00009C04                          1175  * MOVEA.L: $2, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
00009C04                          1176  * MOVE.L: $2, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00009C04                          1177  *
00009C04                          1178  * Register(s) used: D0,D1,D2
00009C04                          1179  *
00009C04                          1180  * Precondition: First nibble has been identified as $2
00009C04                          1181  *
00009C04                          1182  * Postcondition: Parses proper OP code with a nibble value of $2 or finds an
00009C04                          1183  * invalid OP code.********************************************************************************
00009C04                          1184  C_GROUP_2:
00009C04  48E7 E000               1185      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00009C08                          1186  
00009C08                          1187  CHECK_OP_MOVEA_L:
00009C08  3039 000090A0           1188      MOVE.W CUR_OP_CODE_1,D0           ;Move current instruction set into D0  
00009C0E  0240 F000               1189      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00009C12  B07C 2000               1190      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00009C16  4EF9 00009C1C           1191      JMP FIND_MOVEA_L_DIFFERENCE     ;Branch always to check 
00009C1C                          1192      
00009C1C                          1193  FIND_MOVEA_L_DIFFERENCE:            ;Finds difference between MOVEA and MOVE
00009C1C  3039 000090A0           1194      MOVE.W   CUR_OP_CODE_1,D0         ;Move current OP code into D0
00009C22  323C 0007               1195      MOVE.W   #7,D1                  ;Prepare 7 bit shift to D1
00009C26  E368                    1196      LSL.W    D1,D0                  ;Truncate to find the 3 address mode bits
00009C28  E268                    1197      LSR.W    D1,D0                  ;Reposition the bits
00009C2A  323C 0006               1198      MOVE.W   #6,D1                  ;Prepare 6 bit shift to D1
00009C2E  E268                    1199      LSR.W    D1,D0                  ;Truncate to shift 3 bits to a register
00009C30  3400                    1200      MOVE.W   D0,D2                  ;Move 3 address mode bits into D6
00009C32  B47C 0001               1201      CMP.W   #$1,D2                  ;Check if the address mode value is MOVEA
00009C36  6600 000C               1202      BNE     CHECK_OP_MOVE_L         ;Branch if not equal to check MOVE
00009C3A  4EB9 0000A6A6           1203      JSR     PRINT_OP_MOVEA_L        ;Print the OP code if it's a match
00009C40  6000 0024               1204      BRA     GROUP2_SUCCESS          ;Finish routine
00009C44                          1205      
00009C44                          1206      
00009C44                          1207  CHECK_OP_MOVE_L:
00009C44  3039 000090A0           1208      MOVE.W CUR_OP_CODE_1,D0           ;Move current instruction set into D0
00009C4A  0240 F000               1209      ANDI.W #$F000,D0                ;Mask relevant bits to D0
00009C4E  B07C 2000               1210      CMP.W #$2000,D0                 ;Compare the appropriate masked bits
00009C52  6600 000C               1211      BNE GROUP2_INVALID              ;If not equal, OP code is invalid
00009C56  4EB9 0000A6B8           1212      JSR PRINT_OP_MOVE_L             ;Print out MOVE.L
00009C5C  6000 0008               1213      BRA GROUP2_SUCCESS              ;Finish routine
00009C60                          1214      
00009C60                          1215  GROUP2_INVALID:    
00009C60  4EB9 0000A618           1216      JSR INVALID_OP                  ;Invalid OP code found
00009C66                          1217  GROUP2_SUCCESS:
00009C66  4CDF 0007               1218      MOVEM.L (SP)+,D0-D2             ;Restore register
00009C6A  4E75                    1219      RTS                             ;Return to stack
00009C6C                          1220  * GROUP_3
00009C6C                          1221  ********************************************************************************
00009C6C                          1222  * Description: Checks for the following list of OP codes to be present or not.
00009C6C                          1223  * Supported OP codes:
00009C6C                          1224  * MOVEA.W: $3, 11-9 DST Reg, 8-6 %001, 5-3 SRC Mode, 2-0 SRC Reg
00009C6C                          1225  * MOVE.W: $3, 11-9 DST Reg, 8-6 DST Mode, 5-3 SRC Mode, 2-0 SRC Reg
00009C6C                          1226  *
00009C6C                          1227  * Register(s) used: D0,D1,D2
00009C6C                          1228  *
00009C6C                          1229  * Precondition: First nibble has been identified as $3
00009C6C                          1230  *
00009C6C                          1231  * Postcondition: Parses proper OP code with a nibble value of $3 or finds an
00009C6C                          1232  * invalid OP code.
00009C6C                          1233  ********************************************************************************
00009C6C                          1234  C_GROUP_3:
00009C6C  48E7 E000               1235      MOVEM.L D0-D2,-(SP)             ;Save registers to stack
00009C70                          1236      
00009C70                          1237  CHECK_OP_MOVEA_W:
00009C70  3039 000090A0           1238      MOVE.W   CUR_OP_CODE_1,D0        ;Move current instruction set into D0
00009C76  0240 F000               1239      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00009C7A  B07C 3000               1240      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00009C7E  4EF9 00009C84           1241      JMP      FIND_MOVEA_W_DIFF     ;Custom routine to differentiate MOVE and MOVEA
00009C84                          1242  
00009C84                          1243      
00009C84                          1244  FIND_MOVEA_W_DIFF:                 ;Finds difference between MOVEA and MOVE
00009C84  3039 000090A0           1245      MOVE.W   CUR_OP_CODE_1,D0        ;Move current instruction set into D0
00009C8A  323C 0007               1246      MOVE.W   #7,D1                 ;Prepare 7 bit shift to D1
00009C8E  E368                    1247      LSL.W    D1,D0                 ;Truncate to find the 3 address mode bits
00009C90  E268                    1248      LSR.W    D1,D0                 ;Reposition the bits
00009C92  323C 0006               1249      MOVE.W   #6,D1                 ;Prepare 6 bit shift to D1
00009C96  E268                    1250      LSR.W    D1,D0                 ;Truncate to shift 3 bits to a register
00009C98  3400                    1251      MOVE.W   D0,D2                 ;Move 3 address mode bits into D6
00009C9A  B47C 0001               1252      CMP.W    #$1,D2                ;Check if the address mode value is MOVEA
00009C9E  6600 000C               1253      BNE      CHECK_OP_MOVE_W       ;If bits do not match, try MOVE 
00009CA2  4EB9 0000A6CA           1254      JSR      PRINT_OP_MOVEA_W      ;Print the OP code if it's a match
00009CA8  6000 0024               1255      BRA      GROUP3_SUCCESS        ;Finish routine
00009CAC                          1256      
00009CAC                          1257  CHECK_OP_MOVE_W:
00009CAC  3039 000090A0           1258      MOVE.W   CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009CB2  0240 F000               1259      ANDI.W   #$F000,D0             ;Mask relevant bits to D0
00009CB6  B07C 3000               1260      CMP.W    #$3000,D0             ;Compare the appropriate masked bits
00009CBA  6600 000C               1261      BNE      GROUP3_INVALID        ;INVALID OP code found
00009CBE  4EB9 0000A6DC           1262      JSR      PRINT_OP_MOVE_W       ;Print the OP code if it's a match
00009CC4  6000 0008               1263      BRA      GROUP3_SUCCESS        ;Finish routine
00009CC8                          1264      
00009CC8                          1265  GROUP3_INVALID:
00009CC8  4EB9 0000A618           1266      JSR INVALID_OP                 ;INVALID OP code found
00009CCE                          1267  GROUP3_SUCCESS:
00009CCE  4CDF 0007               1268      MOVEM.L (SP)+,D0-D2            ;Restore registers from stack
00009CD2  4E75                    1269      RTS                            ;Return to stack
00009CD4                          1270  
00009CD4                          1271  * GROUP_4
00009CD4                          1272  ********************************************************************************
00009CD4                          1273  * Description: Checks for the following list of OP codes to be present or not.
00009CD4                          1274  * Supported OP codes:
00009CD4                          1275  * LEA: $4, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
00009CD4                          1276  * JSR: $4E, 7-6 %10, 5-3 EA Mode, 2-0 EA Reg 
00009CD4                          1277  * RTS: $4E75
00009CD4                          1278  * NEG: $44, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00009CD4                          1279  * MOVEM: $4, 11 %1, 10 %D, 9-7 %001, 6 S, 5-3 EA Mode, 2-0 EA Reg
00009CD4                          1280  * %D = 0 , Register to Memory, 1 Memory to Register
00009CD4                          1281  *
00009CD4                          1282  * Register(s) used: D0
00009CD4                          1283  *
00009CD4                          1284  * Precondition: First nibble has been identified as $4
00009CD4                          1285  *
00009CD4                          1286  * Postcondition: Parses proper OP code with a nibble value of $4 or finds an
00009CD4                          1287  * invalid OP code. 
00009CD4                          1288  *
00009CD4                          1289  * Unsupported OP codes: MOVE_FROM_SR, MOVE_TO_CCR, MOVE_TO_SR, NEGX, CLR, NOT
00009CD4                          1290  * EXT, NBCD, SWAP, PEA, ILLEGAL, TAS, TST, TRAP, LINK, UNLK, MOVE_USP, RESET,
00009CD4                          1291  * NOP, STOP, RTE, TRAPV, RTR, JMP, CHK
00009CD4                          1292  ********************************************************************************
00009CD4                          1293  C_GROUP_4:
00009CD4  2F00                    1294      MOVE.L  D0,-(SP)            ;Save registers
00009CD6                          1295      
00009CD6                          1296  *Unsupported OP codes to check that are full static bits
00009CD6                          1297  CHECK_OP_STOP:
00009CD6  3039 000090A0           1298      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009CDC  B07C 4E72               1299      CMP.W  #$4E72,D0                ;Compare the appropriate bits
00009CE0  6700 02E6               1300      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009CE4  6600 0002               1301      BNE    CHECK_OP_RESET           ;Check next OP code
00009CE8                          1302      
00009CE8                          1303  CHECK_OP_RESET:
00009CE8  3039 000090A0           1304      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009CEE  B07C 4E70               1305      CMP.W  #$4E70,D0                ;Compare the appropriate bits
00009CF2  6700 02D4               1306      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009CF6  6600 0002               1307      BNE    CHECK_OP_ILLEGAL         ;Check next OP code
00009CFA                          1308          
00009CFA                          1309  CHECK_OP_ILLEGAL:
00009CFA  3039 000090A0           1310      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D00  B07C 4AFC               1311      CMP.W  #$4AFC,D0                ;Compare the appropriate bits
00009D04  6700 02C2               1312      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D08  6600 0002               1313      BNE    CHECK_OP_RTE             ;Check next OP code
00009D0C                          1314      
00009D0C                          1315  CHECK_OP_RTE:    
00009D0C  3039 000090A0           1316      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D12  B07C 4E73               1317      CMP.W #$4E73,D0                 ;Compare the appropriate bits
00009D16  6700 02B0               1318      BEQ   GROUP4_INVALID            ;INVALID OP code found
00009D1A  6600 0002               1319      BNE   CHECK_OP_TRAPV            ;Check next OP code
00009D1E                          1320      
00009D1E                          1321  CHECK_OP_TRAPV:
00009D1E  3039 000090A0           1322      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D24  B07C 4E76               1323      CMP.W  #$4E76,D0                ;Compare the appropriate bits
00009D28  6700 029E               1324      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D2C  6600 0002               1325      BNE    CHECK_OP_RTR             ;Check next OP code
00009D30                          1326      
00009D30                          1327  CHECK_OP_RTR:
00009D30  3039 000090A0           1328      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D36  B07C 4E77               1329      CMP.W #$4E77,D0                 ;Compare the appropriate bits
00009D3A  6700 028C               1330      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D3E  6600 0002               1331      BNE    CHECK_OP_MOVE_FROM_SR    ;Check next OP code
00009D42                          1332  
00009D42                          1333  
00009D42                          1334  *Unsupported OP codes to check that have partial static bits
00009D42                          1335  CHECK_OP_MOVE_FROM_SR:
00009D42  3039 000090A0           1336      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D48  0240 FFC0               1337      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009D4C  B07C 40C0               1338      CMP.W  #$40C0,D0                ;Compare the appropriate masked bits
00009D50  6700 0276               1339      BEQ    GROUP4_INVALID           ;INVALID OP code found  
00009D54  6600 0002               1340      BNE    CHECK_OP_MOVE_TO_CCR     ;Check next OP code
00009D58                          1341      
00009D58                          1342  CHECK_OP_MOVE_TO_CCR:
00009D58  3039 000090A0           1343      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D5E  0240 FFC0               1344      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009D62  B07C 44C0               1345      CMP.W  #$44C0,D0                ;Compare the appropriate masked bits
00009D66  6700 0260               1346      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D6A  6600 0002               1347      BNE    CHECK_OP_MOVE_TO_SR      ;Check next OP code
00009D6E                          1348      
00009D6E                          1349  CHECK_OP_MOVE_TO_SR:
00009D6E  3039 000090A0           1350      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009D74  0240 FFC0               1351      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009D78  B07C 46C0               1352      CMP.W  #$46C0,D0                ;Compare the appropriate masked bits
00009D7C  6700 024A               1353      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D80  6600 0002               1354      BNE    CHECK_OP_NEGX            ;Check next OP code
00009D84                          1355      
00009D84                          1356  CHECK_OP_NEGX:
00009D84  3039 000090A0           1357      MOVE.W CUR_OP_CODE_1,D0          ;Move current instruction set into D0
00009D8A  0240 FF00               1358      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009D8E  B07C 4000               1359      CMP.W  #$4000,D0                ;Compare the appropriate masked bits
00009D92  6700 0234               1360      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009D96  6600 0002               1361      BNE    CHECK_OP_CLR             ;Check next OP code
00009D9A                          1362      
00009D9A                          1363  CHECK_OP_CLR:
00009D9A  3039 000090A0           1364      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009DA0  0240 FF00               1365      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009DA4  B07C 4200               1366      CMP.W  #$4200,D0                ;Compare the appropriate masked bits
00009DA8  6700 021E               1367      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009DAC  6600 0002               1368      BNE    CHECK_OP_NOT             ;Check next OP code
00009DB0                          1369      
00009DB0                          1370  CHECK_OP_NOT:
00009DB0  3039 000090A0           1371      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009DB6  0240 FF00               1372      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009DBA  B07C 4600               1373      CMP.W  #$4600,D0                ;Compare the appropriate masked bits
00009DBE  6700 0208               1374      BEQ    GROUP4_INVALID           ;INVALID OP code found
00009DC2  6600 0002               1375      BNE    CHECK_OP_EXT             ;Check next OP code
00009DC6                          1376      
00009DC6                          1377  CHECK_OP_EXT:
00009DC6  3039 000090A0           1378      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009DCC  0240 FFB8               1379      ANDI.W #$FFB8,D0                ;Mask relevant bits to D0
00009DD0  B07C 4880               1380      CMP.W  #$4880,D0                ;Compare the appropriate masked bits
00009DD4  6700 01F2               1381      BEQ    GROUP4_INVALID           ;INVALID OP code BIT_CHECK_EXT
00009DD8  6600 001E               1382      BNE    CHECK_OP_NBCD            ;Check next OP code
00009DDC                          1383  
00009DDC                          1384  BIT_CHECK_EXT:    
00009DDC  3039 000090A0           1385      MOVE.W CUR_OP_CODE_1,D0         ;This is a special case to check against MOVEM
00009DE2  323C 000A               1386      MOVE.W #10,D1                   ;Prepare a 10 bit shift into D1
00009DE6  E368                    1387      LSL.W  D1,D0                    ;Shift D0 left 10 bits
00009DE8  E068                    1388      LSR.W  D0,D0                    ;Reposition D0
00009DEA  E648                    1389      LSR.W  #3,D0                    ;Shift D0 3 bits
00009DEC  B078 0000               1390      CMP.W  %000,D0                  ;Check the specific bits needed to differentiate EXT
00009DF0  6700 01D6               1391      BEQ    GROUP4_INVALID           ;This means that this OP code is EXT
00009DF4  6600 017E               1392      BNE    MOVEM_BIT_SIZE_1_CHECK   ;This is the only other possibility 
00009DF8                          1393      
00009DF8                          1394  CHECK_OP_NBCD:
00009DF8  3039 000090A0           1395      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009DFE  0240 FFC0               1396      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0           
00009E02  B07C 4800               1397      CMP.W  #$4800,D0                ;Compare the appropriate masked bits
00009E06  6700 01C0               1398      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E0A  6600 0002               1399      BNE    CHECK_OP_SWAP            ;Check next OP code
00009E0E                          1400      
00009E0E                          1401  CHECK_OP_SWAP:                      ; This must go before CHECK_OP PEA as first 3 nibbles can be equivalent
00009E0E  3039 000090A0           1402      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E14  0240 FFF8               1403      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00009E18  B07C 4840               1404      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00009E1C  6700 01AA               1405      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E20  6600 0002               1406      BNE    CHECK_OP_PEA             ;Check next OP code
00009E24                          1407   
00009E24                          1408  CHECK_OP_PEA:                       ;This must go after CHECK_OP_SWAP as first 3 nibbles can be equivalent
00009E24  3039 000090A0           1409      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E2A  0240 FFC0               1410      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009E2E  B07C 4840               1411      CMP.W  #$4840,D0                ;Compare the appropriate masked bits
00009E32  6700 0194               1412      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E36  6600 0002               1413      BNE    CHECK_OP_TAS             ;Check next OP code
00009E3A                          1414      
00009E3A                          1415  CHECK_OP_TAS:
00009E3A  3039 000090A0           1416      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E40  0240 FFC0               1417      ANDI.W #$FFC0,D0                ;Mask relevant bits to D0
00009E44  B07C 4AC0               1418      CMP.W  #$4AC0,D0                ;Compare the appropriate masked bits
00009E48  6700 017E               1419      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E4C  6600 0002               1420      BNE    CHECK_OP_TST             ;Check next OP code
00009E50                          1421  
00009E50                          1422  CHECK_OP_TST:                       ;This must go after CHECK_OP_TAS as first 2 nibbles are equivalent
00009E50  3039 000090A0           1423      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E56  0240 FF00               1424      ANDI.W #$FF00,D0                ;Mask relevant bits to D0
00009E5A  B07C 4A00               1425      CMP.W  #$4A00,D0                ;Compare the appropriate masked bits
00009E5E  6700 0168               1426      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E62  6600 0002               1427      BNE    CHECK_OP_TRAP            ;Check next OP code
00009E66                          1428      
00009E66                          1429  CHECK_OP_TRAP:
00009E66  3039 000090A0           1430      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E6C  0240 FFF0               1431      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00009E70  B07C 4E40               1432      CMP.W  #$4E40,D0                ;Compare the appropriate masked bits
00009E74  6700 0152               1433      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E78  6600 0002               1434      BNE    CHECK_OP_LINK            ;Check next OP code
00009E7C                          1435      
00009E7C                          1436  CHECK_OP_LINK:
00009E7C  3039 000090A0           1437      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E82  0240 FFF8               1438      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00009E86  B07C 4E50               1439      CMP.W  #$4E50,D0                ;Compare the appropriate masked bits
00009E8A  6700 013C               1440      BEQ    GROUP4_INVALID           ;INVALID OP code
00009E8E  6600 0002               1441      BNE    CHECK_OP_UNLK            ;Check next OP code
00009E92                          1442  
00009E92                          1443  CHECK_OP_UNLK:
00009E92  3039 000090A0           1444      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009E98  0240 FFF8               1445      ANDI.W #$FFF8,D0                ;Mask relevant bits to D0
00009E9C  B07C 4E58               1446      CMP.W  #$4E58,D0                ;Compare the appropriate masked bits
00009EA0  6700 0126               1447      BEQ    GROUP4_INVALID           ;INVALID OP code
00009EA4  6600 0002               1448      BNE    CHECK_OP_MOVE_USP        ;Check next OP
00009EA8                          1449      
00009EA8                          1450  CHECK_OP_MOVE_USP:
00009EA8  3039 000090A0           1451      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009EAE  0240 FFF0               1452      ANDI.W #$FFF0,D0                ;Mask relevant bits to D0
00009EB2  B07C 4E60               1453      CMP.W  #$4E60,D0                ;Compare the appropriate masked bits
00009EB6  6700 0110               1454      BEQ    GROUP4_INVALID           ;INVALID OP code
00009EBA  6600 0002               1455      BNE    CHECK_OP_JMP             ;Check next OP
00009EBE                          1456  
00009EBE                          1457  CHECK_OP_JMP:
00009EBE  3039 000090A0           1458       MOVE.W CUR_OP_CODE_1,D0            ;Move current instruction set into D0
00009EC4  0240 FFC0               1459       ANDI.W #$FFC0,D0               ;Mask relevant bits to D0
00009EC8  B07C 4EC0               1460       CMP.W  #$4EC0,D0               ;Compare the appropriate masked bits
00009ECC  6700 00FA               1461       BEQ    GROUP4_INVALID          ;INVALID OP code
00009ED0  6600 0002               1462       BNE    CHECK_OP_CHK            ;Check next OP code
00009ED4                          1463       
00009ED4                          1464  CHECK_OP_CHK:
00009ED4  3039 000090A0           1465      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
00009EDA  0240 F1C0               1466      ANDI.W  #$F1C0,D0               ;Mask relevant bits to D0
00009EDE  B07C 4180               1467      CMP.W   #$4180,D0               ;Compare the appropriate masked bits
00009EE2  6700 0734               1468      BEQ     INVALID_OP              ;INVALID OP code
00009EE6  6600 0002               1469      BNE     CHECK_OP_NOP            ;Check next OP code
00009EEA                          1470  
00009EEA                          1471  *Supported OP codes to check
00009EEA                          1472  CHECK_OP_NOP:                       ;While this code is not in the supported docs, Nash covered it in class and expects it to be implemented
00009EEA  3039 000090A0           1473      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009EF0  B07C 4E71               1474      CMP.W  #$4E71,D0                ;Compare the appropriate bits
00009EF4  6600 000C               1475      BNE    CHECK_OP_RTS             ;Check next OP code
00009EF8  4EB9 0000A712           1476      JSR    PRINT_OP_NOP             ;Print out OP code
00009EFE  6000 00CE               1477      BRA    GROUP4_SUCCESS           ;Finish routine
00009F02                          1478      
00009F02                          1479  CHECK_OP_RTS:
00009F02  3039 000090A0           1480      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009F08  B07C 4E75               1481      CMP.W  #$4E75,D0                ;Mask exact bits for RTS    
00009F0C  6600 000C               1482      BNE    CHECK_OP_LEA             ;If it's equal check next code
00009F10  4EB9 0000A700           1483      JSR    PRINT_OP_RTS             ;Print out OP code
00009F16  6000 00B6               1484      BRA    GROUP4_SUCCESS           ;Finish routine
00009F1A                          1485   
00009F1A                          1486  CHECK_OP_LEA:
00009F1A  3039 000090A0           1487      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009F20  0240 F1C0               1488      ANDI.W #$F1C0,D0                ;Mask appropriate bits
00009F24  B07C 41C0               1489      CMP.W  #$41C0,D0                ;Compare masked bits
00009F28  6600 000C               1490      BNE    CHECK_OP_JSR             ;Check next OP code
00009F2C  4EB9 0000A724           1491      JSR    PRINT_OP_LEA             ;Print out OP code
00009F32  6000 009A               1492      BRA    GROUP4_SUCCESS           ;Finish routine
00009F36                          1493   
00009F36                          1494  CHECK_OP_JSR:
00009F36  3039 000090A0           1495      MOVE.W CUR_OP_CODE_1,D0             ;Move current instruction set into D0
00009F3C  0240 FFC0               1496      ANDI.W #$FFC0,D0                ;Mask appropriate bits
00009F40  B07C 4E80               1497      CMP.W  #$4E80,D0                ;Compare masked bits
00009F44  6600 000C               1498      BNE    CHECK_OP_NEG             ;Check next OP code
00009F48  4EB9 0000A6EE           1499      JSR    PRINT_OP_JSR             ;Print out OP code
00009F4E  6000 007E               1500      BRA    GROUP4_SUCCESS           ;Finish routine
00009F52                          1501      
00009F52                          1502  CHECK_OP_NEG:
00009F52  3039 000090A0           1503      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009F58  0240 FF00               1504      ANDI.W #$FF00,D0                ;Mask appropriate bits
00009F5C  B07C 4400               1505      CMP.W  #$4400,D0                ;Compare masked bits
00009F60  6600 0012               1506      BNE    MOVEM_BIT_SIZE_1_CHECK       ;Check next OP code
00009F64  4EB9 000098A6           1507      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Find size field
00009F6A  4EB9 0000A73C           1508      JSR    PRINT_OP_NEG             ;Print out OP code
00009F70  6000 005C               1509      BRA    GROUP4_SUCCESS           ;Finish routine
00009F74                          1510      
00009F74                          1511  MOVEM_BIT_SIZE_1_CHECK:
00009F74  3039 000090A0           1512      MOVE.W CUR_OP_CODE_1,D0           ;Move current instruction set into D0
00009F7A  4EB9 000098CA           1513      JSR    FIND_1_BIT_SIZE_1_6        ;Parse size for bit 6
00009F80  0C39 0000 0000975A      1514      CMP.B  #%0,OP_SIZE_1              ;Check size bit
00009F88  6700 0006               1515      BEQ    CHECK_OP_MOVEM_W         ;If 0 it's a word
00009F8C  6600 001E               1516      BNE    CHECK_OP_MOVEM_L         ;If 1 it's a long
00009F90                          1517  
00009F90                          1518  *Special checking for MOVEM sizes
00009F90                          1519  CHECK_OP_MOVEM_W:
00009F90  3039 000090A0           1520      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009F96  0240 FB80               1521      ANDI.W #$FB80,D0                ;Mask appropriate bits
00009F9A  B07C 4880               1522      CMP.W  #$4880,D0                ;Compare masked bits
00009F9E  6600 0028               1523      BNE    GROUP4_INVALID           ;INVALID OP code is found
00009FA2  4EB9 0000A754           1524      JSR    PRINT_OP_MOVEM_W         ;PRINT OP code
00009FA8  6000 0024               1525      BRA    GROUP4_SUCCESS           ;Finish routine
00009FAC                          1526      
00009FAC                          1527  CHECK_OP_MOVEM_L:
00009FAC  3039 000090A0           1528      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009FB2  0240 FB80               1529      ANDI.W #$FB80,D0                ;Mask appropriate bits
00009FB6  B07C 4880               1530      CMP.W  #$4880,D0                ;Compare masked bits
00009FBA  6600 000C               1531      BNE    GROUP4_INVALID           ;INVALID OP code is found
00009FBE  4EB9 0000A766           1532      JSR    PRINT_OP_MOVEM_L         ;Print OP code
00009FC4  6000 0008               1533      BRA    GROUP4_SUCCESS           ;Finish routine    
00009FC8                          1534      
00009FC8                          1535  GROUP4_INVALID:
00009FC8  4EB9 0000A618           1536      JSR INVALID_OP                  ;INVALID op code has been found, set IS_VALID_1 to 0
00009FCE                          1537  
00009FCE                          1538  GROUP4_SUCCESS:
00009FCE  4CDF 0001               1539      MOVEM.L (SP)+,D0                ;Restore saved registers
00009FD2  4E75                    1540      RTS                             ;Return to stack
00009FD4                          1541  * GROUP_5
00009FD4                          1542  ********************************************************************************
00009FD4                          1543  * Description: CHecks for the following list of OP codes to be present or not.
00009FD4                          1544  * Supported OP code:
00009FD4                          1545  * SUBQ: $5, 11-9 DATA, 8 %1, 7-6 Size, 5-3 EA Mode, 2-0 EA Reg
00009FD4                          1546  *
00009FD4                          1547  * Register(s) used: D0
00009FD4                          1548  *
00009FD4                          1549  * Precondition: First nibble has been identified as $5
00009FD4                          1550  *
00009FD4                          1551  * Postcondition: Parses proper OP code with a nibble value of $5 or finds an
00009FD4                          1552  * invalid OP code. 
00009FD4                          1553  *
00009FD4                          1554  * Unsupported OP codes: ADDQ, Scc, DBcc
00009FD4                          1555  ********************************************************************************
00009FD4                          1556  C_GROUP_5:
00009FD4  48E7 8000               1557      MOVEM.L D0,-(SP)                ;Save registers to stack
00009FD8                          1558  *Unsupported OP codes
00009FD8                          1559  CHECK_OP_DBcc:                      ;These are ordered first due to checking bits 7-6
00009FD8  3039 000090A0           1560      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009FDE  0240 F0C8               1561      ANDI.W #$F0C8,D0                ;Mask appropriate bits
00009FE2  B07C 50C8               1562      CMP.W  #$50C8,D0                ;Compare appropriate masked bits
00009FE6  6700 0054               1563      BEQ    GROUP5_INVALID           ;INVALID op code found
00009FEA  6600 0002               1564      BNE    CHECK_OP_Scc             ;Check next OP code
00009FEE                          1565  
00009FEE                          1566  CHECK_OP_Scc:
00009FEE  3039 000090A0           1567      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
00009FF4  0240 F0C0               1568      ANDI.W #$F0C0,D0                ;Mask appropriate bits
00009FF8  B07C 50C0               1569      CMP.W  #$50C0,D0                ;Compare appropriate masked bits
00009FFC  6700 003E               1570      BEQ     GROUP5_INVALID          ;INVALID OP code found
0000A000  6600 0002               1571      BNE     CHECK_OP_ADDQ           ;Check next OP code
0000A004                          1572  
0000A004                          1573  CHECK_OP_ADDQ:
0000A004  3039 000090A0           1574      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A00A  0240 F100               1575      ANDI.W #$F100,D0                ;Mask appropriate bits
0000A00E  B07C 5000               1576      CMP.W  #$5000,D0                ;Compare appropriate masked bits
0000A012  6700 0028               1577      BEQ    GROUP5_INVALID           ;INVALID OP code found
0000A016  6600 0002               1578      BNE    CHECK_OP_SUBQ            ;Check next OP code
0000A01A                          1579  
0000A01A                          1580  *Supported OP code   
0000A01A                          1581  CHECK_OP_SUBQ     
0000A01A  3039 000090A0           1582      MOVE.W  CUR_OP_CODE_1,D0        ;Actual check for SUBQ
0000A020  0240 F100               1583      ANDI.W #$F100,D0                ;Bitmask check for SUBQ
0000A024  B07C 5100               1584      CMP.W  #$5100,D0                ;Compare the proper value
0000A028  6600 0012               1585      BNE    GROUP5_INVALID           ;Else the operand is invalid
0000A02C  4EB9 000098A6           1586      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Find size bit to print
0000A032  4EB9 0000A778           1587      JSR    PRINT_OP_SUBQ            ;If equal print it out
0000A038  6000 0008               1588      BRA    GROUP5_SUCCESS           ;Finish routine
0000A03C                          1589      
0000A03C                          1590  GROUP5_INVALID: 
0000A03C  4EB9 0000A618           1591      JSR INVALID_OP                  ;INVALID OP has been found, set IS_VALID_1 to 0
0000A042                          1592  GROUP5_SUCCESS:
0000A042  4CDF 0001               1593      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A046  4E75                    1594      RTS                             ;Return to stack
0000A048                          1595      
0000A048                          1596  * GROUP_6
0000A048                          1597  ********************************************************************************
0000A048                          1598  * Description: Checks for the following list of OP codes to be present or not.
0000A048                          1599  * Supported OP codes
0000A048                          1600  * BRA: $60, 7-0 8-Bit Displacement
0000A048                          1601  * Bcc: $6, 11-8 Condition, 7-0 8-Bit Displacement
0000A048                          1602  *   Branch: <Condition>   
0000A048                          1603  *   BCS: %0101          
0000A048                          1604  *   BGE: %1100      
0000A048                          1605  *   BLT: %1101  
0000A048                          1606  *   BVC: %1000
0000A048                          1607  *
0000A048                          1608  * Register(s) used: D0,D1,D2
0000A048                          1609  *
0000A048                          1610  * Precondition: First nibble has been identified as $6
0000A048                          1611  *
0000A048                          1612  * Postcondition: Parses proper OP code with a nibble value of $6 or finds an
0000A048                          1613  * invalid OP code.
0000A048                          1614  *
0000A048                          1615  * Unsupported OP codes: BSR,BGT,BCC,BEQ,BHI,BMI,BNE,BPL
0000A048                          1616  ********************************************************************************
0000A048                          1617  C_GROUP_6:
0000A048  48E7 8000               1618      MOVEM.L D0,-(SP)            ;Save register to stack
0000A04C                          1619  *Unsupported OP code
0000A04C                          1620  CHECK_OP_BSR:
0000A04C  3039 000090A0           1621      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set to D0
0000A052  0240 FF00               1622      ANDI.W  #$FF00,D0               ;Mask appropriate bits
0000A056  B07C 6100               1623      CMP.W   #$6100,D0               ;Compare masked bits
0000A05A  6700 0142               1624      BEQ     GROUP6_INVALID          ;INVALID OP code found
0000A05E  6600 0002               1625      BNE     CHECK_OP_BGT            ;Check next OP code
0000A062                          1626      
0000A062                          1627  CHECK_OP_BGT:
0000A062  3039 000090A0           1628      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A068  0240 FF00               1629      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A06C  B07C 6E00               1630      CMP.W  #$6E00,D0                ;Compare masked bits
0000A070  6700 012C               1631      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A074  6600 0002               1632      BNE    CHECK_OP_BCC             ;Check next OP code
0000A078                          1633  
0000A078                          1634  CHECK_OP_BCC:
0000A078  3039 000090A0           1635      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A07E  0240 FF00               1636      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A082  B07C 6400               1637      CMP.W  #$6400,D0                ;Compare masked bits
0000A086  6700 0116               1638      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A08A  6600 0002               1639      BNE    CHECK_OP_BEQ             ;Check next OP code 
0000A08E                          1640  
0000A08E                          1641  CHECK_OP_BEQ:
0000A08E  3039 000090A0           1642      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A094  0240 FF00               1643      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A098  B07C 6700               1644      CMP.W  #$6700,D0                ;Compare masked bits
0000A09C  6700 0100               1645      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A0A0  6600 0002               1646      BNE    CHECK_OP_BHI             ;Check next OP code
0000A0A4                          1647  
0000A0A4                          1648  CHECK_OP_BHI:
0000A0A4  3039 000090A0           1649      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A0AA  0240 FF00               1650      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A0AE  B07C 6200               1651      CMP.W  #$6200,D0                ;Compare masked bits
0000A0B2  6700 00EA               1652      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A0B6  6600 0002               1653      BNE    CHECK_OP_BLS             ;Check next OP code
0000A0BA                          1654  
0000A0BA                          1655  CHECK_OP_BLS:
0000A0BA  3039 000090A0           1656      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A0C0  0240 FF00               1657      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A0C4  B07C 6300               1658      CMP.W  #$6300,D0                ;Compare masked bits
0000A0C8  6700 00D4               1659      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A0CC  6600 0002               1660      BNE    CHECK_OP_BMI             ;Check next OP code
0000A0D0                          1661  
0000A0D0                          1662  CHECK_OP_BMI:
0000A0D0  3039 000090A0           1663      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A0D6  0240 FF00               1664      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A0DA  B07C 6B00               1665      CMP.W  #$6B00,D0                ;Compare masked bits
0000A0DE  6700 00BE               1666      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A0E2  6600 0002               1667      BNE    CHECK_OP_BNE             ;Check next OP code
0000A0E6                          1668  
0000A0E6                          1669  CHECK_OP_BNE:
0000A0E6  3039 000090A0           1670      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A0EC  0240 FF00               1671      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A0F0  B07C 6600               1672      CMP.W  #$6600,D0                ;Compare masked bits
0000A0F4  6700 00A8               1673      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A0F8  6600 0002               1674      BNE    CHECK_OP_BPL             ;Check next OP code    
0000A0FC                          1675  
0000A0FC                          1676  CHECK_OP_BPL:
0000A0FC  3039 000090A0           1677      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A102  0240 FF00               1678      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A106  B07C 6A00               1679      CMP.W  #$6A00,D0                ;Compare masked bits
0000A10A  6700 0092               1680      BEQ    GROUP6_INVALID           ;INVALID OP code found
0000A10E  6600 0002               1681      BNE    CHECK_OP_BRA             ;Check next OP code 
0000A112                          1682  
0000A112                          1683  
0000A112                          1684  *Supported OP codes
0000A112                          1685  CHECK_OP_BRA:
0000A112  3039 000090A0           1686      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0       
0000A118  0240 FF00               1687      ANDI.W  #$FF00,D0               ;Mask appropriate bits
0000A11C  B07C 6000               1688      CMP.W   #$6000,D0               ;Compare masked bits
0000A120  6600 000C               1689      BNE     CHECK_OP_BCS            ;Check next OP code
0000A124  4EB9 0000A7F0           1690      JSR     PRINT_OP_BRA            ;Print out OP code
0000A12A  6000 0078               1691      BRA     GROUP6_SUCCESS          ;Finish routine
0000A12E                          1692      
0000A12E                          1693  CHECK_OP_BCS:
0000A12E  3039 000090A0           1694      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A134  0240 FF00               1695      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A138  B07C 6500               1696      CMP.W  #$6500,D0                ;Compare masked bits
0000A13C  6600 000C               1697      BNE    CHECK_OP_BGE             ;Check next OP code
0000A140  4EB9 0000A790           1698      JSR    PRINT_OP_BCS             ;Print out OP code
0000A146  6000 005C               1699      BRA    GROUP6_SUCCESS           ;Finish routine
0000A14A                          1700  
0000A14A                          1701      
0000A14A                          1702  CHECK_OP_BGE:
0000A14A  3039 000090A0           1703      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A150  0240 FF00               1704      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A154  B07C 6C00               1705      CMP.W  #$6C00,D0                ;Compare masked bits
0000A158  6600 000C               1706      BNE    CHECK_OP_BLT             ;Check next OP code
0000A15C  4EB9 0000A7A8           1707      JSR    PRINT_OP_BGE             ;Print out OP code
0000A162  6000 0040               1708      BRA    GROUP6_SUCCESS           ;Finish routine
0000A166                          1709      
0000A166                          1710      
0000A166                          1711  CHECK_OP_BLT:
0000A166  3039 000090A0           1712      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A16C  0240 FF00               1713      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A170  B07C 6D00               1714      CMP.W  #$6D00,D0                ;Compare masked bits
0000A174  6600 000C               1715      BNE    CHECK_OP_BVC             ;Check next OP code
0000A178  4EB9 0000A7C0           1716      JSR    PRINT_OP_BLT             ;Print out OP code
0000A17E  6000 0024               1717      BRA    GROUP6_SUCCESS           ;Finish routine
0000A182                          1718      
0000A182                          1719  CHECK_OP_BVC:
0000A182  3039 000090A0           1720      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A188  0240 FF00               1721      ANDI.W #$FF00,D0                ;Mask appropriate bits
0000A18C  B07C 6800               1722      CMP.W  #$6800,D0                ;Compare masked bits
0000A190  6600 000C               1723      BNE    GROUP6_INVALID           ;Check next OP code
0000A194  4EB9 0000A7D8           1724      JSR    PRINT_OP_BVC             ;Print out OP code
0000A19A  6000 0008               1725      BRA    GROUP6_SUCCESS           ;Finish routine
0000A19E                          1726      
0000A19E                          1727  GROUP6_INVALID:
0000A19E  4EB9 0000A618           1728      JSR    INVALID_OP               ;INVALID OP code found, set IS_VALID_1 to 0
0000A1A4                          1729  GROUP6_SUCCESS:
0000A1A4  4CDF 0001               1730      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A1A8  4E75                    1731      RTS                             ;Return from stack
0000A1AA                          1732      
0000A1AA                          1733  *GROUP_7
0000A1AA                          1734  ********************************************************************************
0000A1AA                          1735  * Description: Checks if the following OP code is present or not.
0000A1AA                          1736  * Currently no OP codes here are supported. MOVEQ is the only code in this group
0000A1AA                          1737  * Register(s) used: D0
0000A1AA                          1738  *
0000A1AA                          1739  * Precondition: First nibble has been identified as $7
0000A1AA                          1740  *
0000A1AA                          1741  * Postcondition: Identifies it's MOVEQ and sets IS_VALID_1 to 0
0000A1AA                          1742  *
0000A1AA                          1743  * Unsupported OP code: MOVEQ
0000A1AA                          1744  ********************************************************************************
0000A1AA                          1745  C_GROUP_7:
0000A1AA  48E7 8000               1746      MOVEM.L D0,-(SP)                ;Save register to stack
0000A1AE                          1747  *Unsupported OP code
0000A1AE                          1748  CHECK_OP_MOVEQ
0000A1AE  3039 000090A0           1749      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set to D0
0000A1B4  0240 F100               1750      ANDI.W  #$F100,D0               ;Mask appropriate bits
0000A1B8  B07C 7000               1751      CMP.W   #$7000,D0               ;Compare masked bits
0000A1BC  6000 0002               1752      BRA     GROUP7_INVALID          ;INVALID OP code found
0000A1C0                          1753  
0000A1C0                          1754  GROUP7_INVALID:
0000A1C0  4EB9 0000A618           1755      JSR     INVALID_OP              ;INVALID OP code found, set IS_VALID_1 to 0
0000A1C6                          1756  GROUP7_SUCCESS:    
0000A1C6  4CDF 0001               1757      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A1CA  4E75                    1758      RTS                             ;Return from stack
0000A1CC                          1759  * GROUP_8
0000A1CC                          1760  ********************************************************************************
0000A1CC                          1761  * Description: Checks the following list of OP codes to be present or not.
0000A1CC                          1762  * Supported OP code:
0000A1CC                          1763  * DIVS: $8, 11-9 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
0000A1CC                          1764  * OR: $80, 7-6 Size, 5-3 EA Mode, 2-0 EA Register
0000A1CC                          1765  * Register(s) used: D0
0000A1CC                          1766  *
0000A1CC                          1767  * Precondition: First nibble has been identified as $8
0000A1CC                          1768  *
0000A1CC                          1769  * Postcondition: Parses proper OP code with a nibble value of $8 or finds an
0000A1CC                          1770  * invalid OP code.
0000A1CC                          1771  *
0000A1CC                          1772  * Unsupported OP codes: DIVU, SBCD
0000A1CC                          1773  ********************************************************************************
0000A1CC                          1774  C_GROUP_8:
0000A1CC  48E7 8000               1775      MOVEM.L D0,-(SP)
0000A1D0                          1776  *Unsupported OP codes
0000A1D0                          1777  CHECK_OP_DIVU:
0000A1D0  3039 000090A0           1778      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
0000A1D6  0240 F1C0               1779      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
0000A1DA  B07C 80C0               1780      CMP.W   #$80C0,D0               ;Compare masked bits
0000A1DE  6700 0048               1781      BEQ     GROUP8_INVALID          ;INVALID OP code found
0000A1E2  6600 0002               1782      BNE     CHECK_OP_SBCD           ;Check next OP code
0000A1E6                          1783  
0000A1E6                          1784  CHECK_OP_SBCD:
0000A1E6  3039 000090A0           1785      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
0000A1EC  0240 F1F0               1786      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
0000A1F0  B07C 8100               1787      CMP.W   #$8100,D0               ;Compare masked bits
0000A1F4  6700 0032               1788      BEQ     GROUP8_INVALID          ;INVALID OP code found
0000A1F8  6600 0002               1789      BNE     CHECK_OP_DIVS           ;Check next OP code
0000A1FC                          1790      
0000A1FC                          1791  *Supported OP codes
0000A1FC                          1792  CHECK_OP_DIVS:
0000A1FC  3039 000090A0           1793      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
0000A202  0240 F1C0               1794      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
0000A206  B07C 81C0               1795      CMP.W   #$81C0,D0               ;Compare masked bits
0000A20A  6600 000C               1796      BNE     CHECK_OP_OR             ;Check next OP code
0000A20E  4EB9 0000A808           1797      JSR     PRINT_OP_DIVS           ;OP Code found
0000A214  6000 0018               1798      BRA     GROUP8_SUCCESS          ;Finish routine
0000A218                          1799      
0000A218                          1800  CHECK_OP_OR:                        ;At this point only remaining $8 code is OR
0000A218  4EB9 000098A6           1801      JSR     FIND_2_BIT_SIZE_1_7_TO_6    ;Finding size bit to print out
0000A21E  4EB9 0000A81A           1802      JSR     PRINT_OP_OR             ;Print out OR
0000A224  6000 0008               1803      BRA     GROUP8_SUCCESS          ;Finish routine
0000A228                          1804  GROUP8_INVALID:
0000A228  4EB9 0000A618           1805       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID_1 to 0
0000A22E                          1806  GROUP8_SUCCESS:
0000A22E  4CDF 0001               1807       MOVEM.L (SP)+,D0               ;Restore register from stack
0000A232  4E75                    1808       RTS                            ;Return to stack
0000A234                          1809       
0000A234                          1810  * GROUP_9                      
0000A234                          1811  ********************************************************************************
0000A234                          1812  * Description: Checks the if the following OP code is present or not.
0000A234                          1813  * Supported OP code:
0000A234                          1814  * SUB: $9, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
0000A234                          1815  *
0000A234                          1816  * Register(s) used: D0,D1
0000A234                          1817  *
0000A234                          1818  * Precondition: First nibble has been identified as $9
0000A234                          1819  *
0000A234                          1820  * Postcondition: Parses proper OP code with a nibble value of $9 or finds an
0000A234                          1821  * invalid OP code.
0000A234                          1822  *
0000A234                          1823  * Unsupported OP codes: SUBX, SUBA
0000A234                          1824  ********************************************************************************
0000A234                          1825  C_GROUP_9:
0000A234  48E7 C000               1826      MOVEM.L D0-D1,-(SP)             ;Save the registers
0000A238                          1827  *Unsupported OP codes
0000A238                          1828  CHECK_SIZE_1_BIT_FOR_SUB:
0000A238  4EB9 000098A6           1829      JSR     FIND_2_BIT_SIZE_1_7_TO_6  ;Find the size bits in 7-6
0000A23E  0C39 0003 0000975A      1830      CMP.B   #%11,OP_SIZE_1            ;If the bits are %11, it has to be SUBA
0000A246  6700 0006               1831      BEQ     CHECK_OP_SUBA           ;If the bits equal it must be SUBA
0000A24A  6600 0018               1832      BNE     CHECK_OP_SUBX           ;If the bits are not equal it could be SUBX
0000A24E                          1833      
0000A24E                          1834  CHECK_OP_SUBA:                      ;Check SUBA first as it has static bits
0000A24E  3039 000090A0           1835      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A254  0240 F0C0               1836      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
0000A258  B07C 90C0               1837      CMP.W   #$90C0,D0               ;Compare masked bits
0000A25C  6700 0048               1838      BEQ     GROUP9_INVALID          ;INVALID OP has been found
0000A260  6600 0002               1839      BNE     CHECK_OP_SUBX           ;Check next OP
0000A264                          1840  
0000A264                          1841  CHECK_OP_SUBX:
0000A264  3039 000090A0           1842      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A26A  0240 F130               1843      ANDI.W  #$F130,D0               ;Mask appropriate bits
0000A26E  B07C 9100               1844      CMP.W   #$9100,D0               ;Compare masked bits
0000A272  6000 0002               1845      BRA     BIT_CHECK_SUBX          ;Checking if this code is SUBX through bit shifts
0000A276                          1846      
0000A276                          1847  BIT_CHECK_SUBX:    
0000A276  3039 000090A0           1848      MOVE.W  CUR_OP_CODE_1,D0        ;Move current instruction set into D0
0000A27C  323C 0007               1849      MOVE.W  #7,D1                   ;Prepare a shift of 7 bits into D1
0000A280  E368                    1850      LSL.W   D1,D0                   ;Shift left 7 bits truncate 15-9 bits
0000A282  E268                    1851      LSR.W   D1,D0                   ;Reposition D0
0000A284  E848                    1852      LSR.W   #4,D0                   ;Truncate 4 right most bits to
0000A286  0240 FF13               1853      ANDI.W  #$FF13,D0               ;Compare remaining static bits
0000A28A  B07C 0010               1854      CMP.W   #$0010,D0               ;If equal to this value it's SUBX
0000A28E  6700 0016               1855      BEQ     GROUP9_INVALID          ;INVALID OP code found
0000A292  6600 0002               1856      BNE     CHECK_OP_SUB            ;Not can only be SUB here
0000A296                          1857      
0000A296                          1858  *Supported OP code 
0000A296                          1859  CHECK_OP_SUB:                       ;At this point only remaining $9 is SUB
0000A296  4EB9 000098A6           1860      JSR     FIND_2_BIT_SIZE_1_7_TO_6    ;Find the size bit to print out
0000A29C  4EB9 0000A832           1861      JSR     PRINT_OP_SUB            ;Print out SUB
0000A2A2  6000 0008               1862      BRA     GROUP9_SUCCESS          ;Finish routine
0000A2A6                          1863      
0000A2A6                          1864  GROUP9_INVALID:
0000A2A6  4EB9 0000A618           1865       JSR     INVALID_OP             ;INVALID OP code found, set IS_VALID_1 to 0
0000A2AC                          1866  GROUP9_SUCCESS: 
0000A2AC  4CDF 0003               1867      MOVEM.L (SP)+,D0-D1             ;Restore registers
0000A2B0  4E75                    1868      RTS                             ;Return to stack
0000A2B2                          1869  
0000A2B2                          1870  *GROUP_A
0000A2B2                          1871  ********************************************************************************
0000A2B2                          1872  * Description: One of the few groups where there are no OP codes at all.
0000A2B2                          1873  * Currently no OP codes here are supported. There are no current OP codes here.
0000A2B2                          1874  * Register(s) used: None
0000A2B2                          1875  *
0000A2B2                          1876  * Precondition: First nibble has been identified as $A
0000A2B2                          1877  *
0000A2B2                          1878  * Postcondition: Sets IS_VALID_1 to 0 as there are no OP codes here
0000A2B2                          1879  ********************************************************************************
0000A2B2                          1880  C_GROUP_A:
0000A2B2  4EB9 0000A618           1881      JSR INVALID_OP                  ;INVALID OP code found, set IS_VALID_1 to 0
0000A2B8  4E75                    1882      RTS                             ;Return to stack
0000A2BA                          1883      
0000A2BA                          1884  * GROUP_B                     
0000A2BA                          1885  ********************************************************************************
0000A2BA                          1886  * Description: Checks if the following list of OP codes is present or not.
0000A2BA                          1887  * Supported OP codes:
0000A2BA                          1888  * EOR: $B, 11-9 Reg, 8 %1, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
0000A2BA                          1889  * CMP: $B, 11-9 Reg, 8 %0, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
0000A2BA                          1890  * The specific bit difference is listed 
0000A2BA                          1891  *
0000A2BA                          1892  * Register(s) used: D0
0000A2BA                          1893  *
0000A2BA                          1894  * Precondition: First nibble has been identified as $B
0000A2BA                          1895  *
0000A2BA                          1896  * Postcondition: Parses proper OP code with a nibble value of $B or finds an
0000A2BA                          1897  * invalid OP code.
0000A2BA                          1898  *
0000A2BA                          1899  * Unsupported OP codes: CMPM, CMPA
0000A2BA                          1900  ********************************************************************************
0000A2BA                          1901  C_GROUP_B:
0000A2BA  48E7 8000               1902      MOVEM.L D0,-(SP)                ;Save current registers to stack
0000A2BE                          1903  *Unsupported OP codes    
0000A2BE                          1904  CHECK_OP_CMPM
0000A2BE  3039 000090A0           1905      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A2C4  0240 F138               1906      ANDI.W  #$F138,D0               ;Mask appropriate bits
0000A2C8  B07C B108               1907      CMP.W   #$B108,D0               ;Compare masked bits
0000A2CC  6700 0060               1908      BEQ     GROUPB_INVALID          ;INVALID OP found
0000A2D0  6600 0002               1909      BNE     CHECK_OP_CMPA           ;Check next OP
0000A2D4                          1910      
0000A2D4                          1911  CHECK_OP_CMPA:
0000A2D4  3039 000090A0           1912      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A2DA  0240 F0C0               1913      ANDI.W  #$F0C0,D0               ;Mask appropriate bits
0000A2DE  B07C B0C0               1914      CMP.W   #$B0C0,D0               ;Compare masked bits
0000A2E2  6700 004A               1915      BEQ     GROUPB_INVALID          ;INVALID OP found
0000A2E6  6600 0002               1916      BNE     CHECK_OP_EOR            ;Check next OP
0000A2EA                          1917  
0000A2EA                          1918  *Supported OP codes    
0000A2EA                          1919  CHECK_OP_EOR:
0000A2EA  3039 000090A0           1920      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A2F0  0240 F100               1921      ANDI.W  #$F100,D0               ;Mask appropriate bits
0000A2F4  B07C B100               1922      CMP.W   #$B100,D0               ;Compare masked bits
0000A2F8  6600 0012               1923      BNE     CHECK_OP_CMP            ;Check next OP 
0000A2FC  4EB9 000098A6           1924      JSR     FIND_2_BIT_SIZE_1_7_TO_6    ;Find size bit field to print out size
0000A302  4EB9 0000A84A           1925      JSR     PRINT_OP_EOR            ;Print out OP code
0000A308  6000 002A               1926      BRA     GROUPB_SUCCESS          ;Finish routine
0000A30C                          1927      
0000A30C                          1928  CHECK_OP_CMP:
0000A30C  3039 000090A0           1929      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A312  0240 F100               1930      ANDI.W  #$F100,D0               ;Mask appropriate bits
0000A316  B07C B000               1931      CMP.W   #$B000,D0               ;Compare masked bits
0000A31A  6600 0012               1932      BNE     GROUPB_INVALID          ;INVALID OP code found
0000A31E  4EB9 000098A6           1933      JSR     FIND_2_BIT_SIZE_1_7_TO_6    ;Find size bit field to print out size
0000A324  4EB9 0000A862           1934      JSR     PRINT_OP_CMP            ;Print out OP code
0000A32A  6000 0008               1935      BRA     GROUPB_SUCCESS          ;Finish routine
0000A32E                          1936      
0000A32E                          1937  GROUPB_INVALID:
0000A32E  4EB9 0000A618           1938      JSR     INVALID_OP              ;INVALID OP has been found, set IS_VALID_1 to 0
0000A334                          1939  GROUPB_SUCCESS:
0000A334  4CDF 0001               1940      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A338  4E75                    1941      RTS                             ;Return to stack
0000A33A                          1942  * GROUP_C                     
0000A33A                          1943  ********************************************************************************
0000A33A                          1944  * Description: Checks if the following list of OP codes is present or not.
0000A33A                          1945  * Supported OP code:
0000A33A                          1946  * MULS: $C, 11-8 Reg, 8-6 %111, 5-3 EA Mode, 2-0 EA Reg
0000A33A                          1947  * Note: EXG OP mode has to be 01000, 01001, 10001, as such can never be 11 for
0000A33A                          1948  * bits 7-6
0000A33A                          1949  *
0000A33A                          1950  * Register(s) used: D0,D1
0000A33A                          1951  *
0000A33A                          1952  * Precondition: First nibble has been identified as $C
0000A33A                          1953  *
0000A33A                          1954  * Postcondition: Parses proper OP code with a nibble value of $C or finds an
0000A33A                          1955  * invalid OP code.
0000A33A                          1956  *
0000A33A                          1957  * Unsupported OP codes: MULU, ABCD, EXG, AND
0000A33A                          1958  ********************************************************************************
0000A33A                          1959  C_GROUP_C:
0000A33A                          1960  *Unsupported OP codes
0000A33A  48E7 C000               1961      MOVEM.L D0-D1,-(SP)
0000A33E                          1962      
0000A33E                          1963  CHECK_OP_MULU:
0000A33E  3039 000090A0           1964      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A344  0240 F1C0               1965      ANDI.W  #$F1C0,D0               ;Mask appropriate bits
0000A348  B07C C0C0               1966      CMP.W   #$C0C0,D0               ;Compare masked bits
0000A34C  6700 006E               1967      BEQ     GROUPC_INVALID          ;INVALID OP code found
0000A350  6600 0002               1968      BNE     CHECK_OP_ABCD           ;Check next OP code
0000A354                          1969   
0000A354                          1970  CHECK_OP_ABCD:
0000A354  3039 000090A0           1971      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A35A  0240 F1F0               1972      ANDI.W  #$F1F0,D0               ;Mask appropriate bits
0000A35E  B07C C100               1973      CMP.W   #$C100,D0               ;Compare masked bits
0000A362  6700 0058               1974      BEQ     GROUPC_INVALID          ;INVALID OP code found
0000A366  6600 0002               1975      BNE     CHECK_OP_EXG            ;Check next OP code
0000A36A                          1976   
0000A36A                          1977  CHECK_OP_EXG:
0000A36A  6000 0002               1978      BRA     BIT_CHECK_EXG           ;Always do bit check here
0000A36E                          1979                          
0000A36E                          1980  BIT_CHECK_EXG:                      ;Checks the OP mode bits 7-6 which cannot be 11 for EXG
0000A36E  3039 000090A0           1981      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A374  323C 0007               1982      MOVE.W  #7,D1                   ;Prepare a bit shift of 7 into D1
0000A378  E368                    1983      LSL.W   D1,D0                   ;Shift D0 to 7 bits
0000A37A  E268                    1984      LSR.W   D1,D0                   ;Reposition D0
0000A37C  E848                    1985      LSR.W   #4,D0                   ;Shift D0 4 bits right
0000A37E  0240 FF83               1986      ANDI.W  #$FF83,D0               ;Mask appropriate bits
0000A382  B07C 0010               1987      CMP.W   #$0010,D0               ;Bit mask static EXG bits
0000A386  6700 0034               1988      BEQ     GROUPC_INVALID          ;If this equals, then OP must be EXG
0000A38A  6600 0002               1989      BNE     CHECK_OP_MULS           ;Otherwise it's MULS
0000A38E                          1990  *Supported OP code
0000A38E                          1991  CHECK_OP_MULS:
0000A38E  3039 000090A0           1992      MOVE.W CUR_OP_CODE_1,D0         ;Move current instruction set into D0
0000A394  0240 F1C0               1993      ANDI.W #$F1C0,D0                ;Mask appropriate bits
0000A398  B07C C1C0               1994      CMP.W  #$C1C0,D0                ;Compare masked bits
0000A39C  6600 000C               1995      BNE    CHECK_OP_AND             ;OP_AND is completely dynamic outside of first nibble
0000A3A0  4EB9 0000A87A           1996      JSR    PRINT_OP_MULS            ;Print OP code
0000A3A6  6000 001A               1997      BRA    GROUPC_SUCCESS           ;Finish routine
0000A3AA                          1998      
0000A3AA                          1999  *Odd completely dynamic unsupported OP code    
0000A3AA                          2000  CHECK_OP_AND:                       ;This would be the only possible OP code left after CHECK_OP_MULS
0000A3AA  3039 000090A0           2001      MOVE.W  CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A3B0  0240 F000               2002      ANDI.W  #$F000,D0               ;Mask appropriate bits
0000A3B4  B07C C000               2003      CMP.W   #$C000,D0               ;Compare masked bits
0000A3B8  6000 0002               2004      BRA    GROUPC_INVALID           ;INVALID OP code found
0000A3BC                          2005      
0000A3BC                          2006  GROUPC_INVALID:
0000A3BC  4EB9 0000A618           2007      JSR     INVALID_OP              ;Set IS_VALID_1 to 0
0000A3C2                          2008      
0000A3C2                          2009  GROUPC_SUCCESS:
0000A3C2  4CDF 0003               2010      MOVEM.L (SP)+,D0-D1             ;Restore registers from stack
0000A3C6  4E75                    2011      RTS                             ;Return to stack
0000A3C8                          2012      
0000A3C8                          2013  * GROUP_D                     
0000A3C8                          2014  ********************************************************************************
0000A3C8                          2015  * Description: Checks if the following list of OP codes is present or not.
0000A3C8                          2016  * Supported OP codes:
0000A3C8                          2017  * ADD: $D, 11-9 Reg, 8-6 OPMODE, 5-3 EA Mode, 2-0 EA Reg
0000A3C8                          2018  * ADDA: $D, 11- 9 Reg, 8-6 OPMODE, 7-6 %11, 5-3 EA Mode, 2-0 EA Reg
0000A3C8                          2019  * The specific bit difference is listed out in the OPMODE field.
0000A3C8                          2020  *
0000A3C8                          2021  * Register(s) used: D0
0000A3C8                          2022  *
0000A3C8                          2023  * Precondition: First nibble has been identified as $D
0000A3C8                          2024  *
0000A3C8                          2025  * Postcondition: Parses proper OP code with a nibble value of $D or finds an
0000A3C8                          2026  * invalid OP code.
0000A3C8                          2027  *
0000A3C8                          2028  * Unsupported: ADDX
0000A3C8                          2029  ********************************************************************************
0000A3C8                          2030  C_GROUP_D:
0000A3C8  48E7 8000               2031      MOVEM.L D0,-(SP)                ;Save registers to stack
0000A3CC                          2032  *Unsupported OP codes
0000A3CC                          2033  BIT_SIZE_1_CHECK
0000A3CC  3039 000090A0           2034      MOVE    CUR_OP_CODE_1,D0          ;Move current instruction set into D0
0000A3D2  4EB9 000098A6           2035      JSR     FIND_2_BIT_SIZE_1_7_TO_6  ;Specific size bit checking to see if it's 11
0000A3D8  0C39 0003 0000975A      2036      CMP.B   #%11,OP_SIZE_1            ;If it's %11 it cannot be ADDX and is either ADDA or ADD
0000A3E0  6700 0026               2037      BEQ     CHECK_OP_ADDA           ;If it's equal check ADDA
0000A3E4  6600 0002               2038      BNE     CHECK_OP_ADDX           ;If it's not equal check ADDX
0000A3E8                          2039      
0000A3E8                          2040  CHECK_OP_ADDX:
0000A3E8  3039 000090A0           2041      MOVE    CUR_OP_CODE_1,D0
0000A3EE  0240 F130               2042      ANDI.W #$F130,D0                ;Mask appropriate bits
0000A3F2  B07C D100               2043      CMP.W  #$D100,D0                ;Compare masked bits
0000A3F6  6700 0030               2044      BEQ    GROUPD_INVALID           ;INVALID OP code found
0000A3FA  6600 0002               2045      BNE    CHECK_OP_ADD             ;Check next OP code
0000A3FE                          2046      
0000A3FE                          2047  *Supported OP codes
0000A3FE                          2048  CHECK_OP_ADD:
0000A3FE  4EB9 0000A88C           2049      JSR PRINT_OP_ADD                ;Only remaining OP in $D is ADD at this point
0000A404  6000 0028               2050      BRA GROUPD_SUCCESS              ;Finish routine
0000A408                          2051  
0000A408                          2052  CHECK_OP_ADDA:
0000A408  3039 000090A0           2053      MOVE    CUR_OP_CODE_1,D0            ;Move current instruction set into D0
0000A40E  0240 F0C0               2054      ANDI.W #$F0C0,D0                ;Mask applicable bits
0000A412  B07C D0C0               2055      CMP.W  #$D0C0,D0                ;Compare masked bits
0000A416  66E6                    2056      BNE    CHECK_OP_ADD             ;Check next OP code
0000A418  4EB9 000098EE           2057      JSR    FIND_1_BIT_SIZE_1_8      ;Size bit to print
0000A41E  4EB9 0000A8A4           2058      JSR    PRINT_OP_ADDA            ;Print out OP code
0000A424  6000 0008               2059      BRA    GROUPD_SUCCESS           ;Finish routine
0000A428                          2060      
0000A428                          2061  GROUPD_INVALID:
0000A428  4EB9 0000A618           2062      JSR INVALID_OP                  ;INVALID OP code found
0000A42E                          2063  GROUPD_SUCCESS:
0000A42E  4CDF 0001               2064      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A432  4E75                    2065      RTS                             ;Return to stack
0000A434                          2066      
0000A434                          2067  * GROUP_E                     
0000A434                          2068  ********************************************************************************
0000A434                          2069  * Description: Check if the following list of OP codes is present or not.
0000A434                          2070  * Supported:
0000A434                          2071  * LSR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
0000A434                          2072  * LSL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %01, 2-0 Reg
0000A434                          2073  * ASR: $E, $0, 8 %0, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
0000A434                          2074  * ASL: $E, $0, 8 %1, 7-6 %11, 5-3 EA Mode, 2-0 EA reg
0000A434                          2075  * ROR: $E, 11-9 Count/Reg, 8 %0, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
0000A434                          2076  * ROL: $E, 11-9 Count/Reg, 8 %1, 7-6 Size, 5 i/r, 4-3 %11, 2-0 Reg
0000A434                          2077  * Count/Reg for LSR/LSL refers to shift count, where 0 = shift count of 8, 1-7 
0000A434                          2078  * refers to the respective value when i/r = 0. If i/r = 1, data register in the 
0000A434                          2079  * Count/Reg field specifies the shift count.  
0000A434                          2080  * For directional bit at 8, R = 0, L = 1
0000A434                          2081  * Count/Reg for ROR/ROL specifies rotate count instead of shift count.
0000A434                          2082  *
0000A434                          2083  * Split into ROT and NO_ROT groups first to make identifying easier.
0000A434                          2084  *
0000A434                          2085  * Register(s) used: D0
0000A434                          2086  *
0000A434                          2087  * Precondition: First nibble has been identified as $E
0000A434                          2088  *
0000A434                          2089  * Postcondition: Parses proper OP code with a nibble value of $E or finds an
0000A434                          2090  * invalid OP code.
0000A434                          2091  *
0000A434                          2092  * Unsupported: ROXL, ROXR
0000A434                          2093  ********************************************************************************
0000A434                          2094  C_GROUP_E:
0000A434  48E7 8000               2095      MOVEM.L D0,-(SP)
0000A438                          2096  *Unsupported OP codes
0000A438                          2097  CHECK_OP_ROXR_NO_ROT:
0000A438  3039 000090A0           2098      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A43E  0240 FFC0               2099      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A442  B07C E4C0               2100      CMP.W  #$E4C0,D0                ;Compare masked bits
0000A446  6700 01BC               2101      BEQ    GROUPE_INVALID           ;INVALID OP code
0000A44A  6600 0002               2102      BNE    CHECK_OP_ROXL_NO_ROT     ;Check next OP code
0000A44E                          2103  
0000A44E                          2104  CHECK_OP_ROXL_NO_ROT:
0000A44E  3039 000090A0           2105      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A454  0240 FFC0               2106      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A458  B07C E5C0               2107      CMP.W  #$E5C0,D0                ;Compare masked bits
0000A45C  6700 01A6               2108      BEQ    GROUPE_INVALID           ;INVALID OP code
0000A460  6600 0002               2109      BNE    CHECK_OP_ROR_NO_ROT      ;Check next OP code
0000A464                          2110  
0000A464                          2111  *Supported OP codes
0000A464                          2112  CHECK_OP_ROR_NO_ROT:
0000A464  3039 000090A0           2113      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A46A  0240 FFC0               2114      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A46E  B07C E6C0               2115      CMP.W  #$E6C0,D0                ;Compare masked bits
0000A472  6600 000C               2116      BNE    CHECK_OP_ROL_NO_ROT      ;Check next OP code
0000A476  4EB9 0000A934           2117      JSR    PRINT_OP_ROR             ;Print out OP code
0000A47C  6000 018C               2118      BRA    GROUPE_SUCCESS           ;Finish routine
0000A480                          2119      
0000A480                          2120  CHECK_OP_ROL_NO_ROT:
0000A480  3039 000090A0           2121      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A486  0240 FFC0               2122      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A48A  B07C E7C0               2123      CMP.W  #$E7C0,D0                ;Compare masked bits
0000A48E  6600 000C               2124      BNE    CHECK_OP_LSR_NO_ROT      ;Check next OP code
0000A492  4EB9 0000A91C           2125      JSR    PRINT_OP_ROL             ;Print out OP code
0000A498  6000 0170               2126      BRA    GROUPE_SUCCESS           ;Finish routine
0000A49C                          2127   
0000A49C                          2128  CHECK_OP_LSR_NO_ROT:
0000A49C  3039 000090A0           2129      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A4A2  0240 FFC0               2130      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A4A6  B07C E2C0               2131      CMP.W  #$E2C0,D0                ;Compare masked bits
0000A4AA  6600 000C               2132      BNE    CHECK_OP_LSL_NO_ROT      ;Check next OP code
0000A4AE  4EB9 0000A8D4           2133      JSR    PRINT_OP_LSR             ;Print out OP code
0000A4B4  6000 0154               2134      BRA    GROUPE_SUCCESS           ;Finish routine
0000A4B8                          2135  
0000A4B8                          2136  CHECK_OP_LSL_NO_ROT:
0000A4B8  3039 000090A0           2137      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A4BE  0240 FFC0               2138      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A4C2  B07C E3C0               2139      CMP.W  #$E3C0,D0                ;Compare masked bits
0000A4C6  6600 000C               2140      BNE    CHECK_OP_ASR_NO_ROT      ;Check next OP code
0000A4CA  4EB9 0000A8BC           2141      JSR    PRINT_OP_LSL             ;Print out OP code
0000A4D0  6000 0138               2142      BRA    GROUPE_SUCCESS           ;Finish routine
0000A4D4                          2143  
0000A4D4                          2144  CHECK_OP_ASR_NO_ROT:
0000A4D4  3039 000090A0           2145      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A4DA  0240 FFC0               2146      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A4DE  B07C E0C0               2147      CMP.W  #$E0C0,D0                ;Compare masked bits
0000A4E2  6600 000C               2148      BNE    CHECK_OP_ASL_NO_ROT      ;Check next OP code
0000A4E6  4EB9 0000A8EC           2149      JSR    PRINT_OP_ASR             ;Print out OP code
0000A4EC  6000 011C               2150      BRA    GROUPE_SUCCESS           ;Finish routine
0000A4F0                          2151              
0000A4F0                          2152  CHECK_OP_ASL_NO_ROT:
0000A4F0  3039 000090A0           2153      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A4F6  0240 FFC0               2154      ANDI.W #$FFC0,D0                ;Mask appropriate bits
0000A4FA  B07C E1C0               2155      CMP.W  #$E1C0,D0                ;Compare masked bits
0000A4FE  6600 000C               2156      BNE    CHECK_OP_ROXR            ;Check next OP code
0000A502  4EB9 0000A904           2157      JSR    PRINT_OP_ASL             Print out OP code
0000A508  6000 0100               2158      BRA    GROUPE_SUCCESS           ;Finish routine
0000A50C                          2159  
0000A50C                          2160  *Unsupported OP codes
0000A50C                          2161  CHECK_OP_ROXR:
0000A50C  3039 000090A0           2162      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A512  0240 F118               2163      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A516  B07C E010               2164      CMP.W  #$E010,D0                ;Compare masked bits
0000A51A  6700 00E8               2165      BEQ    GROUPE_INVALID           ;INVALID OP code found
0000A51E  6600 0002               2166      BNE    CHECK_OP_ROXL            ;Check next OP code
0000A522                          2167      
0000A522                          2168  CHECK_OP_ROXL:
0000A522  3039 000090A0           2169      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A528  0240 F118               2170      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A52C  B07C E110               2171      CMP.W  #$E110,D0                ;Compare masked bits
0000A530  6700 00D2               2172      BEQ    GROUPE_INVALID           ;INVALID OP code found
0000A534  6600 0002               2173      BNE    CHECK_OP_ROR             ;Check next OP code
0000A538                          2174      
0000A538                          2175  *Supported OP codes
0000A538                          2176  CHECK_OP_ROR:
0000A538  3039 000090A0           2177      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A53E  0240 F118               2178      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A542  B07C E018               2179      CMP.W  #$E018,D0                ;Compare masked bits
0000A546  6600 0012               2180      BNE    CHECK_OP_ROL             ;Check next OP code
0000A54A  4EB9 000098A6           2181      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size bits
0000A550  4EB9 0000A934           2182      JSR    PRINT_OP_ROR             ;Print out OP code
0000A556  6000 00B2               2183      BRA    GROUPE_SUCCESS           ;Finish routine
0000A55A                          2184  
0000A55A                          2185  CHECK_OP_ROL:
0000A55A  3039 000090A0           2186      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A560  0240 F118               2187      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A564  B07C E118               2188      CMP.W  #$E118,D0                ;Compare masked bits
0000A568  6600 0012               2189      BNE    CHECK_OP_LSR             ;Check next OP code
0000A56C  4EB9 000098A6           2190      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size field
0000A572  4EB9 0000A91C           2191      JSR    PRINT_OP_ROL             ;Print out OP code
0000A578  6000 0090               2192      BRA    GROUPE_SUCCESS           ;Finish routine
0000A57C                          2193      
0000A57C                          2194  CHECK_OP_LSR:
0000A57C  3039 000090A0           2195      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A582  0240 F118               2196      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A586  B07C E008               2197      CMP.W  #$E008,D0                ;Compare masked bits
0000A58A  6600 0012               2198      BNE    CHECK_OP_LSL             ;Check next OP code
0000A58E  4EB9 000098A6           2199      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size field
0000A594  4EB9 0000A8D4           2200      JSR    PRINT_OP_LSR             ;Print out OP code
0000A59A  6000 006E               2201      BRA    GROUPE_SUCCESS           ;Finish routine
0000A59E                          2202  
0000A59E                          2203  CHECK_OP_LSL:
0000A59E  3039 000090A0           2204      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A5A4  0240 F118               2205      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A5A8  B07C E108               2206      CMP.W  #$E108,D0                ;Compare masked bits
0000A5AC  6600 0012               2207      BNE    CHECK_OP_ASR             ;Check next OP code
0000A5B0  4EB9 000098A6           2208      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size field
0000A5B6  4EB9 0000A8BC           2209      JSR    PRINT_OP_LSL             ;Print out OP code
0000A5BC  6000 004C               2210      BRA    GROUPE_SUCCESS           ;Finish routine
0000A5C0                          2211  
0000A5C0                          2212  CHECK_OP_ASR:
0000A5C0  3039 000090A0           2213      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A5C6  0240 F118               2214      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A5CA  B07C E000               2215      CMP.W  #$E000,D0                ;Compare masked bits
0000A5CE  6600 0012               2216      BNE    CHECK_OP_ASL             ;Check next OP code
0000A5D2  4EB9 000098A6           2217      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size field
0000A5D8  4EB9 0000A8EC           2218      JSR    PRINT_OP_ASR             ;Print out OP code
0000A5DE  6000 002A               2219      BRA    GROUPE_SUCCESS           ;Finish routine
0000A5E2                          2220  
0000A5E2                          2221  CHECK_OP_ASL:
0000A5E2  3039 000090A0           2222      MOVE CUR_OP_CODE_1,D0               ;Move current instruction set into D0
0000A5E8  0240 F118               2223      ANDI.W #$F118,D0                ;Mask appropriate bits
0000A5EC  B07C E100               2224      CMP.W  #$E100,D0                ;Compare masked bits
0000A5F0  6600 0012               2225      BNE    GROUPE_INVALID           ;Last possible OP code
0000A5F4  4EB9 000098A6           2226      JSR    FIND_2_BIT_SIZE_1_7_TO_6 ;Parse size field
0000A5FA  4EB9 0000A904           2227      JSR    PRINT_OP_ASL             ;Print out OP code
0000A600  6000 0008               2228      BRA    GROUPE_SUCCESS           ;Finish routine
0000A604                          2229  
0000A604                          2230  GROUPE_INVALID:
0000A604  4EB9 0000A618           2231      JSR     INVALID_OP              ;Set IS_VALID_1 to 0
0000A60A                          2232  GROUPE_SUCCESS:
0000A60A  4CDF 0001               2233      MOVEM.L (SP)+,D0                ;Restore registers from stack
0000A60E  4E75                    2234      RTS                             ;Return to stack
0000A610                          2235  * GROUP_F
0000A610                          2236  ********************************************************************************
0000A610                          2237  * Description: One of the few groups that have no OP codes
0000A610                          2238  * Currently no OP codes here are supported. There are no OP codes here
0000A610                          2239  *
0000A610                          2240  * Register(s) used: None
0000A610                          2241  *
0000A610                          2242  * Precondition: Identified nibble value is $F
0000A610                          2243  *
0000A610                          2244  * Postcondition: IS_VALID_1 is set to 0 as there are no OP codes here
0000A610                          2245  ********************************************************************************
0000A610                          2246  C_GROUP_F:
0000A610  4EB9 0000A618           2247      JSR     INVALID_OP              ;Set IS_VALID_1 to 0
0000A616  4E75                    2248      RTS                             ;Return to stack
0000A618                          2249      
0000A618                          2250  * INVALID_OP                     
0000A618                          2251  ********************************************************************************
0000A618                          2252  * Description: Finds any value that is not covered in the above supported groups 
0000A618                          2253  * and considers it invalid 
0000A618                          2254  * The following values in the first nibble would also indicate that the 
0000A618                          2255  * operand codes is already invalid: $7, $A, $F.
0000A618                          2256  * For unsupported OP codes, display <MEMORY ADDRESS> DATA $<INVALID HEX>   
0000A618                          2257  *
0000A618                          2258  * Register(s) used: None
0000A618                          2259  *
0000A618                          2260  * Precondition: INVALID OP code has been found
0000A618                          2261  *
0000A618                          2262  * Postcondition: IS_VALID_1 is set to 0
0000A618                          2263  ********************************************************************************
0000A618                          2264  INVALID_OP:                         ; ONLY SETS IS_VALID_1 TO 0
0000A618  13FC 0000 000090A2      2265      MOVE.B #0,IS_VALID_1                ;Sets IS_VALID_1 to 0
0000A620  4E75                    2266      RTS                             ;Return to stack
0000A622                          2267  
0000A622                          2268  ********************** PRINTING ROUTINES **************************************
0000A622                          2269  * Description: These routines are to print the associated op codes, by placing
0000A622                          2270  * them in the appropriate area to the buffer
0000A622                          2271  *
0000A622                          2272  * Registers used: D0,D1,D2,D3,A0,A1
0000A622                          2273  *
0000A622                          2274  * Precondition: The relevant opcode has been identified correctly.
0000A622                          2275  *
0000A622                          2276  * Postcondition: Prints out the associated opcode to the buffer.
0000A622                          2277  *******************************************************************************
0000A622                          2278  
0000A622                          2279  * Prints the loaded item into G_BUFFER_1
0000A622                          2280  PRINT_TO_BUFFER:
0000A622  23FC 00009000 00009264  2281      MOVE.L #G_BUFFER_1, BUFFER_POINTER_1
0000A62C  4EB9 0000926E           2282      JSR AddStrToBuffer_1
0000A632  4E75                    2283      RTS
0000A634                          2284      
0000A634                          2285  ****************************** GROUP 0 **************************************** 
0000A634                          2286  PRINT_OP_ORI:
0000A634  23FC 0000A9C6 00009260  2287      MOVE.L #P_OP_ORI, STRING_BUFFER_1_POINTER_1
0000A63E  4EB9 0000A622           2288      JSR PRINT_TO_BUFFER
0000A644  4EB9 0000A982           2289      JSR PRINT_OP_SIZE_1
0000A64A  4E75                    2290      RTS
0000A64C                          2291  PRINT_OP_CMPI:
0000A64C  23FC 0000A9CD 00009260  2292      MOVE.L #P_OP_CMPI, STRING_BUFFER_1_POINTER_1
0000A656  4EB9 0000A622           2293      JSR PRINT_TO_BUFFER
0000A65C  4EB9 0000A982           2294      JSR PRINT_OP_SIZE_1
0000A662  4E75                    2295      RTS
0000A664                          2296  PRINT_OP_STATIC_BCLR:
0000A664  23FC 0000A9D5 00009260  2297      MOVE.L #P_OP_BCLR, STRING_BUFFER_1_POINTER_1
0000A66E  4EB9 0000A622           2298      JSR PRINT_TO_BUFFER
0000A674  4EB9 0000A982           2299      JSR PRINT_OP_SIZE_1
0000A67A  4E75                    2300      RTS
0000A67C                          2301      
0000A67C                          2302  PRINT_OP_DYNAMIC_BCLR:
0000A67C  23FC 0000A9D5 00009260  2303      MOVE.L #P_OP_BCLR, STRING_BUFFER_1_POINTER_1
0000A686  4EB9 0000A622           2304      JSR PRINT_TO_BUFFER
0000A68C  4EB9 0000A982           2305      JSR PRINT_OP_SIZE_1
0000A692  4E75                    2306      RTS
0000A694                          2307  ******************************* END OF GROUP 0 ********************************
0000A694                          2308  
0000A694                          2309  ****************************** GROUP 1 ****************************************    
0000A694                          2310  PRINT_OP_MOVEB:
0000A694  23FC 0000A9DD 00009260  2311      MOVE.L #P_OP_MOVEB, STRING_BUFFER_1_POINTER_1
0000A69E  4EB9 0000A622           2312      JSR PRINT_TO_BUFFER
0000A6A4  4E75                    2313      RTS
0000A6A6                          2314  ******************************* END OF GROUP 1 ********************************
0000A6A6                          2315      
0000A6A6                          2316  ****************************** GROUP 2 **************************************** 
0000A6A6                          2317  PRINT_OP_MOVEA_L:
0000A6A6  23FC 0000A9E8 00009260  2318      MOVE.L #P_OP_MOVEA_L, STRING_BUFFER_1_POINTER_1
0000A6B0  4EB9 0000A622           2319      JSR PRINT_TO_BUFFER
0000A6B6  4E75                    2320      RTS
0000A6B8                          2321  PRINT_OP_MOVE_L:
0000A6B8  23FC 0000A9F4 00009260  2322      MOVE.L #P_OP_MOVE_L, STRING_BUFFER_1_POINTER_1
0000A6C2  4EB9 0000A622           2323      JSR PRINT_TO_BUFFER
0000A6C8  4E75                    2324      RTS
0000A6CA                          2325  ******************************* END OF GROUP 2 ********************************
0000A6CA                          2326      
0000A6CA                          2327  ****************************** GROUP 3 ****************************************    
0000A6CA                          2328  PRINT_OP_MOVEA_W:
0000A6CA  23FC 0000A9FF 00009260  2329      MOVE.L #P_OP_MOVEA_W, STRING_BUFFER_1_POINTER_1
0000A6D4  4EB9 0000A622           2330      JSR PRINT_TO_BUFFER
0000A6DA  4E75                    2331      RTS
0000A6DC                          2332  PRINT_OP_MOVE_W:
0000A6DC  23FC 0000AA0B 00009260  2333      MOVE.L #P_OP_MOVE_W, STRING_BUFFER_1_POINTER_1
0000A6E6  4EB9 0000A622           2334      JSR PRINT_TO_BUFFER
0000A6EC  4E75                    2335      RTS
0000A6EE                          2336  ******************************* END OF GROUP 3 ********************************
0000A6EE                          2337  
0000A6EE                          2338  ****************************** GROUP 4 ****************************************
0000A6EE                          2339  PRINT_OP_JSR:
0000A6EE  23FC 0000AA35 00009260  2340      MOVE.L #P_OP_JSR, STRING_BUFFER_1_POINTER_1
0000A6F8  4EB9 0000A622           2341      JSR PRINT_TO_BUFFER
0000A6FE  4E75                    2342      RTS
0000A700                          2343  PRINT_OP_RTS:
0000A700  23FC 0000AA43 00009260  2344      MOVE.L #P_OP_RTS, STRING_BUFFER_1_POINTER_1
0000A70A  4EB9 0000A622           2345      JSR PRINT_TO_BUFFER
0000A710  4E75                    2346      RTS
0000A712                          2347  PRINT_OP_NOP:
0000A712  23FC 0000AA3C 00009260  2348      MOVE.L #P_OP_NOP, STRING_BUFFER_1_POINTER_1
0000A71C  4EB9 0000A622           2349      JSR PRINT_TO_BUFFER
0000A722  4E75                    2350      RTS
0000A724                          2351  PRINT_OP_LEA:
0000A724  23FC 0000AA2E 00009260  2352      MOVE.L #P_OP_LEA, STRING_BUFFER_1_POINTER_1
0000A72E  4EB9 0000A622           2353      JSR PRINT_TO_BUFFER
0000A734  4EB9 0000A982           2354      JSR PRINT_OP_SIZE_1
0000A73A  4E75                    2355      RTS
0000A73C                          2356  PRINT_OP_NEG:
0000A73C  23FC 0000AA4A 00009260  2357      MOVE.L #P_OP_NEG, STRING_BUFFER_1_POINTER_1
0000A746  4EB9 0000A622           2358      JSR PRINT_TO_BUFFER
0000A74C  4EB9 0000A982           2359      JSR PRINT_OP_SIZE_1
0000A752  4E75                    2360      RTS
0000A754                          2361  PRINT_OP_MOVEM_W:
0000A754  23FC 0000AA16 00009260  2362      MOVE.L #P_OP_MOVEM_W, STRING_BUFFER_1_POINTER_1
0000A75E  4EB9 0000A622           2363      JSR PRINT_TO_BUFFER
0000A764  4E75                    2364      RTS
0000A766                          2365  PRINT_OP_MOVEM_L:
0000A766  23FC 0000AA22 00009260  2366      MOVE.L #P_OP_MOVEM_L, STRING_BUFFER_1_POINTER_1
0000A770  4EB9 0000A622           2367      JSR PRINT_TO_BUFFER
0000A776  4E75                    2368      RTS
0000A778                          2369  ******************************* END OF GROUP 4 ********************************
0000A778                          2370      
0000A778                          2371  ****************************** GROUP 5 ****************************************
0000A778                          2372  PRINT_OP_SUBQ:
0000A778  23FC 0000AA51 00009260  2373      MOVE.L #P_OP_SUBQ, STRING_BUFFER_1_POINTER_1
0000A782  4EB9 0000A622           2374      JSR PRINT_TO_BUFFER
0000A788  4EB9 0000A982           2375      JSR PRINT_OP_SIZE_1
0000A78E  4E75                    2376      RTS
0000A790                          2377  ******************************* END OF GROUP 5 ********************************
0000A790                          2378  
0000A790                          2379  ****************************** GROUP 6 ****************************************
0000A790                          2380  PRINT_OP_BCS:
0000A790  23FC 0000AA60 00009260  2381      MOVE.L #P_OP_BCS, STRING_BUFFER_1_POINTER_1
0000A79A  4EB9 0000A622           2382      JSR PRINT_TO_BUFFER
0000A7A0  4EB9 0000A982           2383      JSR PRINT_OP_SIZE_1
0000A7A6  4E75                    2384      RTS
0000A7A8                          2385  PRINT_OP_BGE:
0000A7A8  23FC 0000AA67 00009260  2386      MOVE.L #P_OP_BGE, STRING_BUFFER_1_POINTER_1
0000A7B2  4EB9 0000A622           2387      JSR PRINT_TO_BUFFER
0000A7B8  4EB9 0000A982           2388      JSR PRINT_OP_SIZE_1
0000A7BE  4E75                    2389      RTS
0000A7C0                          2390  PRINT_OP_BLT:
0000A7C0  23FC 0000AA6E 00009260  2391      MOVE.L #P_OP_BLT, STRING_BUFFER_1_POINTER_1
0000A7CA  4EB9 0000A622           2392      JSR PRINT_TO_BUFFER
0000A7D0  4EB9 0000A982           2393      JSR PRINT_OP_SIZE_1
0000A7D6  4E75                    2394      RTS
0000A7D8                          2395  PRINT_OP_BVC:
0000A7D8  23FC 0000AA75 00009260  2396      MOVE.L #P_OP_BVC, STRING_BUFFER_1_POINTER_1
0000A7E2  4EB9 0000A622           2397      JSR PRINT_TO_BUFFER
0000A7E8  4EB9 0000A982           2398      JSR PRINT_OP_SIZE_1
0000A7EE  4E75                    2399      RTS
0000A7F0                          2400  PRINT_OP_BRA:
0000A7F0  23FC 0000AA59 00009260  2401      MOVE.L #P_OP_BRA, STRING_BUFFER_1_POINTER_1
0000A7FA  4EB9 0000A622           2402      JSR PRINT_TO_BUFFER
0000A800  4EB9 0000A982           2403      JSR PRINT_OP_SIZE_1
0000A806  4E75                    2404      RTS
0000A808                          2405  ******************************* END OF GROUP 6 ********************************
0000A808                          2406  
0000A808                          2407  ****************************** GROUP 7 ****************************************
0000A808                          2408  * No currently supported OP codes to print here.
0000A808                          2409  ******************************* END OF GROUP 7 ********************************
0000A808                          2410  
0000A808                          2411  ****************************** GROUP 8 ****************************************
0000A808                          2412  PRINT_OP_DIVS:
0000A808  23FC 0000AA7C 00009260  2413      MOVE.L #P_OP_DIVS, STRING_BUFFER_1_POINTER_1
0000A812  4EB9 0000A622           2414      JSR PRINT_TO_BUFFER
0000A818  4E75                    2415      RTS
0000A81A                          2416  PRINT_OP_OR:
0000A81A  23FC 0000AA87 00009260  2417      MOVE.L #P_OP_OR, STRING_BUFFER_1_POINTER_1
0000A824  4EB9 0000A622           2418      JSR PRINT_TO_BUFFER
0000A82A  4EB9 0000A982           2419      JSR PRINT_OP_SIZE_1
0000A830  4E75                    2420      RTS
0000A832                          2421  ******************************* END OF GROUP 8 ********************************
0000A832                          2422  
0000A832                          2423  ****************************** GROUP 9 ****************************************
0000A832                          2424  PRINT_OP_SUB:
0000A832  23FC 0000AA8D 00009260  2425      MOVE.L #P_OP_SUB, STRING_BUFFER_1_POINTER_1
0000A83C  4EB9 0000A622           2426      JSR PRINT_TO_BUFFER
0000A842  4EB9 0000A982           2427      JSR PRINT_OP_SIZE_1
0000A848  4E75                    2428      RTS
0000A84A                          2429  ******************************* END OF GROUP 9 ********************************
0000A84A                          2430  
0000A84A                          2431  ****************************** GROUP A ****************************************
0000A84A                          2432  * No currently supported OP codes to print here.
0000A84A                          2433  ******************************* END OF GROUP A ********************************
0000A84A                          2434  
0000A84A                          2435  ****************************** GROUP B ****************************************
0000A84A                          2436  PRINT_OP_EOR:
0000A84A  23FC 0000AA94 00009260  2437      MOVE.L #P_OP_EOR, STRING_BUFFER_1_POINTER_1
0000A854  4EB9 0000A622           2438      JSR PRINT_TO_BUFFER
0000A85A  4EB9 0000A982           2439      JSR PRINT_OP_SIZE_1
0000A860  4E75                    2440      RTS
0000A862                          2441  PRINT_OP_CMP:
0000A862  23FC 0000AA9B 00009260  2442      MOVE.L #P_OP_CMP, STRING_BUFFER_1_POINTER_1
0000A86C  4EB9 0000A622           2443      JSR PRINT_TO_BUFFER
0000A872  4EB9 0000A982           2444      JSR PRINT_OP_SIZE_1
0000A878  4E75                    2445      RTS
0000A87A                          2446  ******************************* END OF GROUP B ********************************
0000A87A                          2447  
0000A87A                          2448  ****************************** GROUP C ****************************************
0000A87A                          2449  PRINT_OP_MULS:
0000A87A  23FC 0000AAA2 00009260  2450      MOVE.L #P_OP_MULS, STRING_BUFFER_1_POINTER_1
0000A884  4EB9 0000A622           2451      JSR PRINT_TO_BUFFER
0000A88A  4E75                    2452      RTS
0000A88C                          2453  ******************************* END OF GROUP C ********************************
0000A88C                          2454  
0000A88C                          2455  ****************************** GROUP D ****************************************
0000A88C                          2456  PRINT_OP_ADD:
0000A88C  23FC 0000AAB5 00009260  2457      MOVE.L #P_OP_ADD, STRING_BUFFER_1_POINTER_1
0000A896  4EB9 0000A622           2458      JSR PRINT_TO_BUFFER
0000A89C  4EB9 0000A982           2459      JSR PRINT_OP_SIZE_1
0000A8A2  4E75                    2460      RTS
0000A8A4                          2461  PRINT_OP_ADDA:
0000A8A4  23FC 0000AAAD 00009260  2462      MOVE.L #P_OP_ADDA, STRING_BUFFER_1_POINTER_1
0000A8AE  4EB9 0000A622           2463      JSR PRINT_TO_BUFFER
0000A8B4  4EB9 0000A9A2           2464      JSR PRINT_OP_SIZE_1_ADDA
0000A8BA  4E75                    2465      RTS
0000A8BC                          2466  
0000A8BC                          2467  ******************************* END OF GROUP D ********************************
0000A8BC                          2468  
0000A8BC                          2469  ****************************** GROUP E ****************************************
0000A8BC                          2470  PRINT_OP_LSL:
0000A8BC  23FC 0000AAC3 00009260  2471      MOVE.L #P_OP_LSL, STRING_BUFFER_1_POINTER_1
0000A8C6  4EB9 0000A622           2472      JSR PRINT_TO_BUFFER
0000A8CC  4EB9 0000A982           2473      JSR PRINT_OP_SIZE_1
0000A8D2  4E75                    2474      RTS
0000A8D4                          2475  PRINT_OP_LSR:
0000A8D4  23FC 0000AABC 00009260  2476      MOVE.L #P_OP_LSR, STRING_BUFFER_1_POINTER_1
0000A8DE  4EB9 0000A622           2477      JSR PRINT_TO_BUFFER
0000A8E4  4EB9 0000A982           2478      JSR PRINT_OP_SIZE_1
0000A8EA  4E75                    2479      RTS
0000A8EC                          2480  PRINT_OP_ASR:
0000A8EC  23FC 0000AACA 00009260  2481      MOVE.L #P_OP_ASR, STRING_BUFFER_1_POINTER_1
0000A8F6  4EB9 0000A622           2482      JSR PRINT_TO_BUFFER
0000A8FC  4EB9 0000A982           2483      JSR PRINT_OP_SIZE_1
0000A902  4E75                    2484      RTS
0000A904                          2485  PRINT_OP_ASL:
0000A904  23FC 0000AAD1 00009260  2486      MOVE.L #P_OP_ASL, STRING_BUFFER_1_POINTER_1
0000A90E  4EB9 0000A622           2487      JSR PRINT_TO_BUFFER
0000A914  4EB9 0000A982           2488      JSR PRINT_OP_SIZE_1
0000A91A  4E75                    2489      RTS
0000A91C                          2490  PRINT_OP_ROL:
0000A91C  23FC 0000AADF 00009260  2491      MOVE.L #P_OP_ROL, STRING_BUFFER_1_POINTER_1
0000A926  4EB9 0000A622           2492      JSR PRINT_TO_BUFFER
0000A92C  4EB9 0000A982           2493      JSR PRINT_OP_SIZE_1
0000A932  4E75                    2494      RTS
0000A934                          2495  PRINT_OP_ROR:
0000A934  23FC 0000AAD8 00009260  2496      MOVE.L #P_OP_ROR, STRING_BUFFER_1_POINTER_1
0000A93E  4EB9 0000A622           2497      JSR PRINT_TO_BUFFER
0000A944  4EB9 0000A982           2498      JSR PRINT_OP_SIZE_1
0000A94A  4E75                    2499      RTS
0000A94C                          2500  ******************************* END OF GROUP E ********************************
0000A94C                          2501  
0000A94C                          2502  ****************************** GROUP F ****************************************
0000A94C                          2503  * No currently supported OP codes to print here.
0000A94C                          2504  ******************************* END OF GROUP F ********************************
0000A94C                          2505  
0000A94C                          2506  ****************************** SIZE_1 PRINTS ************************************
0000A94C                          2507  PRINT_SIZE_1_BYTE:
0000A94C  23FC 0000A9BA 00009260  2508      MOVE.L #P_SIZE_1_B, STRING_BUFFER_1_POINTER_1
0000A956  4EB9 0000A622           2509      JSR PRINT_TO_BUFFER
0000A95C  4E75                    2510      RTS    
0000A95E                          2511  
0000A95E                          2512  PRINT_SIZE_1_WORD:
0000A95E  23FC 0000A9BE 00009260  2513      MOVE.L #P_SIZE_1_W, STRING_BUFFER_1_POINTER_1
0000A968  4EB9 0000A622           2514      JSR PRINT_TO_BUFFER
0000A96E  4E75                    2515      RTS
0000A970                          2516      
0000A970                          2517  PRINT_SIZE_1_LONG:
0000A970  23FC 0000A9C2 00009260  2518      MOVE.L #P_SIZE_1_L, STRING_BUFFER_1_POINTER_1
0000A97A  4EB9 0000A622           2519      JSR PRINT_TO_BUFFER
0000A980  4E75                    2520      RTS
0000A982                          2521  
0000A982                          2522  PRINT_OP_SIZE_1:                        ;Prints current OP code byte size if applicable
0000A982  0C39 0000 0000975A      2523      CMP.B  #%00,OP_SIZE_1               ;Checks for byte size
0000A98A  67C0                    2524      BEQ    PRINT_SIZE_1_BYTE            ;Print .B to buffer
0000A98C  0C39 0001 0000975A      2525      CMP.B  #%01,OP_SIZE_1               ;Check for word size
0000A994  67C8                    2526      BEQ    PRINT_SIZE_1_WORD            ;Print .W to buffer
0000A996  0C39 0002 0000975A      2527      CMP.B  #%10,OP_SIZE_1               ;Check for long size
0000A99E  67D0                    2528      BEQ    PRINT_SIZE_1_LONG            ;Print .L to buffer
0000A9A0  4E75                    2529      RTS
0000A9A2                          2530      
0000A9A2                          2531  PRINT_OP_SIZE_1_ADDA:                   ;Special  print for ADDA
0000A9A2  0C39 0000 0000975A      2532      CMP.B #%0,OP_SIZE_1             ;Checks if the OP_SIZE_1 is 0
0000A9AA  67B2                    2533      BEQ    PRINT_SIZE_1_WORD            ;If it is the size is word
0000A9AC  66C2                    2534      BNE    PRINT_SIZE_1_LONG            ;If it's not the size is long
0000A9AE                          2535      
0000A9AE                          2536  ******************* END OF SIZE_1 PRINTS ****************************************
0000A9AE                          2537  
0000A9AE                          2538  ******************* END OF PRINTING ROUTINES **********************************
0000A9AE                          2539  
0000A9AE                          2540  ******************* END OF JMP LABELS *****************************************
0000A9AE                          2541  
0000A9AE                          2542  ******************* DATA CONSTANT PRINTS **************************************
0000A9AE                          2543  * Formatting is as follows: P_OP_<OPCODE>, where P = Print, OP = Operation,
0000A9AE                          2544  * <OPCODE> is any valid operand
0000A9AE                          2545  
0000A9AE= 20 20 20 44 41 54 ...   2546  P_INVALID_OP    DC.B    '   DATA   $',0
0000A9BA= 2E 42 20 00             2547  P_SIZE_1_B        DC.B    '.B ',0
0000A9BE= 2E 57 20 00             2548  P_SIZE_1_W        DC.B    '.W ',0
0000A9C2= 2E 4C 20 00             2549  P_SIZE_1_L        DC.B    '.L ',0
0000A9C6= 20 20 20 4F 52 49 00    2550  P_OP_ORI        DC.B    '   ORI',0
0000A9CD= 20 20 20 43 4D 50 ...   2551  P_OP_CMPI       DC.B    '   CMPI',0
0000A9D5= 20 20 20 42 43 4C ...   2552  P_OP_BCLR       DC.B    '   BCLR',0
0000A9DD= 20 20 20 4D 4F 56 ...   2553  P_OP_MOVEB      DC.B    '   MOVE.B ',0
0000A9E8= 20 20 20 4D 4F 56 ...   2554  P_OP_MOVEA_L    DC.B    '   MOVEA.L ',0 
0000A9F4= 20 20 20 4D 4F 56 ...   2555  P_OP_MOVE_L     DC.B    '   MOVE.L ',0
0000A9FF= 20 20 20 4D 4F 56 ...   2556  P_OP_MOVEA_W    DC.B    '   MOVEA.W ',0
0000AA0B= 20 20 20 4D 4F 56 ...   2557  P_OP_MOVE_W     DC.B    '   MOVE.W ',0
0000AA16= 20 20 20 4D 4F 56 ...   2558  P_OP_MOVEM_W    DC.B    '   MOVEM.W ',0
0000AA22= 20 20 20 4D 4F 56 ...   2559  P_OP_MOVEM_L    DC.B    '   MOVEM.L ',0
0000AA2E= 20 20 20 4C 45 41 00    2560  P_OP_LEA        DC.B    '   LEA',0
0000AA35= 20 20 20 4A 53 52 00    2561  P_OP_JSR        DC.B    '   JSR',0
0000AA3C= 20 20 20 4E 4F 50 00    2562  P_OP_NOP        DC.B    '   NOP',0
0000AA43= 20 20 20 52 54 53 00    2563  P_OP_RTS        DC.B    '   RTS',0
0000AA4A= 20 20 20 4E 45 47 00    2564  P_OP_NEG        DC.B    '   NEG',0
0000AA51= 20 20 20 53 55 42 ...   2565  P_OP_SUBQ       DC.B    '   SUBQ',0
0000AA59= 20 20 20 42 52 41 00    2566  P_OP_BRA        DC.B    '   BRA',0
0000AA60= 20 20 20 42 43 53 00    2567  P_OP_BCS        DC.B    '   BCS',0
0000AA67= 20 20 20 42 47 45 00    2568  P_OP_BGE        DC.B    '   BGE',0
0000AA6E= 20 20 20 42 4C 54 00    2569  P_OP_BLT        DC.B    '   BLT',0
0000AA75= 20 20 20 42 56 43 00    2570  P_OP_BVC        DC.B    '   BVC',0
0000AA7C= 20 20 20 44 49 56 ...   2571  P_OP_DIVS       DC.B    '   DIVS.W ',0
0000AA87= 20 20 20 4F 52 00       2572  P_OP_OR         DC.B    '   OR',0
0000AA8D= 20 20 20 53 55 42 00    2573  P_OP_SUB        DC.B    '   SUB',0
0000AA94= 20 20 20 45 4F 52 00    2574  P_OP_EOR        DC.B    '   EOR',0
0000AA9B= 20 20 20 43 4D 50 00    2575  P_OP_CMP        DC.B    '   CMP',0
0000AAA2= 20 20 20 4D 55 4C ...   2576  P_OP_MULS       DC.B    '   MULS.W ',0
0000AAAD= 20 20 20 41 44 44 ...   2577  P_OP_ADDA       DC.B    '   ADDA',0
0000AAB5= 20 20 20 41 44 44 00    2578  P_OP_ADD        DC.B    '   ADD',0
0000AABC= 20 20 20 4C 53 52 00    2579  P_OP_LSR        DC.B    '   LSR',0
0000AAC3= 20 20 20 4C 53 4C 00    2580  P_OP_LSL        DC.B    '   LSL',0
0000AACA= 20 20 20 41 53 52 00    2581  P_OP_ASR        DC.B    '   ASR',0
0000AAD1= 20 20 20 41 53 4C 00    2582  P_OP_ASL        DC.B    '   ASL',0
0000AAD8= 20 20 20 52 4F 52 00    2583  P_OP_ROR        DC.B    '   ROR',0
0000AADF= 20 20 20 52 4F 4C 00    2584  P_OP_ROL        DC.B    '   ROL',0
0000AAE6                          2585  ***************** END OF DATA CONSTANT PRINTS ***********************************
0000AAE6                          2586  
0000AAE6                          2587      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AAE6                          2588  * MESSAGE VARIABLES ******************************
0000AAE6                          2589  
0000AAE6                          2590  * ASCII values for respective characters
0000AAE6                          2591  
0000AAE6= 41                      2592  ADDRESS         DC.B    $41
0000AAE7= 44                      2593  DATA            DC.B    $44
0000AAE8                          2594  
0000AAE8= 28                      2595  PTHSIS_OPEN     DC.B    $28
0000AAE9= 29                      2596  PTHSIS_CLSD     DC.B    $29
0000AAEA= 24                      2597  HEX_SIGN        DC.B    $24
0000AAEB= 23                      2598  IMMDTE_VALU     DC.B    $23
0000AAEC= 2B                      2599  PLUS_SIGN       DC.B    $2B
0000AAED= 2D                      2600  MINUS_SIGN      DC.B    $2D
0000AAEE                          2601  
0000AAEE= 2C                      2602  COMMA           DC.B    $2C
0000AAEF= 20                      2603  SPACE           DC.B    $20
0000AAF0                          2604  **************************************************
0000AAF0                          2605  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AAF0                          2606  
0000AAF0                          2607  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0000AAF0                          2608  * Essential VARIABLE. KEEP THIS
0000AAF0                          2609  TRAILING_SIZE_1   DS.W    1 * Size of any immediate or
0000AAF2                          2610                            * address values. Immediate or address
0000AAF2                          2611                            * value of a BYTE is still processed as
0000AAF2                          2612                            * WORD because the trailing bytes
0000AAF2                          2613                            * are represented as a word regardless.
0000AAF2                          2614                            * $1 = BYTE, $2 = WORD, $4 = LONG
0000AAF2                          2615                            
0000AAF2                          2616  X               DS.B    1
0000AAF3                          2617  Y               DS.B    1 * always X -> Y
0000AAF4                          2618  X_COUNTER       DS.B    1
0000AAF5                          2619  Y_COUNTER       DS.B    1
0000AAF6                          2620  FIRST_X         DS.B    1 * 0: it is first X
0000AAF7                          2621                            * 1: it is second X
0000AAF7                          2622  FIRST_Y         DS.B    1 * 0: it is first Y
0000AAF8                          2623                            * 1: it is second Y
0000AAF8                          2624  **************************************************
0000AAF8                          2625  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AAF8                          2626  
0000AAF8                          2627  * EXECUTION **************************************
0000AAF8                          2628  main_EA:
0000AAF8  4EB9 0000995C           2629      JSR PARSE_EA_CONSTANT_BITS    
0000AAFE                          2630  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AAFE                          2631  
0000AAFE                          2632  
0000AAFE                          2633  
0000AAFE                          2634  * RULES BEFORE EXECUTION
0000AAFE                          2635  *
0000AAFE                          2636  * G_BUFFER_1 should be loaded in A4
0000AAFE                          2637  *
0000AAFE                          2638  * READING FROM START_ADDRESS should be loaded in A5
0000AAFE                          2639  *
0000AAFE                          2640  * ALL variables should have the same name with daniel's
0000AAFE                          2641  *
0000AAFE                          2642  * CUR_OP_CODE_1, MNEMONIC, FIRST_3, etc should have values already.
0000AAFE                          2643  
0000AAFE                          2644  
0000AAFE                          2645  
0000AAFE                          2646  
0000AAFE                          2647  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
0000AAFE                          2648  * ESSENTIAL EXECUTION PORTION. DO NOT ERASE ******
0000AAFE                          2649  
0000AAFE  4EB9 0000AB0A           2650      JSR     CHECK_XXXX
0000AB04                          2651  EXT                        * Main EXT alias to finish routine
0000AB04  4EF9 000091C6           2652      JMP check_print 
0000AB0A                          2653  **************************************************
0000AB0A                          2654  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AB0A                          2655  
0000AB0A                          2656  * CHECK_MNEMONIC FUNCTIONS ***************
0000AB0A                          2657  * <EA>
0000AB0A                          2658  **********************************************************************************
0000AB0A                          2659  * Description: Checks the mnemonic starting from XXXX
0000AB0A                          2660  *
0000AB0A                          2661  * Registers used: X
0000AB0A                          2662  *
0000AB0A                          2663  * Precondition: X
0000AB0A                          2664  *
0000AB0A                          2665  * Postcondition: X
0000AB0A                          2666  **********************************************************************************
0000AB0A                          2667  CHECK_XXXX:
0000AB0A  0C39 0008 0000975B      2668      CMPI.B  #$8, MNEMONIC
0000AB12  6D00 0008               2669      BLT     CHECK_0XXX
0000AB16  4EF9 0000AB2E           2670      JMP     CHECK_1XXX
0000AB1C                          2671  
0000AB1C                          2672  * <EA>
0000AB1C                          2673  **********************************************************************************
0000AB1C                          2674  * Description: Checks the mnemonic starting from 0XXX
0000AB1C                          2675  *
0000AB1C                          2676  * Registers used: X
0000AB1C                          2677  *
0000AB1C                          2678  * Precondition: X
0000AB1C                          2679  *
0000AB1C                          2680  * Postcondition: X
0000AB1C                          2681  **********************************************************************************
0000AB1C                          2682  CHECK_0XXX:
0000AB1C  0C39 0004 0000975B      2683      CMPI.B  #$4, MNEMONIC
0000AB24  6D00 0058               2684      BLT     CHECK_00XX
0000AB28  4EF9 0000AB8E           2685      JMP     CHECK_01XX
0000AB2E                          2686  
0000AB2E                          2687  * <EA>
0000AB2E                          2688  **********************************************************************************
0000AB2E                          2689  * Description: Checks the mnemonic starting from 1XXX
0000AB2E                          2690  *
0000AB2E                          2691  * Registers used: X
0000AB2E                          2692  *
0000AB2E                          2693  * Precondition: X
0000AB2E                          2694  *
0000AB2E                          2695  * Postcondition: X
0000AB2E                          2696  **********************************************************************************
0000AB2E                          2697  CHECK_1XXX:
0000AB2E  0C39 0008 0000975B      2698      CMPI.B  #$8, MNEMONIC
0000AB36  6700 0352               2699      BEQ     LOAD_1000
0000AB3A  0C39 0009 0000975B      2700      CMPI.B  #$9, MNEMONIC
0000AB42  6700 0340               2701      BEQ     LOAD_1001
0000AB46  0C39 000B 0000975B      2702      CMPI.B  #$B, MNEMONIC
0000AB4E  6700 032E               2703      BEQ     LOAD_1011
0000AB52  0C39 000C 0000975B      2704      CMPI.B  #$C, MNEMONIC
0000AB5A  6700 031C               2705      BEQ     LOAD_1100
0000AB5E  0C39 000D 0000975B      2706      CMPI.B  #$D, MNEMONIC
0000AB66  6700 02A2               2707      BEQ     LOAD_1101
0000AB6A  0C39 000E 0000975B      2708      CMPI.B  #$E, MNEMONIC
0000AB72  6700 0040               2709      BEQ     LOAD_1110
0000AB76                          2710      
0000AB76  4EF9 0000BA9C           2711      JMP     INVALID
0000AB7C                          2712      
0000AB7C  4E75                    2713      RTS
0000AB7E                          2714  
0000AB7E                          2715  * <EA>
0000AB7E                          2716  **********************************************************************************
0000AB7E                          2717  * Description: Checks the mnemonic starting from 00XX
0000AB7E                          2718  *
0000AB7E                          2719  * Registers used: X
0000AB7E                          2720  *
0000AB7E                          2721  * Precondition: X
0000AB7E                          2722  *
0000AB7E                          2723  * Postcondition: X
0000AB7E                          2724  **********************************************************************************
0000AB7E                          2725  CHECK_00XX:
0000AB7E  0C39 0001 0000975B      2726      CMPI.B  #$1, MNEMONIC
0000AB86  6D00 0AA6               2727      BLT     LOAD_0000
0000AB8A  6C00 0C5C               2728      BGE     LOAD_00XX
0000AB8E                          2729  
0000AB8E                          2730  * <EA>
0000AB8E                          2731  **********************************************************************************
0000AB8E                          2732  * Description: Checks the mnemonic starting from 01XX
0000AB8E                          2733  *
0000AB8E                          2734  * Registers used: X
0000AB8E                          2735  *
0000AB8E                          2736  * Precondition: X
0000AB8E                          2737  *
0000AB8E                          2738  * Postcondition: X
0000AB8E                          2739  **********************************************************************************
0000AB8E                          2740  CHECK_01XX:
0000AB8E  0C39 0004 0000975B      2741      CMPI.B  #%0100, MNEMONIC
0000AB96  6700 04CA               2742      BEQ     LOAD_0100
0000AB9A  0C39 0005 0000975B      2743      CMPI.B  #%0101, MNEMONIC
0000ABA2  6700 0420               2744      BEQ     LOAD_0101
0000ABA6  0C39 0006 0000975B      2745      CMPI.B  #%0110, MNEMONIC
0000ABAE  6700 0146               2746      BEQ     LOAD_0110
0000ABB2  4E75                    2747      RTS
0000ABB4                          2748  
0000ABB4                          2749  **************************************************
0000ABB4                          2750  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000ABB4                          2751  
0000ABB4                          2752  
0000ABB4                          2753  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000ABB4                          2754  * LOAD_THIS FUNCTIONS (HIGHEST LEVEL) ************
0000ABB4                          2755  
0000ABB4                          2756  * <EA>
0000ABB4                          2757  **********************************************************************************
0000ABB4                          2758  * Description: Once the mnemonic is 1110, it is either ASd, LSd, or ROd.
0000ABB4                          2759  *
0000ABB4                          2760  * Registers used: Whether if it is ASd, LSd, or ROd, they all share the same
0000ABB4                          2761  *                 EA algorithm. D5 for calculation, A2 and A3 for returning from subbranches.
0000ABB4                          2762  *
0000ABB4                          2763  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000ABB4                          2764  *
0000ABB4                          2765  * Postcondition: X
0000ABB4                          2766  **********************************************************************************
0000ABB4                          2767  LOAD_1110:
0000ABB4  247C 00000000           2768              MOVEA.L #0, A2
0000ABBA  267C 00000000           2769              MOVEA.L #0, A3
0000ABC0  4285                    2770              CLR.L   D5
0000ABC2                          2771      
0000ABC2  1A39 0000975D           2772              MOVE.B  SECOND_3, D5
0000ABC8  0205 0003               2773              ANDI.B  #%011, D5
0000ABCC                          2774      
0000ABCC  0C05 0003               2775              CMPI.B  #%11, D5
0000ABD0  6700 0006               2776              BEQ     MYBE_ASd_1
0000ABD4  6600 007A               2777              BNE     MYBE_ASd_2
0000ABD8                          2778  
0000ABD8                          2779  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000ABD8                          2780  ***111111111 ASd <ea> 111111111***
0000ABD8  0C39 0000 0000975C      2781  MYBE_ASd_1  CMPI.B  #%000, FIRST_3
0000ABE0  6700 0020               2782              BEQ     ASd_1
0000ABE4  0C39 0001 0000975C      2783              CMPI.B  #%001, FIRST_3
0000ABEC  6700 0014               2784              BEQ     ASd_1 * LSd
0000ABF0  0C39 0003 0000975C      2785              CMPI.B  #%011, FIRST_3
0000ABF8  6700 0008               2786              BEQ     ASd_1 * ROd
0000ABFC  4EF9 0000BA9C           2787              JMP     INVALID
0000AC02                          2788  
0000AC02  0C39 0007 0000975E      2789  ASd_1       CMPI.B  #%111, THIRD_3
0000AC0A  6600 000E               2790              BNE     MOVEON  
0000AC0E  0C39 0004 0000975F      2791              CMPI.B  #%100, FOURTH_3
0000AC16  6700 0E84               2792              BEQ     INVALID
0000AC1A                          2793  
0000AC1A  367C AC36               2794  MOVEON      MOVEA.W #ASd_1_BACK, A3           
0000AC1E  0C39 0000 0000975F      2795              CMPI.B  #%000, FOURTH_3
0000AC26  6700 0CEA               2796              BEQ     SIZE_1_W
0000AC2A  0C39 0001 0000975F      2797              CMPI.B  #%001, FOURTH_3
0000AC32  6700 0CE8               2798              BEQ     SIZE_1_L
0000AC36                          2799  
0000AC36  1639 0000975E           2800  ASd_1_BACK  MOVE.B  THIRD_3, D3
0000AC3C  1439 0000975F           2801              MOVE.B  FOURTH_3, D2
0000AC42                          2802              
0000AC42  4EB9 0000B85C           2803              JSR     LOAD_EA
0000AC48  4EB9 0000B9D6           2804              JSR     LOAD_NEW_LINE
0000AC4E  4E75                    2805              RTS
0000AC50                          2806  ***111111111 ASd <ea> 111111111***
0000AC50                          2807  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000AC50                          2808  
0000AC50                          2809  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000AC50                          2810  ***111111111 ASd X, Y 11111111***
0000AC50  4285                    2811  MYBE_ASd_2  CLR.L   D5
0000AC52                          2812  
0000AC52  1A39 0000975E           2813              MOVE.B  THIRD_3, D5
0000AC58  0205 0003               2814              ANDI.B  #%011, D5
0000AC5C  0C05 0002               2815              CMPI.B  #%10, D5
0000AC60  6600 0006               2816              BNE     ASd_2 * or LSd or ROd
0000AC64  6700 0E36               2817              BEQ     INVALID
0000AC68                          2818              
0000AC68  4285                    2819  ASd_2       CLR.L   D5
0000AC6A                          2820  
0000AC6A  1A39 0000975E           2821              MOVE.B  THIRD_3, D5
0000AC70  0205 0004               2822              ANDI.B  #%100, D5
0000AC74  0C05 0004               2823              CMPI.B  #%100, D5
0000AC78  6700 004E               2824              BEQ     ASd_2_REG
0000AC7C  6600 0002               2825              BNE     ASd_2_IMD
0000AC80                          2826              
0000AC80                          2827  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000AC80                          2828  ***222222222 ASd #<data>, Dy 222222222***
0000AC80  347C ACAA               2829  ASd_2_IMD   MOVEA.W #ASd_2_IMD_B, A2
0000AC84  0C39 0000 0000975C      2830              CMPI.B  #%000, FIRST_3
0000AC8C  6700 0006               2831              BEQ     LOAD_8
0000AC90  6600 000C               2832              BNE     LOAD_FIRST3
0000AC94                          2833              
0000AC94  183C 0008               2834  LOAD_8      MOVE.B  #8, D4
0000AC98  4EF9 0000B99E           2835              JMP     LOAD_IMMDTE
0000AC9E                          2836  
0000AC9E  1839 0000975C           2837  LOAD_FIRST3 MOVE.B  FIRST_3, D4
0000ACA4  4EF9 0000B99E           2838              JMP     LOAD_IMMDTE
0000ACAA                          2839  
0000ACAA  4EB9 0000B9D8           2840  ASd_2_IMD_B JSR     LOAD_COMMA_SPACE
0000ACB0                          2841  
0000ACB0  163C 0000               2842              MOVE.B  #%000, D3
0000ACB4  1439 0000975F           2843              MOVE.B  FOURTH_3, D2
0000ACBA                          2844              
0000ACBA  4EB9 0000B85C           2845              JSR     LOAD_EA
0000ACC0  4EB9 0000B9D6           2846              JSR     LOAD_NEW_LINE
0000ACC6  4E75                    2847              RTS
0000ACC8                          2848  ***222222222 ASd #<data>, Dy 222222222***
0000ACC8                          2849  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000ACC8                          2850  
0000ACC8                          2851  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000ACC8                          2852  ***222222222 ASd Dx, Dy 222222222***
0000ACC8  163C 0000               2853  ASd_2_REG   MOVE.B  #%000, D3
0000ACCC  1439 0000975C           2854              MOVE.B  FIRST_3, D2
0000ACD2                          2855              
0000ACD2  4EB9 0000B85C           2856              JSR     LOAD_EA
0000ACD8  4EB9 0000B9D8           2857              JSR     LOAD_COMMA_SPACE
0000ACDE                          2858              
0000ACDE  163C 0000               2859              MOVE.B  #%000, D3
0000ACE2  1439 0000975F           2860              MOVE.B  FOURTH_3, D2
0000ACE8                          2861              
0000ACE8  4EB9 0000B85C           2862              JSR     LOAD_EA
0000ACEE  4EB9 0000B9D6           2863              JSR     LOAD_NEW_LINE
0000ACF4  4E75                    2864              RTS
0000ACF6                          2865  ***222222222 ASd Dx, Dy 222222222***
0000ACF6                          2866  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000ACF6                          2867  
0000ACF6                          2868  ***111111111 ASd X, Y 111111111***
0000ACF6                          2869  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000ACF6                          2870  
0000ACF6                          2871  
0000ACF6                          2872  * <EA>
0000ACF6                          2873  **********************************************************************************
0000ACF6                          2874  * Description: Once the mnemonic is 0110, it is either BRA or Bcc.
0000ACF6                          2875  *
0000ACF6                          2876  * Registers used: Whether if it is BRA or Bcc, in terms of EA, both instructions
0000ACF6                          2877  *                 share the same EA algorithm. D4 for the displacement, D5 for calculation,
0000ACF6                          2878  *                 D6 for checking the current opcode, A2 and A3 for returning from subbranches.
0000ACF6                          2879  *
0000ACF6                          2880  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000ACF6                          2881  *
0000ACF6                          2882  * Postcondition: X
0000ACF6                          2883  **********************************************************************************
0000ACF6                          2884  LOAD_0110:
0000ACF6  247C 00000000           2885              MOVEA.L #0, A2
0000ACFC  267C 00000000           2886              MOVEA.L #0, A3
0000AD02  4285                    2887              CLR.L   D5
0000AD04  4286                    2888              CLR.L   D6
0000AD06  4284                    2889              CLR.L   D4
0000AD08                          2890  
0000AD08  0C39 0000 0000975C      2891              CMPI.B  #%000, FIRST_3
0000AD10  6700 0006               2892              BEQ     MYBE_BRA
0000AD14  6600 0012               2893              BNE     NOT_BRA
0000AD18  0C39 0004 0000975D      2894  MYBE_BRA    CMPI.B  #%100, SECOND_3
0000AD20  6D00 003E               2895              BLT     BRA
0000AD24  6C00 0002               2896              BGE     NOT_BRA
0000AD28                          2897              
0000AD28  1A39 0000975C           2898  NOT_BRA     MOVE.B  FIRST_3, D5
0000AD2E  E305                    2899              ASL.B   #1, D5
0000AD30  1C39 0000975D           2900              MOVE.B  SECOND_3, D6
0000AD36  E406                    2901              ASR.B   #2, D6
0000AD38  DA06                    2902              ADD.B   D6, D5
0000AD3A                          2903              
0000AD3A  0C05 0005               2904              CMPI.B  #%0101, D5
0000AD3E  6700 0020               2905              BEQ     BRA * CS
0000AD42  0C05 0008               2906              CMPI.B  #%1000, D5
0000AD46  6700 0018               2907              BEQ     BRA * VC
0000AD4A  0C05 000C               2908              CMPI.B  #%1100, D5
0000AD4E  6700 0010               2909              BEQ     BRA * GE
0000AD52  0C05 000D               2910              CMPI.B  #%1101, D5
0000AD56  6700 0008               2911              BEQ     BRA * LT
0000AD5A                          2912              
0000AD5A  4EF9 0000BA9C           2913              JMP     INVALID
0000AD60                          2914              
0000AD60                          2915              
0000AD60  4285                    2916  BRA         CLR.L   D5
0000AD62  4286                    2917              CLR.L   D6
0000AD64                          2918  
0000AD64  3A0D                    2919              MOVE.W  A5, D5 * D5 has $1002 (Starting + MNEMONICS)
0000AD66  3C39 000090A0           2920              MOVE.W  CUR_OP_CODE_1, D6
0000AD6C  0246 00FF               2921              ANDI.W  #$00FF, D6 * D6 now has $E
0000AD70  0C06 0000               2922              CMPI.B  #$00, D6
0000AD74  6700 0052               2923              BEQ     BRA_WORD * word. there is 4 hex trailing bits (word)
0000AD78                          2924  
0000AD78  0C06 00FF               2925              CMPI.B  #$FF, D6
0000AD7C  6700 0010               2926              BEQ     BRA_BYTE
0000AD80  0C06 00FE               2927              CMPI.B  #$FE, D6
0000AD84  6700 0008               2928              BEQ     BRA_BYTE
0000AD88                          2929  
0000AD88  4EF9 0000BA9C           2930              JMP     INVALID
0000AD8E                          2931              
0000AD8E                          2932  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000AD8E                          2933  ***111111111 BRA_BYTE 111111111***
0000AD8E  0C06 00FE               2934  BRA_BYTE    CMPI.B  #$FE, D6
0000AD92  6700 0010               2935              BEQ     DOWN_ZERO
0000AD96  0C06 00FF               2936              CMPI.B  #$FF, D6
0000AD9A  6700 0010               2937              BEQ     DOWN_ONE
0000AD9E                          2938              
0000AD9E  4EF9 0000BA9C           2939              JMP     INVALID
0000ADA4                          2940              
0000ADA4  5505                    2941  DOWN_ZERO   SUBI.B  #$2, D5 * D5 has $1000 (Starting)
0000ADA6  4EF9 0000ADB4           2942              JMP     BRA_BYTE2
0000ADAC                          2943              
0000ADAC  5305                    2944  DOWN_ONE    SUBI.B  #$1, D5 * D5 has $1001 (Starting + 1)
0000ADAE  4EF9 0000ADB4           2945              JMP     BRA_BYTE2
0000ADB4                          2946              
0000ADB4  347C ADC0               2947  BRA_BYTE2   MOVE.W  #BRA_BYTE3, A2
0000ADB8  3805                    2948              MOVE.W  D5, D4
0000ADBA  4EF9 0000B97A           2949              JMP     LOAD_ABS_SHORT
0000ADC0  4EB9 0000B9D6           2950  BRA_BYTE3   JSR     LOAD_NEW_LINE
0000ADC6  4E75                    2951              RTS
0000ADC8                          2952  ***111111111 BRA_BYTE 111111111***
0000ADC8                          2953  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000ADC8                          2954  
0000ADC8                          2955  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000ADC8                          2956  ***111111111 BRA_WORD 111111111***
0000ADC8  381D                    2957  BRA_WORD    MOVE.W  (A5)+, D4 * D4 now has $000E
0000ADCA                          2958  
0000ADCA  0C84 00008000           2959              CMPI.L  #$8000, D4
0000ADD0  6C00 001A               2960              BGE     NEG_WORD
0000ADD4  6D00 0002               2961              BLT     POS_WORD
0000ADD8                          2962              
0000ADD8                          2963  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000ADD8                          2964  ***222222222 BRA_WORD_POSITIVE 222222222***
0000ADD8  347C ADE4               2965  POS_WORD    MOVE.W  #BRA_WORD_BK, A2
0000ADDC  D845                    2966              ADD.W   D5, D4 * D4 now has $100E
0000ADDE  4EF9 0000B97A           2967              JMP     LOAD_ABS_SHORT
0000ADE4  4EB9 0000B9D6           2968  BRA_WORD_BK JSR     LOAD_NEW_LINE
0000ADEA  4E75                    2969              RTS
0000ADEC                          2970  ***222222222 BRA_WORD_POSITIVE 222222222***
0000ADEC                          2971  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000ADEC                          2972  
0000ADEC                          2973  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000ADEC                          2974  ***222222222 BRA_WORD_NEGATIVE 222222222***
0000ADEC  347C AE02               2975  NEG_WORD    MOVE.W  #BRA_WRD_BK2, A2
0000ADF0  4444                    2976              NEG     D4
0000ADF2                          2977              
0000ADF2  B885                    2978              CMP.L   D5, D4 * $4002 vs DISPLACEMENT
0000ADF4  6E00 0CA6               2979              BGT     INVALID
0000ADF8                          2980              
0000ADF8  9A44                    2981              SUB.W   D4, D5 * D5 now has $1000 - 2cmp'ed $000E
0000ADFA  3805                    2982              MOVE.W  D5, D4
0000ADFC  4EF9 0000B97A           2983              JMP     LOAD_ABS_SHORT
0000AE02  4EB9 0000B9D6           2984  BRA_WRD_BK2 JSR     LOAD_NEW_LINE
0000AE08  4E75                    2985              RTS
0000AE0A                          2986  ***222222222 BRA_WORD_NEGATIVE 222222222***
0000AE0A                          2987  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000AE0A                          2988  
0000AE0A                          2989  ***111111111 BRA_WORD 111111111***
0000AE0A                          2990  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000AE0A                          2991  
0000AE0A                          2992  
0000AE0A                          2993  * <EA>
0000AE0A                          2994  **********************************************************************************
0000AE0A                          2995  * Description: Once the mnemonic is 1001, it is either ADD or ADDA.
0000AE0A                          2996  *
0000AE0A                          2997  * Registers used: If ADDA, D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch, D1 for size calculation.
0000AE0A                          2998  *                 If ADD, basically recycling the algorithm for DIVS/OR
0000AE0A                          2999  *
0000AE0A                          3000  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000AE0A                          3001  *
0000AE0A                          3002  * Postcondition: X
0000AE0A                          3003  **********************************************************************************
0000AE0A                          3004  LOAD_1101:
0000AE0A  0C39 0003 0000975D      3005              CMPI.B  #%011, SECOND_3
0000AE12  6700 0014               3006              BEQ     ADDA
0000AE16  0C39 0007 0000975D      3007              CMPI.B  #%111, SECOND_3
0000AE1E  6700 0008               3008              BEQ     ADDA
0000AE22                          3009              
0000AE22  4EF9 0000AE8A           3010              JMP     LOAD_1000
0000AE28                          3011              
0000AE28  367C AE48               3012  ADDA        MOVEA.W #ADDA_BACK, A3
0000AE2C  4281                    3013              CLR.L   D1
0000AE2E  1239 0000975D           3014              MOVE.B  SECOND_3, D1
0000AE34  0201 0004               3015              ANDI.B  #%100, D1
0000AE38                          3016              
0000AE38  0C01 0000               3017              CMPI.B  #%000, D1
0000AE3C  6700 0AD4               3018              BEQ     SIZE_1_W
0000AE40  0C01 0004               3019              CMPI.B  #%100, D1
0000AE44  6700 0AD6               3020              BEQ     SIZE_1_L
0000AE48                          3021              
0000AE48  1639 0000975E           3022  ADDA_BACK   MOVE.B  THIRD_3, D3
0000AE4E  1439 0000975F           3023              MOVE.B  FOURTH_3, D2
0000AE54                          3024  
0000AE54  4EB9 0000B85C           3025              JSR     LOAD_EA
0000AE5A  4EB9 0000B9D8           3026              JSR     LOAD_COMMA_SPACE
0000AE60                          3027              
0000AE60  163C 0001               3028              MOVE.B  #%001, D3
0000AE64  1439 0000975C           3029              MOVE.B  FIRST_3, D2
0000AE6A                          3030              
0000AE6A  4EB9 0000B85C           3031              JSR     LOAD_EA
0000AE70  4EB9 0000B9D6           3032              JSR     LOAD_NEW_LINE
0000AE76  4E75                    3033              RTS
0000AE78                          3034  
0000AE78                          3035  * <EA>
0000AE78                          3036  **********************************************************************************
0000AE78                          3037  * Description: Once the mnemonic is 1001, it is MULS.
0000AE78                          3038  *
0000AE78                          3039  * Registers used: X. Basically recycling the algorithm for DIVS/OR
0000AE78                          3040  *
0000AE78                          3041  * Precondition: X
0000AE78                          3042  *
0000AE78                          3043  * Postcondition: X
0000AE78                          3044  **********************************************************************************
0000AE78                          3045  LOAD_1100:
0000AE78  4EF9 0000AE8A           3046      JMP     LOAD_1000
0000AE7E                          3047      
0000AE7E                          3048  * <EA>
0000AE7E                          3049  **********************************************************************************
0000AE7E                          3050  * Description: Once the mnemonic is 1001, it is either EOR or CMP.
0000AE7E                          3051  *
0000AE7E                          3052  * Registers used: X. Basically recycling the algorithm for DIVS/OR
0000AE7E                          3053  *
0000AE7E                          3054  * Precondition: X
0000AE7E                          3055  *
0000AE7E                          3056  * Postcondition: X
0000AE7E                          3057  **********************************************************************************
0000AE7E                          3058  LOAD_1011:
0000AE7E  4EF9 0000AE8A           3059      JMP     LOAD_1000
0000AE84                          3060  
0000AE84                          3061  
0000AE84                          3062  * <EA>
0000AE84                          3063  **********************************************************************************
0000AE84                          3064  * Description: Once the mnemonic is 1001, it is SUB.
0000AE84                          3065  *
0000AE84                          3066  * Registers used: X. Basically recycling the algorithm for DIVS/OR
0000AE84                          3067  *
0000AE84                          3068  * Precondition: X
0000AE84                          3069  *
0000AE84                          3070  * Postcondition: X
0000AE84                          3071  **********************************************************************************
0000AE84                          3072  LOAD_1001:
0000AE84  4EF9 0000AE8A           3073      JMP     LOAD_1000
0000AE8A                          3074  
0000AE8A                          3075  
0000AE8A                          3076  * <EA>
0000AE8A                          3077  **********************************************************************************
0000AE8A                          3078  * Description: Once the mnemonic is 1000, it is either DIVS or OR.
0000AE8A                          3079  *
0000AE8A                          3080  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch.
0000AE8A                          3081  *
0000AE8A                          3082  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000AE8A                          3083  *
0000AE8A                          3084  * Postcondition: X
0000AE8A                          3085  **********************************************************************************
0000AE8A                          3086  LOAD_1000:
0000AE8A  4283                    3087              CLR.L   D3
0000AE8C  4282                    3088              CLR.L   D2
0000AE8E  267C 00000000           3089              MOVEA.L #0, A3
0000AE94                          3090              
0000AE94  0C39 0007 0000975D      3091              CMPI.B  #%111, SECOND_3
0000AE9C  6700 00CE               3092              BEQ     DIVS
0000AEA0                          3093              
0000AEA0  0C39 0003 0000975D      3094              CMPI.B  #%011, SECOND_3
0000AEA8  6700 0BF2               3095              BEQ     INVALID
0000AEAC                          3096              
0000AEAC                          3097  ***vvvvvvvvvvvvvvvvvvv***
0000AEAC  0C39 0004 0000975D      3098              CMPI.B  #%100, SECOND_3
0000AEB4  6D00 0006               3099              BLT     DIR_0 * direction bit 0
0000AEB8  6C00 005A               3100              BGE     DIR_1 * direction bit 1
0000AEBC                          3101              
0000AEBC  4281                    3102  DIR_0       CLR.L   D1
0000AEBE  1239 0000975D           3103              MOVE.B  SECOND_3, D1
0000AEC4  0201 0003               3104              ANDI.B  #%011, D1
0000AEC8                          3105      
0000AEC8  367C AEE4               3106              MOVEA.W #OR_BACK, A3
0000AECC  0C01 0000               3107              CMPI.B  #%00, D1
0000AED0  6700 0A36               3108              BEQ     SIZE_1_B
0000AED4  0C01 0001               3109              CMPI.B  #%01, D1
0000AED8  6700 0A38               3110              BEQ     SIZE_1_W
0000AEDC  0C01 0002               3111              CMPI.B  #%10, D1
0000AEE0  6700 0A3A               3112              BEQ     SIZE_1_L
0000AEE4                          3113              
0000AEE4  1639 0000975E           3114  OR_BACK     MOVE.B  THIRD_3, D3
0000AEEA  1439 0000975F           3115              MOVE.B  FOURTH_3, D2
0000AEF0                          3116  
0000AEF0  4EB9 0000B85C           3117              JSR     LOAD_EA
0000AEF6  4EB9 0000B9D8           3118              JSR     LOAD_COMMA_SPACE
0000AEFC                          3119              
0000AEFC  163C 0000               3120              MOVE.B  #%000, D3
0000AF00  1439 0000975C           3121              MOVE.B  FIRST_3, D2
0000AF06                          3122              
0000AF06  4EB9 0000B85C           3123              JSR     LOAD_EA
0000AF0C  4EB9 0000B9D6           3124              JSR     LOAD_NEW_LINE
0000AF12  4E75                    3125              RTS
0000AF14                          3126              
0000AF14  163C 0000               3127  DIR_1       MOVE.B  #%000, D3
0000AF18  1439 0000975C           3128              MOVE.B  FIRST_3, D2
0000AF1E                          3129              
0000AF1E  4EB9 0000B85C           3130              JSR     LOAD_EA
0000AF24  4EB9 0000B9D8           3131              JSR     LOAD_COMMA_SPACE
0000AF2A                          3132              
0000AF2A  4281                    3133              CLR.L   D1
0000AF2C  1239 0000975D           3134              MOVE.B  SECOND_3, D1
0000AF32  0201 0003               3135              ANDI.B  #%011, D1
0000AF36                          3136      
0000AF36  367C AF52               3137              MOVEA.W #OR_BACK2, A3
0000AF3A  0C01 0000               3138              CMPI.B  #%00, D1
0000AF3E  6700 09C8               3139              BEQ     SIZE_1_B
0000AF42  0C01 0001               3140              CMPI.B  #%01, D1
0000AF46  6700 09CA               3141              BEQ     SIZE_1_W
0000AF4A  0C01 0002               3142              CMPI.B  #%10, D1
0000AF4E  6700 09CC               3143              BEQ     SIZE_1_L
0000AF52                          3144              
0000AF52  1639 0000975E           3145  OR_BACK2    MOVE.B  THIRD_3, D3
0000AF58  1439 0000975F           3146              MOVE.B  FOURTH_3, D2
0000AF5E                          3147  
0000AF5E  4EB9 0000B85C           3148              JSR     LOAD_EA
0000AF64  4EB9 0000B9D6           3149              JSR     LOAD_NEW_LINE
0000AF6A  4E75                    3150              RTS    
0000AF6C                          3151  ***^^^^^^^^^^^^^^^^^^^***
0000AF6C                          3152              
0000AF6C                          3153  ***vvvvvvvvvvvvvvvvvvv***
0000AF6C  367C AF94               3154  DIVS        MOVEA.W #DIVS_BACK, A3
0000AF70  0C39 0000 0000975F      3155              CMPI.B  #%000, FOURTH_3
0000AF78  6700 0998               3156              BEQ     SIZE_1_W
0000AF7C  0C39 0001 0000975F      3157              CMPI.B  #%001, FOURTH_3
0000AF84  6700 0B16               3158              BEQ     INVALID
0000AF88  0C39 0004 0000975F      3159              CMPI.B  #%100, FOURTH_3
0000AF90  6700 0980               3160              BEQ     SIZE_1_W
0000AF94                          3161              
0000AF94  1639 0000975E           3162  DIVS_BACK   MOVE.B  THIRD_3, D3
0000AF9A  1439 0000975F           3163              MOVE.B  FOURTH_3, D2
0000AFA0                          3164  
0000AFA0  4EB9 0000B85C           3165              JSR     LOAD_EA
0000AFA6  4EB9 0000B9D8           3166              JSR     LOAD_COMMA_SPACE
0000AFAC                          3167  
0000AFAC  163C 0000               3168              MOVE.B  #%000, D3
0000AFB0  1439 0000975C           3169              MOVE.B  FIRST_3, D2
0000AFB6                          3170  
0000AFB6  4EB9 0000B85C           3171              JSR     LOAD_EA
0000AFBC  4EB9 0000B9D6           3172              JSR     LOAD_NEW_LINE
0000AFC2  4E75                    3173              RTS
0000AFC4                          3174  ***^^^^^^^^^^^^^^^^^^^***
0000AFC4                          3175  
0000AFC4                          3176  
0000AFC4                          3177  * <EA>
0000AFC4                          3178  **********************************************************************************
0000AFC4                          3179  * Description: Once the mnemonic is 0101, it is SUBQ
0000AFC4                          3180  *
0000AFC4                          3181  * Registers used: D4 to load the data within the EA bits, and A2 to come back
0000AFC4                          3182  *
0000AFC4                          3183  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000AFC4                          3184  *
0000AFC4                          3185  * Postcondition: X
0000AFC4                          3186  **********************************************************************************
0000AFC4                          3187  LOAD_0101:
0000AFC4  4283                    3188              CLR.L   D3
0000AFC6  4282                    3189              CLR.L   D2
0000AFC8  267C 00000000           3190              MOVEA.L #0, A3
0000AFCE                          3191  
0000AFCE  0C39 0007 0000975C      3192              CMPI.B  #%111, FIRST_3
0000AFD6  6F00 0008               3193              BLE     MYBE_SUBQ1
0000AFDA  4EF9 0000BA9C           3194              JMP     INVALID
0000AFE0                          3195              
0000AFE0  0C39 0003 0000975D      3196  MYBE_SUBQ1  CMPI.B  #%011, SECOND_3
0000AFE8  6E00 0008               3197              BGT     MYBE_SUBQ2
0000AFEC  4EF9 0000BA9C           3198              JMP     INVALID
0000AFF2                          3199  
0000AFF2  0C39 0007 0000975D      3200  MYBE_SUBQ2  CMPI.B  #%111, SECOND_3
0000AFFA  6D00 0008               3201              BLT     SUBQ
0000AFFE  4EF9 0000BA9C           3202              JMP     INVALID
0000B004                          3203  
0000B004  5239 0000975C           3204  SUBQ        ADDI.B  #%1, FIRST_3
0000B00A  1839 0000975C           3205              MOVE.B  FIRST_3, D4
0000B010                          3206              
0000B010  347C B01A               3207              MOVEA.W #SUBQ_SAVED, A2
0000B014  4EF9 0000B99E           3208              JMP     LOAD_IMMDTE
0000B01A                          3209              
0000B01A  4EB9 0000B9D8           3210  SUBQ_SAVED  JSR     LOAD_COMMA_SPACE
0000B020                          3211  
0000B020  367C B048               3212              MOVEA.W #SUBQ_BACK, A3
0000B024  0C39 0004 0000975D      3213              CMPI.B  #%100, SECOND_3
0000B02C  6700 08DA               3214              BEQ     SIZE_1_B
0000B030  0C39 0005 0000975D      3215              CMPI.B  #%101, SECOND_3
0000B038  6700 08D8               3216              BEQ     SIZE_1_W
0000B03C  0C39 0006 0000975D      3217              CMPI.B  #%110, SECOND_3
0000B044  6700 08D6               3218              BEQ     SIZE_1_L
0000B048                          3219              
0000B048  1639 0000975E           3220  SUBQ_BACK   MOVE.B  THIRD_3, D3
0000B04E  1439 0000975F           3221              MOVE.B  FOURTH_3, D2
0000B054                          3222  
0000B054  4EB9 0000B85C           3223              JSR     LOAD_EA
0000B05A  4EB9 0000B9D6           3224              JSR     LOAD_NEW_LINE
0000B060  4E75                    3225              RTS
0000B062                          3226  
0000B062                          3227  * <EA>
0000B062                          3228  **********************************************************************************
0000B062                          3229  * Description: Once the mnemonic is 0100, it is either NEG, RTS, JSR, MOVEM, or LEA.
0000B062                          3230  *
0000B062                          3231  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch,
0000B062                          3232  *                 D5, D4 for BCLR, D6 for recognizing MOVEM
0000B062                          3233  *
0000B062                          3234  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000B062                          3235  *
0000B062                          3236  * Postcondition: X
0000B062                          3237  **********************************************************************************
0000B062                          3238  LOAD_0100:
0000B062  4283                    3239              CLR.L   D3
0000B064  4282                    3240              CLR.L   D2
0000B066  267C 00000000           3241              MOVEA.L #0, A3
0000B06C                          3242  
0000B06C  0C39 0002 0000975C      3243              CMPI.B  #%010, FIRST_3
0000B074  6700 0006               3244              BEQ     MYBE_NEG
0000B078  6600 000E               3245              BNE     NOT_NEG
0000B07C  0C39 0003 0000975D      3246  MYBE_NEG    CMPI.B  #%011, SECOND_3
0000B084  6D00 00A2               3247              BLT     NEG
0000B088                          3248  
0000B088  0C39 0007 0000975C      3249  NOT_NEG     CMPI.B  #%111, FIRST_3
0000B090  6700 0006               3250              BEQ     MYBE_RTS1
0000B094  6600 003A               3251              BNE     NOT_RTS
0000B098  0C39 0001 0000975D      3252  MYBE_RTS1   CMPI.B  #%001, SECOND_3
0000B0A0  6700 0006               3253              BEQ     MYBE_RTS2
0000B0A4  6600 002A               3254              BNE     NOT_RTS
0000B0A8  0C39 0006 0000975E      3255  MYBE_RTS2   CMPI.B  #%110, THIRD_3
0000B0B0  6700 0006               3256              BEQ     MYBE_RTS3
0000B0B4  6600 001A               3257              BNE     NOT_RTS
0000B0B8  0C39 0005 0000975F      3258  MYBE_RTS3   CMPI.B  #%101, FOURTH_3
0000B0C0  6700 00A8               3259              BEQ     RTS
0000B0C4  0C39 0001 0000975F      3260              CMPI.B  #%001, FOURTH_3 
0000B0CC  6700 009C               3261              BEQ     RTS * It's actually NOP but it's the same shit in EA perspective
0000B0D0                          3262              
0000B0D0  0C39 0007 0000975C      3263  NOT_RTS     CMPI.B  #%111, FIRST_3
0000B0D8  6700 0006               3264              BEQ     MYBE_JSR
0000B0DC  6600 000E               3265              BNE     NOT_JSR
0000B0E0  0C39 0002 0000975D      3266  MYBE_JSR    CMPI.B  #%010, SECOND_3
0000B0E8  6700 0088               3267              BEQ     JSR
0000B0EC                          3268  
0000B0EC  4286                    3269  NOT_JSR     CLR.L   D6
0000B0EE  1C39 0000975C           3270              MOVE.B  FIRST_3, D6
0000B0F4  0206 0005               3271              ANDI.B  #%101, D6 * Making %1X0 -> %100
0000B0F8  0C06 0004               3272              CMPI.B  #%100, D6
0000B0FC  6700 0006               3273              BEQ     MYBE_MOVEM
0000B100  6600 0014               3274              BNE     NOT_MOVEM
0000B104                          3275              
0000B104  1C39 0000975D           3276  MYBE_MOVEM  MOVE.B  SECOND_3, D6
0000B10A  0206 0006               3277              ANDI.B  #%110, D6
0000B10E  0C06 0002               3278              CMPI.B  #%010, D6
0000B112  6700 0094               3279              BEQ     MOVEM
0000B116                          3280              
0000B116  0C39 0007 0000975D      3281  NOT_MOVEM   CMPI.B  #%111, SECOND_3
0000B11E  6700 0096               3282              BEQ     LEA
0000B122                          3283              
0000B122  4EF9 0000BA9C           3284              JMP     INVALID
0000B128                          3285  
0000B128                          3286  NEG:
0000B128  367C B150               3287              MOVEA.W #NEG_BACK, A3
0000B12C  0C39 0000 0000975D      3288              CMPI.B  #%000, SECOND_3
0000B134  6700 07D2               3289              BEQ     SIZE_1_B
0000B138  0C39 0001 0000975D      3290              CMPI.B  #%001, SECOND_3
0000B140  6700 07D0               3291              BEQ     SIZE_1_W
0000B144  0C39 0002 0000975D      3292              CMPI.B  #%010, SECOND_3
0000B14C  6700 07CE               3293              BEQ     SIZE_1_L
0000B150                          3294              
0000B150  1639 0000975E           3295  NEG_BACK    MOVE.B  THIRD_3, D3
0000B156  1439 0000975F           3296              MOVE.B  FOURTH_3, D2
0000B15C                          3297  
0000B15C  4EB9 0000B85C           3298              JSR     LOAD_EA
0000B162  4EB9 0000B9D6           3299              JSR     LOAD_NEW_LINE
0000B168  4E75                    3300              RTS
0000B16A                          3301              
0000B16A                          3302  RTS:
0000B16A  4EB9 0000B9D6           3303              JSR     LOAD_NEW_LINE
0000B170  4E75                    3304              RTS
0000B172                          3305  
0000B172                          3306  JSR:
0000B172  367C B18E               3307              MOVEA.W #JSR_BACK, A3
0000B176  0C39 0000 0000975F      3308              CMPI.B  #%000, FOURTH_3
0000B17E  6700 0792               3309              BEQ     SIZE_1_W
0000B182  0C39 0001 0000975F      3310              CMPI.B  #%001, FOURTH_3
0000B18A  6700 0790               3311              BEQ     SIZE_1_L
0000B18E                          3312              
0000B18E  1639 0000975E           3313  JSR_BACK    MOVE.B  THIRD_3, D3
0000B194  1439 0000975F           3314              MOVE.B  FOURTH_3, D2
0000B19A                          3315              
0000B19A  4EB9 0000B85C           3316              JSR     LOAD_EA
0000B1A0  4EB9 0000B9D6           3317              JSR     LOAD_NEW_LINE
0000B1A6  4E75                    3318              RTS
0000B1A8                          3319  
0000B1A8                          3320  MOVEM:
0000B1A8  4EB9 0000B20E           3321              JSR     FUK_MOVEM
0000B1AE  4EB9 0000B9D6           3322              JSR     LOAD_NEW_LINE
0000B1B4  4E75                    3323              RTS
0000B1B6                          3324      
0000B1B6                          3325  LEA:
0000B1B6  367C B1DE               3326              MOVEA.W #LEA_BACK, A3
0000B1BA  0C39 0000 0000975F      3327              CMPI.B  #%000, FOURTH_3
0000B1C2  6700 074E               3328              BEQ     SIZE_1_W
0000B1C6  0C39 0001 0000975F      3329              CMPI.B  #%001, FOURTH_3
0000B1CE  6700 074C               3330              BEQ     SIZE_1_L
0000B1D2  0C39 0004 0000975F      3331              CMPI.B  #%100, FOURTH_3
0000B1DA  6700 08C0               3332              BEQ     INVALID 
0000B1DE                          3333              
0000B1DE  1639 0000975E           3334  LEA_BACK    MOVE.B  THIRD_3, D3
0000B1E4  1439 0000975F           3335              MOVE.B  FOURTH_3, D2
0000B1EA                          3336              
0000B1EA  4EB9 0000B85C           3337              JSR     LOAD_EA
0000B1F0  4EB9 0000B9D8           3338              JSR     LOAD_COMMA_SPACE
0000B1F6                          3339              
0000B1F6  163C 0001               3340              MOVE.B  #%001, D3
0000B1FA  1439 0000975C           3341              MOVE.B  FIRST_3, D2
0000B200                          3342              
0000B200  4EB9 0000B85C           3343              JSR     LOAD_EA
0000B206  4EB9 0000B9D6           3344              JSR     LOAD_NEW_LINE
0000B20C  4E75                    3345              RTS 
0000B20E                          3346  
0000B20E                          3347  FUK_MOVEM:  * Functional Utilization of Knowledge in MOVEM
0000B20E  4284                    3348              CLR.L   D4
0000B210  4285                    3349              CLR.L   D5
0000B212  4286                    3350              CLR.L   D6
0000B214  267C 00000000           3351              MOVEA.L #0, A3
0000B21A                          3352              
0000B21A  1C39 0000975C           3353              MOVE.B  FIRST_3, D6
0000B220  0206 0002               3354              ANDI.B  #%010, D6
0000B224  0C06 0002               3355              CMPI.B  #%010, D6
0000B228  6700 0006               3356              BEQ     MOVEM_POST
0000B22C  6600 00E8               3357              BNE     MOVEM_PRE
0000B230                          3358  
0000B230  0C39 0003 0000975E      3359  MOVEM_POST  CMPI.B  #%011, THIRD_3
0000B238  6700 0020               3360              BEQ     MOVEM_POST2
0000B23C  0C39 0002 0000975E      3361              CMPI.B  #%010, THIRD_3
0000B244  6700 0014               3362              BEQ     MOVEM_POST2
0000B248  0C39 0007 0000975E      3363              CMPI.B  #%111, THIRD_3
0000B250  6700 0028               3364              BEQ     MOVEM_POST3
0000B254  4EF9 0000BA9C           3365              JMP     INVALID
0000B25A                          3366  
0000B25A  1639 0000975E           3367  MOVEM_POST2 MOVE.B  THIRD_3, D3
0000B260  1439 0000975F           3368              MOVE.B  FOURTH_3, D2
0000B266  4EB9 0000B85C           3369              JSR     LOAD_EA
0000B26C  4EB9 0000B9D8           3370              JSR     LOAD_COMMA_SPACE
0000B272                          3371  
0000B272  4EB9 0000B382           3372              JSR     MOVEM_PARSE
0000B278  4E75                    3373              RTS
0000B27A                          3374  
0000B27A                          3375  MOVEM_POST3 * see if new displacement doesnt exceed END_ADDRESS
0000B27A  4286                    3376              CLR.L   D6
0000B27C  3C0D                    3377              MOVE.W  A5, D6
0000B27E  5406                    3378              ADDI.B  #2, D6
0000B280  BC4E                    3379              CMP.W   A6, D6
0000B282  6E00 0818               3380              BGT     INVALID
0000B286                          3381              
0000B286                          3382              * push A5 pointer +2
0000B286  544D                    3383              ADDA.W  #2, A5
0000B288  0C39 0000 0000975F      3384              CMPI.B  #%000, FOURTH_3
0000B290  6700 0014               3385              BEQ     MOVEM_POSTW
0000B294  0C39 0001 0000975F      3386              CMPI.B  #%001, FOURTH_3
0000B29C  6700 0040               3387              BEQ     MOVEM_POSTL
0000B2A0  4EF9 0000BA9C           3388              JMP     INVALID
0000B2A6                          3389              
0000B2A6                          3390  MOVEM_POSTW * see if new displacement doesnt exceed END_ADDRESS
0000B2A6  4286                    3391              CLR.L   D6
0000B2A8  3C0D                    3392              MOVE.W  A5, D6
0000B2AA  5406                    3393              ADDI.B  #2, D6
0000B2AC  BC4E                    3394              CMP.W   A6, D6
0000B2AE  6E00 07EC               3395              BGT     INVALID
0000B2B2                          3396              
0000B2B2                          3397              * munch 2
0000B2B2  33FC 0002 0000AAF0      3398              MOVE.W  #$2, TRAILING_SIZE_1
0000B2BA  1639 0000975E           3399              MOVE.B  THIRD_3, D3
0000B2C0  1439 0000975F           3400              MOVE.B  FOURTH_3, D2
0000B2C6  4EB9 0000B85C           3401              JSR     LOAD_EA
0000B2CC  4EB9 0000B9D8           3402              JSR     LOAD_COMMA_SPACE
0000B2D2                          3403              
0000B2D2                          3404              * push back -4
0000B2D2  594D                    3405              SUBA.W  #4, A5
0000B2D4  4EB9 0000B382           3406              JSR     MOVEM_PARSE
0000B2DA                          3407              * push 2
0000B2DA  544D                    3408              ADDA.W  #2, A5
0000B2DC  4E75                    3409              RTS
0000B2DE                          3410  
0000B2DE                          3411  MOVEM_POSTL * see if new displacement doesnt exceed END_ADDRESS
0000B2DE  4286                    3412              CLR.L   D6
0000B2E0  3C0D                    3413              MOVE.W  A5, D6
0000B2E2  5406                    3414              ADDI.B  #2, D6
0000B2E4  BC4E                    3415              CMP.W   A6, D6
0000B2E6  6E00 07B4               3416              BGT     INVALID         
0000B2EA                          3417              
0000B2EA                          3418              * munch 4
0000B2EA  33FC 0004 0000AAF0      3419              MOVE.W  #$4, TRAILING_SIZE_1
0000B2F2  1639 0000975E           3420              MOVE.B  THIRD_3, D3
0000B2F8  1439 0000975F           3421              MOVE.B  FOURTH_3, D2
0000B2FE  4EB9 0000B85C           3422              JSR     LOAD_EA
0000B304  4EB9 0000B9D8           3423              JSR     LOAD_COMMA_SPACE
0000B30A                          3424  
0000B30A                          3425              * push back -6
0000B30A  5D4D                    3426              SUBA.W  #6, A5
0000B30C  4EB9 0000B382           3427              JSR     MOVEM_PARSE
0000B312                          3428              * push 4
0000B312  584D                    3429              ADDA.W  #4, A5
0000B314  4E75                    3430              RTS
0000B316                          3431  
0000B316  4EB9 0000B382           3432  MOVEM_PRE   JSR     MOVEM_PARSE
0000B31C  4EB9 0000B9D8           3433              JSR     LOAD_COMMA_SPACE
0000B322                          3434  
0000B322  367C B344               3435              MOVEA.W #MOVEM_PRE_B, A3
0000B326  0C39 0000 0000975F      3436              CMPI.B  #%000, FOURTH_3
0000B32E  6700 05E2               3437              BEQ     SIZE_1_W
0000B332  0C39 0001 0000975F      3438              CMPI.B  #%001, FOURTH_3
0000B33A  6700 05E0               3439              BEQ     SIZE_1_L
0000B33E  4EF9 0000BA9C           3440              JMP     INVALID
0000B344                          3441              
0000B344  0C39 0000 0000975E      3442  MOVEM_PRE_B CMPI.B  #%000, THIRD_3
0000B34C  6700 074E               3443              BEQ     INVALID
0000B350  0C39 0003 0000975E      3444              CMPI.B  #%011, THIRD_3
0000B358  6700 0742               3445              BEQ     INVALID
0000B35C  0C39 0001 0000975E      3446              CMPI.B  #%001, THIRD_3
0000B364  6700 0736               3447              BEQ     INVALID
0000B368                          3448              
0000B368  1639 0000975E           3449              MOVE.B  THIRD_3, D3
0000B36E  1439 0000975F           3450              MOVE.B  FOURTH_3, D2
0000B374                          3451              
0000B374  4EB9 0000B85C           3452              JSR     LOAD_EA
0000B37A  4EB9 0000B9D6           3453              JSR     LOAD_NEW_LINE
0000B380  4E75                    3454              RTS
0000B382                          3455              
0000B382                          3456  MOVEM_PARSE:
0000B382  4284                    3457              CLR.L   D4
0000B384  381D                    3458              MOVE.W  (A5)+, D4 * D4 has $00FF
0000B386                          3459                          
0000B386  0C39 0004 0000975E      3460              CMPI.B  #%100, THIRD_3
0000B38E  6600 0006               3461              BNE     A_TO_D
0000B392  6700 0038               3462              BEQ     D_TO_A
0000B396                          3463  
0000B396  13FC 0001 0000AAF2      3464  A_TO_D      MOVE.B  #%001, X * X = A
0000B39E  13FC 0000 0000AAF3      3465              MOVE.B  #%000, Y * Y = D
0000B3A6  13FC 0008 0000AAF4      3466              MOVE.B  #$8, X_COUNTER * start from 8
0000B3AE  13FC 0008 0000AAF5      3467              MOVE.B  #$8, Y_COUNTER * start from 8
0000B3B6  13FC 0000 0000AAF6      3468              MOVE.B  #0, FIRST_X
0000B3BE  13FC 0000 0000AAF7      3469              MOVE.B  #0, FIRST_Y
0000B3C6                          3470  
0000B3C6  4EF9 0000B518           3471              JMP     GO_A_TO_D
0000B3CC                          3472              
0000B3CC  13FC 0000 0000AAF2      3473  D_TO_A      MOVE.B  #%000, X * X = D
0000B3D4  13FC 0001 0000AAF3      3474              MOVE.B  #%001, Y * Y = A
0000B3DC  13FC 00FF 0000AAF4      3475              MOVE.B  #$FF, X_COUNTER * start from -1
0000B3E4  13FC 00FF 0000AAF5      3476              MOVE.B  #$FF, Y_COUNTER * start from -1
0000B3EC  13FC 0000 0000AAF6      3477              MOVE.B  #0, FIRST_X
0000B3F4  13FC 0000 0000AAF7      3478              MOVE.B  #0, FIRST_Y
0000B3FC                          3479              
0000B3FC  4EF9 0000B402           3480              JMP     GO_D_TO_A
0000B402                          3481  
0000B402                          3482  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000B402                          3483  ***111111111 MOVEM D->A 111111111***
0000B402  E35C                    3484  GO_D_TO_A   ROL.W   #1, D4
0000B404  3A04                    3485              MOVE.W  D4, D5
0000B406  0245 0001               3486              ANDI.W  #$1, D5
0000B40A                          3487              
0000B40A  0C39 0007 0000AAF4      3488              CMPI.B  #7, X_COUNTER
0000B412  6C00 0012               3489              BGE     ADD_Y
0000B416  6D00 0002               3490              BLT     ADD_X
0000B41A                          3491              
0000B41A  5239 0000AAF4           3492  ADD_X       ADDI.B  #1, X_COUNTER
0000B420  4EF9 0000B43A           3493              JMP     KEEP_GOING0
0000B426                          3494  
0000B426  5239 0000AAF5           3495  ADD_Y       ADDI.B  #1, Y_COUNTER
0000B42C  13FC 0008 0000AAF4      3496              MOVE.B  #8, X_COUNTER
0000B434  4EF9 0000B43A           3497              JMP     KEEP_GOING0
0000B43A                          3498              
0000B43A  0C45 0001               3499  KEEP_GOING0 CMPI.W  #$1, D5
0000B43E  6700 0006               3500              BEQ     BIT_ON
0000B442  6600 00C4               3501              BNE     KEEP_GOING
0000B446                          3502              
0000B446  0C39 0008 0000AAF4      3503  BIT_ON      CMPI.B  #8, X_COUNTER
0000B44E  6600 0006               3504              BNE     ITS_X
0000B452  6700 003E               3505              BEQ     MYBE_Y
0000B456                          3506              
0000B456  1639 0000AAF2           3507  ITS_X       MOVE.B  X, D3 * LOAD[XX_COUNTER]
0000B45C  1439 0000AAF4           3508              MOVE.B  X_COUNTER, D2
0000B462  4EB9 0000B85C           3509              JSR     LOAD_EA
0000B468  0C39 0000 0000AAF6      3510              CMPI.B  #0, FIRST_X
0000B470  6700 0006               3511              BEQ     FST_X
0000B474  6600 0014               3512              BNE     SND_X
0000B478                          3513  
0000B478  18FC 002D               3514  FST_X       MOVE.B  #$2D, (A4)+ * LOAD '-'
0000B47C  13FC 0001 0000AAF6      3515              MOVE.B  #1, FIRST_X * FIRST_X = 1
0000B484  4EF9 0000B508           3516              JMP     KEEP_GOING
0000B48A                          3517              
0000B48A  554C                    3518  SND_X       SUBA.W  #2, A4 * push back G_BUFFER_1 pointer by 2
0000B48C  4EF9 0000B508           3519              JMP     KEEP_GOING
0000B492                          3520  
0000B492  0C39 0008 0000AAF5      3521  MYBE_Y      CMPI.B  #8, Y_COUNTER
0000B49A  6600 0006               3522              BNE     ITS_Y
0000B49E  6700 0068               3523              BEQ     KEEP_GOING
0000B4A2                          3524  
0000B4A2  0C39 0000 0000AAF7      3525  ITS_Y       CMPI.B  #0, FIRST_Y
0000B4AA  6700 0024               3526              BEQ     FST_Y1
0000B4AE  1639 0000AAF3           3527  ITS_Y_BACK  MOVE.B  Y, D3 * LOAD[YY_COUNTER]
0000B4B4  1439 0000AAF5           3528              MOVE.B  Y_COUNTER, D2
0000B4BA  4EB9 0000B85C           3529              JSR     LOAD_EA
0000B4C0  0C39 0000 0000AAF7      3530              CMPI.B  #0, FIRST_Y
0000B4C8  6700 0024               3531              BEQ     FST_Y2
0000B4CC  6600 0032               3532              BNE     SND_Y
0000B4D0                          3533  
0000B4D0  0C39 0001 0000AAF6      3534  FST_Y1      CMPI.B  #1, FIRST_X
0000B4D8  6600 000E               3535              BNE     SKIP_HERE
0000B4DC                          3536              ;ADDA.W #2, A4 * push G_BUFFER_1 pointer by 2
0000B4DC                          3537                          
0000B4DC  18FC 0020               3538              MOVE.B  #$20, (A4)+
0000B4E0  18FC 0020               3539              MOVE.B  #$20, (A4)+
0000B4E4                          3540  
0000B4E4  18FC 002F               3541              MOVE.B  #$2F, (A4)+ * LOAD '/'
0000B4E8  4EF9 0000B4AE           3542  SKIP_HERE   JMP     ITS_Y_BACK
0000B4EE                          3543  
0000B4EE  18FC 002D               3544  FST_Y2      MOVE.B  #$2D, (A4)+ * LOAD '-'
0000B4F2  13FC 0001 0000AAF7      3545              MOVE.B  #1, FIRST_Y * FIRST_Y = 1
0000B4FA  4EF9 0000B508           3546              JMP     KEEP_GOING
0000B500                          3547  
0000B500  554C                    3548  SND_Y       SUBA.W  #2, A4 * push back G_BUFFER_1 pointer by 2
0000B502  4EF9 0000B508           3549              JMP     KEEP_GOING
0000B508                          3550  
0000B508  0C39 0008 0000AAF5      3551  KEEP_GOING  CMPI.B  #8, Y_COUNTER
0000B510  6600 FEF0               3552              BNE     GO_D_TO_A
0000B514                          3553              
0000B514  544C                    3554              ADDA.W  #2, A4 * push G_BUFFER_1 pointer by 2
0000B516  4E75                    3555              RTS
0000B518                          3556  ***111111111 MOVEM D->A 111111111***
0000B518                          3557  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000B518                          3558  
0000B518                          3559  
0000B518                          3560  ***vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv***
0000B518                          3561  ***111111111 MOVEM A->D 111111111***
0000B518  E35C                    3562  GO_A_TO_D   ROL.W   #1, D4
0000B51A  3A04                    3563              MOVE.W  D4, D5
0000B51C  0245 0001               3564              ANDI.W  #$1, D5
0000B520                          3565              
0000B520  0C39 0000 0000AAF4      3566              CMPI.B  #0, X_COUNTER
0000B528  6E00 0006               3567              BGT     SUBTRACT_X  
0000B52C  6F00 000E               3568              BLE     SUBTRACT_Y  
0000B530                          3569              
0000B530  5339 0000AAF4           3570  SUBTRACT_X  SUBI.B  #1, X_COUNTER
0000B536  4EF9 0000B550           3571              JMP     KEEP_GOING1
0000B53C                          3572  
0000B53C  5339 0000AAF5           3573  SUBTRACT_Y  SUBI.B  #1, Y_COUNTER
0000B542  13FC 00FF 0000AAF4      3574              MOVE.B  #$FF, X_COUNTER
0000B54A  4EF9 0000B550           3575              JMP     KEEP_GOING1
0000B550                          3576              
0000B550  0C45 0001               3577  KEEP_GOING1 CMPI.W  #$1, D5
0000B554  6700 0006               3578              BEQ     BIT_ON2
0000B558  6600 00C4               3579              BNE     KEEP_GOING2
0000B55C                          3580              
0000B55C  0C39 00FF 0000AAF4      3581  BIT_ON2     CMPI.B  #$FF, X_COUNTER
0000B564  6600 0006               3582              BNE     ITS_X2
0000B568  6700 003E               3583              BEQ     MYBE_Y2
0000B56C                          3584              
0000B56C  1639 0000AAF2           3585  ITS_X2      MOVE.B  X, D3 * LOAD[XX_COUNTER]
0000B572  1439 0000AAF4           3586              MOVE.B  X_COUNTER, D2
0000B578  4EB9 0000B85C           3587              JSR     LOAD_EA
0000B57E  0C39 0000 0000AAF6      3588              CMPI.B  #0, FIRST_X
0000B586  6700 0006               3589              BEQ     FST_X2
0000B58A  6600 0014               3590              BNE     SND_X2
0000B58E                          3591  
0000B58E  18FC 002D               3592  FST_X2      MOVE.B  #$2D, (A4)+ * LOAD '-'
0000B592  13FC 0001 0000AAF6      3593              MOVE.B  #1, FIRST_X * FIRST_X = 1
0000B59A  4EF9 0000B61E           3594              JMP     KEEP_GOING2
0000B5A0                          3595              
0000B5A0  554C                    3596  SND_X2      SUBA.W  #2, A4 * push back G_BUFFER_1 pointer by 2
0000B5A2  4EF9 0000B61E           3597              JMP     KEEP_GOING2
0000B5A8                          3598  
0000B5A8  0C39 00FF 0000AAF5      3599  MYBE_Y2     CMPI.B  #$FF, Y_COUNTER
0000B5B0  6600 0006               3600              BNE     ITS_Y2
0000B5B4  6700 0068               3601              BEQ     KEEP_GOING2
0000B5B8                          3602  
0000B5B8  0C39 0000 0000AAF7      3603  ITS_Y2      CMPI.B  #0, FIRST_Y
0000B5C0  6700 0024               3604              BEQ     FST_Y3
0000B5C4  1639 0000AAF3           3605  ITS_Y2_BACK MOVE.B  Y, D3 * LOAD[YY_COUNTER]
0000B5CA  1439 0000AAF5           3606              MOVE.B  Y_COUNTER, D2
0000B5D0  4EB9 0000B85C           3607              JSR     LOAD_EA
0000B5D6  0C39 0000 0000AAF7      3608              CMPI.B  #0, FIRST_Y
0000B5DE  6700 0024               3609              BEQ     FST_Y4
0000B5E2  6600 0032               3610              BNE     SND_Y2
0000B5E6                          3611  
0000B5E6  0C39 0001 0000AAF6      3612  FST_Y3      CMPI.B  #1, FIRST_X
0000B5EE  6600 000E               3613              BNE     SKIP_HERE2
0000B5F2                          3614              ;ADDA.W #2, A4 * push G_BUFFER_1 pointer by 2
0000B5F2                          3615              
0000B5F2  18FC 0020               3616              MOVE.B  #$20, (A4)+
0000B5F6  18FC 0020               3617              MOVE.B  #$20, (A4)+
0000B5FA                          3618              
0000B5FA  18FC 002F               3619              MOVE.B  #$2F, (A4)+ * LOAD '/'
0000B5FE  4EF9 0000B5C4           3620  SKIP_HERE2  JMP     ITS_Y2_BACK
0000B604                          3621  
0000B604  18FC 002D               3622  FST_Y4      MOVE.B  #$2D, (A4)+ * LOAD '-'
0000B608  13FC 0001 0000AAF7      3623              MOVE.B  #1, FIRST_Y * FIRST_Y = 1
0000B610  4EF9 0000B61E           3624              JMP     KEEP_GOING2
0000B616                          3625  
0000B616  554C                    3626  SND_Y2      SUBA.W  #2, A4 * push back G_BUFFER_1 pointer by 2
0000B618  4EF9 0000B61E           3627              JMP     KEEP_GOING2
0000B61E                          3628  
0000B61E  0C39 00FF 0000AAF5      3629  KEEP_GOING2 CMPI.B  #$FF, Y_COUNTER
0000B626  6600 FEF0               3630              BNE     GO_A_TO_D   
0000B62A                          3631              
0000B62A  544C                    3632              ADDA.W  #2, A4 * push G_BUFFER_1 pointer by 2
0000B62C  4E75                    3633              RTS
0000B62E                          3634  ***111111111 MOVEM A->D 111111111***
0000B62E                          3635  ***^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***
0000B62E                          3636  
0000B62E                          3637  
0000B62E                          3638  
0000B62E                          3639  * <EA>
0000B62E                          3640  **********************************************************************************
0000B62E                          3641  * Description: Once the mnemonic is 0000, it is either BCLR, CMPI, ORI, or Dynamic BCLR.
0000B62E                          3642  *
0000B62E                          3643  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch,
0000B62E                          3644  *                 D5, D4 for BCLR
0000B62E                          3645  *
0000B62E                          3646  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000B62E                          3647  *
0000B62E                          3648  * Postcondition: X
0000B62E                          3649  **********************************************************************************
0000B62E                          3650  LOAD_0000:
0000B62E  4283                    3651              CLR.L   D3
0000B630  4282                    3652              CLR.L   D2
0000B632  267C 00000000           3653              MOVEA.L #0, A3
0000B638                          3654  
0000B638  0C39 0000 0000975C      3655              CMPI.B  #%000, FIRST_3
0000B640  6700 0006               3656              BEQ     MYBE_ORI
0000B644  6600 000E               3657              BNE     NOT_ORI
0000B648  0C39 0003 0000975D      3658  MYBE_ORI    CMPI.B  #%011, SECOND_3
0000B650  6D00 004C               3659              BLT     ORI_CMPI            
0000B654                          3660  
0000B654  0C39 0006 0000975C      3661  NOT_ORI     CMPI.B  #%110, FIRST_3
0000B65C  6700 0006               3662              BEQ     MYBE_CMPI
0000B660  6600 000E               3663              BNE     NOT_CMPI
0000B664  0C39 0003 0000975D      3664  MYBE_CMPI   CMPI.B  #%011, SECOND_3
0000B66C  6D00 0030               3665              BLT     ORI_CMPI
0000B670                          3666              
0000B670  0C39 0004 0000975C      3667  NOT_CMPI    CMPI.B  #%100, FIRST_3
0000B678  6700 0006               3668              BEQ     MYBE_BCLR
0000B67C  6600 000E               3669              BNE     NOT_BCLR
0000B680  0C39 0002 0000975D      3670  MYBE_BCLR   CMPI.B  #%010, SECOND_3
0000B688  6700 0092               3671              BEQ     BCLR
0000B68C                          3672  
0000B68C  0C39 0006 0000975D      3673  NOT_BCLR    CMPI.B  #%110, SECOND_3
0000B694  6700 00FA               3674              BEQ     DYNMC_BCLR
0000B698                          3675              
0000B698  4EF9 0000BA9C           3676              JMP     INVALID
0000B69E                          3677              
0000B69E                          3678  ***vvvvvvvvvvvvvvvvvvv***
0000B69E  367C B6C6               3679  ORI_CMPI    MOVEA.W #BACK, A3
0000B6A2  0C39 0000 0000975D      3680              CMPI.B  #%000, SECOND_3
0000B6AA  6700 025C               3681              BEQ     SIZE_1_B
0000B6AE  0C39 0001 0000975D      3682              CMPI.B  #%001, SECOND_3
0000B6B6  6700 025A               3683              BEQ     SIZE_1_W
0000B6BA  0C39 0002 0000975D      3684              CMPI.B  #%010, SECOND_3
0000B6C2  6700 0258               3685              BEQ     SIZE_1_L
0000B6C6                          3686  
0000B6C6  163C 0007               3687  BACK        MOVE.B  #%111, D3
0000B6CA  143C 0004               3688              MOVE.B  #%100, D2
0000B6CE                          3689              
0000B6CE  4EB9 0000B85C           3690              JSR     LOAD_EA
0000B6D4  4EB9 0000B9D8           3691              JSR     LOAD_COMMA_SPACE
0000B6DA                          3692              
0000B6DA  367C B702               3693              MOVEA.W #BACK2, A3   
0000B6DE  0C39 0000 0000975F      3694              CMPI.B  #%000, FOURTH_3
0000B6E6  6700 022A               3695              BEQ     SIZE_1_W
0000B6EA  0C39 0001 0000975F      3696              CMPI.B  #%001, FOURTH_3
0000B6F2  6700 0228               3697              BEQ     SIZE_1_L
0000B6F6  0C39 0004 0000975F      3698              CMPI.B  #%100, FOURTH_3 
0000B6FE  6700 039C               3699              BEQ     INVALID 
0000B702                          3700  
0000B702  1639 0000975E           3701  BACK2       MOVE.B  THIRD_3, D3
0000B708  1439 0000975F           3702              MOVE.B  FOURTH_3, D2
0000B70E                          3703          
0000B70E  4EB9 0000B85C           3704              JSR     LOAD_EA
0000B714  4EB9 0000B9D6           3705              JSR     LOAD_NEW_LINE
0000B71A  4E75                    3706              RTS
0000B71C                          3707  ***^^^^^^^^^^^^^^^^^^^***
0000B71C                          3708  
0000B71C                          3709  ***vvvvvvvvvvvvvvvvvvv***
0000B71C  4285                    3710  BCLR        CLR.L   D5
0000B71E  4284                    3711              CLR.L   D4
0000B720  247C 00000000           3712              MOVEA.L #0, A2
0000B726                          3713  
0000B726  3A0E                    3714              MOVE.W  A6, D5
0000B728  9A4D                    3715              SUB.W   A5, D5
0000B72A  0C45 0002               3716              CMPI.W  #$2, D5
0000B72E  6D00 036C               3717              BLT     INVALID
0000B732                          3718  
0000B732  381D                    3719              MOVE.W  (A5)+, D4
0000B734  4284                    3720              CLR.L   D4
0000B736  381D                    3721              MOVE.W  (A5)+, D4
0000B738  0244 00FF               3722              ANDI.W  #$00FF, D4
0000B73C  247C 0000B748           3723              MOVEA.L #BACK4, A2
0000B742  4EF9 0000B99E           3724              JMP     LOAD_IMMDTE
0000B748                          3725              
0000B748  4EB9 0000B9D8           3726  BACK4       JSR     LOAD_COMMA_SPACE
0000B74E                          3727              
0000B74E  367C B776               3728              MOVEA.W #BACK3, A3
0000B752  0C39 0000 0000975F      3729              CMPI.B  #%000, FOURTH_3
0000B75A  6700 01B6               3730              BEQ     SIZE_1_W
0000B75E  0C39 0001 0000975F      3731              CMPI.B  #%001, FOURTH_3
0000B766  6700 01B4               3732              BEQ     SIZE_1_L
0000B76A  0C39 0004 0000975F      3733              CMPI.B  #%100, FOURTH_3 
0000B772  6700 0328               3734              BEQ     INVALID 
0000B776                          3735  
0000B776  1639 0000975E           3736  BACK3       MOVE.B  THIRD_3, D3
0000B77C  1439 0000975F           3737              MOVE.B  FOURTH_3, D2
0000B782                          3738  
0000B782  4EB9 0000B85C           3739              JSR     LOAD_EA
0000B788  4EB9 0000B9D6           3740              JSR     LOAD_NEW_LINE
0000B78E                          3741  
0000B78E  4E75                    3742              RTS
0000B790                          3743  ***^^^^^^^^^^^^^^^^^^^***
0000B790                          3744  
0000B790                          3745  ***vvvvvvvvvvvvvvvvvvv***
0000B790  163C 0000               3746  DYNMC_BCLR  MOVE.B  #%000, D3
0000B794  1439 0000975C           3747              MOVE.B  FIRST_3, D2
0000B79A                          3748              
0000B79A  4EB9 0000B85C           3749              JSR     LOAD_EA
0000B7A0  4EB9 0000B9D8           3750              JSR     LOAD_COMMA_SPACE
0000B7A6                          3751  
0000B7A6  367C B7CE               3752              MOVEA.W #BACK5, A3
0000B7AA  0C39 0000 0000975F      3753              CMPI.B  #%000, FOURTH_3
0000B7B2  6700 015E               3754              BEQ     SIZE_1_W
0000B7B6  0C39 0001 0000975F      3755              CMPI.B  #%001, FOURTH_3
0000B7BE  6700 015C               3756              BEQ     SIZE_1_L
0000B7C2  0C39 0004 0000975F      3757              CMPI.B  #%100, FOURTH_3 
0000B7CA  6700 02D0               3758              BEQ     INVALID 
0000B7CE                          3759              
0000B7CE  1639 0000975E           3760  BACK5       MOVE.B  THIRD_3, D3
0000B7D4  1439 0000975F           3761              MOVE.B  FOURTH_3, D2
0000B7DA                          3762              
0000B7DA  4EB9 0000B85C           3763              JSR     LOAD_EA
0000B7E0  4EB9 0000B9D6           3764              JSR     LOAD_NEW_LINE
0000B7E6                          3765              
0000B7E6  4E75                    3766              RTS
0000B7E8                          3767  ***^^^^^^^^^^^^^^^^^^^***
0000B7E8                          3768  
0000B7E8                          3769  * <EA>
0000B7E8                          3770  **********************************************************************************
0000B7E8                          3771  * Description: Once the mnemonic is 00XX, it is either MOVE or MOVEA. Checks the 3-bit bundles and
0000B7E8                          3772  *              the size of immediate/address values if necessary.
0000B7E8                          3773  *
0000B7E8                          3774  * Registers used: D3 for SRC/DST mod, D2 for SRC/DST reg, A3 to get back from the subbranch
0000B7E8                          3775  *
0000B7E8                          3776  * Precondition: FIRST_3, SECOND_3, THIRD_3, FOURTH_3
0000B7E8                          3777  *
0000B7E8                          3778  * Postcondition: X
0000B7E8                          3779  **********************************************************************************
0000B7E8                          3780  LOAD_00XX:
0000B7E8  4283                    3781          CLR.L   D3
0000B7EA  4282                    3782          CLR.L   D2
0000B7EC  267C 00000000           3783          MOVEA.L #0, A3
0000B7F2                          3784          
0000B7F2  367C B80E               3785          MOVEA.W #GOO, A3
0000B7F6  0C39 0003 0000975B      3786          CMPI.B  #%0011, MNEMONIC
0000B7FE  6700 0112               3787          BEQ     SIZE_1_W
0000B802  0C39 0002 0000975B      3788          CMPI.B  #%0010, MNEMONIC
0000B80A  6700 0110               3789          BEQ     SIZE_1_L
0000B80E                          3790  
0000B80E  1639 0000975E           3791  GOO     MOVE.B  THIRD_3, D3
0000B814  1439 0000975F           3792          MOVE.B  FOURTH_3, D2
0000B81A                          3793      
0000B81A  4EB9 0000B85C           3794          JSR     LOAD_EA
0000B820  4EB9 0000B9D8           3795          JSR     LOAD_COMMA_SPACE
0000B826                          3796      
0000B826  367C B842               3797          MOVEA.W #GOO2, A3
0000B82A  0C39 0000 0000975C      3798          CMPI.B  #%000, FIRST_3
0000B832  6700 00DE               3799          BEQ     SIZE_1_W
0000B836  0C39 0001 0000975C      3800          CMPI.B  #%001, FIRST_3
0000B83E  6700 00DC               3801          BEQ     SIZE_1_L
0000B842                          3802      
0000B842  1639 0000975D           3803  GOO2    MOVE.B  SECOND_3, D3
0000B848  1439 0000975C           3804          MOVE.B  FIRST_3, D2
0000B84E                          3805              
0000B84E  4EB9 0000B85C           3806          JSR     LOAD_EA
0000B854  4EB9 0000B9D6           3807          JSR     LOAD_NEW_LINE
0000B85A                          3808      
0000B85A  4E75                    3809          RTS
0000B85C                          3810  **************************************************
0000B85C                          3811  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B85C                          3812  
0000B85C                          3813  
0000B85C                          3814  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B85C                          3815  * LOAD_THIS FUNCTIONS (HIGH LEVEL) ***************
0000B85C                          3816  
0000B85C                          3817  * <EA>
0000B85C                          3818  **********************************************************************************
0000B85C                          3819  * Description: Checks the SRC/DST mod
0000B85C                          3820  *
0000B85C                          3821  * Registers used: A2 for branching back from subbranches
0000B85C                          3822  *
0000B85C                          3823  * Precondition: D3 for SRC/DST mod
0000B85C                          3824  *
0000B85C                          3825  * Postcondition: X
0000B85C                          3826  **********************************************************************************
0000B85C                          3827  LOAD_EA:
0000B85C  347C B86C               3828          MOVEA.W #SAVED, A2 * remember to come back!
0000B860                          3829  
0000B860  0C43 0007               3830          CMPI    #%111, D3
0000B864  6D00 0008               3831          BLT     LOAD_LT_111
0000B868  6C00 0032               3832          BGE     LOAD_GE_111
0000B86C                          3833      
0000B86C  4E75                    3834  SAVED   RTS
0000B86E                          3835  
0000B86E                          3836  * <EA>
0000B86E                          3837  **********************************************************************************
0000B86E                          3838  * Description: Checks the SRC/DST mod where it is not immediate/address value
0000B86E                          3839  *
0000B86E                          3840  * Registers used: X
0000B86E                          3841  *
0000B86E                          3842  * Precondition: D3 for SRC/DST mod
0000B86E                          3843  *
0000B86E                          3844  * Postcondition: X
0000B86E                          3845  **********************************************************************************
0000B86E                          3846  LOAD_LT_111:
0000B86E  0C43 0000               3847      CMPI    #%000, D3 * e.g. D3
0000B872  6700 00B2               3848      BEQ     LOAD_DATA_REGISTER
0000B876  0C43 0001               3849      CMPI    #%001, D3 * e.g. A3
0000B87A  6700 00BC               3850      BEQ     LOAD_ADDR_REGISTER
0000B87E  0C43 0002               3851      CMPI    #%010, D3 * e.g. (A3)
0000B882  6700 00C6               3852      BEQ     LOAD_ADDRESS
0000B886  0C43 0003               3853      CMPI    #%011, D3 * e.g. (A3)+
0000B88A  6700 00D2               3854      BEQ     LOAD_ADDRESS_W_POST_INC
0000B88E  0C43 0004               3855      CMPI    #%100, D3 * e.g. -(A3)
0000B892  6700 00D8               3856      BEQ     LOAD_ADDRESS_W_PRE_DEC
0000B896                          3857      
0000B896  4EF9 0000BA9C           3858      JMP     INVALID
0000B89C                          3859      
0000B89C                          3860  * <EA>
0000B89C                          3861  **********************************************************************************
0000B89C                          3862  * Description: Checks the SRC/DST mod where it is immediate/address value
0000B89C                          3863  *
0000B89C                          3864  * Registers used: D5 for SUB.W, D4 for immediate/address value extraction
0000B89C                          3865  *
0000B89C                          3866  * Precondition: A5 for START_ADDRESS iteration, TRAILING_SIZE_1 for size of the immediate/address value
0000B89C                          3867  *
0000B89C                          3868  * Postcondition: IS_INVALID flag set if EA bit not valid
0000B89C                          3869  **********************************************************************************
0000B89C                          3870  LOAD_GE_111:
0000B89C  4285                    3871              CLR.L   D5
0000B89E  4284                    3872              CLR.L   D4
0000B8A0                          3873  
0000B8A0  3A0E                    3874              MOVE.W  A6, D5
0000B8A2  9A4D                    3875              SUB.W   A5, D5
0000B8A4  BA79 0000AAF0           3876              CMP.W   TRAILING_SIZE_1, D5
0000B8AA  6D00 01F0               3877              BLT     INVALID
0000B8AE                          3878  
0000B8AE  0C79 0001 0000AAF0      3879              CMPI.W  #$1, TRAILING_SIZE_1
0000B8B6  6700 001A               3880              BEQ     CHUMP_BYTE
0000B8BA  0C79 0002 0000AAF0      3881              CMPI.W  #$2, TRAILING_SIZE_1
0000B8C2  6700 0016               3882              BEQ     CHUMP_WORD
0000B8C6  0C79 0004 0000AAF0      3883              CMPI.W  #$4, TRAILING_SIZE_1
0000B8CE  6700 0012               3884              BEQ     CHUMP_LONG
0000B8D2                          3885  
0000B8D2  381D                    3886  CHUMP_BYTE  MOVE.W  (A5)+, D4 * Minimum 4 hex (e.g. MOVE.B #1, $2 = XXXX 0001 0002)
0000B8D4  4EF9 0000B8EA           3887              JMP     GO
0000B8DA                          3888  
0000B8DA  381D                    3889  CHUMP_WORD  MOVE.W  (A5)+, D4
0000B8DC  4EF9 0000B8EA           3890              JMP     GO
0000B8E2                          3891              
0000B8E2  281D                    3892  CHUMP_LONG  MOVE.L  (A5)+, D4
0000B8E4  4EF9 0000B8EA           3893              JMP     GO
0000B8EA                          3894  
0000B8EA  0C42 0000               3895  GO          CMPI    #%000, D2
0000B8EE  6700 008A               3896              BEQ     LOAD_ABS_SHORT
0000B8F2  0C42 0001               3897              CMPI    #%001, D2
0000B8F6  6700 0094               3898              BEQ     LOAD_ABS_LONG
0000B8FA  0C42 0004               3899              CMPI    #%100, D2
0000B8FE  6700 009E               3900              BEQ     LOAD_IMMDTE
0000B902                          3901      
0000B902  4EF9 0000BA9C           3902              JMP     INVALID
0000B908                          3903  * <EA>
0000B908                          3904  **********************************************************************************
0000B908                          3905  * Description: Puts in the proper value in TRAILING_SIZE_1 based on the immediate/address value size
0000B908                          3906  *
0000B908                          3907  * Registers used: X
0000B908                          3908  *
0000B908                          3909  * Precondition: X
0000B908                          3910  *
0000B908                          3911  * Postcondition: Set up TRAILING_SIZE_1
0000B908                          3912  **********************************************************************************
0000B908                          3913  TRAILING_HELPER:            
0000B908  33FC 0002 0000AAF0      3914  SIZE_1_B  MOVE.W  #$2, TRAILING_SIZE_1
0000B910  4ED3                    3915          JMP     (A3)
0000B912                          3916  
0000B912  33FC 0002 0000AAF0      3917  SIZE_1_W  MOVE.W  #$2, TRAILING_SIZE_1
0000B91A  4ED3                    3918          JMP     (A3)
0000B91C                          3919          
0000B91C  33FC 0004 0000AAF0      3920  SIZE_1_L  MOVE.W  #$4, TRAILING_SIZE_1
0000B924  4ED3                    3921          JMP     (A3)
0000B926                          3922  **************************************************
0000B926                          3923  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B926                          3924  
0000B926                          3925  
0000B926                          3926  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B926                          3927  * LOAD_THIS FUNCTIONS (INTERMEDIATE LEVEL) *******
0000B926                          3928  
0000B926                          3929  * <EA>
0000B926                          3930  **********************************************************************************
0000B926                          3931  * Description: Loads ASCII for e.g. D3 in G_BUFFER_1
0000B926                          3932  *
0000B926                          3933  * Registers used: D0 for actually loading
0000B926                          3934  *
0000B926                          3935  * Precondition: D2 for SRC/DST reg
0000B926                          3936  *
0000B926                          3937  * Postcondition: X
0000B926                          3938  **********************************************************************************
0000B926                          3939  LOAD_DATA_REGISTER:
0000B926  4280                    3940      CLR.L   D0
0000B928                          3941      
0000B928  4EB9 0000B9F4           3942      JSR     LOAD_D
0000B92E  1002                    3943      MOVE.B  D2, D0
0000B930  4EB9 0000BA78           3944      JSR     LOAD_NUM
0000B936  4ED2                    3945      JMP     (A2)
0000B938                          3946  
0000B938                          3947  * <EA>
0000B938                          3948  **********************************************************************************
0000B938                          3949  * Description: Loads ASCII for e.g. A3 in G_BUFFER_1
0000B938                          3950  *
0000B938                          3951  * Registers used: D0 for actually loading
0000B938                          3952  *
0000B938                          3953  * Precondition: D2 for SRC/DST reg
0000B938                          3954  *
0000B938                          3955  * Postcondition: X
0000B938                          3956  **********************************************************************************
0000B938                          3957  LOAD_ADDR_REGISTER:
0000B938  4280                    3958      CLR.L   D0
0000B93A                          3959  
0000B93A  4EB9 0000BA04           3960      JSR     LOAD_A
0000B940  1002                    3961      MOVE.B  D2, D0
0000B942  4EB9 0000BA78           3962      JSR     LOAD_NUM
0000B948  4ED2                    3963      JMP     (A2)
0000B94A                          3964  
0000B94A                          3965  * <EA>
0000B94A                          3966  **********************************************************************************
0000B94A                          3967  * Description: Loads ASCII for e.g. (A3) in G_BUFFER_1
0000B94A                          3968  *
0000B94A                          3969  * Registers used: X
0000B94A                          3970  *
0000B94A                          3971  * Precondition: X
0000B94A                          3972  *
0000B94A                          3973  * Postcondition: X
0000B94A                          3974  **********************************************************************************
0000B94A                          3975  LOAD_ADDRESS:
0000B94A  4EB9 0000BA14           3976      JSR     LOAD_PTHSIS_OPEN
0000B950  4EB9 0000B938           3977      JSR     LOAD_ADDR_REGISTER
0000B956  4EB9 0000BA24           3978      JSR     LOAD_PTHSIS_CLSD
0000B95C  4ED2                    3979      JMP     (A2)
0000B95E                          3980  
0000B95E                          3981  * <EA>
0000B95E                          3982  **********************************************************************************
0000B95E                          3983  * Description: Loads ASCII for e.g. (A3)+ in G_BUFFER_1
0000B95E                          3984  *
0000B95E                          3985  * Registers used: X
0000B95E                          3986  *
0000B95E                          3987  * Precondition: X
0000B95E                          3988  *
0000B95E                          3989  * Postcondition: X
0000B95E                          3990  **********************************************************************************
0000B95E                          3991  LOAD_ADDRESS_W_POST_INC:
0000B95E  4EB9 0000B94A           3992      JSR     LOAD_ADDRESS
0000B964  4EB9 0000BA54           3993      JSR     LOAD_PLUS_SIGN
0000B96A  4ED2                    3994      JMP     (A2)
0000B96C                          3995  
0000B96C                          3996  * <EA>
0000B96C                          3997  **********************************************************************************
0000B96C                          3998  * Description: Loads ASCII for e.g. -(A3) in G_BUFFER_1
0000B96C                          3999  *
0000B96C                          4000  * Registers used: X
0000B96C                          4001  *
0000B96C                          4002  * Precondition: X
0000B96C                          4003  *
0000B96C                          4004  * Postcondition: X
0000B96C                          4005  **********************************************************************************
0000B96C                          4006  LOAD_ADDRESS_W_PRE_DEC:
0000B96C  4EB9 0000BA64           4007      JSR     LOAD_MINUS_SIGN
0000B972  4EB9 0000B94A           4008      JSR     LOAD_ADDRESS
0000B978  4ED2                    4009      JMP     (A2)
0000B97A                          4010  
0000B97A                          4011  * <EA>
0000B97A                          4012  **********************************************************************************
0000B97A                          4013  * Description: Loads ASCII for e.g. $1234 in G_BUFFER_1
0000B97A                          4014  *
0000B97A                          4015  * Registers used: D0 for actually loading
0000B97A                          4016  *
0000B97A                          4017  * Precondition: D4 for immediate/address value  
0000B97A                          4018  *
0000B97A                          4019  * Postcondition: X
0000B97A                          4020  **********************************************************************************
0000B97A                          4021  LOAD_ABS_SHORT:
0000B97A  4280                    4022      CLR.L   D0
0000B97C                          4023  
0000B97C  4EB9 0000BA34           4024      JSR     LOAD_HEX_SIGN
0000B982  3004                    4025      MOVE.W  D4, D0
0000B984  4EB9 0000B9AA           4026      JSR     LOAD_BYTES
0000B98A  4ED2                    4027      JMP     (A2)
0000B98C                          4028  
0000B98C                          4029  * <EA>
0000B98C                          4030  **********************************************************************************
0000B98C                          4031  * Description: Loads ASCII for e.g. $12345678 in G_BUFFER_1
0000B98C                          4032  *
0000B98C                          4033  * Registers used: D0 for actually loading
0000B98C                          4034  *
0000B98C                          4035  * Precondition: D4 for immediate/address value  
0000B98C                          4036  *
0000B98C                          4037  * Postcondition: X
0000B98C                          4038  **********************************************************************************
0000B98C                          4039  LOAD_ABS_LONG:
0000B98C  4280                    4040      CLR.L   D0
0000B98E                          4041  
0000B98E  4EB9 0000BA34           4042      JSR     LOAD_HEX_SIGN
0000B994  2004                    4043      MOVE.L  D4, D0
0000B996  4EB9 0000B9AA           4044      JSR     LOAD_BYTES
0000B99C  4ED2                    4045      JMP     (A2)
0000B99E                          4046  
0000B99E                          4047  * <EA>
0000B99E                          4048  **********************************************************************************
0000B99E                          4049  * Description: Loads ASCII for e.g. #$1234 in G_BUFFER_1
0000B99E                          4050  *
0000B99E                          4051  * Registers used: X
0000B99E                          4052  *
0000B99E                          4053  * Precondition: X 
0000B99E                          4054  *
0000B99E                          4055  * Postcondition: X
0000B99E                          4056  **********************************************************************************
0000B99E                          4057  LOAD_IMMDTE:
0000B99E  4EB9 0000BA44           4058      JSR     LOAD_IMMDTE_VALU
0000B9A4  4EF9 0000B98C           4059      JMP     LOAD_ABS_LONG
0000B9AA                          4060  
0000B9AA                          4061  **************************************************
0000B9AA                          4062  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B9AA                          4063  
0000B9AA                          4064  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B9AA                          4065  * LOAD_THIS FUNCTIONS (LOW LEVEL) ****************
0000B9AA                          4066  
0000B9AA                          4067  * <EA>
0000B9AA                          4068  **********************************************************************************
0000B9AA                          4069  * Description: Shifts the hex to the left and loads from the left-most hex to G_BUFFER_1 in ASCII
0000B9AA                          4070  *
0000B9AA                          4071  * Registers used: D5 for the loop counter, D1 for loop assist
0000B9AA                          4072  *
0000B9AA                          4073  * Precondition: D0 for the immediate/address value  
0000B9AA                          4074  *
0000B9AA                          4075  * Postcondition: X
0000B9AA                          4076  **********************************************************************************
0000B9AA                          4077  LOAD_BYTES:
0000B9AA  4285                    4078          CLR.L   D5
0000B9AC  4281                    4079          CLR.L   D1
0000B9AE                          4080  
0000B9AE  2200                    4081          MOVE.L  D0, D1
0000B9B0  1A3C 0008               4082          MOVE.B  #8, D5
0000B9B4  0C45 0000               4083  LOOP    CMPI    #0, D5
0000B9B8  6E00 0004               4084          BGT     ROTATE
0000B9BC  4E75                    4085          RTS
0000B9BE                          4086      
0000B9BE  E999                    4087  ROTATE  ROL.L   #$04, D1
0000B9C0  1001                    4088          MOVE.B  D1, D0
0000B9C2  0280 0000000F           4089          ANDI.L  #$0000000F, D0
0000B9C8  4EB9 0000BA78           4090          JSR     LOAD_NUM
0000B9CE  5345                    4091          SUBI    #1, D5
0000B9D0  4EF9 0000B9B4           4092          JMP     LOOP        
0000B9D6                          4093  
0000B9D6                          4094  * <EA>
0000B9D6                          4095  **********************************************************************************
0000B9D6                          4096  * Description: Loads ASCII for CR, LF 
0000B9D6                          4097  *
0000B9D6                          4098  * Registers used: D0 for actually loading
0000B9D6                          4099  *
0000B9D6                          4100  * Precondition: CR, LF 
0000B9D6                          4101  *
0000B9D6                          4102  * Postcondition: X
0000B9D6                          4103  **********************************************************************************
0000B9D6                          4104  LOAD_NEW_LINE:
0000B9D6                          4105      ;CLR.L   D0
0000B9D6                          4106  
0000B9D6                          4107      ;MOVE.B  CR, D0
0000B9D6                          4108      ;JSR     LOAD_THIS_SHIT
0000B9D6                          4109      ;MOVE.B  LF, D0
0000B9D6                          4110      ;JSR     LOAD_THIS_SHIT
0000B9D6  4E75                    4111      RTS
0000B9D8                          4112  
0000B9D8                          4113  * <EA>
0000B9D8                          4114  **********************************************************************************
0000B9D8                          4115  * Description: Loads ASCII for ', ' 
0000B9D8                          4116  *
0000B9D8                          4117  * Registers used: D0 for actually loading
0000B9D8                          4118  *
0000B9D8                          4119  * Precondition: COMMA, SPACE
0000B9D8                          4120  *
0000B9D8                          4121  * Postcondition: X
0000B9D8                          4122  **********************************************************************************
0000B9D8                          4123  LOAD_COMMA_SPACE:
0000B9D8  4280                    4124      CLR.L   D0
0000B9DA                          4125  
0000B9DA  1039 0000AAEE           4126      MOVE.B  COMMA, D0
0000B9E0  4EB9 0000BA74           4127      JSR     LOAD_THIS_SHIT
0000B9E6  1039 0000AAEF           4128      MOVE.B  SPACE, D0
0000B9EC  4EB9 0000BA74           4129      JSR     LOAD_THIS_SHIT
0000B9F2                          4130      
0000B9F2  4E75                    4131      RTS
0000B9F4                          4132  
0000B9F4                          4133  * <EA>
0000B9F4                          4134  **********************************************************************************
0000B9F4                          4135  * Description: Loads ASCII for D 
0000B9F4                          4136  *
0000B9F4                          4137  * Registers used: D0 for actually loading
0000B9F4                          4138  *
0000B9F4                          4139  * Precondition: DATA
0000B9F4                          4140  *
0000B9F4                          4141  * Postcondition: X
0000B9F4                          4142  **********************************************************************************
0000B9F4                          4143  LOAD_D:
0000B9F4  4280                    4144      CLR.L   D0
0000B9F6                          4145  
0000B9F6  1039 0000AAE7           4146      MOVE.B  DATA, D0
0000B9FC  4EB9 0000BA74           4147      JSR     LOAD_THIS_SHIT
0000BA02  4E75                    4148      RTS
0000BA04                          4149  
0000BA04                          4150  * <EA>
0000BA04                          4151  **********************************************************************************
0000BA04                          4152  * Description: Loads ASCII for A
0000BA04                          4153  *
0000BA04                          4154  * Registers used: D0 for actually loading
0000BA04                          4155  *
0000BA04                          4156  * Precondition: ADDRESS
0000BA04                          4157  *
0000BA04                          4158  * Postcondition: X
0000BA04                          4159  **********************************************************************************
0000BA04                          4160  LOAD_A:
0000BA04  4280                    4161      CLR.L   D0
0000BA06                          4162  
0000BA06  1039 0000AAE6           4163      MOVE.B  ADDRESS, D0
0000BA0C  4EB9 0000BA74           4164      JSR     LOAD_THIS_SHIT
0000BA12  4E75                    4165      RTS
0000BA14                          4166  
0000BA14                          4167  * <EA>
0000BA14                          4168  **********************************************************************************
0000BA14                          4169  * Description: Loads ASCII for (
0000BA14                          4170  *
0000BA14                          4171  * Registers used: D0 for actually loading
0000BA14                          4172  *
0000BA14                          4173  * Precondition: PTHSIS_OPEN
0000BA14                          4174  *
0000BA14                          4175  * Postcondition: X
0000BA14                          4176  **********************************************************************************
0000BA14                          4177  LOAD_PTHSIS_OPEN:
0000BA14  4280                    4178      CLR.L   D0
0000BA16                          4179  
0000BA16  1039 0000AAE8           4180      MOVE.B  PTHSIS_OPEN, D0
0000BA1C  4EB9 0000BA74           4181      JSR     LOAD_THIS_SHIT
0000BA22  4E75                    4182      RTS
0000BA24                          4183  
0000BA24                          4184  * <EA>
0000BA24                          4185  **********************************************************************************
0000BA24                          4186  * Description: Loads ASCII for )
0000BA24                          4187  *
0000BA24                          4188  * Registers used: D0 for actually loading
0000BA24                          4189  *
0000BA24                          4190  * Precondition: PTHSIS_CLSD
0000BA24                          4191  *
0000BA24                          4192  * Postcondition: X
0000BA24                          4193  **********************************************************************************
0000BA24                          4194  LOAD_PTHSIS_CLSD:
0000BA24  4280                    4195      CLR.L   D0
0000BA26                          4196  
0000BA26  1039 0000AAE9           4197      MOVE.B  PTHSIS_CLSD, D0
0000BA2C  4EB9 0000BA74           4198      JSR     LOAD_THIS_SHIT
0000BA32  4E75                    4199      RTS
0000BA34                          4200  
0000BA34                          4201  * <EA>
0000BA34                          4202  **********************************************************************************
0000BA34                          4203  * Description: Loads ASCII for $
0000BA34                          4204  *
0000BA34                          4205  * Registers used: D0 for actually loading
0000BA34                          4206  *
0000BA34                          4207  * Precondition: HEX_SIGN
0000BA34                          4208  *
0000BA34                          4209  * Postcondition: X
0000BA34                          4210  **********************************************************************************
0000BA34                          4211  LOAD_HEX_SIGN:
0000BA34  4280                    4212      CLR.L   D0
0000BA36                          4213  
0000BA36  1039 0000AAEA           4214      MOVE.B  HEX_SIGN, D0
0000BA3C  4EB9 0000BA74           4215      JSR     LOAD_THIS_SHIT
0000BA42  4E75                    4216      RTS
0000BA44                          4217  
0000BA44                          4218  * <EA>
0000BA44                          4219  **********************************************************************************
0000BA44                          4220  * Description: Loads ASCII for #
0000BA44                          4221  *
0000BA44                          4222  * Registers used: D0 for actually loading
0000BA44                          4223  *
0000BA44                          4224  * Precondition: IMMDTE_VALU
0000BA44                          4225  *
0000BA44                          4226  * Postcondition: X
0000BA44                          4227  **********************************************************************************
0000BA44                          4228  LOAD_IMMDTE_VALU:
0000BA44  4280                    4229      CLR.L   D0
0000BA46                          4230  
0000BA46  1039 0000AAEB           4231      MOVE.B  IMMDTE_VALU, D0
0000BA4C  4EB9 0000BA74           4232      JSR     LOAD_THIS_SHIT
0000BA52  4E75                    4233      RTS
0000BA54                          4234  
0000BA54                          4235  * <EA>
0000BA54                          4236  **********************************************************************************
0000BA54                          4237  * Description: Loads ASCII for +
0000BA54                          4238  *
0000BA54                          4239  * Registers used: D0 for actually loading
0000BA54                          4240  *
0000BA54                          4241  * Precondition: PLUS_SIGN
0000BA54                          4242  *
0000BA54                          4243  * Postcondition: X
0000BA54                          4244  **********************************************************************************
0000BA54                          4245  LOAD_PLUS_SIGN:
0000BA54  4280                    4246      CLR.L   D0
0000BA56                          4247  
0000BA56  1039 0000AAEC           4248      MOVE.B  PLUS_SIGN, D0
0000BA5C  4EB9 0000BA74           4249      JSR     LOAD_THIS_SHIT
0000BA62  4E75                    4250      RTS
0000BA64                          4251  
0000BA64                          4252  * <EA>
0000BA64                          4253  **********************************************************************************
0000BA64                          4254  * Description: Loads ASCII for -
0000BA64                          4255  *
0000BA64                          4256  * Registers used: D0 for actually loading
0000BA64                          4257  *
0000BA64                          4258  * Precondition: MINUS_SIGN
0000BA64                          4259  *
0000BA64                          4260  * Postcondition: X
0000BA64                          4261  **********************************************************************************
0000BA64                          4262  LOAD_MINUS_SIGN:
0000BA64  4280                    4263      CLR.L   D0
0000BA66                          4264  
0000BA66  1039 0000AAED           4265      MOVE.B  MINUS_SIGN, D0
0000BA6C  4EB9 0000BA74           4266      JSR     LOAD_THIS_SHIT
0000BA72  4E75                    4267      RTS
0000BA74                          4268  **************************************************
0000BA74                          4269  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000BA74                          4270  
0000BA74                          4271  
0000BA74                          4272  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000BA74                          4273  * LOAD_THIS FUNCTIONS (LOWEST LEVEL) *************
0000BA74                          4274  * <EA>
0000BA74                          4275  **********************************************************************************
0000BA74                          4276  * Description: Loads the hex value from D0 to G_BUFFER_1 in ASCII. SHIT stands for        
0000BA74                          4277  *               Specially-Heeded I/O Target
0000BA74                          4278  *
0000BA74                          4279  * Registers used: X
0000BA74                          4280  *
0000BA74                          4281  * Precondition: X
0000BA74                          4282  *
0000BA74                          4283  * Postcondition: X
0000BA74                          4284  **********************************************************************************
0000BA74                          4285  LOAD_THIS_SHIT:
0000BA74  18C0                    4286      MOVE.B  D0, (A4)+
0000BA76  4E75                    4287      RTS
0000BA78                          4288  
0000BA78                          4289  * <EA>
0000BA78                          4290  **********************************************************************************
0000BA78                          4291  * Description: Adds $30 to a number in D0 to make it a hex. If the number is greater
0000BA78                          4292  *              than 9 (A~F), then adds $37. Then moves the hex value from D0 to G_BUFFER_1 in ASCII
0000BA78                          4293  *
0000BA78                          4294  * Registers used: X
0000BA78                          4295  *
0000BA78                          4296  * Precondition: X
0000BA78                          4297  *
0000BA78                          4298  * Postcondition: X
0000BA78                          4299  **********************************************************************************
0000BA78                          4300  LOAD_NUM:
0000BA78  0C00 0009               4301      CMPI.B  #$9, D0
0000BA7C  6E00 0006               4302      BGT     GT
0000BA80  6F00 000C               4303      BLE     LE
0000BA84                          4304      
0000BA84  0600 0037               4305  GT  ADDI.B  #$37, D0 * A~F
0000BA88  4EF9 0000BA98           4306      JMP     END
0000BA8E  0600 0030               4307  LE  ADDI.B  #$30, D0 * 0~9
0000BA92  4EF9 0000BA98           4308      JMP     END
0000BA98                          4309  
0000BA98  18C0                    4310  END MOVE.B  D0, (A4)+
0000BA9A  4E75                    4311      RTS
0000BA9C                          4312  
0000BA9C                          4313  * <EA>
0000BA9C                          4314  **********************************************************************************
0000BA9C                          4315  * Description: Execution goes here if even one of the EA bit is invalid. Flags the invalid-bit and
0000BA9C                          4316  *              entirely exits the EA process.
0000BA9C                          4317  *
0000BA9C                          4318  * Registers used: X
0000BA9C                          4319  *
0000BA9C                          4320  * Precondition: X
0000BA9C                          4321  *
0000BA9C                          4322  * Postcondition: X
0000BA9C                          4323  **********************************************************************************
0000BA9C                          4324  INVALID:
0000BA9C  13FC 0000 000090A2      4325              MOVE.B  #%0, IS_VALID_1
0000BAA4  4EF9 0000AB04           4326              JMP     EXT
0000BAAA                          4327  **************************************************
0000BAAA                          4328  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000BAAA                          4329      
0000BAAA                          4330     ;END    START                                    ;Last line of program
0000BAAA                          4331  
0000BAAA                          4332  
0000BAAA                          4333  
0000BAAA                          4334  
0000BAAA                          4335  
Line 4336 WARNING: END directive missing, starting address not set

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA                AE28
ADDA_BACK           AE48
ADDRESS             AAE6
ADDSTRTOBUFFER_1    926E
ADD_CHAR_TO_STRING  9358
ADD_X               B41A
ADD_Y               B426
ASCIITOHEXREGLIST_1HEXREGLIST  1
ASCIITOHEX_1        9402
ASCII_VAL           9714
ASD_1               AC02
ASD_1_BACK          AC36
ASD_2               AC68
ASD_2_IMD           AC80
ASD_2_IMD_B         ACAA
ASD_2_REG           ACC8
A_TO_D              B396
BACK                B6C6
BACK2               B702
BACK3               B776
BACK4               B748
BACK5               B7CE
BCLR                B71C
BIT_CHECK_EXG       A36E
BIT_CHECK_EXT       9DDC
BIT_CHECK_MOVEP     9B12
BIT_CHECK_SUBX      A276
BIT_ON              B446
BIT_ON2             B55C
BIT_SIZE_1_CHECK    A3CC
BRA                 AD60
BRA_BYTE            AD8E
BRA_BYTE2           ADB4
BRA_BYTE3           ADC0
BRA_WORD            ADC8
BRA_WORD_BK         ADE4
BRA_WRD_BK2         AE02
BUFFER_ADD_SUCCESS_1  926C
BUFFER_LENGTH_EXCEEDED_1  92BE
BUFFER_POINTER_1    9264
BUFFER_POINTER_1_LENGTH  9268
BUFFER_STRING_END   92C6
BYTEREAD            9713
B_BUFFER_1          9050
CHARNUM_TO_CONVERT_1  92FC
CHECK_00XX          AB7E
CHECK_01XX          AB8E
CHECK_0XXX          AB1C
CHECK_1XXX          AB2E
CHECK_OP_ABCD       A354
CHECK_OP_ADD        A3FE
CHECK_OP_ADDA       A408
CHECK_OP_ADDI       9A62
CHECK_OP_ADDQ       A004
CHECK_OP_ADDX       A3E8
CHECK_OP_AND        A3AA
CHECK_OP_ANDI       9A36
CHECK_OP_ANDI_TO_CCR  99EE
CHECK_OP_ANDI_TO_SR  9A00
CHECK_OP_ASL        A5E2
CHECK_OP_ASL_NO_ROT  A4F0
CHECK_OP_ASR        A5C0
CHECK_OP_ASR_NO_ROT  A4D4
CHECK_OP_BCC        A078
CHECK_OP_BCS        A12E
CHECK_OP_BEQ        A08E
CHECK_OP_BGE        A14A
CHECK_OP_BGT        A062
CHECK_OP_BHI        A0A4
CHECK_OP_BLS        A0BA
CHECK_OP_BLT        A166
CHECK_OP_BMI        A0D0
CHECK_OP_BNE        A0E6
CHECK_OP_BPL        A0FC
CHECK_OP_BRA        A112
CHECK_OP_BSR        A04C
CHECK_OP_BVC        A182
CHECK_OP_CHK        9ED4
CHECK_OP_CLR        9D9A
CHECK_OP_CMP        A30C
CHECK_OP_CMPA       A2D4
CHECK_OP_CMPI       9B66
CHECK_OP_CMPM       A2BE
CHECK_OP_DBCC       9FD8
CHECK_OP_DIVS       A1FC
CHECK_OP_DIVU       A1D0
CHECK_OP_DYNAMIC_BCHG  9AE6
CHECK_OP_DYNAMIC_BCLR  9BAA
CHECK_OP_DYNAMIC_BSET  9AFC
CHECK_OP_DYNAMIC_BTST  9AD0
CHECK_OP_EOR        A2EA
CHECK_OP_EORI       9A78
CHECK_OP_EORI_TO_CCR  9A12
CHECK_OP_EORI_TO_SR  9A24
CHECK_OP_EXG        A36A
CHECK_OP_EXT        9DC6
CHECK_OP_ILLEGAL    9CFA
CHECK_OP_JMP        9EBE
CHECK_OP_JSR        9F36
CHECK_OP_LEA        9F1A
CHECK_OP_LINK       9E7C
CHECK_OP_LSL        A59E
CHECK_OP_LSL_NO_ROT  A4B8
CHECK_OP_LSR        A57C
CHECK_OP_LSR_NO_ROT  A49C
CHECK_OP_MOVEA_L    9C08
CHECK_OP_MOVEA_W    9C70
CHECK_OP_MOVEM_L    9FAC
CHECK_OP_MOVEM_W    9F90
CHECK_OP_MOVEP      9B2E
CHECK_OP_MOVEQ      A1AE
CHECK_OP_MOVE_B     9BDC
CHECK_OP_MOVE_FROM_SR  9D42
CHECK_OP_MOVE_L     9C44
CHECK_OP_MOVE_TO_CCR  9D58
CHECK_OP_MOVE_TO_SR  9D6E
CHECK_OP_MOVE_USP   9EA8
CHECK_OP_MOVE_W     9CAC
CHECK_OP_MULS       A38E
CHECK_OP_MULU       A33E
CHECK_OP_NBCD       9DF8
CHECK_OP_NEG        9F52
CHECK_OP_NEGX       9D84
CHECK_OP_NOP        9EEA
CHECK_OP_NOT        9DB0
CHECK_OP_OR         A218
CHECK_OP_ORI        9B44
CHECK_OP_ORI_TO_CCR  99CA
CHECK_OP_ORI_TO_SR  99DC
CHECK_OP_PEA        9E24
CHECK_OP_RESET      9CE8
CHECK_OP_ROL        A55A
CHECK_OP_ROL_NO_ROT  A480
CHECK_OP_ROR        A538
CHECK_OP_ROR_NO_ROT  A464
CHECK_OP_ROXL       A522
CHECK_OP_ROXL_NO_ROT  A44E
CHECK_OP_ROXR       A50C
CHECK_OP_ROXR_NO_ROT  A438
CHECK_OP_RTE        9D0C
CHECK_OP_RTR        9D30
CHECK_OP_RTS        9F02
CHECK_OP_SBCD       A1E6
CHECK_OP_SCC        9FEE
CHECK_OP_STATIC_BCHG  9AA4
CHECK_OP_STATIC_BCLR  9B88
CHECK_OP_STATIC_BSET  9ABA
CHECK_OP_STATIC_BTST  9A8E
CHECK_OP_STOP       9CD6
CHECK_OP_SUB        A296
CHECK_OP_SUBA       A24E
CHECK_OP_SUBI       9A4C
CHECK_OP_SUBQ       A01A
CHECK_OP_SUBX       A264
CHECK_OP_SWAP       9E0E
CHECK_OP_TAS        9E3A
CHECK_OP_TRAP       9E66
CHECK_OP_TRAPV      9D1E
CHECK_OP_TST        9E50
CHECK_OP_UNLK       9E92
CHECK_POSITIVE_LENGTH  932A
CHECK_PRINT         91C6
CHECK_SIZE_1_BIT_FOR_SUB  A238
CHECK_VALID_LENGTH  9334
CHECK_XXXX          AB0A
CHRDONE             941E
CHRLOOP             940A
CHUMP_BYTE          B8D2
CHUMP_LONG          B8E2
CHUMP_WORD          B8DA
CLEAR_BUFFER_1      92D4
CLEAR_BUFFER_1_END  92F2
CLEAR_BUFFER_1_LENGTH_1  92D0
CLEAR_BUFFER_1_LOOP  92E6
CLEAR_BUFFER_1_POINTER_1  92CC
COMMA               AAEE
CONVERTED_HEX_STRING_1  92FD
CONVERT_HEX_TO_STRING_1  9306
CONVERT_TO_HEX_LETTER  9350
COUNTDONE           93BE
COUNTLOOP           93AC
CR                  D
CUR_OP_CODE_1       90A0
C_GROUP_0           99C6
C_GROUP_1           9BD8
C_GROUP_2           9C04
C_GROUP_3           9C6C
C_GROUP_4           9CD4
C_GROUP_5           9FD4
C_GROUP_6           A048
C_GROUP_7           A1AA
C_GROUP_8           A1CC
C_GROUP_9           A234
C_GROUP_A           A2B2
C_GROUP_B           A2BA
C_GROUP_C           A33A
C_GROUP_D           A3C8
C_GROUP_E           A434
C_GROUP_F           A610
DATA                AAE7
DIGIT_LOOP          933C
DIR_0               AEBC
DIR_1               AF14
DIVS                AF6C
DIVS_BACK           AF94
DONE_1              925C
DOWN_ONE            ADAC
DOWN_ZERO           ADA4
DYNMC_BCLR          B790
D_TO_A              B3CC
END                 BA98
EXT                 AB04
FILEID_1            973C
FILENAME_1          971C
FINDNULLLOOPDONE    938E
FIND_1_BIT_SIZE_1_6  98CA
FIND_1_BIT_SIZE_1_8  98EE
FIND_2_BIT_SIZE_1_7_TO_6  98A6
FIND_MOVEA_L_DIFFERENCE  9C1C
FIND_MOVEA_W_DIFF   9C84
FIRST_3             975C
FIRST_X             AAF6
FIRST_Y             AAF7
FOURTH_3            975F
FST_X               B478
FST_X2              B58E
FST_Y1              B4D0
FST_Y2              B4EE
FST_Y3              B5E6
FST_Y4              B604
FUK_MOVEM           B20E
GO                  B8EA
GOO                 B80E
GOO2                B842
GO_A_TO_D           B518
GO_D_TO_A           B402
GROUP0_INVALID      9BCC
GROUP0_SUCCESS      9BD2
GROUP1_INVALID      9BF8
GROUP1_SUCCESS      9BFE
GROUP2_INVALID      9C60
GROUP2_SUCCESS      9C66
GROUP3_INVALID      9CC8
GROUP3_SUCCESS      9CCE
GROUP4_INVALID      9FC8
GROUP4_SUCCESS      9FCE
GROUP5_INVALID      A03C
GROUP5_SUCCESS      A042
GROUP6_INVALID      A19E
GROUP6_SUCCESS      A1A4
GROUP7_INVALID      A1C0
GROUP7_SUCCESS      A1C6
GROUP8_INVALID      A228
GROUP8_SUCCESS      A22E
GROUP9_INVALID      A2A6
GROUP9_SUCCESS      A2AC
GROUPB_INVALID      A32E
GROUPB_SUCCESS      A334
GROUPC_INVALID      A3BC
GROUPC_SUCCESS      A3C2
GROUPD_INVALID      A428
GROUPD_SUCCESS      A42E
GROUPE_INVALID      A604
GROUPE_SUCCESS      A60A
GROUP_0             9776
GROUP_1             9788
GROUP_2             979A
GROUP_3             97AC
GROUP_4             97BE
GROUP_5             97D0
GROUP_6             97E2
GROUP_7             97F4
GROUP_8             9806
GROUP_9             9818
GROUP_A             982A
GROUP_B             983C
GROUP_C             984E
GROUP_D             9860
GROUP_E             9872
GROUP_F             9884
GT                  BA84
G_BUFFER_1          9000
HEX_SIGN            AAEA
IMMDTE_VALU         AAEB
INVALID             BA9C
INVALID_ADDRES_MESSAGE_1  9740
INVALID_OP          A618
IO_BUFFER_1         9727
IS_VALID_1          90A2
ITS_X               B456
ITS_X2              B56C
ITS_Y               B4A2
ITS_Y2              B5B8
ITS_Y2_BACK         B5C4
ITS_Y_BACK          B4AE
JSR                 B172
JSR_BACK            B18E
KEEP_GOING          B508
KEEP_GOING0         B43A
KEEP_GOING1         B550
KEEP_GOING2         B61E
LE                  BA8E
LEA                 B1B6
LEA_BACK            B1DE
LF                  A
LOAD_0000           B62E
LOAD_00XX           B7E8
LOAD_0100           B062
LOAD_0101           AFC4
LOAD_0110           ACF6
LOAD_1000           AE8A
LOAD_1001           AE84
LOAD_1011           AE7E
LOAD_1100           AE78
LOAD_1101           AE0A
LOAD_1110           ABB4
LOAD_8              AC94
LOAD_A              BA04
LOAD_ABS_LONG       B98C
LOAD_ABS_SHORT      B97A
LOAD_ADDRESS        B94A
LOAD_ADDRESS_W_POST_INC  B95E
LOAD_ADDRESS_W_PRE_DEC  B96C
LOAD_ADDR_REGISTER  B938
LOAD_BYTES          B9AA
LOAD_COMMA_SPACE    B9D8
LOAD_D              B9F4
LOAD_DATA_REGISTER  B926
LOAD_EA             B85C
LOAD_FIRST3         AC9E
LOAD_GE_111         B89C
LOAD_HEX_SIGN       BA34
LOAD_IMMDTE         B99E
LOAD_IMMDTE_VALU    BA44
LOAD_LT_111         B86E
LOAD_MINUS_SIGN     BA64
LOAD_NEW_LINE       B9D6
LOAD_NUM            BA78
LOAD_PLUS_SIGN      BA54
LOAD_PTHSIS_CLSD    BA24
LOAD_PTHSIS_OPEN    BA14
LOAD_THIS_SHIT      BA74
LOOP                B9B4
MAIN_CONSOLE_1      944A
MAIN_EA             AAF8
MAIN_LOOP_1         9160
MINUS_SIGN          AAED
MNEMONIC            975B
MOVEM               B1A8
MOVEM_BIT_SIZE_1_CHECK  9F74
MOVEM_PARSE         B382
MOVEM_POST          B230
MOVEM_POST2         B25A
MOVEM_POST3         B27A
MOVEM_POSTL         B2DE
MOVEM_POSTW         B2A6
MOVEM_PRE           B316
MOVEM_PRE_B         B344
MOVEON              AC1A
MOVE_AND_MOVEA_PARSE_EA  9912
MYBE_ASD_1          ABD8
MYBE_ASD_2          AC50
MYBE_BCLR           B680
MYBE_BRA            AD18
MYBE_CMPI           B664
MYBE_JSR            B0E0
MYBE_MOVEM          B104
MYBE_NEG            B07C
MYBE_ORI            B648
MYBE_RTS1           B098
MYBE_RTS2           B0A8
MYBE_RTS3           B0B8
MYBE_SUBQ1          AFE0
MYBE_SUBQ2          AFF2
MYBE_Y              B492
MYBE_Y2             B5A8
NEG                 B128
NEG_BACK            B150
NEG_WORD            ADEC
NEWLINE             96F6
NOT_BCLR            B68C
NOT_BRA             AD28
NOT_CMPI            B670
NOT_JSR             B0EC
NOT_MOVEM           B116
NOT_NEG             B088
NOT_ORI             B654
NOT_RTS             B0D0
NULLLOOP            9380
NUMBER_TO_CONVERT_1  92F8
OP_JSR_DONE_1       9892
OP_JSR_ROUTINE_1    9760
OP_SIZE_1           975A
ORI_CMPI            B69E
OR_BACK             AEE4
OR_BACK2            AF52
OUTFILENAME         96FC
PARSE_EA_CONSTANT_BITS  995C
PLUS_SIGN           AAEC
POS_WORD            ADD8
PRINT_DATA          91E6
PRINT_INSTRUCTION   91D6
PRINT_OP_ADD        A88C
PRINT_OP_ADDA       A8A4
PRINT_OP_ASL        A904
PRINT_OP_ASR        A8EC
PRINT_OP_BCS        A790
PRINT_OP_BGE        A7A8
PRINT_OP_BLT        A7C0
PRINT_OP_BRA        A7F0
PRINT_OP_BVC        A7D8
PRINT_OP_CMP        A862
PRINT_OP_CMPI       A64C
PRINT_OP_DIVS       A808
PRINT_OP_DYNAMIC_BCLR  A67C
PRINT_OP_EOR        A84A
PRINT_OP_JSR        A6EE
PRINT_OP_LEA        A724
PRINT_OP_LSL        A8BC
PRINT_OP_LSR        A8D4
PRINT_OP_MOVEA_L    A6A6
PRINT_OP_MOVEA_W    A6CA
PRINT_OP_MOVEB      A694
PRINT_OP_MOVEM_L    A766
PRINT_OP_MOVEM_W    A754
PRINT_OP_MOVE_L     A6B8
PRINT_OP_MOVE_W     A6DC
PRINT_OP_MULS       A87A
PRINT_OP_NEG        A73C
PRINT_OP_NOP        A712
PRINT_OP_OR         A81A
PRINT_OP_ORI        A634
PRINT_OP_ROL        A91C
PRINT_OP_ROR        A934
PRINT_OP_RTS        A700
PRINT_OP_SIZE_1     A982
PRINT_OP_SIZE_1_ADDA  A9A2
PRINT_OP_STATIC_BCLR  A664
PRINT_OP_SUB        A832
PRINT_OP_SUBQ       A778
PRINT_SIZE_1_BYTE   A94C
PRINT_SIZE_1_LONG   A970
PRINT_SIZE_1_WORD   A95E
PRINT_TO_BUFFER     A622
PTHSIS_CLSD         AAE9
PTHSIS_OPEN         AAE8
P_INVALID_OP        A9AE
P_OP_ADD            AAB5
P_OP_ADDA           AAAD
P_OP_ASL            AAD1
P_OP_ASR            AACA
P_OP_BCLR           A9D5
P_OP_BCS            AA60
P_OP_BGE            AA67
P_OP_BLT            AA6E
P_OP_BRA            AA59
P_OP_BVC            AA75
P_OP_CMP            AA9B
P_OP_CMPI           A9CD
P_OP_DIVS           AA7C
P_OP_EOR            AA94
P_OP_JSR            AA35
P_OP_LEA            AA2E
P_OP_LSL            AAC3
P_OP_LSR            AABC
P_OP_MOVEA_L        A9E8
P_OP_MOVEA_W        A9FF
P_OP_MOVEB          A9DD
P_OP_MOVEM_L        AA22
P_OP_MOVEM_W        AA16
P_OP_MOVE_L         A9F4
P_OP_MOVE_W         AA0B
P_OP_MULS           AAA2
P_OP_NEG            AA4A
P_OP_NOP            AA3C
P_OP_OR             AA87
P_OP_ORI            A9C6
P_OP_ROL            AADF
P_OP_ROR            AAD8
P_OP_RTS            AA43
P_OP_SUB            AA8D
P_OP_SUBQ           AA51
P_SIZE_1_B          A9BA
P_SIZE_1_L          A9C2
P_SIZE_1_W          A9BE
RET_SA              9448
ROTATE              B9BE
RTS                 B16A
SAVED               B86C
SECOND_3            975D
SIZE_1              14
SIZE_1_B            B908
SIZE_1_L            B91C
SIZE_1_W            B912
SKIP_HERE           B4E8
SKIP_HERE2          B5FE
SND_X               B48A
SND_X2              B5A0
SND_Y               B500
SND_Y2              B616
SPACE               AAEF
STRING_ADD_SUCCESS  92B6
STRING_BUFFER_1_ADD_LOOP  92A0
STRING_BUFFER_1_LOOP  928C
STRING_BUFFER_1_POINTER_1  9260
STRIP_ASCII         9424
SUB30               9444
SUB37               943C
SUBQ                B004
SUBQ_BACK           B048
SUBQ_SAVED          B01A
SUBTRACT_X          B530
SUBTRACT_Y          B53C
THIRD_3             975E
TOSAVE              C3F
TRAILING_HELPER     B908
TRAILING_SIZE_1     AAF0
TRAPTASK13_1        936C
VALIDATE_END_POS_1  911C
VALIDATE_EVEN_1     913E
VALIDATE_POSITIVE_ADDRESS_1  90FA
VALIDATE_START_ADDRESS_1  90F8
X                   AAF2
X_COUNTER           AAF4
Y                   AAF3
Y_COUNTER           AAF5
_00000000           93A2
